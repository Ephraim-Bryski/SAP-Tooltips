def start_sap(strict = True):
    import os
    import sys
    import comtypes.client
    import numpy as np

    helper = comtypes.client.CreateObject('SAP2000v1.Helper')
    helper = helper.QueryInterface(comtypes.gen.SAP2000v1.cHelper)

    try:
        mySapObject = helper.GetObject("CSI.SAP2000.API.SapObject") 
    except (OSError, comtypes.COMError):
        print("No running instance of the program found or failed to attach.")
        sys.exit(-1)

    if mySapObject == None:
        try:
            mySapObject = helper.CreateObjectProgID("CSI.SAP2000.API.SapObject")
        except (OSError, comtypes.COMError):
            print("Cannot start a new instance of the program.")
            sys.exit(-1)
        mySapObject.ApplicationStart()

    api = mySapObject

    return SapModel(strict, api)

class SapModel:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.AreaElm = AreaElm(strict, api)
        self.LineElm = LineElm(strict, api)
        self.LinkElm = LinkElm(strict, api)
        self.PlaneElm = PlaneElm(strict, api)
        self.PointElm = PointElm(strict, api)
        self.SolidElm = SolidElm(strict, api)
        self.Results = Results(strict, api)
        self.Analyze = Analyze(strict, api)
        self.BridgeAdvancedSuper = BridgeAdvancedSuper(strict, api)
        self.BridgeObj = BridgeObj(strict, api)
        self.RespCombo = RespCombo(strict, api)
        self.ConstraintDef = ConstraintDef(strict, api)
        self.CoordSys = CoordSys(strict, api)
        self.LoadCases = LoadCases(strict, api)
        self.Func = Func(strict, api)
        self.GDispl = GDispl(strict, api)
        self.GenRefLine = GenRefLine(strict, api)
        self.GroupDef = GroupDef(strict, api)
        self.PatternDef = PatternDef(strict, api)
        self.LoadPatterns = LoadPatterns(strict, api)
        self.SourceMass = SourceMass(strict, api)
        self.NamedAssign = NamedAssign(strict, api)
        self.NamedSets = NamedSets(strict, api)
        self.PropArea = PropArea(strict, api)
        self.PropCable = PropCable(strict, api)
        self.PropFrame = PropFrame(strict, api)
        self.PropLink = PropLink(strict, api)
        self.PropMaterial = PropMaterial(strict, api)
        self.PropRebar = PropRebar(strict, api)
        self.PropSolid = PropSolid(strict, api)
        self.PropTendon = PropTendon(strict, api)
        self.SectCut = SectCut(strict, api)
        self.DesignAluminum = DesignAluminum(strict, api)
        self.DesignColdFormed = DesignColdFormed(strict, api)
        self.DesignConcrete = DesignConcrete(strict, api)
        self.DesignSteel = DesignSteel(strict, api)
        self.DesignResults = DesignResults(strict, api)
        self.EditArea = EditArea(strict, api)
        self.EditFrame = EditFrame(strict, api)
        self.EditPoint = EditPoint(strict, api)
        self.EditSolid = EditSolid(strict, api)
        self.EditGeneral = EditGeneral(strict, api)
        self.File = File(strict, api)
        self.AreaObj = AreaObj(strict, api)
        self.CableObj = CableObj(strict, api)
        self.ExternalAnalysisResults = ExternalAnalysisResults(strict, api)
        self.FrameObj = FrameObj(strict, api)
        self.LinkObj = LinkObj(strict, api)
        self.PointObj = PointObj(strict, api)
        self.SolidObj = SolidObj(strict, api)
        self.TendonObj = TendonObj(strict, api)
        self.Options = Options(strict, api)
        self.SelectObj = SelectObj(strict, api)
        self.View = View(strict, api)

    def GetKeyStringsExtendedEntityData(self):
        """

 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GetKeyStringsExtendedEntityData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetKeyStringsExtendedEntityData" failed')
        
        return ret

    def GetKeysWithStringsExtendedEntityData(self):
        """

 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GetKeysWithStringsExtendedEntityData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetKeysWithStringsExtendedEntityData" failed')
        
        return ret

    def SetStringsExtendedEntityData(self, AppName = None, Key = None, NumberValues = None, Values = None):
        """
This function can be used to store metadata for a model, or any other data specific to your application.

AppName: This is an application name of your choice under which your application previously stored some data. It is recommended you choose a unique name to guarantee no other third-party application resets the data that was set by your application. Application names are stored in their original capitalization and character set, but are compared in a case insensitive and culturally invariant manner for retrieval purposes.
Key: This is an entry name under which the data provided in the remaining arguments was stored. This data can later be retrieved, reset, or deleted by providing a valid application name and entry name. Entry names are stored in their original capitalization and character set, but are compared in a case insensitive and culturally invariant manner for retrieval purposes.
NumberValues: The number of strings to store for the given application name and entry name.
Values: A one-dimensional array of strings containing NumberValues strings. These strings replace any strings previously stored for the given application name and entry name. Calling this function with NumberValues equal to zero is equivalent to erasing any previously stored data.
        """

        all_args = [AppName, Key, NumberValues, Values]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SetStringsExtendedEntityData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetStringsExtendedEntityData" failed')
        
        return ret

    def GetDatabaseUnits(self):
        """
This function returns one of the following items from the eUnits enumeration indicating the database units for the model. All data is internally stored in the model in these units and converted to the present units as needed.
lb_in_F = 1
lb_ft_F = 2
kip_in_F = 3
kip_ft_F = 4
kN_mm_C = 5
kN_m_C = 6
kgf_mm_C = 7
kgf_m_C = 8
N_mm_C = 9
N_m_C = 10
Ton_mm_C = 11
Ton_m_C = 12
kN_cm_C = 13
kgf_cm_C = 14
N_cm_C = 15
Ton_cm_C = 16

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GetDatabaseUnits(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDatabaseUnits" failed')
        
        return ret

    def GetMergeTol(self, MergeTol = None):
        """
This function retrieves the value of the program auto merge tolerance.
The function returns zero if the tolerance is successfully retrieved; otherwise it returns a nonzero value.

MergeTol: The program auto merge tolerance. [L]
        """

        all_args = [MergeTol]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GetMergeTol(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMergeTol" failed')
        
        return ret

    def GetModelFilename(self, IncludePath = None):
        """
The function returns a string that represents the filename of the current model, with or without the full path.

IncludePath: A boolean (True or False) value. When this item is True, the returned filename includes the full path where the file is located.
        """

        all_args = [IncludePath]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GetModelFilename(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModelFilename" failed')
        
        return ret

    def GetModelFilepath(self):
        """
The function returns a string that represents the filepath of the current model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GetModelFilepath(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModelFilepath" failed')
        
        return ret

    def GetModelIsLocked(self):
        """
The function returns True if the model is locked and False if it is unlocked.
With some exceptions, definitions and assignments can not be changed in a model while the model is locked. If an attempt is made to change a definition or assignment while the model is locked and that change is not allowed in a locked model, an error will be returned.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GetModelIsLocked(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModelIsLocked" failed')
        
        return ret

    def GetPresentCoordSystem(self):
        """
This function returns the name of the present coordinate system.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GetPresentCoordSystem(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPresentCoordSystem" failed')
        
        return ret

    def GetPresentUnits(self):
        """
This function returns one of the following items from the eUnits enumeration indicating the units presently specified for the model:
lb_in_F = 1
lb_ft_F = 2
kip_in_F = 3
kip_ft_F = 4
kN_mm_C = 5
kN_m_C = 6
kgf_mm_C = 7
kgf_m_C = 8
N_mm_C = 9
N_m_C = 10
Ton_mm_C = 11
Ton_m_C = 12
kN_cm_C = 13
kgf_cm_C = 14
N_cm_C = 15
Ton_cm_C = 16

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GetPresentUnits(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPresentUnits" failed')
        
        return ret

    def GetProjectInfo(self, NumberItems = None, Item = None, Data = None):
        """
This function retrieves the project information data.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of project info items returned.
Item: This is an array that includes the name of the project information item.
Data: This is an array that includes the data for the specified project information item.
        """

        all_args = [NumberItems, Item, Data]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GetProjectInfo(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProjectInfo" failed')
        
        return ret

    def GetUserComment(self, Comment = None):
        """
This function retrieves the data in the user comments and log.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Comment: The data in the user comments and log.
        """

        all_args = [Comment]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GetUserComment(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUserComment" failed')
        
        return ret

    def GetVersion(self, Version = None, MyVersionNumber = None):
        """
This function returns the SAP2000 program version.
The function returns zero if the information is successfully retrieved; otherwise it returns a nonzero value.

Version: The program version name that is externally displayed to the user.
MyVersionNumber: The program version number that is used internally by the program and not displayed to the user.
        """

        all_args = [Version, MyVersionNumber]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GetVersion(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetVersion" failed')
        
        return ret

    def InitializeNewModel(self, Units = None):
        """
This function clears the previous model and initializes the program for a new model. If it is later needed, you should save your previous model prior to calling this function.
After calling the InitializeNewModel function, it is not necessary to also call the ApplicationStart function because the functionality of the ApplicationStart function is included in the InitializeNewModel function.
The function returns zero if a new model is successfully initialized, otherwise it returns a nonzero value.

Units: This is the database units for the new model. All data is internally stored in the model in these units. The units are one of the following items in the eUnits enumeration:
lb_in_F = 1
lb_ft_F = 2
kip_in_F = 3
kip_ft_F = 4
kN_mm_C = 5
kN_m_C = 6
kgf_mm_C = 7
kgf_m_C = 8
N_mm_C = 9
N_m_C = 10
Ton_mm_C = 11
Ton_m_C = 12
kN_cm_C = 13
kgf_cm_C = 14
N_cm_C = 15
Ton_cm_C = 16
        """

        all_args = [Units]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.InitializeNewModel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"InitializeNewModel" failed')
        
        return ret

    def SetMergeTol(self, MergeTol = None):
        """
This function sets the program auto merge tolerance.
The function returns zero if the tolerance is successfully set; otherwise it returns a nonzero value.

MergeTol: The program auto merge tolerance. [L]
        """

        all_args = [MergeTol]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SetMergeTol(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMergeTol" failed')
        
        return ret

    def SetModelIsLocked(self, LockIt = None):
        """
The function returns zero if the locked status of the model is successfully set. Otherwise it returns a nonzero value.
With some exceptions, definitions and assignments can not be changed in a model while the model is locked. If an attempt is made to change a definition or assignment while the model is locked and that change is not allowed in a locked model, an error will be returned.

LockIt: The item is True if the model is to be locked and False if it is to be unlocked.
        """

        all_args = [LockIt]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SetModelIsLocked(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModelIsLocked" failed')
        
        return ret

    def SetPresentCoordSystem(self, CSys = None):
        """
This function sets the present coordinate system.
The function returns zero if the present coordinate system is successfully set. Otherwise it returns a nonzero value.

CSys: The name of a defined coordinate system.
        """

        all_args = [CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SetPresentCoordSystem(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPresentCoordSystem" failed')
        
        return ret

    def SetPresentUnits(self, Units = None):
        """
This function returns zero if the units are successfully set and nonzero if they are not set.

Units: One of the following items in the eUnits enumeration:
lb_in_F = 1
lb_ft_F = 2
kip_in_F = 3
kip_ft_F = 4
kN_mm_C = 5
kN_m_C = 6
kgf_mm_C = 7
kgf_m_C = 8
N_mm_C = 9
N_m_C = 10
Ton_mm_C = 11
Ton_m_C = 12
kN_cm_C = 13
kgf_cm_C = 14
N_cm_C = 15
Ton_cm_C = 16
        """

        all_args = [Units]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SetPresentUnits(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPresentUnits" failed')
        
        return ret

    def SetProjectInfo(self, Item = None, Data = None):
        """
This function sets the data for an item in the project information.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Item: The name of the project information item to be set.
Data: The data for the specified project information item.
        """

        all_args = [Item, Data]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SetProjectInfo(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetProjectInfo" failed')
        
        return ret

    def SetUserComment(self, Comment = None, NumLines = None, Replace = None):
        """
This function sets the user comments and log data.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Comment: The data to be added to the user comments and log.
NumLines: The number of carriage return and line feeds to be included before the specified comment. This item is ignored if Replace = True. It is also ignored if there are no existing comments.
Replace: If this item is True, all existing comments are replaced with the specified comment.
        """

        all_args = [Comment, NumLines, Replace]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SetUserComment(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUserComment" failed')
        
        return ret

class AreaElm:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetLoadGravity(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, CSys = None, x = None, y = None, z = None, ItemTypeElm = None):
        """
This function retrieves the gravity load assignments to area elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area element or group, depending on the value of the ItemType item.
NumberItems: The total number of gravity loads retrieved for the specified area elements.
AreaName: This is an array that includes the name of the area element associated with each gravity load.
LoadPat: This is an array that includes the name of the coordinate system in which the gravity load multipliers are specified.
CSys: This is an array that includes the name of the coordinate system associated with each gravity load.
x: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the area elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the area element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the area elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for area elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, CSys, x, y, z, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadGravity" failed')
        
        return ret

    def GetLoadPorePressure(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the pore pressure load assignments to area elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area element or group depending on the value of the ItemType item.
NumberItems: The total number of pore pressure loads retrieved for the specified area elements.
AreaName: This is an array that includes the name of the area element associated with each pore pressure load.
LoadPat: This is an array that includes the name of the load pattern associated with each pore pressure load.
Value: This is an array that includes the pore pressure load value. [F/L2]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the pore pressure load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the area elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the area element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the area elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for area elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetLoadPorePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadPorePressure" failed')
        
        return ret

    def GetLoadStrain(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, Component = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the strain load assignments to area elements.
The function returns zero if the strain load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area element or group, depending on the value of the ItemType item.
NumberItems: The total number of strain loads retrieved for the specified area elements.
AreaName: This is an array that includes the name of the area element associated with each strain load.
LoadPat: This is an array that includes the name of the load pattern associated with each strain load.
Component: This is an array that includes 1, 2, 3, 4, 5, 6, 7 or 8, indicating the component associated with each strain load.
1 = Strain11
2 = Strain22
3 = Strain12
4 = Curvature11
5 = Curvature22
6 = Curvature12
7 = Strain13
8 = Strain23
Value: This is an array that includes the strain value. [L/L] for Component = 1, 2, 3, 7 and 8, and [1/L] for Component = 4, 5 and 6
PatternName: This is an array that includes the joint pattern name, if any, used to specify the strain load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the area elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the area element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the area elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for area elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, Component, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadStrain" failed')
        
        return ret

    def GetLoadSurfacePressure(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, Face = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the surface pressure load assignments to area elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area element or group, depending on the value of the ItemType item.
NumberItems: The total number of surface pressure loads retrieved for the specified area elements.
AreaName: This is an array that includes the name of the area element associated with each surface pressure load.
LoadPat: This is an array that includes the name of the load pattern associated with each surface pressure load.
Face: This is an array that includes -1, -2 or a nonzero, positive integer, indicating the area element face to which the specified load assignment applies.
-1 = Bottom face
-2 = Top face
>0 = Edge face

Note that edge face n is from area element point n to area element point n + 1. For example, edge face 2 is from area element point 2 to area element point 3.
Value: This is an array that includes the surface pressure load value. [F/L2]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the surface pressure load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the area elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the area element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the area elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for area elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, Face, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetLoadSurfacePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadSurfacePressure" failed')
        
        return ret

    def GetLoadTemperature(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, MyType = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the temperature load assignments to area elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area element or group, depending on the value of the ItemType item.
NumberItems: The total number of temperature loads retrieved for the specified area elements.
AreaName: This is an array that includes the name of the area element associated with each temperature load.
LoadPat: This is an array that includes the name of the load pattern associated with each temperature load.
MyType: This is an array that includes either 1 or 3, indicating the type of temperature load.
1 = Temperature
3 = Temperature gradient along local 3 axis
Value: This is an array that includes the temperature load value. [T] for MyType= 1 and [T/L] for MyType= 3
PatternName: This is an array that includes the joint pattern name, if any, used to specify the temperature load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the area elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the area element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the area elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for area elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, MyType, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTemperature" failed')
        
        return ret

    def GetLoadUniform(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, CSys = None, Dir = None, Value = None, ItemTypeElm = None):
        """
This function retrieves the uniform load assignments to area elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area element or group, depending on the value of the ItemType item.
NumberItems: The total number of uniform loads retrieved for the specified area elements.
AreaName: This is an array that includes the name of the area element associated with each uniform load.
LoadPat: This is an array that includes the name of the coordinate system in which the uniform load is specified.
CSys: This is an array that includes the name of the coordinate system associated with each uniform load.
Dir: This is an integer between 1 and 11, indicating the direction of the load.
1 = Local 1 axis (applies only when CSys is Local)
2 = Local 2 axis (applies only when CSys is Local)
3 = Local 3 axis (applies only when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
7 = Projected X direction (does not apply when CSys is Local)
8 = Projected Y direction (does not apply when CSys is Local)
9 = Projected Z direction (does not apply when CSys is Local)
10 = Gravity direction (applies only when CSys is Global)
11 = Projected Gravity direction (applies only when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) is in the negative Global Z direction.
Value: The uniform load value. [F/L2]
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the area elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the area element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the area elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for area elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, CSys, Dir, Value, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetLoadUniform(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadUniform" failed')
        
        return ret

    def GetLocalAxes(self, Name = None, Ang = None):
        """
This function retrieves the local axis angle assignment for area elements.
The function returns zero if the assignment is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area element.
Ang: This is the angle that the local 1 and 2 axes are rotated about the positive local 3 axis from the default orientation. The rotation for a positive angle appears counter clockwise when the local +3 axis is pointing toward you. [deg]
        """

        all_args = [Name, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxes" failed')
        
        return ret

    def GetMaterialOverwrite(self, Name = None, PropName = None):
        """
This function retrieves the material overwrite assigned to an area element, if any. The material property name is indicated as None if there is no material overwrite assignment.
The function returns zero if the material overwrite assignment is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined area element.
PropName: This is None, indicating that no material overwrite exists for the specified area element, or it is the name of an existing material property.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetMaterialOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMaterialOverwrite" failed')
        
        return ret

    def GetMatTemp(self, Name = None, Temp = None, PatternName = None):
        """
This function retrieves the material temperature assignments to area elements.
The function returns zero if the material temperature assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area element.
Temp: This is the material temperature value assigned to the area element. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the area element is uniform over the element at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the area element may vary. The material temperature at each corner point around the area element perimeter is equal to the specified temperature multiplied by the pattern value at the associated point element. The material temperature at other points in the area element is calculated by interpolation from the corner points.
        """

        all_args = [Name, Temp, PatternName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMatTemp" failed')
        
        return ret

    def GetModifiers(self, Name = None, Value = None):
        """
This function retrieves the modifier assignment for area elements. The default value for all modifiers is one.
The function returns zero if the modifier assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area element.
Value: This is an array of ten unitless modifiers.
Value(0) = Membrane f11 modifier
Value(1) = Membrane f22 modifier
Value(2) = Membrane f12 modifier
Value(3) = Bending m11 modifier
Value(4) = Bending m22 modifier
Value(5) = Bending m12 modifier
Value(6) = Shear v13 modifier
Value(7) = Shear v23 modifier
Value(8) = Mass modifier
Value(9) = Weight modifier

        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModifiers" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined area elements.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of area element names retrieved by the program.
MyName: This is a one-dimensional array of area element names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames â€“ 1) inside the SAP2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetOffsets(self, Name = None, OffsetType = None, OffsetPattern = None, OffsetPatternSF = None, Offset = None):
        """
This function retrieves the joint offset assignments for area elements.
The function returns zero if the assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area element.
OffsetType: This is 0, 1 or 2, indicating the joint offset type.
0 = No joint offsets
1 = User defined joint offsets specified by joint pattern
2 = User defined joint offsets specified by point

OffsetPattern: This item applies only when OffsetType = 1. It is the name of the defined joint pattern that is used to calculate the joint offsets.
OffsetPatternSF: This item only applies when OffsetType = 1. It is the scale factor applied to the joint pattern when calculating the joint offsets. [L]
Offset: This item applies only when OffsetType = 2. It is an array of joint offsets for each of the points that define the area element. [L]
        """

        all_args = [Name, OffsetType, OffsetPattern, OffsetPatternSF, Offset]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetOffsets(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOffsets" failed')
        
        return ret

    def GetPoints(self, Name = None, NumberPoints = None, Point = None):
        """
This function retrieves the names of the point elements that define an area element.
The function returns zero if the point element names are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an area element.
NumberPoints: The number of point elements that define the area element.
Point: This is an array containing the names of the point elements that define the area element. The point names are in order around the area element.
        """

        all_args = [Name, NumberPoints, Point]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPoints" failed')
        
        return ret

    def GetProperty(self, Name = None, PropName = None):
        """
This function retrieves the area property assigned to an area element.
The function returns zero if the property is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined area element.
PropName: The name of the area property assigned to the area element. This item is None if there is no area property assigned to the area element.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProperty" failed')
        
        return ret

    def GetThickness(self, Name = None, ThicknessType = None, ThicknessPattern = None, ThicknessPatternSF = None, Thickness = None):
        """
This function retrieves the thickness overwrite assignments for area elements.
The function returns zero if the assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area element.
ThicknessType: This is 0, 1 or 2, indicating the thickness overwrite type.
0 = No thickness overwrites
1 = User defined thickness overwrites specified by joint pattern
2 = User defined thickness overwrites specified by point

ThicknessPattern: This item applies only when ThicknessType = 1. It is the name of the defined joint pattern that is used to calculate the thicknesses.
ThicknessPatternSF: This item applies only when ThicknessType = 1. It is the scale factor applied to the joint pattern when calculating the thicknesses. [L]
Thickness: This item applies only when ThicknessType = 2. It is an array of thicknesses at each of the points that define the area element. [L]
        """

        all_args = [Name, ThicknessType, ThicknessPattern, ThicknessPatternSF, Thickness]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaElm.GetThickness(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetThickness" failed')
        
        return ret

class LineElm:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetEndLengthOffset(self, Name = None, Length1 = None, Length2 = None, rz = None):
        """
This function retrieves the line element end offsets along the 1-axis of the element.
The function returns zero if the offsets are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line element.
Length1: The offset length along the 1-axis of the line element at the I-End of the line element. [L]
Length2: The offset along the 1-axis of the line element at the J-End of the line element. [L]
rz: The rigid zone factor.This is the fraction of the end offset length assumed to be rigid for bending and shear deformations.
        """

        all_args = [Name, Length1, Length2, rz]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetEndLengthOffset(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEndLengthOffset" failed')
        
        return ret

    def GetInsertionPoint(self, Name = None, Offset1 = None, Offset2 = None):
        """
This function retrieves line element insertion point assignments. The assignments are reported as end joint offsets.
The function returns zero if the insertion point data is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line element.
Offset1: This is an array of three joint offset distances, in the Global coordinate system, at the I-End of the line element. [L]
Offset1(0) = I-End offset in the global X-axis direction
Offset1(1) = I-End offset in the global Y-axis direction
Offset1(2) = I-End offset in the global Z-axis direction
Offset2: This is an array of three joint offset distances, in the Global coordinate system, at the J-End of the line element. [L]
Offset2(0) = J-End offset in the global X-axis direction
Offset2(1) = J-End offset in the global Y-axis direction
Offset2(2) = J-End offset in the global Z-axis direction
        """

        all_args = [Name, Offset1, Offset2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetInsertionPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInsertionPoint" failed')
        
        return ret

    def GetLoadDeformation(self, Name = None, NumberItems = None, LineName = None, LoadPat = None, dof1 = None, dof2 = None, dof3 = None, dof4 = None, dof5 = None, dof6 = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None, ItemTypeElm = None):
        """
This function retrieves the deformation load assignments to line elements.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line object, line element or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: The total number of deformation loads retrieved for the specified line elements.
LineName: This is an array that includes the name of the line element associated with each deformation load.
LoadPat: This is an array that includes the name of the load pattern associated with each deformation load.
dof1: These are arrays of boolean values indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof2: These are arrays of boolean values indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof3: These are arrays of boolean values indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof4: These are arrays of boolean values indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof5: These are arrays of boolean values indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof6: These are arrays of boolean values indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
U1: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
U2: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
U3: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
R1: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
R2: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
R3: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the line elements corresponding to the line object specified by the Name item.
If this item is Element, the load assignments are retrieved for the line element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the line elements corresponding to all line objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for line elements corresponding to all selected line objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LineName, LoadPat, dof1, dof2, dof3, dof4, dof5, dof6, U1, U2, U3, R1, R2, R3, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadDeformation" failed')
        
        return ret

    def GetLoadDistributed(self, Name = None, NumberItems = None, LineName = None, LoadPat = None, MyType = None, CSys = None, Dir = None, RD1 = None, RD2 = None, Dist1 = None, Dist2 = None, Val1 = None, Val2 = None, ItemTypeElm = None):
        """
This function retrieves the distributed load assignments to line elements.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line object, line element or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: The total number of distributed loads retrieved for the specified line elements.
LineName: This is an array that includes the name of the line element associated with each distributed load.
LoadPat: This is an array that includes the name of the coordinate system in which the distributed loads are specified.
MyType: This is an array that includes either 1 or 2, indicating the type of distributed load.
1 = Force
2 = Moment
CSys: This is an array that includes the name of the coordinate system in which each distributed load is defined. It may be Local or the name of a defined coordinate system.
Dir: This is an array that includes an integer between 1 and 11, indicating the direction of the load.
1 = Local 1 axis (only applies when CSys is Local)
2 = Local 2 axis (only applies when CSys is Local)
3 = Local 3 axis (only applies when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
7 = Projected X direction (does not apply when CSys is Local)
8 = Projected Y direction (does not apply when CSys is Local)
9 = Projected Z direction (does not apply when CSys is Local)
10 = Gravity direction (only applies when CSys is Global)
11 = Projected Gravity direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) is in the negative Global Z direction.
RD1: This is an array that includes the relative distance from the I-End of the line element to the start of the distributed load.
RD2: This is an array that includes the relative distance from the I-End of the line element to the end of the distributed load.
Dist1: This is an array that includes the actual distance from the I-End of the line element to the start of the distributed load. [L]
Dist2: This is an array that includes the actual distance from the I-End of the line element to the end of the distributed load. [L]
Val1: This is an array that includes the load value at the start of the distributed load. [F/L] when MyType is 1 and [FL/L] when MyType is 2
Val2: This is an array that includes the load value at the end of the distributed load. [F/L] when MyType is 1 and [FL/L] when MyType is 2
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the line elements corresponding to the line object specified by the Name item.
If this item is Element, the load assignments are retrieved for the line element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the line elements corresponding to all line objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for line elements corresponding to all selected line objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LineName, LoadPat, MyType, CSys, Dir, RD1, RD2, Dist1, Dist2, Val1, Val2, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetLoadDistributed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadDistributed" failed')
        
        return ret

    def GetLoadGravity(self, Name = None, NumberItems = None, LineName = None, LoadPat = None, CSys = None, x = None, y = None, z = None, ItemTypeElm = None):
        """
This function retrieves the gravity load assignments to line elements.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line object, line element or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: The total number of gravity loads retrieved for the specified line elements.
LineName: This is an array that includes the name of the line element associated with each gravity load.
LoadPat: This is an array that includes the name of the coordinate system in which the gravity load multipliers are specified.
CSys: This is an array that includes the name of the coordinate system associated with each gravity load.
x: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the line elements corresponding to the line object specified by the Name item.
If this item is Element, the load assignments are retrieved for the line element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the line elements corresponding to all line objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for line elements corresponding to all selected line objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LineName, LoadPat, CSys, x, y, z, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadGravity" failed')
        
        return ret

    def GetLoadPoint(self, Name = None, NumberItems = None, LineName = None, LoadPat = None, MyType = None, CSys = None, Dir = None, RelDist = None, Dist = None, Val = None, ItemTypeElm = None):
        """
This function retrieves the point load assignments to line elements.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line object, line element or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: The total number of point loads retrieved for the specified line elements.
LineName: This is an array that includes the name of the line element associated with each point load.
LoadPat: This is an array that includes the name of the coordinate system in which the point loads are specified.
MyType: This is an array that includes either 1 or 2, indicating the type of point load.
1 = Force
2 = Moment
CSys: This is an array that includes the name of the coordinate system in which each point load is defined. It may be Local or the name of a defined coordinate system.
Dir: This is an array that includes an integer between 1 and 11, indicating the direction of the load.
1 = Local 1 axis (only applies when CSys is Local)
2 = Local 2 axis (only applies when CSys is Local)
3 = Local 3 axis (only applies when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
7 = Projected X direction (does not apply when CSys is Local)
8 = Projected Y direction (does not apply when CSys is Local)
9 = Projected Z direction (does not apply when CSys is Local)
10 = Gravity direction (only applies when CSys is Global)
11 = Projected Gravity direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) is in the negative Global Z direction.
RelDist: This is an array that includes the relative distance from the I-End of the line element to the location where the point load is applied.
Dist: This is an array that includes the actual distance from the I-End of the line element to the location where the point load is applied. [L]
Val: This is an array that includes the value of the point load. [F] when MyType is 1 and [FL] when MyType is 2
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the line elements corresponding to the line object specified by the Name item.
If this item is Element, the load assignments are retrieved for the line element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the line elements corresponding to all line objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for line elements corresponding to all selected line objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LineName, LoadPat, MyType, CSys, Dir, RelDist, Dist, Val, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetLoadPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadPoint" failed')
        
        return ret

    def GetLoadStrain(self, Name = None, NumberItems = None, LineName = None, LoadPat = None, DOF = None, Val = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the strain load assignments to line elements.
The function returns zero if the strain load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line object, line element or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: The total number of strain loads retrieved for the specified line elements.
LineName: This is an array that includes the name of the line element associated with each strain load.
LoadPat: This is an array that includes the name of the load pattern associated with each strain load.
DOF: This is an array that includes 1, 2, 3, 4, 5 or 6, indicating the degree of freedom associated with each strain load.
1 = Strain11
2 = Strain12
3 = Strain13
4 = Curvature1
5 = Curvature2
6 = Curvature3
Val: This is an array that includes the strain value. [L/L] for DOF = 1, 2 and 3 and [1/L] for DOF = 4, 5 and 6
PatternName: This is an array that includes the joint pattern name, if any, used to specify the strain load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the line elements corresponding to the line object specified by the Name item.
If this item is Element, the load assignments are retrieved for the line element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the line elements corresponding to all line objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for line elements corresponding to all selected line objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LineName, LoadPat, DOF, Val, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadStrain" failed')
        
        return ret

    def GetLoadTargetForce(self, Name = None, NumberItems = None, LineName = None, LoadPat = None, dof1 = None, dof2 = None, dof3 = None, dof4 = None, dof5 = None, dof6 = None, P = None, V2 = None, V3 = None, T = None, M2 = None, M3 = None, T1 = None, T2 = None, T3 = None, T4 = None, T5 = None, T6 = None, ItemTypeElm = None):
        """
This function retrieves the target force assignments to line elements.
The function returns zero if the target force assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line object, line element or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: The total number of deformation loads retrieved for the specified line elements.
LineName: This is an array that includes the name of the line element associated with each target force.
LoadPat: This is an array that includes the name of the load pattern associated with each target force.
dof1: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof2: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof3: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof4: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof5: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof6: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
P: These are arrays of target force values. The target forces specified for a given degree of freedom are only applicable if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
V2: These are arrays of target force values. The target forces specified for a given degree of freedom are only applicable if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
V3: These are arrays of target force values. The target forces specified for a given degree of freedom are only applicable if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
T: These are arrays of target force values. The target forces specified for a given degree of freedom are only applicable if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
M2: These are arrays of target force values. The target forces specified for a given degree of freedom are only applicable if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
M3: These are arrays of target force values. The target forces specified for a given degree of freedom are only applicable if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
T1: These are arrays of the relative distances along the line elements where the target force values apply. The relative distances specified for a given degree of freedom are only applicable if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T2: These are arrays of the relative distances along the line elements where the target force values apply. The relative distances specified for a given degree of freedom are only applicable if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T3: These are arrays of the relative distances along the line elements where the target force values apply. The relative distances specified for a given degree of freedom are only applicable if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T4: These are arrays of the relative distances along the line elements where the target force values apply. The relative distances specified for a given degree of freedom are only applicable if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T5: These are arrays of the relative distances along the line elements where the target force values apply. The relative distances specified for a given degree of freedom are only applicable if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T6: These are arrays of the relative distances along the line elements where the target force values apply. The relative distances specified for a given degree of freedom are only applicable if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the line elements corresponding to the line object specified by the Name item.
If this item is Element, the load assignments are retrieved for the line element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the line elements corresponding to all line objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for line elements corresponding to all selected line objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LineName, LoadPat, dof1, dof2, dof3, dof4, dof5, dof6, P, V2, V3, T, M2, M3, T1, T2, T3, T4, T5, T6, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetLoadTargetForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTargetForce" failed')
        
        return ret

    def GetLoadTemperature(self, Name = None, NumberItems = None, LineName = None, LoadPat = None, MyType = None, Val = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the temperature load assignments to line elements.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line object, line element or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: The total number of temperature loads retrieved for the specified line elements.
LineName: This is an array that includes the name of the line element associated with each temperature load.
LoadPat: This is an array that includes the name of the load pattern associated with each temperature load.
MyType: This is an array that includes 1, 2 or 3, indicating the type of temperature load.
1 = Temperature
2 = Temperature gradient along local 2 axis
3 = Temperature gradient along local 3 axis
Val: This is an array that includes the temperature load value. [T] for MyType= 1 and [T/L] for MyType= 2 and 3
PatternName: This is an array that includes the joint pattern name, if any, used to specify the temperature load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the line elements corresponding to the line object specified by the Name item.
If this item is Element, the load assignments are retrieved for the line element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the line elements corresponding to all line objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for line elements corresponding to all selected line objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LineName, LoadPat, MyType, Val, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTemperature" failed')
        
        return ret

    def GetLocalAxes(self, Name = None, Ang = None):
        """
This function retrieves the local axis angle assignment for line elements.
The function returns zero if the assignment is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line element.
Ang: This is the angle that the local 2 and 3 axes are rotated about the positive local 1 axis, from the default orientation. The rotation for a positive angle appears counterclockwise when the local +1 axis is pointing toward you. [deg]
        """

        all_args = [Name, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxes" failed')
        
        return ret

    def GetMaterialOverwrite(self, Name = None, PropName = None):
        """
This function retrieves the material overwrite assigned to a line element, if any. It returns None if there is no material overwrite assignment.
The function returns zero if the material overwrite assignment is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined line element.
PropName: This is None, indicating that no material overwrite exists for the specified line element, or it is the name of an existing material property.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetMaterialOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMaterialOverwrite" failed')
        
        return ret

    def GetMatTemp(self, Name = None, Temp = None, PatternName = None):
        """
This function retrieves the material temperature assignments to line elements.
The function returns zero if the material temperature assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line element.
Temp: This is the material temperature value assigned to the line element. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the line element is uniform along the element at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the line element may vary from one end to the other. The material temperature at each end of the element is equal to the specified temperature multiplied by the pattern value at the joint at the end of the line element.
        """

        all_args = [Name, Temp, PatternName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMatTemp" failed')
        
        return ret

    def GetModifiers(self, Name = None, Value = None):
        """
This function retrieves the section  modifier assignment for line elements. The default value for all modifiers is one.
The function returns zero if the modifier assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line element.
Value: This is an array of eight unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Shear area in local 2 direction modifier
Value(2) = Shear area in local 3 direction modifier
Value(3) = Torsional constant modifier
Value(4) = Moment of inertia about local 2 axis modifier
Value(5) = Moment of inertia about local 3 axis modifier
Value(6) = Mass modifier
Value(7) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModifiers" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined line elements.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of line element names retrieved by the program.
MyName: This is a one-dimensional array of line element names. The MyName array is created as a dynamic, zero-based, array by the APIuser:
Dim MyName() as String
The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetPDeltaForce(self, Name = None, NumberForces = None, PDeltaForce = None, Dir = None, CSys = None):
        """
This function retrieves the P-Delta force assignments to line elements.
The function returns zero if the assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line element.
NumberForces: The number of P-Delta forces assigned to the line element.
PDeltaForce: This is an array of the P-Delta force values assigned to the line element. [F]
Dir: This is an array that contains 0, 1, 2 or 3, indicating the direction of each P-Delta force assignment.
0 = Frame object local 1-axis direction
1 = Projected X direction in CSys coordinate system
2 = Projected Y direction in CSys coordinate system
3 = Projected Z direction in CSys coordinate system
CSys: This is an array that contains the name of the coordinate system in which each projected P-Delta force is defined. This item is blank when the Dir item is zero, that is, when the P-Delta force is defined in the line element local 1-axis direction.
        """

        all_args = [Name, NumberForces, PDeltaForce, Dir, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetPDeltaForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPDeltaForce" failed')
        
        return ret

    def GetPoints(self, Name = None, Point1 = None, Point2 = None):
        """
This function retrieves the names of the point elements at each end of a specified line element.
The function returns zero if the point names are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined line element.
Point1: The name of the point element at the I-End of the specified line element.
Point2: The name of the point element at the J-End of the specified line element.
        """

        all_args = [Name, Point1, Point2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPoints" failed')
        
        return ret

    def GetProperty(self, Name = None, PropName = None, ObjType = None, Var = None, sVarTotalLength = None, sVarRelStartLoc = None):
        """
This function retrieves the property assignment to a line element.
The function returns zero if the property data is successfully retrieved, otherwise it returns a nonzero value.
The sVarTotalLength and sVarRelStartLoc items apply only when the Var item is True.

Name: The name of an existing line element.
PropName: The name of the frame section, cable or tendon property assigned to the line element.
ObjType: This is 0, 1, 2 or 3, indicating the type of object from which the line element was created.
0 = Straight frame object
1 = Curved frame object
2 = Cable object
3 = Tendon object
Var: This item is True if the specified property is a nonprismatic (variable) frame section property.
sVarTotalLength: This is the total assumed length of the nonprismatic section. A zero value for this item means that the section length is the same as the line element length.
sVarRelStartLoc: This is the relative distance along the nonprismatic section to the I-End (start) of the line element. This item is ignored when the sVarTotalLengthitem is 0.
        """

        all_args = [Name, PropName, ObjType, Var, sVarTotalLength, sVarRelStartLoc]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProperty" failed')
        
        return ret

    def GetReleases(self, Name = None, ii = None, jj = None, StartValue = None, EndValue = None):
        """
This function retrieves the line element end release and partial fixity assignments.
The function returns zero if the assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing line element.
ii: These are arrays of six booleans indicating the I-End and J-End releases for the line element.
ii(0) and jj(0) = U1 release
ii(1) and jj(1) = U2 release
ii(2) and jj(2) = U3 release
ii(3) and jj(3) = R1 release
ii(4) and jj(4) = R2 release
ii(5) and jj(5) = R3 release

jj: These are arrays of six booleans indicating the I-End and J-End releases for the line element.
ii(0) and jj(0) = U1 release
ii(1) and jj(1) = U2 release
ii(2) and jj(2) = U3 release
ii(3) and jj(3) = R1 release
ii(4) and jj(4) = R2 release
ii(5) and jj(5) = R3 release

StartValue: These are arrays of six values indicating the I-End and J-End partial fixity springs for the line element.
StartValue(0) and EndValue(0) = U1 partial fixity [F/L]
StartValue(1) and EndValue(1) = U2 partial fixity [F/L]
StartValue(2) and EndValue(2) = U3 partial fixity [F/L]
StartValue(3) and EndValue(3) = R1 partial fixity [FL/rad]
StartValue(4) and EndValue(4) = R2 partial fixity [FL/rad]
StartValue(5) and EndValue(5) = R3 partial fixity [FL/rad]
EndValue: These are arrays of six values indicating the I-End and J-End partial fixity springs for the line element.
StartValue(0) and EndValue(0) = U1 partial fixity [F/L]
StartValue(1) and EndValue(1) = U2 partial fixity [F/L]
StartValue(2) and EndValue(2) = U3 partial fixity [F/L]
StartValue(3) and EndValue(3) = R1 partial fixity [FL/rad]
StartValue(4) and EndValue(4) = R2 partial fixity [FL/rad]
StartValue(5) and EndValue(5) = R3 partial fixity [FL/rad]
        """

        all_args = [Name, ii, jj, StartValue, EndValue]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetReleases(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetReleases" failed')
        
        return ret

    def GetTCLimits(self, Name = None, LimitCompressionExists = None, LimitCompression = None, LimitTensionExists = None, LimitTension = None):
        """
This function retrieves the tension/compression force limit assignments to line elements.
The function returns zero if the assignments are successfully retrieved, otherwise it returns a nonzero value.
Note that the tension and compression limits are only used in nonlinear analyses.

Name: The name of an existing line element.
LimitCompressionExists: This item is True if a compression force limit exists for the line element.
LimitCompression: The compression force limit for the line element. [F]
LimitTensionExists: This item is True if a tension force limit exists for the line element.
LimitTension: The tension force limit for the line element. [F]
        """

        all_args = [Name, LimitCompressionExists, LimitCompression, LimitTensionExists, LimitTension]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LineElm.GetTCLimits(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTCLimits" failed')
        
        return ret

class LinkElm:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetLoadDeformation(self, Name = None, NumberItems = None, LinkName = None, LoadPat = None, dof1 = None, dof2 = None, dof3 = None, dof4 = None, dof5 = None, dof6 = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None, ItemTypeElm = None):
        """
This function retrieves the deformation load assignments to link elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing link object, link element or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: The total number of deformation loads retrieved for the specified link elements.
LinkName: This is an array that includes the name of the link element associated with each deformation load.
LoadPat: This is an array that includes the name of the load pattern associated with each deformation load.
dof1: These are arrays of boolean values, indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof2: These are arrays of boolean values, indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof3: These are arrays of boolean values, indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof4: These are arrays of boolean values, indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof5: These are arrays of boolean values, indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof6: These are arrays of boolean values, indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
U1: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
U2: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
U3: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
R1: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
R2: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
R3: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the link elements corresponding to the link object specified by the Name item.
If this item is Element, the load assignments are retrieved for the link element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the link elements corresponding to all link objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for link elements corresponding to all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LinkName, LoadPat, dof1, dof2, dof3, dof4, dof5, dof6, U1, U2, U3, R1, R2, R3, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkElm.GetLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadDeformation" failed')
        
        return ret

    def GetLoadGravity(self, Name = None, NumberItems = None, LinkName = None, LoadPat = None, CSys = None, x = None, y = None, z = None, ItemTypeElm = None):
        """
This function retrieves the gravity load assignments to link elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing link object, link element or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: The total number of gravity loads retrieved for the specified link elements.
LinkName: This is an array that includes the name of the link element associated with each gravity load.
LoadPat: This is an array that includes the name of the coordinate system in which the gravity load multipliers are specified.
CSys: This is an array that includes the name of the coordinate system associated with each gravity load.
x: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the link elements corresponding to the link object specified by the Name item.
If this item is Element, the load assignments are retrieved for the link element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the link elements corresponding to all link objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for link elements corresponding to all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LinkName, LoadPat, CSys, x, y, z, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkElm.GetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadGravity" failed')
        
        return ret

    def GetLoadTargetForce(self, Name = None, NumberItems = None, LinkName = None, LoadPat = None, dof1 = None, dof2 = None, dof3 = None, dof4 = None, dof5 = None, dof6 = None, P = None, V2 = None, V3 = None, T = None, M2 = None, M3 = None, T1 = None, T2 = None, T3 = None, T4 = None, T5 = None, T6 = None, ItemTypeElm = None):
        """
This function retrieves the target force assignments to link elements.
The function returns zero if the target force assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing link object, link element or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: The total number of deformation loads retrieved for the specified link elements.
LinkName: This is an array that includes the name of the link element associated with each target force.
LoadPat: This is an array that includes the name of the load pattern associated with each target force.
dof1: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof2: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof3: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof4: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof5: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof6: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
P: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
V2: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
V3: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
T: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
M2: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
M3: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
T1: These are arrays of the relative distances along the link elements where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T2: These are arrays of the relative distances along the link elements where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T3: These are arrays of the relative distances along the link elements where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T4: These are arrays of the relative distances along the link elements where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T5: These are arrays of the relative distances along the link elements where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T6: These are arrays of the relative distances along the link elements where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the link elements corresponding to the link object specified by the Name item.
If this item is Element, the load assignments are retrieved for the link element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the link elements corresponding to all link objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for link elements corresponding to all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LinkName, LoadPat, dof1, dof2, dof3, dof4, dof5, dof6, P, V2, V3, T, M2, M3, T1, T2, T3, T4, T5, T6, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkElm.GetLoadTargetForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTargetForce" failed')
        
        return ret

    def GetLocalAxes(self, Name = None, Ang = None):
        """
This function retrieves the local axis angle assignment for link elements.
The function returns zero if the assignment is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing link element.
Ang: This is the angle that the local 2 and 3 axes are rotated about the positive local 1 axis, from the default orientation. The rotation for a positive angle appears counter clockwise when the local +1 axis is pointing toward you. [deg]
        """

        all_args = [Name, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkElm.GetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxes" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined link elements.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of link element names retrieved by the program.
MyName: This is a one-dimensional array of link element names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the SAP2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkElm.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetPoints(self, Name = None, Point1 = None, Point2 = None):
        """
This function retrieves the names of the point elements at each end of a specified link element. The points at each end have the same name if the link element is a one-joint element.
The function returns zero if the point names are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined link element.
Point1: The name of the point element at the I-End of the specified link element.
Point2: The name of the point element at the J-End of the specified link element.
        """

        all_args = [Name, Point1, Point2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkElm.GetPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPoints" failed')
        
        return ret

    def GetPropertyFD(self, Name = None, PropName = None):
        """
This function retrieves the frequency dependent property assignment to a link element. If no frequency dependent property is assigned to the link, the PropName is returned as None.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing link element.
PropName: The name of the frequency dependent link property assigned to the link element.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkElm.GetPropertyFD(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPropertyFD" failed')
        
        return ret

    def GetProperty(self, Name = None, PropName = None):
        """
This function retrieves the property assignment to a link element.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.
The sVarTotalLength and sVarRelStartLoc items apply only when the Var item is True.

Name: The name of an existing link element.
PropName: The name of the link property assigned to the link element.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkElm.GetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProperty" failed')
        
        return ret

class PlaneElm:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetLoadGravity(self, Name = None, NumberItems = None, PlaneName = None, LoadPat = None, CSys = None, x = None, y = None, z = None, ItemTypeElm = None):
        """
This function retrieves the gravity load assignments to plane elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing plane element or group, depending on the value of the ItemType item.
NumberItems: The total number of gravity loads retrieved for the specified plane elements.
PlaneName: This is an array that includes the name of the plane element associated with each gravity load.
LoadPat: This is an array that includes the name of the coordinate system in which the gravity load multipliers are specified.
CSys: This is an array that includes the name of the coordinate system associated with each gravity load.
x: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the plane elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the plane element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the plane elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for plane elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, PlaneName, LoadPat, CSys, x, y, z, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PlaneElm.GetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadGravity" failed')
        
        return ret

    def GetLoadPorePressure(self, Name = None, NumberItems = None, PlaneName = None, LoadPat = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the pore pressure load assignments to plane elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing plane element or group, depending on the value of the ItemType item.
NumberItems: The total number of pore pressure loads retrieved for the specified plane elements.
PlaneName: This is an array that includes the name of the plane element associated with each pore pressure load.
LoadPat: This is an array that includes the name of the load pattern associated with each pore pressure load.
Value: This is an array that includes the pore pressure load value. [F/L2]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the pore pressure load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the plane elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the plane element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the plane elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for plane elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, PlaneName, LoadPat, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PlaneElm.GetLoadPorePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadPorePressure" failed')
        
        return ret

    def GetLoadRotate(self, Name = None, NumberItems = None, PlaneName = None, LoadPat = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the rotate load assignments to plane elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing plane element or group, depending on the value of the ItemType item.
NumberItems: The total number of rotate loads retrieved for the specified plane elements.
PlaneName: This is an array that includes the name of the plane element associated with each rotate load.
LoadPat: This is an array that includes the name of the load pattern associated with each rotate load.
Value: This is an array that includes the rotate load value. [F/L2]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the rotate load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the plane elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the plane element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the plane elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for plane elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, PlaneName, LoadPat, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PlaneElm.GetLoadRotate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadRotate" failed')
        
        return ret

    def GetLoadStrain(self, Name = None, NumberItems = None, PlaneName = None, LoadPat = None, Component = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the strain load assignments to plane elements.
The function returns zero if the strain load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing plane element or group, depending on the value of the ItemType item.
NumberItems: The total number of strain loads retrieved for the specified plane elements.
PlaneName: This is an array that includes the name of the plane element associated with each strain load.
LoadPat: This is an array that includes the name of the load pattern associated with each strain load.
Component: This is an array that includes 1, 2, 3, 4 or 5, indicating the component associated with each strain load.
1 = Strain11
2 = Strain22
3 = Strain12
4 = Strain13
5 = Strain23
Value: This is an array that includes the strain value. [L/L]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the strain load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the plane elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the plane element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the plane elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for plane elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, PlaneName, LoadPat, Component, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PlaneElm.GetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadStrain" failed')
        
        return ret

    def GetLoadSurfacePressure(self, Name = None, NumberItems = None, PlaneName = None, LoadPat = None, Face = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the surface pressure load assignments to plane elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing plane element or group, depending on the value of the ItemType item.
NumberItems: The total number of surface pressure loads retrieved for the specified plane elements.
PlaneName: This is an array that includes the name of the plane element associated with each surface pressure load.
LoadPat: This is an array that includes the name of the load pattern associated with each surface pressure load.
Face: This is an array that includes -1, -2 or a nonzero, positive integer, indicating the area element face to which the specified load assignment applies.
-1 = Bottom face
-2 = Top face
>0 = Edge face

Note that edge face n is from plane element point n to plane element point n + 1. For example, edge face 2 is from plane element point 2 to plane element point 3.
Value: This is an array that includes the surface pressure load value. [F/L2]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the surface pressure load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the plane elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the plane element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the plane elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for plane elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, PlaneName, LoadPat, Face, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PlaneElm.GetLoadSurfacePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadSurfacePressure" failed')
        
        return ret

    def GetLoadTemperature(self, Name = None, NumberItems = None, PlaneName = None, LoadPat = None, MyType = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the temperature load assignments to plane elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing plane element or group, depending on the value of the ItemType item.
NumberItems: The total number of temperature loads retrieved for the specified plane elements.
PlaneName: This is an array that includes the name of the plane element associated with each temperature load.
LoadPat: This is an array that includes the name of the load pattern associated with each temperature load.
MyType: This is an array that includes either 1 or 3, indicating the type of temperature load.
1 = Temperature
3 = Temperature gradient along local 3 axis
Value: This is an array that includes the temperature load value. [T] for MyType= 1 and [T/L] for MyType= 3
PatternName: This is an array that includes the joint pattern name, if any, used to specify the temperature load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the plane elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the plane element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the plane elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for plane elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, PlaneName, LoadPat, MyType, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PlaneElm.GetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTemperature" failed')
        
        return ret

    def GetLoadUniform(self, Name = None, NumberItems = None, PlaneName = None, LoadPat = None, CSys = None, Dir = None, Value = None, ItemTypeElm = None):
        """
This function retrieves the uniform load assignments to plane elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing plane element or group, depending on the value of the ItemType item.
NumberItems: The total number of uniform loads retrieved for the specified plane elements.
PlaneName: This is an array that includes the name of the plane element associated with each uniform load.
LoadPat: This is an array that includes the name of the coordinate system in which the uniform load is specified.
CSys: This is an array that includes the name of the coordinate system associated with each uniform load.
Dir: This is an integer between 1 and 11, indicating the direction of the load.
1 = Local 1 axis (applies only when CSys is Local)
2 = Local 2 axis (applies only when CSys is Local)
3 = Local 3 axis (applies only when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
7 = Projected X direction (does not apply when CSys is Local)
8 = Projected Y direction (does not apply when CSys is Local)
9 = Projected Z direction (does not apply when CSys is Local)
10 = Gravity direction (applies only when CSys is Global)
11 = Projected Gravity direction (applies only when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) is in the negative Global Z direction.
Value: The uniform load value. [F/L2]
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the plane elements corresponding to the area object specified by the Name item.
If this item is Element, the load assignments are retrieved for the plane element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the plane elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for plane elements corresponding to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, PlaneName, LoadPat, CSys, Dir, Value, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PlaneElm.GetLoadUniform(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadUniform" failed')
        
        return ret

    def GetLocalAxes(self, Name = None, Ang = None):
        """
This function retrieves the local axis angle assignment for plane elements.
The function returns zero if the assignment is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing plane element.
Ang: This is the angle that the local 1 and 2 axes are rotated about the positive local 3 axis from the default orientation. The rotation for a positive angle appears counter clockwise when the local +3 axis is pointing toward you. [deg]
        """

        all_args = [Name, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PlaneElm.GetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxes" failed')
        
        return ret

    def GetMatTemp(self, Name = None, Temp = None, PatternName = None):
        """
This function retrieves the material temperature assignments to plane elements.
The function returns zero if the material temperature assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing plane element.
Temp: This is the material temperature value assigned to the plane element. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the plane element is uniform over the element at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the plane element may vary. The material temperature at each corner point around the plane element perimeter is equal to the specified temperature multiplied by the pattern value at the associated point element. The material temperature at other points in the plane element is calculated by interpolation from the corner points.
        """

        all_args = [Name, Temp, PatternName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PlaneElm.GetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMatTemp" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined plane elements.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of plane element names retrieved by the program.
MyName: This is a one-dimensional array of plane element names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PlaneElm.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetPoints(self, Name = None, NumberPoints = None, Point = None):
        """
This function retrieves the names of the point elements that define an plane element.
The function returns zero if the point element names are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an plane element.
NumberPoints: The number of point elements that define the plane element.
Point: This is an array containing the names of the point elements that define the plane element. The point names are in order around the plane element.
        """

        all_args = [Name, NumberPoints, Point]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PlaneElm.GetPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPoints" failed')
        
        return ret

    def GetProperty(self, Name = None, PropName = None):
        """
This function retrieves the area property assigned to an plane element.
The function returns zero if the property is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined plane element.
PropName: The name of the area property assigned to the plane element. This item is None if there is no area property assigned to the plane element.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PlaneElm.GetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProperty" failed')
        
        return ret

class PointElm:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def CountConstraint(self, Count = None, Name = None):
        """
If the Name item is provided, the Count item returns the total number of constraint assignments made to the specified point element. If the Name item is not specified or is specified as an empty string, the Count item returns the total number of constraint assignments to all point elements in the model. If the Name item is specified but it is not recognized by the program as a valid point element, an error is returned.
This function returns zero if the count is successfully completed, otherwise it returns a nonzero value.

Count: The number of counted constraints.
Name: This optional item is the name of an existing point element.
        """

        all_args = [Count, Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.CountConstraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountConstraint" failed')
        
        return ret

    def CountLoadDispl(self, Count = None, Name = None, LoadPat = None):
        """
If neither the Name item nor the LoadPat item is provided, the Count item returns the total number of ground displacement load assignments to point elements in the model.
If the Name item is provided but not the LoadPat item, the Count item returns the total number of ground displacement load assignments made for the specified point element.
If the Name item is not provided but the LoadPat item is specified, the Count item returns the total number of ground displacement load assignments made to all point elements for the specified load pattern.
If both the Name item and the LoadPat item are provided, the Count item returns the total number of ground displacement load assignments made to the specified point element for the specified load pattern.
If the Name item or the LoadPat item is provided but is not recognized by the program as valid, an error is returned.
This function returns zero if the count is successfully completed, otherwise it returns a nonzero value.

Count: The number of counted ground displacement loads.
Name: This optional item is the name of an existing point element.
LoadPat: This optional item is the name of an existing load pattern.
        """

        all_args = [Count, Name, LoadPat]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.CountLoadDispl(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountLoadDispl" failed')
        
        return ret

    def CountLoadForce(self, Count = None, Name = None, LoadPat = None):
        """
If neither the Name item nor the LoadPat item is provided, the Count item returns the total number of point load assignments to point elements in the model.
If the Name item is provided but not the LoadPat item, the Count item returns the total number of point load assignments made for the specified point element.
If the Name item is not provided but the LoadPat item is specified, the Count item returns the total number of point load assignments made to all point elements for the specified load pattern.
If both the Name item and the LoadPat item are provided, the Count item returns the total number of point load assignments made to the specified point element for the specified load pattern.
If the Name item or the LoadPat item is provided but is not recognized by the program as valid, an error is returned.
This function returns zero if the count is successfully completed, otherwise it returns a nonzero value.

Count: The number of counted point loads.
Name: This optional item is the name of an existing point element.
LoadPat: This optional item is the name of an existing load pattern.
        """

        all_args = [Count, Name, LoadPat]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.CountLoadForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountLoadForce" failed')
        
        return ret

    def CountRestraint(self):
        """
This function returns the total number of point elements in the model with restraint assignments.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.CountRestraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountRestraint" failed')
        
        return ret

    def CountSpring(self):
        """
This function returns the total number of point elements in the model with spring assignments.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.CountSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountSpring" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of point elements in the analysis model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def GetConnectivity(self, Name = None, NumberItems = None, ObjectType = None, ObjectName = None, PointNumber = None):
        """
This function returns a list of elements connected to a specified point element.
The function returns zero if the list is successfully filled; otherwise it returns nonzero.

Name: The name of an existing point element.
NumberItems: This is the total number of elements connected to the specified point element.
ObjectType: This is an array that includes the element type of each element connected to the specified point element.
2 = Frame element
3 = Cable element
4 = Tendon element
5 = Area element
6 = Solid element
7 = Link element
ObjectName: This is an array that includes the element name of each element connected to the specified point element.
PointNumber: This is an array that includes the point number within the considered element that corresponds to the specified point element.
        """

        all_args = [Name, NumberItems, ObjectType, ObjectName, PointNumber]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetConnectivity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetConnectivity" failed')
        
        return ret

    def GetConstraint(self, Name = None, NumberItems = None, PointName = None, ConstraintName = None, ItemTypeElm = None):
        """
This function returns a list of constraint assignments made to one or more specified point elements.
The function returns zero if the constraint name list is successfully filled, otherwise it returns nonzero.
The PointName and ConstraintName items are returned in one-dimensional arrays. Each array is created as a dynamic array by the API user. In VBA a dynamic string array is defined by:
   Dim PointName() as String
 
The arrays are dimensioned to (NumberItems – 1) inside the Sap2000 program, filled with values, and returned to the API user.
The arrays are zero-based. Thus the first item is at array index 0, and the last item is at array index (NumberItems - 1).

Name: The name of an existing point object, point element, or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: This is the total number of constraint assignments returned.
PointName: This is an array that includes the name of the point element to which the specified constraint assignment applies.
ConstraintName: This is an array that includes the name of the constraint that is assigned to the point element specified by the PointName item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the constraint assignments are retrieved for the point element corresponding to the point object specified by the Name item.
If this item is Element, the constraint assignments are retrieved for the point element specified by the Name item.
If this item is GroupElm, the constraint assignments are retrieved for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the constraint assignments are retrieved for all point elements directly or indirectly selected, and the Name item is ignored.
See Item Type for Elements for more information.
        """

        all_args = [Name, NumberItems, PointName, ConstraintName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetConstraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetConstraint" failed')
        
        return ret

    def GetCoordCartesian(self, Name = None, x = None, y = None, z = None, CSys = None):
        """
The function returns zero if the coordinates are successfully returned; otherwise it returns nonzero. If successful, the function returns the x, y and z coordinates of the specified point element in the Present Units. The coordinates are reported in the coordinate system specified by CSys.

Name: The name of an existing point element.
x: The X-coordinate of the specified point element in the specified coordinate system. [L]
y: The Y-coordinate of the specified point element in the specified coordinate system. [L]
z: The Z-coordinate of the specified point element in the specified coordinate system. [L]
CSys: The name of the coordinate system in which the joint coordinates are returned.
        """

        all_args = [Name, x, y, z, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetCoordCartesian(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCoordCartesian" failed')
        
        return ret

    def GetCoordCylindrical(self, Name = None, r = None, Theta = None, z = None, CSys = None):
        """
The function returns zero if the coordinates are successfully returned; otherwise it returns nonzero. If successful, the function returns the r, Theta and z coordinates of the specified point element in the Present Units. The coordinates are reported in the coordinate system specified by CSys.

Name: The name of an existing point element.
r: The radius for the point element in the specified coordinate system. [L]
Theta: The angle for the specified point element in the specified coordinate system. The angle is measured in the XY plane from the positive X axis. When looking in the XY plane with the positive Z axis pointing toward you, a positive Theta angle is counter clockwise. [deg]
z: The Z-coordinate of the specified point element in the specified coordinate system. [L]
CSys: The name of the coordinate system in which the joint coordinates are returned.
        """

        all_args = [Name, r, Theta, z, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetCoordCylindrical(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCoordCylindrical" failed')
        
        return ret

    def GetCoordSpherical(self, Name = None, r = None, a = None, b = None, CSys = None):
        """
The function returns zero if the coordinates are successfully returned; otherwise it returns nonzero. If successful, the function returns the r, a and b coordinates of the specified point element in the Present Units. The coordinates are reported in the coordinate system specified by CSys.

Name: The name of an existing point element.
r: The radius for the point element in the specified coordinate system. [L]
a: The plan angle for the point element in the specified coordinate system. This angle is measured in the XY plane from the positive global X axis. When looking in the XY plane with the positive Z axis pointing toward you, a positive a angle is counter clockwise. [deg]
b: The elevation angle for the point element in the specified coordinate system. This angle is measured in an X'Z plane that is perpendicular to the XY plane with the positive X' axis oriented at angle a from the positive global X axis. Angle b is measured from the positive global Z axis. When looking in the X’Z plane with the positive Y' axis pointing toward you, a positive b angle is counter clockwise. [deg]
CSys: The name of the coordinate system in which the joint coordinates are returned.
        """

        all_args = [Name, r, a, b, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetCoordSpherical(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCoordSpherical" failed')
        
        return ret

    def GetLoadDispl(self, Name = None, NumberItems = None, PointName = None, LoadPat = None, LCStep = None, CSys = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None, ItemTypeElm = None):
        """
This function retrieves the ground displacement load assignments to point elements.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point object, point element, or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: This is the total number of joint ground displacement assignments returned.
PointName: This is an array that includes the name of the point element to which the specified ground displacement assignment applies.
LoadPat: This is an array that includes the name of the load pattern for the ground displacement load.
LCStep: This is an array that includes the load pattern step for the ground displacement load. In most cases, this item does not apply and will be returned as 0.
CSys: This is an array that includes the name of the coordinate system for the ground displacement load. This is either Local or the name of a defined coordinate system.
U1: This is an array that includes the assigned translational ground displacement in the local 1-axis or coordinate system X-axis direction, depending on the specified CSys. [L]
U2: This is an array that includes the assigned translational ground displacement in the local 2-axis or coordinate system Y-axis direction, depending on the specified CSys. [L]
U3: This is an array that includes the assigned translational ground displacement in the local 3-axis or coordinate system Z-axis direction, depending on the specified CSys. [L]
R1: This is an array that includes the assigned rotational ground displacement about the local 1-axis or coordinate system X-axis, depending on the specified CSys. [rad]
R2: This is an array that includes the assigned rotational ground displacement about the local 2-axis or coordinate system Y-axis, depending on the specified CSys. [rad]
R3: This is an array that includes the assigned rotational ground displacement about the local 3-axis or coordinate system Z-axis, depending on the specified CSys. [rad]
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the ground displacement assignments are retrieved for the point element corresponding to the point object specified by the Name item.
If this item is Element, the ground displacement assignments are retrieved for the point element specified by the Name item.
If this item is GroupElm, the ground displacement assignments are retrieved for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the ground displacement assignments are retrieved for all point elements directly or indirectly selected, and the Name item is ignored.
See Item Type for Elements for more information.
        """

        all_args = [Name, NumberItems, PointName, LoadPat, LCStep, CSys, U1, U2, U3, R1, R2, R3, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetLoadDispl(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadDispl" failed')
        
        return ret

    def GetLoadForce(self, Name = None, NumberItems = None, PointName = None, LoadPat = None, LCStep = None, CSys = None, F1 = None, F2 = None, F3 = None, M1 = None, M2 = None, M3 = None, ItemTypeElm = None):
        """
This function retrieves the joint force load assignments to point elements.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point object, point element, or group of objects, depending on the value of the ItemTypeElm item.
NumberItems: This is the total number of joint force load assignments returned.
PointName: This is an array that includes the name of the point element to which the specified load assignment applies.
LoadPat: This is an array that includes the name of the load pattern for the load.
LCStep: This is an array that includes the load pattern step for the load. In most cases this item does not apply and will be returned as 0.
CSys: This is an array that includes the name of the coordinate system for the load. This is either Local or the name of a defined coordinate system.
F1: This is an array that includes the assigned translational force in the local 1-axis or coordinate system X-axis direction, depending on the specified CSys. [F]
F2: This is an array that includes the assigned translational force in the local 2-axis or coordinate system Y-axis direction, depending on the specified CSys. [F]
F3: This is an array that includes the assigned translational force in the local 3-axis or coordinate system Z-axis direction, depending on the specified CSys. [F]
M1: This is an array that includes the assigned moment about the local 1-axis or coordinate system X-axis, depending on the specified CSys. [FL]
M2: This is an array that includes the assigned moment about the local 2-axis or coordinate system Y-axis, depending on the specified CSys. [FL]
M3: This is an array that includes the assigned moment about the local 3-axis or coordinate system Z-axis, depending on the specified CSys. [FL]
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the point element corresponding to the point object specified by the Name item.
If this item is Element, the load assignments are retrieved for the point element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for all point elements directly or indirectly selected and the Name item is ignored.
See Item Type for Elements for more information.
        """

        all_args = [Name, NumberItems, PointName, LoadPat, LCStep, CSys, F1, F2, F3, M1, M2, M3, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetLoadForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadForce" failed')
        
        return ret

    def GetLocalAxes(self, Name = None, a = None, b = None, c = None):
        """
This function retrieves the local axes angles for a point element.
The function returns zero if the local axes angles are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point element.
a: The local axes of the point are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
b: The local axes of the point are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
c: The local axes of the point are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
        """

        all_args = [Name, a, b, c]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxes" failed')
        
        return ret

    def GetMergeNumber(self, Name = None, MergeNumber = None):
        """
This function retrieves the merge number for a point element. By default the merge number for a point is zero. Points with different merge numbers are not automatically merged by the program.
The function returns zero if the merge number is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point element.
MergeNumber: The merge number assigned to the specified point element.
        """

        all_args = [Name, MergeNumber]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetMergeNumber(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMergeNumber" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined point elements.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of point element names retrieved by the program.
MyName: This is a one-dimensional array of point element names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetObj(self, Name = None, Obj = None, ObjType = None):
        """
This function retrieves the object or defined item associated 
 with a specified point element.
The function returns zero if the object is successfully 
 retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point element.
Obj: The name of the object or defined item associated with 
 the specified point element. The type of object or item is determined 
 from the ObjType variable.
ObjType: A number indicating the type of object or defined item 
 that is associated with the point element.
1
Obj is the point object 
 corresponding to the specified point element.

2
Obj is a line object that 
 is internally meshed by the program to create the specified point element.

3
Obj is an area object 
 that is internally meshed by the program to create the specified point 
 element.

6
Obj is a solid object 
 that is internally meshed by the program to create the specified point 
 element.

9
Obj is a point object 
 that has a panel zone assignment. The specified point element is internally 
 added by the program at the point object (panel zone) location to model 
 the panel zone. The specified point element does not directly correspond 
 to the point object returned; it is an added point at the same location 
 as the point object.

21
Obj is a defined diaphragm 
 constraint. The specified point element was internally added by the program 
 for application of auto wind and auto seismic loads.

107
Obj is a link element 
 that was generated as part of the analysis model. 
        """

        all_args = [Name, Obj, ObjType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetObj(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetObj" failed')
        
        return ret

    def GetPatternValue(self, Name = None, PatternName = None, Value = None):
        """
This function retrieves the joint pattern value for a specific point element and joint pattern.
The function returns zero if the value is successfully retrieved, otherwise it returns a nonzero value.
Joint pattern values are unitless.

Name: The name of an existing point element.
PatternName: The name of a defined joint pattern.
Value: The value that the specified point element has for the specified joint pattern.
        """

        all_args = [Name, PatternName, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetPatternValue(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPatternValue" failed')
        
        return ret

    def GetRestraint(self, Name = None, Value = None):
        """
This function retrieves the restraint assignments for a point element. The restraint assignments are always returned in the point local coordinate system.
The function returns zero if the restraint assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point element.
Value: This is an array of six restraint values.
Value(0) = U1
Value(1) = U2
Value(2) = U3
Value(3) = R1
Value(4) = R2
Value(5) = R3
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetRestraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetRestraint" failed')
        
        return ret

    def GetSpringCoupled(self, Name = None, k = None):
        """
This function retrieves coupled spring stiffness assignments for a point element.
The spring stiffnesses reported are the sum of all springs assigned to the point element either directly or indirectly through line, area and solid spring assignments. The spring stiffness values are reported in the point local coordinate system.
The function returns zero if the stiffnesses are successfully retrieved, otherwise it returns a nonzero value. If no springs exist at the point element, the function returns a nonzero value.

Name: The name of an existing point element.
k: This is an array of twenty one spring stiffness values.
Value(0) = U1U1 [F/L]
Value(1) = U1U2 [F/L]
Value(2) = U2U2 [F/L]
Value(3) = U1U3 [F/L]
Value(4) = U2U3 [F/L]
Value(5) = U3U3 [F/L]
Value(6) = U1R1 [F/rad]
Value(7) = U2R1 [F/rad]
Value(8) = U3R1 [F/rad]
Value(9) = R1R1 [FL/rad]
Value(10) = U1R2 [F/rad]
Value(11) = U2R2 [F/rad]
Value(12) = U3R2 [F/rad]
Value(13) = R1R2 [FL/rad]
Value(14) = R2R2 [FL/rad]
Value(15) = U1R3 [F/rad]
Value(16) = U2R3 [F/rad]
Value(17) = U3R3 [F/rad]
Value(18) = R1R3 [FL/rad]
Value(19) = R2R3 [FL/rad]
Value(20) = R3R3 [FL/rad]
        """

        all_args = [Name, k]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetSpringCoupled(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSpringCoupled" failed')
        
        return ret

    def GetSpring(self, Name = None, k = None):
        """
This function retrieves uncoupled spring stiffness assignments for a point element; that is, it retrieves the diagonal terms in the 6x6 spring matrix for the point element.
The spring stiffnesses reported are the sum of all springs assigned to the point element either directly or indirectly through line, area and solid spring assignments. The spring stiffness values are reported in the point local coordinate system.
The function returns zero if the stiffnesses are successfully retrieved, otherwise it returns a nonzero value. If no springs exist at the point element, the function returns a nonzero value.

Name: The name of an existing point element.
k: This is an array of six spring stiffness values.
Value(0) = U1 [F/L]
Value(1) = U2 [F/L]
Value(2) = U3 [F/L]
Value(3) = R1 [FL/rad]
Value(4) = R2 [FL/rad]
Value(5) = R3 [FL/rad]
        """

        all_args = [Name, k]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSpring" failed')
        
        return ret

    def GetTransformationMatrix(self, Name = None, Value = None):
        """
The function returns zero if the transformation matrix is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point element.
Value: Value is an array of nine direction cosines that define the transformation matrix.
The following matrix equation shows how the transformation matrix is used to convert items from the point element local coordinate system to the global coordinate system.

In the equation, c0 through c8 are the nine values from the transformation array; (Local1, Local2, Local3) are an item (such as a point load) in the point element local coordinate system; and (GlobalX, GlobalY, GlobalZ) are the same item in the global coordinate system.
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.GetTransformationMatrix(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTransformationMatrix" failed')
        
        return ret

    def IsSpringCoupled(self, Name = None, IsCoupled = None):
        """
This function indicates if the spring assignments to a point element are coupled, that is, if there are off-diagonal terms in the 6x6 spring matrix for the point element.
The function returns zero if the coupled status is successfully retrieved, otherwise it returns a nonzero value. If no springs exist at the point object, the function returns a nonzero value.

Name: The name of an existing point element.
IsCoupled: This item is True if the spring assignment to the specified point element is coupled, otherwise it is False.
        """

        all_args = [Name, IsCoupled]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointElm.IsSpringCoupled(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"IsSpringCoupled" failed')
        
        return ret

class SolidElm:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetLoadGravity(self, Name = None, NumberItems = None, SolidName = None, LoadPat = None, CSys = None, x = None, y = None, z = None, ItemTypeElm = None):
        """
This function retrieves the gravity load assignments to solid elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid element or group, depending on the value of the ItemType item.
NumberItems: The total number of gravity loads retrieved for the specified solid elements.
SolidName: This is an array that includes the name of the solid element associated with each gravity load.
LoadPat: This is an array that includes the name of the coordinate system in which the gravity load multipliers are specified.
CSys: This is an array that includes the name of the coordinate system associated with each gravity load.
x: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the solid elements corresponding to the solid object specified by the Name item.
If this item is Element, the load assignments are retrieved for the solid element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the solid elements corresponding to all solid objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for solid elements corresponding to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, SolidName, LoadPat, CSys, x, y, z, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidElm.GetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadGravity" failed')
        
        return ret

    def GetLoadPorePressure(self, Name = None, NumberItems = None, SolidName = None, LoadPat = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the pore pressure load assignments to solid elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid element or group, depending on the value of the ItemType item.
NumberItems: The total number of pore pressure loads retrieved for the specified solid elements.
SolidName: This is an array that includes the name of the solid element associated with each pore pressure load.
LoadPat: This is an array that includes the name of the load pattern associated with each pore pressure load.
Value: This is an array that includes the pore pressure load value. [F/L2]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the pore pressure load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the solid elements corresponding to the solid object specified by the Name item.
If this item is Element, the load assignments are retrieved for the solid element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the solid elements corresponding to all solid objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for solid elements corresponding to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, SolidName, LoadPat, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidElm.GetLoadPorePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadPorePressure" failed')
        
        return ret

    def GetLoadStrain(self, Name = None, NumberItems = None, SolidName = None, LoadPat = None, Component = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the strain load assignments to solid elements.
The function returns zero if the strain load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid element or group, depending on the value of the ItemType item.
NumberItems: The total number of strain loads retrieved for the specified solid elements.
SolidName: This is an array that includes the name of the solid element associated with each strain load.
LoadPat: This is an array that includes the name of the load pattern associated with each strain load.
Component: This is 1, 2, 3, 4, 5 or 6, indicating the component to which the strain load is applied.
1 = Strain11
2 = Strain22
3 = Strain33
4 = Strain12
5 = Strain13
6 = Strain23
Value: This is an array that includes the strain value. [L/L]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the strain load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the solid elements corresponding to the solid object specified by the Name item.
If this item is Element, the load assignments are retrieved for the solid element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the solid elements corresponding to all solid objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for solid elements corresponding to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, SolidName, LoadPat, Component, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidElm.GetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadStrain" failed')
        
        return ret

    def GetLoadSurfacePressure(self, Name = None, NumberItems = None, SolidName = None, LoadPat = None, Face = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the surface pressure load assignments to solid objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid element or group, depending on the value of the ItemType item.
NumberItems: The total number of surface pressure loads retrieved for the specified solid elements.
SolidName: This is an array that includes the name of the solid element associated with each surface pressure load.
LoadPat: This is an array that includes the name of the load pattern associated with each surface pressure load.
Face: This is an array that includes 1, 2, 3, 4, 5 or 6, indicating the solid element face to which the specified load assignment applies.
Value: This is an array that includes the surface pressure load value. [F/L2]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the surface pressure load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the solid elements corresponding to the solid object specified by the Name item.
If this item is Element, the load assignments are retrieved for the solid element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the solid elements corresponding to all solid objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for solid elements corresponding to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, SolidName, LoadPat, Face, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidElm.GetLoadSurfacePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadSurfacePressure" failed')
        
        return ret

    def GetLoadTemperature(self, Name = None, NumberItems = None, SolidName = None, LoadPat = None, Value = None, PatternName = None, ItemTypeElm = None):
        """
This function retrieves the temperature load assignments to solid elements.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid element or group, depending on the value of the ItemType item.
NumberItems: The total number of temperature loads retrieved for the specified solid elements.
SolidName: This is an array that includes the name of the solid element associated with each temperature load.
LoadPat: This is an array that includes the name of the load pattern associated with each temperature load.
Value: This is an array that includes the temperature load value. [T]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the temperature load.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the load assignments are retrieved for the solid elements corresponding to the solid object specified by the Name item.
If this item is Element, the load assignments are retrieved for the solid element specified by the Name item.
If this item is GroupElm, the load assignments are retrieved for the solid elements corresponding to all solid objects included in the group specified by the Name item.
If this item is SelectionElm, the load assignments are retrieved for solid elements corresponding to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, SolidName, LoadPat, Value, PatternName, ItemTypeElm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidElm.GetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTemperature" failed')
        
        return ret

    def GetLocalAxes(self, Name = None, a = None, b = None, c = None):
        """
This function retrieves the local axis angle assignment for solid elements.
The function returns zero if the assignment is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid element.
a: The local axes of the solid element are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
b: The local axes of the solid element are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
c: The local axes of the solid element are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
        """

        all_args = [Name, a, b, c]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidElm.GetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxes" failed')
        
        return ret

    def GetMatTemp(self, Name = None, Temp = None, PatternName = None):
        """
This function retrieves the material temperature assignments to solid elements.
The function returns zero if the material temperature assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid element.
Temp: This is the material temperature value assigned to the solid element. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the solid element is uniform over the element at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the solid element may vary. The material temperature at each corner point of the solid element is equal to the specified temperature multiplied by the pattern value at the associated point element. The material temperature at other locations in the solid element is calculated by interpolation from the corner points.
        """

        all_args = [Name, Temp, PatternName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidElm.GetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMatTemp" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined solid elements.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of solid element names retrieved by the program.
MyName: This is a one-dimensional array of solid element names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the SAP2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidElm.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetPoints(self, Name = None, Point = None):
        """
This function retrieves the names of the eight point elements that define a solid element.
The function returns zero if the point element names are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an solid element.
Point: This is an array containing the names of the eight point elements that define the solid element. The point names are in order around the solid element.
        """

        all_args = [Name, Point]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidElm.GetPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPoints" failed')
        
        return ret

    def GetProperty(self, Name = None, PropName = None):
        """
This function retrieves the solid property assigned to a solid element.
The function returns zero if the property is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined solid element.
PropName: The name of the solid property assigned to the solid element.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidElm.GetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProperty" failed')
        
        return ret

class Results:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.Setup = Setup(strict, api)

    def AreaStrainShell(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, PointElm = None, LoadCase = None, StepType = None, StepNum = None, E11Top = None, E22Top = None, G12Top = None, E11Bot = None, E22Bot = None, G12Bot = None, EMaxTop = None, EMinTop = None, EMaxBot = None, EMinBot = None, EAngleTop = None, EAngleBot = None, EVMTop = None, EVMBot = None, G13Avg = None, G23Avg = None, GMaxAvg = None, GAngleAvg = None):
        """
This function reports the area strains for the specified area elements that are assigned shell section properties (not plane or asolid properties). Strains are reported at each point element associated with the area element.
The function returns zero if the strains are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing area object, area element or group of objects, depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the area elements corresponding to the area object specified by the Name item.
If this item is Element, the result request is for the area element specified by the Name item.
If this item is GroupElm, the result request is for the area elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the result request is for area elements corresponding to all selected area objects and the Name item is ignored.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the area object name associated with each result, if any.
Elm: This is an array that includes the area element name associated with each result.
PointElm: This is an array that includes the name of the point element where the results are reported.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
E11Top: The area element internal E11, E22 and G12 strains, at the top or bottom of the specified area element, at the specified point element location, reported in the area element local coordinate system.
E22Top: The area element internal E11, E22 and G12 strains, at the top or bottom of the specified area element, at the specified point element location, reported in the area element local coordinate system.
G12Top: The area element internal E11, E22 and G12 strains, at the top or bottom of the specified area element, at the specified point element location, reported in the area element local coordinate system.
E11Bot: The area element internal E11, E22 and G12 strains, at the top or bottom of the specified area element, at the specified point element location, reported in the area element local coordinate system.
E22Bot: The area element internal E11, E22 and G12 strains, at the top or bottom of the specified area element, at the specified point element location, reported in the area element local coordinate system.
G12Bot: The area element internal E11, E22 and G12 strains, at the top or bottom of the specified area element, at the specified point element location, reported in the area element local coordinate system.
EMaxTop: The area element maximum and minimum principal strains, at the top or bottom of the specified area element, at the specified point element location.
EMinTop: The area element maximum and minimum principal strains, at the top or bottom of the specified area element, at the specified point element location.
EMaxBot: The area element maximum and minimum principal strains, at the top or bottom of the specified area element, at the specified point element location.
EMinBot: The area element maximum and minimum principal strains, at the top or bottom of the specified area element, at the specified point element location.
EAngleTop: The angle measured counter clockwise (when the local 3 axis is pointing toward you) from the area local 1 axis to the direction of the maximum principal strain, at the top or bottom of the specified area element. [deg]
EAngleBot: The angle measured counter clockwise (when the local 3 axis is pointing toward you) from the area local 1 axis to the direction of the maximum principal strain, at the top or bottom of the specified area element. [deg]
EVMTop: The area element internal top or bottom Von Mises strain at the specified point element.
EVMBot: The area element internal top or bottom Von Mises strain at the specified point element.
G13Avg: The area element average G13 or G23 out-of-plane shear strain at the specified point element. These items are only reported for area elements with properties that allow plate bending behavior.
G23Avg: The area element average G13 or G23 out-of-plane shear strain at the specified point element. These items are only reported for area elements with properties that allow plate bending behavior.
GMaxAvg: The area element maximum average out-of-plane shear strain.It is equal to the square root of the sum of the squares of G13Avg and G23Avg. This item is only reported for area elements with properties that allow plate bending behavior.
GAngleAvg: The angle measured counter clockwise (when the local 3 axis is pointing toward you) from the area local 1 axis to the direction of GMaxAvg. This item is only reported for area elements with properties that allow plate bending behavior. [deg]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, PointElm, LoadCase, StepType, StepNum, E11Top, E22Top, G12Top, E11Bot, E22Bot, G12Bot, EMaxTop, EMinTop, EMaxBot, EMinBot, EAngleTop, EAngleBot, EVMTop, EVMBot, G13Avg, G23Avg, GMaxAvg, GAngleAvg]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.AreaStrainShell(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AreaStrainShell" failed')
        
        return ret

    def AreaStressShell(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, PointElm = None, LoadCase = None, StepType = None, StepNum = None, S11Top = None, S22Top = None, S12Top = None, S11Bot = None, S22Bot = None, S12Bot = None, SMaxTop = None, SMinTop = None, SMaxBot = None, SMinBot = None, SAngleTop = None, SAngleBot = None, SVMTop = None, SVMBot = None, S13Avg = None, S23Avg = None, SMaxAvg = None, SAngleAvg = None):
        """
This function reports the area stresses for the specified area elements that are assigned shell section properties (not plane or asolid properties). Stresses are reported at each point element associated with the area element.
The function returns zero if the stresses are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing area object, area element or group of objects, depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the area elements corresponding to the area object specified by the Name item.
If this item is Element, the result request is for the area element specified by the Name item.
If this item is GroupElm, the result request is for the area elements corresponding to all area objects included in the group specified by the Name item.
If this item is SelectionElm, the result request is for area elements corresponding to all selected area objects and the Name item is ignored.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the area object name associated with each result, if any.
Elm: This is an array that includes the area element name associated with each result.
PointElm: This is an array that includes the name of the point element where the results are reported.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
S11Top: The area element internal S11, S22 and S12 stresses, at the top or bottom of the specified area element, at the specified point element location, reported in the area element local coordinate system. [F/L2]
S22Top: The area element internal S11, S22 and S12 stresses, at the top or bottom of the specified area element, at the specified point element location, reported in the area element local coordinate system. [F/L2]
S12Top: The area element internal S11, S22 and S12 stresses, at the top or bottom of the specified area element, at the specified point element location, reported in the area element local coordinate system. [F/L2]
S11Bot: The area element internal S11, S22 and S12 stresses, at the top or bottom of the specified area element, at the specified point element location, reported in the area element local coordinate system. [F/L2]
S22Bot: The area element internal S11, S22 and S12 stresses, at the top or bottom of the specified area element, at the specified point element location, reported in the area element local coordinate system. [F/L2]
S12Bot: The area element internal S11, S22 and S12 stresses, at the top or bottom of the specified area element, at the specified point element location, reported in the area element local coordinate system. [F/L2]
SMaxTop: The area element maximum and minimum principal stresses, at the top or bottom of the specified area element, at the specified point element location. [F/L2]
SMinTop: The area element maximum and minimum principal stresses, at the top or bottom of the specified area element, at the specified point element location. [F/L2]
SMaxBot: The area element maximum and minimum principal stresses, at the top or bottom of the specified area element, at the specified point element location. [F/L2]
SMinBot: The area element maximum and minimum principal stresses, at the top or bottom of the specified area element, at the specified point element location. [F/L2]
SAngleTop: The angle measured counter clockwise (when the local 3 axis is pointing toward you) from the area local 1 axis to the direction of the maximum principal stress, at the top or bottom of the specified area element. [deg]
SAngleBot: The angle measured counter clockwise (when the local 3 axis is pointing toward you) from the area local 1 axis to the direction of the maximum principal stress, at the top or bottom of the specified area element. [deg]
SVMTop: The area element internal top or bottom Von Mises stress at the specified point element. [F/L2]
SVMBot: The area element internal top or bottom Von Mises stress at the specified point element. [F/L2]
S13Avg: The area element average S13 or S23 out-of-plane shear stress at the specified point element. These items are only reported for area elements with properties that allow plate bending behavior. [F/L2]
S23Avg: The area element average S13 or S23 out-of-plane shear stress at the specified point element. These items are only reported for area elements with properties that allow plate bending behavior. [F/L2]
SMaxAvg: The area element maximum average out-of-plane shear stress.It is equal to the square root of the sum of the squares of S13Avg and S23Avg. This item is only reported for area elements with properties that allow plate bending behavior. [F/L2]
SAngleAvg: The angle measured counter clockwise (when the local 3 axis is pointing toward you) from the area local 1 axis to the direction of SMaxAvg. This item is only reported for area elements with properties that allow plate bending behavior. [deg]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, PointElm, LoadCase, StepType, StepNum, S11Top, S22Top, S12Top, S11Bot, S22Bot, S12Bot, SMaxTop, SMinTop, SMaxBot, SMinBot, SAngleTop, SAngleBot, SVMTop, SVMBot, S13Avg, S23Avg, SMaxAvg, SAngleAvg]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.AreaStressShell(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AreaStressShell" failed')
        
        return ret

    def AssembledJointMass_1(self, MassSourceName = None, Name = None, ItemTypeElm = None, NumberResults = None, PointElm = None, MassSource = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None):
        """
This function reports the assembled joint masses for 
 the specified point elements.
The function returns zero if the masses are successfully 
 recovered, otherwise it returns a nonzero value.
See Analysis 
 Results Remarks for more information.

MassSourceName: The name of an existing mass source definition. If this 
value is left empty or unrecognized, data for all mass sources will be returned.
Name: The name of an existing point element or group of objects, 
 depending on the value of the ItemTypeElm item. 
ItemTypeElm: This is one of the following items in the eItemTypeElm 
 enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for 
 the point element corresponding to the point object specified by the Name 
 item.
If this item is Element, the result request is for the 
 point element specified by the Name item.
If this item is GroupElm, the result request is for 
 all point elements directly or indirectly specified in the group specified 
 by the Name item.
If this item is SelectionElm, the result request is 
 for all point elements directly or indirectly selected and the Name item 
 is ignored.
See Type for Elements 
 for more information.
NumberResults: The total number of results returned by the program.
PointElm: This is an array that includes the point element name 
 associated with each result.
MassSource: This is an array that includes the mass source name 
 associated with each result.
U1: These are one dimensional arrays that include the translational 
 mass in the point element local 1, 2 and 3 axes directions, respectively, 
 for each result. [M]
U2: These are one dimensional arrays that include the translational 
 mass in the point element local 1, 2 and 3 axes directions, respectively, 
 for each result. [M]
U3: These are one dimensional arrays that include the translational 
 mass in the point element local 1, 2 and 3 axes directions, respectively, 
 for each result. [M]
R1: These are one dimensional arrays that include the rotational 
 mass moment of inertia about the point element local 1, 2 and 3 axes, 
 respectively, for each result. [ML2]
R2: These are one dimensional arrays that include the rotational 
 mass moment of inertia about the point element local 1, 2 and 3 axes, 
 respectively, for each result. [ML2]
R3: These are one dimensional arrays that include the rotational 
 mass moment of inertia about the point element local 1, 2 and 3 axes, 
 respectively, for each result. [ML2]
        """

        all_args = [MassSourceName, Name, ItemTypeElm, NumberResults, PointElm, MassSource, U1, U2, U3, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.AssembledJointMass_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AssembledJointMass_1" failed')
        
        return ret

    def BaseReact(self, NumberResults = None, LoadCase = None, StepType = None, StepNum = None, Fx = None, Fy = None, Fz = None, Mx = None, My = None, Mz = None, gx = None, gy = None, gz = None):
        """
This function reports the structure total base reactions.
The function returns zero if the reactions are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for additional information.

NumberResults: The total number of results returned by the program.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
Fx: These are one dimensional arrays that include the base reaction forces in the global X, Y and Z directions, respectively, for each result. [F]
Fy: These are one dimensional arrays that include the base reaction forces in the global X, Y and Z directions, respectively, for each result. [F]
Fz: These are one dimensional arrays that include the base reaction forces in the global X, Y and Z directions, respectively, for each result. [F]
Mx: These are one dimensional arrays that include the base reaction moments about the global X, Y and Z axes, respectively, for each result. [FL]
My: These are one dimensional arrays that include the base reaction moments about the global X, Y and Z axes, respectively, for each result. [FL]
Mz: These are one dimensional arrays that include the base reaction moments about the global X, Y and Z axes, respectively, for each result. [FL]
gx: These are the global X, Y and Z coordinates of the point at which the base reactions are reported. [L]
gy: These are the global X, Y and Z coordinates of the point at which the base reactions are reported. [L]
gz: These are the global X, Y and Z coordinates of the point at which the base reactions are reported. [L]
        """

        all_args = [NumberResults, LoadCase, StepType, StepNum, Fx, Fy, Fz, Mx, My, Mz, gx, gy, gz]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.BaseReact(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"BaseReact" failed')
        
        return ret

    def BaseReactWithCentroid(self, NumberResults = None, LoadCase = None, StepType = None, StepNum = None, Fx = None, Fy = None, Fz = None, Mx = None, My = None, Mz = None, gx = None, gy = None, gz = None, XCentroidForFx = None, YCentroidForFx = None, ZCentroidForFx = None, XCentroidForFy = None, YCentroidForFy = None, ZCentroidForFy = None, XCentroidForFz = None, YCentroidForFz = None, ZCentroidForFz = None):
        """
This function reports the structure total base reactions and includes information on the centroid of the translational reaction forces.
The function returns zero if the reactions are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.
Note that the reported base reaction centroids are not the same as the centroid of the applied loads. See Base Reaction Centroids for additional information.

NumberResults: The total number of results returned by the program.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
Fx: These are one dimensional arrays that include the base reaction forces in the global X, Y and Z directions, respectively, for each result. [F]
Fy: These are one dimensional arrays that include the base reaction forces in the global X, Y and Z directions, respectively, for each result. [F]
Fz: These are one dimensional arrays that include the base reaction forces in the global X, Y and Z directions, respectively, for each result. [F]
Mx: These are one dimensional arrays that include the base reaction moments about the global X, Y and Z axes, respectively, for each result. [FL]
My: These are one dimensional arrays that include the base reaction moments about the global X, Y and Z axes, respectively, for each result. [FL]
Mz: These are one dimensional arrays that include the base reaction moments about the global X, Y and Z axes, respectively, for each result. [FL]
gx: These are the global X, Y and Z coordinates of the point at which the base reactions are reported. [L]
gy: These are the global X, Y and Z coordinates of the point at which the base reactions are reported. [L]
gz: These are the global X, Y and Z coordinates of the point at which the base reactions are reported. [L]
XCentroidForFx: These are arrays of the global X, Y and Z coordinates, respectively, of the centroid of all global X-direction translational reaction forces for each result. See Base Reaction Centroids for more information. [L]
YCentroidForFx: These are arrays of the global X, Y and Z coordinates, respectively, of the centroid of all global X-direction translational reaction forces for each result. See Base Reaction Centroids for more information. [L]
ZCentroidForFx: These are arrays of the global X, Y and Z coordinates, respectively, of the centroid of all global X-direction translational reaction forces for each result. See Base Reaction Centroids for more information. [L]
XCentroidForFy: These are arrays of the global X, Y and Z coordinates, respectively, of the centroid of all global Y-direction translational reaction forces for each result. See Base Reaction Centroids for more information. [L]
YCentroidForFy: These are arrays of the global X, Y and Z coordinates, respectively, of the centroid of all global Y-direction translational reaction forces for each result. See Base Reaction Centroids for more information. [L]
ZCentroidForFy: These are arrays of the global X, Y and Z coordinates, respectively, of the centroid of all global Y-direction translational reaction forces for each result. See Base Reaction Centroids for more information. [L]
XCentroidForFz: These are arrays of the global X, Y and Z coordinates, respectively, of the centroid of all global Z-direction translational reaction forces for each result. See Base Reaction Centroids for more information. [L]
YCentroidForFz: These are arrays of the global X, Y and Z coordinates, respectively, of the centroid of all global Z-direction translational reaction forces for each result. See Base Reaction Centroids for more information. [L]
ZCentroidForFz: These are arrays of the global X, Y and Z coordinates, respectively, of the centroid of all global Z-direction translational reaction forces for each result. See Base Reaction Centroids for more information. [L]
        """

        all_args = [NumberResults, LoadCase, StepType, StepNum, Fx, Fy, Fz, Mx, My, Mz, gx, gy, gz, XCentroidForFx, YCentroidForFx, ZCentroidForFx, XCentroidForFy, YCentroidForFy, ZCentroidForFy, XCentroidForFz, YCentroidForFz, ZCentroidForFz]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.BaseReactWithCentroid(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"BaseReactWithCentroid" failed')
        
        return ret

    def BridgeSuperCutLongitStress(self, Name = None, CutIndex = None, PointIndex = None, NumberResults = None, LoadCase = None, StepType = None, StepNum = None, Stress = None):
        """
This function returns the longitudinal stresses for multiple cases/combos at a single stress point in a superstructure section cut in a bridge object. Use the functions in SapModel.Results.Setup to control the loads and steps for which results are to be obtained.
The function returns zero if the information is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing bridge object.
CutIndex: The index number of section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by function SapModel.BridgeObj.CountSuperCut.
PointIndex: The index number of the stress point in this section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by function SapModel.BridgeObj.CountSuperCutStressPoint.
NumberResults: The total number of results returned.
LoadCase: This is an array that includes the name of the load case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
Stress: This is an array that includes the longitudinal stress value for each result. [F/L2]
        """

        all_args = [Name, CutIndex, PointIndex, NumberResults, LoadCase, StepType, StepNum, Stress]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.BridgeSuperCutLongitStress(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"BridgeSuperCutLongitStress" failed')
        
        return ret

    def BucklingFactor(self, NumberResults = None, LoadCase = None, StepType = None, StepNum = None, Factor = None):
        """
This function reports buckling factors obtained from buckling load cases.
The function returns zero if the factors are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

NumberResults: The total number of results returned by the program.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type for each result. For buckling factors, the step type is always Mode.
StepNum: This is an array that includes the step number for each result. For buckling factors, the step number is always the buckling mode number.
Factor: This is an array that includes the buckling factors.
        """

        all_args = [NumberResults, LoadCase, StepType, StepNum, Factor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.BucklingFactor(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"BucklingFactor" failed')
        
        return ret

    def FrameForce(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, ObjSta = None, Elm = None, ElmSta = None, LoadCase = None, StepType = None, StepNum = None, P = None, V2 = None, V3 = None, T = None, M2 = None, M3 = None):
        """
This function reports the frame forces for the specified line elements.
The function returns zero if the forces are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for additional information.

Name: The name of an existing line object, line element or group of objects depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the line elements corresponding to the line object specified by the Name item.
If this item is Element, the result request is for the line element specified by the Name item.
If this item is GroupElm, the result request is for the line elements corresponding to all line objects included in the group specified by the Name item.
If this item is SelectionElm, the result request is for line elements corresponding to all selected line objects and the Name item is ignored.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the line object name associated with each result, if any.
ObjSta: This is an array that includes the distance measured from the I-end of the line object to the result location.
Elm: This is an array that includes the line element name associated with each result.
ElmSta: This is an array that includes the distance measured from the I-end of the line element to the result location.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
P: These are one dimensional arrays that include the axial force, shear force in the local 2 direction, and shear force in the local 3 direction, respectively, for each result. [F]
V2: These are one dimensional arrays that include the axial force, shear force in the local 2 direction, and shear force in the local 3 direction, respectively, for each result. [F]
V3: These are one dimensional arrays that include the axial force, shear force in the local 2 direction, and shear force in the local 3 direction, respectively, for each result. [F]
T: These are one dimensional arrays that include the torsion, moment about the local 2axis, and moment about the local 3-axis, respectively, for each result. [FL]
M2: These are one dimensional arrays that include the torsion, moment about the local 2axis, and moment about the local 3-axis, respectively, for each result. [FL]
M3: These are one dimensional arrays that include the torsion, moment about the local 2axis, and moment about the local 3-axis, respectively, for each result. [FL]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, ObjSta, Elm, ElmSta, LoadCase, StepType, StepNum, P, V2, V3, T, M2, M3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.FrameForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"FrameForce" failed')
        
        return ret

    def FrameJointForce(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, PointElm = None, LoadCase = None, StepType = None, StepNum = None, F1 = None, F2 = None, F3 = None, M1 = None, M2 = None, M3 = None):
        """
This function reports the frame joint forces for the point elements at each end of the specified line elements.
The function returns zero if the forces are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for additional information.

Name: The name of an existing line object, line element or group of objects depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the line elements corresponding to the line object specified by the Name item.
If this item is Element, the result request is for the line element specified by the Name item.
If this item is GroupElm, the result request is for the line elements corresponding to all line objects included in the group specified by the Name item.
If this item is SelectionElm, the result request is for line elements corresponding to all selected line objects and the Name item is ignored.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the line object name associated with each result, if any.
Elm: This is an array that includes the line element name associated with each result.
PointElm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
F1: These are one dimensional arrays that include the joint force components in the point element local axes directions. [F]
F2: These are one dimensional arrays that include the joint force components in the point element local axes directions. [F]
F3: These are one dimensional arrays that include the joint force components in the point element local axes directions. [F]
M1: These are one dimensional arrays that include the joint moment components about the point element local axes. [FL]
M2: These are one dimensional arrays that include the joint moment components about the point element local axes. [FL]
M3: These are one dimensional arrays that include the joint moment components about the point element local axes. [FL]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, PointElm, LoadCase, StepType, StepNum, F1, F2, F3, M1, M2, M3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.FrameJointForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"FrameJointForce" failed')
        
        return ret

    def GeneralizedDispl(self, Name = None, NumberResults = None, GD = None, LoadCase = None, StepType = None, StepNum = None, DType = None, Value = None):
        """
This function reports the displacement values for the specified generalized displacements.
The function returns zero if the displacements are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing generalized displacement for which results are returned. If the program does not recognize this name as a defined generalized displacement, it returns results for all selected generalized displacements, if any. For example, entering a blank string (i.e., "") for the name will prompt the program to return results for all selected generalized displacements.
NumberResults: The total number of results returned by the program.
GD: This is an array that includes the generalized displacement name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
DType: This is an array that includes the generalized displacement type for each result. It is either Translation or Rotation.
Value: This is an array of the generalized displacement values for each result.[L] when DType is Translation , [rad] when DType is Rotation.
        """

        all_args = [Name, NumberResults, GD, LoadCase, StepType, StepNum, DType, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.GeneralizedDispl(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GeneralizedDispl" failed')
        
        return ret

    def JointAcc(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, LoadCase = None, StepType = None, StepNum = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None):
        """
This function reports the joint accelerations for the specified point elements. The accelerations reported by this function are relative accelerations.
The function returns zero if the accelerations are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for additional information.

Name: The name of an existing point object, point element, or group of objects, depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the point element corresponding to the point object specified by the Name item.
If this item is Element, the result request is for the point element specified by the Name item.
If this item is GroupElm, the result request is for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for all point elements directly or indirectly selected and the Name item is ignored.
See Item Type for Elements for more information.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the point object name associated with each result, if any. Some results will have no point object associated with them. For those cases, this item will be blank.
Elm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
U1: These are one dimensional arrays that include the translational acceleration in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L/s2]
U2: These are one dimensional arrays that include the translational acceleration in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L/s2]
U3: These are one dimensional arrays that include the translational acceleration in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L/s2]
R1: These are one dimensional arrays that include the rotational acceleration about the point element local 1, 2 and 3 axes, respectively, for each result. [rad/s2]
R2: These are one dimensional arrays that include the rotational acceleration about the point element local 1, 2 and 3 axes, respectively, for each result. [rad/s2]
R3: These are one dimensional arrays that include the rotational acceleration about the point element local 1, 2 and 3 axes, respectively, for each result. [rad/s2]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, LoadCase, StepType, StepNum, U1, U2, U3, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.JointAcc(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"JointAcc" failed')
        
        return ret

    def JointAccAbs(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, LoadCase = None, StepType = None, StepNum = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None):
        """
This function reports the joint absolute accelerations for the specified point elements. Absolute and relative accelerations are the same, except when reported for time history load cases subjected to acceleration loading.
The function returns zero if the accelerations are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing point object, point element, or group of objects depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the point element corresponding to the point object specified by the Name item.
If this item is Element, the result request is for the point element specified by the Name item.
If this item is GroupElm, the result request is for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for all point elements directly or indirectly selected and the Name item is ignored.
See Item Type for Elements for more information.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the point object name associated with each result, if any. Some results will have no point object associated with them. For those cases, this item will be blank.
Elm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
U1: These are one dimensional arrays that include the translational acceleration in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L/s2]
U2: These are one dimensional arrays that include the translational acceleration in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L/s2]
U3: These are one dimensional arrays that include the translational acceleration in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L/s2]
R1: These are one dimensional arrays that include the rotational acceleration about the point element local 1, 2 and 3 axes, respectively, for each result. [rad/s2]
R2: These are one dimensional arrays that include the rotational acceleration about the point element local 1, 2 and 3 axes, respectively, for each result. [rad/s2]
R3: These are one dimensional arrays that include the rotational acceleration about the point element local 1, 2 and 3 axes, respectively, for each result. [rad/s2]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, LoadCase, StepType, StepNum, U1, U2, U3, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.JointAccAbs(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"JointAccAbs" failed')
        
        return ret

    def JointDispl(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, LoadCase = None, StepType = None, StepNum = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None):
        """
This function reports the joint displacements for the specified point elements. The displacements reported by this function are relative displacements.
The function returns zero if the displacements are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing point object, point element, or group of objects depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the point element corresponding to the point object specified by the Name item.
If this item is Element, the result request is for the point element specified by the Name item.
If this item is GroupElm, the result request is for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for all point elements directly or indirectly selected and the Name item is ignored.
See Item Type for Elements for more information.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the point object name associated with each result, if any. Some results will have no point object associated with them. For these cases this item will be blank.
Elm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
U1: These are one dimensional arrays that include the displacement in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L]
U2: These are one dimensional arrays that include the displacement in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L]
U3: These are one dimensional arrays that include the displacement in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L]
R1: These are one dimensional arrays that include the rotation about the point element local 1, 2 and 3 axes, respectively, for each result. [rad]
R2: These are one dimensional arrays that include the rotation about the point element local 1, 2 and 3 axes, respectively, for each result. [rad]
R3: These are one dimensional arrays that include the rotation about the point element local 1, 2 and 3 axes, respectively, for each result. [rad]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, LoadCase, StepType, StepNum, U1, U2, U3, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.JointDispl(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"JointDispl" failed')
        
        return ret

    def JointDisplAbs(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, LoadCase = None, StepType = None, StepNum = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None):
        """
This function reports the absolute joint displacements for the specified point elements. Absolute and relative displacements are the same except when reported for time history load cases subjected to acceleration loading.
The function returns zero if the displacements are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing point object, point element, or group of objects depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the point element corresponding to the point object specified by the Name item.
If this item is Element, the result request is for the point element specified by the Name item.
If this item is GroupElm, the result request is for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for all point elements directly or indirectly selected and the Name item is ignored.
See Item Type for Elements for more information.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the point object name associated with each result, if any. Some results will have no point object associated with them. For those cases, this item will be blank.
Elm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
U1: These are one dimensional arrays that include the displacement in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L]
U2: These are one dimensional arrays that include the displacement in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L]
U3: These are one dimensional arrays that include the displacement in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L]
R1: These are one dimensional arrays that include the rotation about the point element local 1, 2 and 3 axes, respectively, for each result. [rad]
R2: These are one dimensional arrays that include the rotation about the point element local 1, 2 and 3 axes, respectively, for each result. [rad]
R3: These are one dimensional arrays that include the rotation about the point element local 1, 2 and 3 axes, respectively, for each result. [rad]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, LoadCase, StepType, StepNum, U1, U2, U3, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.JointDisplAbs(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"JointDisplAbs" failed')
        
        return ret

    def JointReact(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, LoadCase = None, StepType = None, StepNum = None, F1 = None, F2 = None, F3 = None, M1 = None, M2 = None, M3 = None):
        """
This function reports the joint reactions for the specified point elements. The reactions reported are from restraints, springs and grounded (one-joint) links.
The function returns zero if the reactions are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing point object, point element, or group of objects depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElmc = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the point element corresponding to the point object specified by the Name item.
If this item is Element, the result request is for the point element specified by the Name item.
If this item is GroupElm, the result request is for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for all point elements directly or indirectly selected and the Name item is ignored.
See Item Type for Elements for more information.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the point object name associated with each result, if any. Some results will have no point object associated with them. For those cases, this item will be blank.
Elm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
F1: These are one dimensional arrays that include the reaction forces in the point element local 1, 2 and 3 axes directions, respectively, for each result. [F]
F2: These are one dimensional arrays that include the reaction forces in the point element local 1, 2 and 3 axes directions, respectively, for each result. [F]
F3: These are one dimensional arrays that include the reaction forces in the point element local 1, 2 and 3 axes directions, respectively, for each result. [F]
M1: These are one dimensional arrays that include the reaction moments about the point element local 1, 2 and 3 axes, respectively, for each result. [FL]
M2: These are one dimensional arrays that include the reaction moments about the point element local 1, 2 and 3 axes, respectively, for each result. [FL]
M3: These are one dimensional arrays that include the reaction moments about the point element local 1, 2 and 3 axes, respectively, for each result. [FL]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, LoadCase, StepType, StepNum, F1, F2, F3, M1, M2, M3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.JointReact(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"JointReact" failed')
        
        return ret

    def JointRespSpec(self, Name = None, ItemTypeElem = None, NamedSet = None, NumberResults = None, Obj = None, Elm = None, LoadCase = None, CoordSys = None, Dir = None, Damping = None, SpecWidening = None, AbscissaValue = None, OrdinateValue = None):
        """
This function reports the joint response spectra values, due to a time history analysis, for the specified point elements.
The function returns zero if the response spectra data is successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information

Name: The name of an existing point object, point element, or group of objects depending on the value of the ItemTypeElm item.
ItemTypeElem: This is one of the following items in the ItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3
Default = 4
If this item is ObjectElm, the result request is for the point element corresponding to the point object specified by the Name item.
If this item is Element, the result request is for the point element specified by the Name item.
If this item is GroupElm, the result request is for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for all point elements directly or indirectly selected and the Name item is ignored.
If this item is Default, the result request is for the point object specified in the named set.
See Item Type for Elements for more information.
NamedSet: The name of an existing joint response spectrum named set. See SapModel.NamedSet.SetJointRespSpec. 
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the point object name associated with each result, if any. Some results will have no point object associated with them. For those cases, this item will be blank.
Elm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the load case associated with each result.
CoordSys: This is an array that includes the coordinate system in which the results are reported.
Dir: This is an array that includes the direction for which the results are reported. Valid values for the direction are:
1 = Local 1, Global X, or user-defined coordinate system X
2 = Local 2, Global Y, or user-defined coordinate system Y
3 = Local 3, Global Z, or user-defined coordinate system Z
Damping: This is an array that includes the critical damping ratio, for each result.
SpecWidening: This is an array that includes the percent spectrum widening, for each result.
AbscissaValue: This is an array that includes the period or frequency, as defined in each named set, for each result. [s or 1/s]
OrdinateValue: This is an array of the response quantity, as defined in each named set, for each result. The possible response quantities are spectral displacement [L], spectral velocity [L/s], pseudo spectral velocity [L/s], spectral acceleration [L/s2], or pseudo spectral acceleration [L/s2].
        """

        all_args = [Name, ItemTypeElem, NamedSet, NumberResults, Obj, Elm, LoadCase, CoordSys, Dir, Damping, SpecWidening, AbscissaValue, OrdinateValue]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.JointRespSpec(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"JointRespSpec" failed')
        
        return ret

    def JointVel(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, LoadCase = None, StepType = None, StepNum = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None):
        """
This function reports the joint velocities for the specified point elements. The velocities reported by this function are relative velocities.
The function returns zero if the velocities are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing point object, point element, or group of objects depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the point element corresponding to the point object specified by the Name item.
If this item is Element, the result request is for the point element specified by the Name item.
If this item is GroupElm, the result request is for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for all point elements directly or indirectly selected and the Name item is ignored.
See Item Type for Elements for more information.
NumberResults: The number total of results returned by the program.
Obj: This is an array that includes the point object name associated with each result, if any. Some results will have no point object associated with them. For those cases, this item will be blank.
Elm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
U1: These are one dimensional arrays that include the translational velocity in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L/s]
U2: These are one dimensional arrays that include the translational velocity in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L/s]
U3: These are one dimensional arrays that include the translational velocity in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L/s]
R1: These are one dimensional arrays that include the rotational velocity about the point element local 1, 2 and 3 axes, respectively, for each result. [rad/s]
R2: These are one dimensional arrays that include the rotational velocity about the point element local 1, 2 and 3 axes, respectively, for each result. [rad/s]
R3: These are one dimensional arrays that include the rotational velocity about the point element local 1, 2 and 3 axes, respectively, for each result. [rad/s]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, LoadCase, StepType, StepNum, U1, U2, U3, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.JointVel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"JointVel" failed')
        
        return ret

    def JointVelAbs(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, LoadCase = None, StepType = None, StepNum = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None):
        """
This function reports the joint absolute velocities for the specified point elements. Absolute and relative velocities are the same, except when reported for time history load cases subjected to acceleration loading.
The function returns zero if the velocities are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing point object, point element, or group of objects depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the point element corresponding to the point object specified by the Name item.
If this item is Element, the result request is for the point element specified by the Name item.
If this item is GroupElm, the result request is for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for all point elements directly or indirectly selected and the Name item is ignored.
See Item Type for Elements for more information.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the point object name associated with each result, if any. Some results will have no point object associated with them. For those cases, this item will be blank.
Elm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
U1: These are one dimensional arrays that include the translational velocity in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L/s]
U2: These are one dimensional arrays that include the translational velocity in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L/s]
U3: These are one dimensional arrays that include the translational velocity in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L/s]
R1: These are one dimensional arrays that include the rotational velocity about the point element local 1, 2 and 3 axes, respectively, for each result. [rad/s]
R2: These are one dimensional arrays that include the rotational velocity about the point element local 1, 2 and 3 axes, respectively, for each result. [rad/s]
R3: These are one dimensional arrays that include the rotational velocity about the point element local 1, 2 and 3 axes, respectively, for each result. [rad/s]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, LoadCase, StepType, StepNum, U1, U2, U3, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.JointVelAbs(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"JointVelAbs" failed')
        
        return ret

    def LinkDeformation(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, LoadCase = None, StepType = None, StepNum = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None):
        """
This function reports the link internal deformations.
The function returns zero if the deformations are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing link object, link element, or group of objects, depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm= = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the link element corresponding to the link object specified by the Name item.
If this item is Element, the result request is for the link element specified by the Name item.
If this item is GroupElm, the result request is for all link elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for link elements directly or indirectly selected, and the Name item is ignored.
For GroupElm and SelectionElm a link element may be indirectly specified through point objects that have panel zone assignments and through line, area, and solid objects that have spring assignments.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the link object name associated with each result, if any.
Elm: This is an array that includes the link element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
U1: These are one dimensional arrays that include the internal translational deformation of the link in the link element local axes directions. [L]
U2: These are one dimensional arrays that include the internal translational deformation of the link in the link element local axes directions. [L]
U3: These are one dimensional arrays that include the internal translational deformation of the link in the link element local axes directions. [L]
R1: These are one dimensional arrays that include the internal rotational deformation of the link about the link element local axes. [rad]
R2: These are one dimensional arrays that include the internal rotational deformation of the link about the link element local axes. [rad]
R3: These are one dimensional arrays that include the internal rotational deformation of the link about the link element local axes. [rad]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, LoadCase, StepType, StepNum, U1, U2, U3, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.LinkDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"LinkDeformation" failed')
        
        return ret

    def LinkForce(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, PointElm = None, LoadCase = None, StepType = None, StepNum = None, P = None, V2 = None, V3 = None, T = None, M2 = None, M3 = None):
        """
This function reports the link forces at the point elements at the ends of the specified link elements.
The function returns zero if the forces are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing link object, link element, or group of objects ,depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the link element corresponding to the link object specified by the Name item.
If this item is Element, the result request is for the link element specified by the Name item.
If this item is GroupElm, the result request is for all link elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for link elements directly or indirectly selected and the Name item is ignored.
For GroupElm and SelectionElm a link element may be indirectly specified through point objects that have panel zone assignments and through line, area and solid objects that have spring assignments.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the link object name associated with each result, if any.
Elm: This is an array that includes the link element name associated with each result.
PointElm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
P: This is an array that includes the link axial force (in the link local 1-axis direction) at the specified point element. [F]
V2: These are one dimensional arrays that include the link shear force components in the link element local axes directions. [F]
V3: These are one dimensional arrays that include the link shear force components in the link element local axes directions. [F]
T: This is an array that includes the link torsion (about the link local 1-axis) at the specified point element. [FL]
M2: These are one dimensional arrays that include the link moment components about the link element local axes. [FL]
M3: These are one dimensional arrays that include the link moment components about the link element local axes. [FL]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, PointElm, LoadCase, StepType, StepNum, P, V2, V3, T, M2, M3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.LinkForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"LinkForce" failed')
        
        return ret

    def LinkJointForce(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, PointElm = None, LoadCase = None, StepType = None, StepNum = None, F1 = None, F2 = None, F3 = None, M1 = None, M2 = None, M3 = None):
        """
This function reports the joint forces for the point elements at the ends of the specified link elements.
The function returns zero if the forces are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing link object, link element or group of objects depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the link element corresponding to the link object specified by the Name item.
If this item is Element, the result request is for the link element specified by the Name item.
If this item is GroupElm, the result request is for all link elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for link elements directly or indirectly selected and the Name item is ignored.
For GroupElm and SelectionElm a link element may be indirectly specified through point objects that have panel zone assignments and through line, area and solid objects that have spring assignments.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the link object name associated with each result, if any.
Elm: This is an array that includes the link element name associated with each result.
PointElm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
F1: These are one dimensional arrays that include the joint force components in the point element local axes directions. [F]
F2: These are one dimensional arrays that include the joint force components in the point element local axes directions. [F]
F3: These are one dimensional arrays that include the joint force components in the point element local axes directions. [F]
M1: These are one dimensional arrays that include the joint moment components about the point element local axes. [FL]
M2: These are one dimensional arrays that include the joint moment components about the point element local axes. [FL]
M3: These are one dimensional arrays that include the joint moment components about the point element local axes. [FL]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, PointElm, LoadCase, StepType, StepNum, F1, F2, F3, M1, M2, M3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.LinkJointForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"LinkJointForce" failed')
        
        return ret

    def ModalLoadParticipationRatios(self, NumberResults = None, LoadCase = None, ItemType = None, Item = None, Stat = None, Dyn = None):
        """
This function reports the modal load participation ratios for each selected modal analysis case.
The function returns zero if the data is successfully recovered; otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

NumberResults: The total number of results returned by the program.
LoadCase: This is an array that includes the name of the modal load case associated with each result.
ItemType: This is an array that includes Load Pattern, Acceleration, Link or Panel Zone. It specifies the type of item for which the modal load participation is reported.
Item: This is an array whose values depend on the ItemType. If the ItemType is Load Pattern, this is the name of the load pattern.
If the ItemType is Acceleration, this is UX, UY, UZ, RX, RY, or RZ, indicating the acceleration direction.
If the ItemType is Link, this is the name of the link followed by U1, U2, U3, R1, R2, or R3 (in parenthesis), indicating the link degree of freedom for which the output is reported.
If the ItemType is Panel Zone, this is the name of the joint to which the panel zone is assigned, followed by U1, U2, U3, R1, R2, or R3 (in parenthesis), indicating the degree of freedom for which the output is reported.
Stat: This is an array that includes the percent static load participation ratio.
Dyn: This is an array that includes the percent dynamic load participation ratio.
        """

        all_args = [NumberResults, LoadCase, ItemType, Item, Stat, Dyn]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.ModalLoadParticipationRatios(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ModalLoadParticipationRatios" failed')
        
        return ret

    def ModalParticipatingMassRatios(self, NumberResults = None, LoadCase = None, StepType = None, StepNum = None, Period = None, Ux = None, Uy = None, Uz = None, SumUx = None, SumUy = None, SumUz = None, Rx = None, Ry = None, Rz = None, SumRx = None, SumRy = None, SumRz = None):
        """
This function reports the modal participating mass ratios for each mode of each selected modal analysis case.
The function returns zero if the data is successfully recovered; otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

NumberResults: The total number of results returned by the program.
LoadCase: This is an array that includes the name of the modal load case associated with each result.
StepType: This is an array that includes the step type, if any, for each result. For modal results, this will always be Mode.
StepNum: This is an array that includes the step number for each result. For modal results, this is always the mode number.
Period: This is an array that includes the period for each result. [s]
Ux: This is an array that includes the modal participating mass ratio for the structure Ux degree of freedom. The ratio applies to the specified mode.
Uy: This is an array that includes the modal participating mass ratio for the structure Uy degree of freedom. The ratio applies to the specified mode.
Uz: This is an array that includes the modal participating mass ratio for the structure Uz degree of freedom. The ratio applies to the specified mode.
SumUx: This is an array that includes the cumulative sum of the modal participating mass ratios for the structure Ux degree of freedom.
SumUy: This is an array that includes the cumulative sum of the modal participating mass ratios for the structure Uy degree of freedom.
SumUz: This is an array that includes the cumulative sum of the modal participating mass ratios for the structure Uz degree of freedom.
Rx: This is an array that includes the modal participating mass ratio for the structure Rx degree of freedom. The ratio applies to the specified mode.
Ry: This is an array that includes the modal participating mass ratio for the structure Ry degree of freedom. The ratio applies to the specified mode.
Rz: This is an array that includes the modal participating mass ratio for the structure Rz degree of freedom. The ratio applies to the specified mode.
SumRx: This is an array that includes the cumulative sum of the modal participating mass ratios for the structure Rx degree of freedom.
SumRy: This is an array that includes the cumulative sum of the modal participating mass ratios for the structure Ry degree of freedom.
SumRz: This is an array that includes the cumulative sum of the modal participating mass ratios for the structure Rz degree of freedom.
        """

        all_args = [NumberResults, LoadCase, StepType, StepNum, Period, Ux, Uy, Uz, SumUx, SumUy, SumUz, Rx, Ry, Rz, SumRx, SumRy, SumRz]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.ModalParticipatingMassRatios(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ModalParticipatingMassRatios" failed')
        
        return ret

    def ModalParticipationFactors(self, NumberResults = None, LoadCase = None, StepType = None, StepNum = None, Period = None, Ux = None, Uy = None, Uz = None, Rx = None, Ry = None, Rz = None, ModalMass = None, ModalStiff = None):
        """
This function reports the modal participation factors for each mode of each selected modal analysis case.
The function returns zero if the data is successfully recovered; otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

NumberResults: The total number of results returned by the program.
LoadCase: This is an array that includes the name of the modal load case associated with each result.
StepType: This is an array that includes the step type, if any, for each result. For modal results, this will always be Mode.
StepNum: This is an array that includes the step number for each result. For modal results, this will always be the mode number.
Period: This is an array that includes the period for each result. [s]
Ux: This is an array that includes the modal participation factor for the structure Ux degree of freedom. The factor applies to the specified mode. [Fs2]
Uy: This is an array that includes the modal participation factor for the structure Uy degree of freedom. The factor applies to the specified mode. [Fs2]
Uz: This is an array that includes the modal participation factor for the structure Uz degree of freedom. The factor applies to the specified mode. [Fs2]
Rx: This is an array that includes the modal participation factor for the structure Rx degree of freedom. The factor applies to the specified mode. [FLs2]
Ry: This is an array that includes the modal participation factor for the structure Ry degree of freedom. The factor applies to the specified mode. [FLs2]
Rz: This is an array that includes the modal participation factor for the structure Rz degree of freedom. The factor applies to the specified mode. [FLs2]
ModalMass: This is an array that includes the modal mass for the specified mode.This is a measure of the kinetic energy in the structure as it is deforming in the specified mode. [FLs2]
ModalStiff: This is an array that includes the modal stiffness for the specified mode.This is a measure of the strain energy in the structure as it is deforming in the specified mode. [FL]
        """

        all_args = [NumberResults, LoadCase, StepType, StepNum, Period, Ux, Uy, Uz, Rx, Ry, Rz, ModalMass, ModalStiff]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.ModalParticipationFactors(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ModalParticipationFactors" failed')
        
        return ret

    def ModalPeriod(self, NumberResults = None, LoadCase = None, StepType = None, StepNum = None, Period = None, Frequency = None, CircFreq = None, EigenValue = None):
        """
This function reports the modal period, cyclic frequency, circular frequency and eigenvalue for each selected modal load case.
The function returns zero if the data is successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

NumberResults: The number total of results returned by the program.
LoadCase: This is an array that includes the name of the modal analysis case associated with each result.
StepType: This is an array that includes the step type, if any, for each result. For modal results this is always be Mode.
StepNum: This is an array that includes the step number for each result. For modal results this is always the mode number.
Period: This is an array that includes the period for each result. [s]
Frequency: This is an array that includes the cyclic frequency for each result. [1/s]
CircFreq: This is an array that includes the circular frequency for each result. [rad/s]
EigenValue: This is an array that includes the eigenvalue for the specified mode for each result. [rad2/s2]
        """

        all_args = [NumberResults, LoadCase, StepType, StepNum, Period, Frequency, CircFreq, EigenValue]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.ModalPeriod(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ModalPeriod" failed')
        
        return ret

    def ModeShape(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, LoadCase = None, StepType = None, StepNum = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None):
        """
This function reports the modal displacements (mode shapes) for the specified point elements.
The function returns zero if the displacements are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing point element or group of objects, depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the point element corresponding to the point object specified by the Name item.
If this item is Element, the result request is for the point element specified by the Name item.
If this item is GroupElm, the result request is for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for all point elements directly or indirectly selected and the Name item is ignored.
See Item Type for Elements for more information.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the point object name associated with each result, if any. Some results will have no point object associated with them. For these cases this item will be blank.
Elm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the modal analysis case associated with each result.
StepType: This is an array that includes the step type, if any, for each result. For mode shape results, this is always be Mode.
StepNum: This is an array that includes the step number for each result. For mode shape results, this is always the mode number.
U1: These are one dimensional arrays that include the displacement in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L]
U2: These are one dimensional arrays that include the displacement in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L]
U3: These are one dimensional arrays that include the displacement in the point element local 1, 2 and 3 axes directions, respectively, for each result. [L]
R1: These are one dimensional arrays that include the rotation about the point element local 1, 2 and 3 axes, respectively, for each result. [rad]
R2: These are one dimensional arrays that include the rotation about the point element local 1, 2 and 3 axes, respectively, for each result. [rad]
R3: These are one dimensional arrays that include the rotation about the point element local 1, 2 and 3 axes, respectively, for each result. [rad]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, LoadCase, StepType, StepNum, U1, U2, U3, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.ModeShape(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ModeShape" failed')
        
        return ret

    def PanelZoneDeformation(self, Name = None, ItemTypeElm = None, NumberResults = None, Elm = None, LoadCase = None, StepType = None, StepNum = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None):
        """
This function reports the panel zone (link) internal deformations.
The function returns zero if the deformations are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing link object, link element, or group of objects, depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the panel zone (link) element corresponding to the panel zone assignment to the point object specified by the Name item.
If this item is Element, the result request is for the panel zone (link) element specified by the Name item.
If this item is GroupElm, the result request is for all panel zone (link) elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for panel zone (link) elements directly or indirectly selected and the Name item is ignored.
For GroupElm and SelectionElm a panel zone (link) element may be indirectly specified through point objects that have panel zone assignments.
NumberResults: The total number of results returned by the program.
Elm: This is an array that includes the panel zone (link) element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
U1: These are one dimensional arrays that include the internal translational deformation of the panel zone (link) in the link element local axes directions. [L]
U2: These are one dimensional arrays that include the internal translational deformation of the panel zone (link) in the link element local axes directions. [L]
U3: These are one dimensional arrays that include the internal translational deformation of the panel zone (link) in the link element local axes directions. [L]
R1: These are one dimensional arrays that include the internal rotational deformation of the panel zone (link) about the link element local axes. [rad]
R2: These are one dimensional arrays that include the internal rotational deformation of the panel zone (link) about the link element local axes. [rad]
R3: These are one dimensional arrays that include the internal rotational deformation of the panel zone (link) about the link element local axes. [rad]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Elm, LoadCase, StepType, StepNum, U1, U2, U3, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.PanelZoneDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PanelZoneDeformation" failed')
        
        return ret

    def PanelZoneForce(self, Name = None, ItemTypeElm = None, NumberResults = None, Elm = None, PointElm = None, LoadCase = None, StepType = None, StepNum = None, P = None, V2 = None, V3 = None, T = None, M2 = None, M3 = None):
        """
This function reports the panel zone (link) forces at the point elements at the ends of the specified panel zone (link) elements.
The function returns zero if the forces are successfully recovered, otherwise it returns a nonzero value.
See Analysis Result Remarks for more information.

Name: The name of an existing point object, point element, or group of objects, depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the panel zone (link) element corresponding to the panel zone assignment to the point object specified by the Name item.
If this item is Element, the result request is for the panel zone (link) element specified by the Name item.
If this item is GroupElm, the result request is for all panel zone (link) elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for panel zone (link) elements directly or indirectly selected and the Name item is ignored.
For GroupElm and SelectionElm a panel zone (link) element may be indirectly specified through point objects that have panel zone assignments.
NumberResults: The total number of results returned by the program.
Elm: This is an array that includes the panel zone (link) element name associated with each result.
PointElm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
P: This is an array that includes the panel zone (link) axial force (in the link local 1-axis direction) at the specified point element. [F]
V2: These are one dimensional arrays that include the panel zone (link) shear force components in the link element local axes directions. [F]
V3: These are one dimensional arrays that include the panel zone (link) shear force components in the link element local axes directions. [F]
T: This is an array that includes the panel zone (link) torsion (about the link local 1-axis) at the specified point element. [FL]
M2: These are one dimensional arrays that include the panel zone (link) moment components about the link element local axes. [FL]
M3: These are one dimensional arrays that include the panel zone (link) moment components about the link element local axes. [FL]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Elm, PointElm, LoadCase, StepType, StepNum, P, V2, V3, T, M2, M3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.PanelZoneForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PanelZoneForce" failed')
        
        return ret

    def SectionCutAnalysis(self, NumberResults = None, SCut = None, LoadCase = None, StepType = None, StepNum = None, F1 = None, F2 = None, F3 = None, M1 = None, M2 = None, M3 = None):
        """
This function reports the section cut force for sections cuts that are specified to have an Analysis (F1, F2, F3, M1, M2, M3) result type.
The function returns zero if the section cut forces are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

NumberResults: The number total of results returned by the program.
SCut: This is an array that includes the name of the section cut associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
F1: These are one dimensional arrays that include the forces in the section cut local axes directions for each result. [F]
F2: These are one dimensional arrays that include the forces in the section cut local axes directions for each result. [F]
F3: These are one dimensional arrays that include the forces in the section cut local axes directions for each result. [F]
M1: These are one dimensional arrays that include the moments about the section cut local axes for each result. [FL]
M2: These are one dimensional arrays that include the moments about the section cut local axes for each result. [FL]
M3: These are one dimensional arrays that include the moments about the section cut local axes for each result. [FL]
        """

        all_args = [NumberResults, SCut, LoadCase, StepType, StepNum, F1, F2, F3, M1, M2, M3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.SectionCutAnalysis(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SectionCutAnalysis" failed')
        
        return ret

    def SectionCutDesign(self, NumberResults = None, SCut = None, LoadCase = None, StepType = None, StepNum = None, P = None, V2 = None, V3 = None, T = None, M2 = None, M3 = None):
        """
This function reports the section cut force for sections cuts that are specified to have a Design (P, V2, V3, T, M2, M3) result type.
The function returns zero if the section cut forces are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

NumberResults: The total number of results returned by the program.
SCut: This is an array that includes the name of the section cut associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
P: These are one dimensional arrays that include the axial force, shear force in the section cut local 2 direction and shear force in the section cut local 3 direction, respectively, for each result. [F]
V2: These are one dimensional arrays that include the axial force, shear force in the section cut local 2 direction and shear force in the section cut local 3 direction, respectively, for each result. [F]
V3: These are one dimensional arrays that include the axial force, shear force in the section cut local 2 direction and shear force in the section cut local 3 direction, respectively, for each result. [F]
T: These are one dimensional arrays that include the torsion, moment about the section cut local 2 axis and moment about the section cut local 3-axis, respectively, for each result. [FL]
M2: These are one dimensional arrays that include the torsion, moment about the section cut local 2 axis and moment about the section cut local 3-axis, respectively, for each result. [FL]
M3: These are one dimensional arrays that include the torsion, moment about the section cut local 2 axis and moment about the section cut local 3-axis, respectively, for each result. [FL]
        """

        all_args = [NumberResults, SCut, LoadCase, StepType, StepNum, P, V2, V3, T, M2, M3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.SectionCutDesign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SectionCutDesign" failed')
        
        return ret

    def SolidJointForce(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, PointElm = None, LoadCase = None, StepType = None, StepNum = None, F1 = None, F2 = None, F3 = None, M1 = None, M2 = None, M3 = None):
        """
This function reports the joint forces for the point elements at each corner of the specified solid elements.
The function returns zero if the forces are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing solid object, solid element, or group of objects, depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the solid elements corresponding to the solid object specified by the Name item.
If this item is Element, the result request is for the solid element specified by the Name item.
If this item is GroupElm, the result request is for the solid elements corresponding to all solid objects included in the group specified by the Name item.
If this item is SelectionElm, the result request is for solid elements corresponding to all selected solid objects and the Name item is ignored.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the solid object name associated with each result, if any.
Elm: This is an array that includes the solid element name associated with each result.
PointElm: This is an array that includes the point element name associated with each result.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
F1: These are one dimensional arrays that include the joint force components in the point element local axes directions. [F]
F2: These are one dimensional arrays that include the joint force components in the point element local axes directions. [F]
F3: These are one dimensional arrays that include the joint force components in the point element local axes directions. [F]
M1: These are one dimensional arrays that include the joint moment components about the point element local axes. [FL]
M2: These are one dimensional arrays that include the joint moment components about the point element local axes. [FL]
M3: These are one dimensional arrays that include the joint moment components about the point element local axes. [FL]
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, PointElm, LoadCase, StepType, StepNum, F1, F2, F3, M1, M2, M3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.SolidJointForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SolidJointForce" failed')
        
        return ret

    def SolidStrain(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, PointElm = None, LoadCase = None, StepType = None, StepNum = None, E11 = None, E22 = None, E33 = None, G12 = None, G13 = None, G23 = None, EMax = None, EMid = None, EMin = None, EVM = None, DirCosMax1 = None, DirCosMax2 = None, DirCosMax3 = None, DirCosMid1 = None, DirCosMid2 = None, DirCosMid3 = None, DirCosMin1 = None, DirCosMin2 = None, DirCosMin3 = None):
        """
This function reports the strains for the specified solid elements. Strains are reported at each point element associated with the solid element.
The function returns zero if the strains are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing solid object, solid element, or group of objects, depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the solid elements corresponding to the solid object specified by the Name item.
If this item is Element, the result request is for the solid element specified by the Name item.
If this item is GroupElm, the result request is for the solid elements corresponding to all solid objects included in the group specified by the Name item.
If this item is SelectionElm, the result request is for solid elements corresponding to all selected solid objects and the Name item is ignored.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the solid object name associated with each result, if any.
Elm: This is an array that includes the solid element name associated with each result.
PointElm: This is an array that includes the name of the point element where the results are reported.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
E11: The solid element internal E11, E22, E33, G12, G13 and G23 strains at the specified point element location, reported in the solid element local coordinate system.
E22: The solid element internal E11, E22, E33, G12, G13 and G23 strains at the specified point element location, reported in the solid element local coordinate system.
E33: The solid element internal E11, E22, E33, G12, G13 and G23 strains at the specified point element location, reported in the solid element local coordinate system.
G12: The solid element internal E11, E22, E33, G12, G13 and G23 strains at the specified point element location, reported in the solid element local coordinate system.
G13: The solid element internal E11, E22, E33, G12, G13 and G23 strains at the specified point element location, reported in the solid element local coordinate system.
G23: The solid element internal E11, E22, E33, G12, G13 and G23 strains at the specified point element location, reported in the solid element local coordinate system.
EMax: The solid element maximum, middle and minimum principal strains at the specified point element location.
EMid: The solid element maximum, middle and minimum principal strains at the specified point element location.
EMin: The solid element maximum, middle and minimum principal strains at the specified point element location.
EVM: The solid element internal Von Mises strain at the specified point element location.
DirCosMax1: These are three direction cosines defining the orientation of the maximum principal strain with respect to the solid element local axes.
DirCosMax2: These are three direction cosines defining the orientation of the maximum principal strain with respect to the solid element local axes.
DirCosMax3: These are three direction cosines defining the orientation of the maximum principal strain with respect to the solid element local axes.
DirCosMid1: These are three direction cosines defining the orientation of the middle principal strain with respect to the solid element local axes.
DirCosMid2: These are three direction cosines defining the orientation of the middle principal strain with respect to the solid element local axes.
DirCosMid3: These are three direction cosines defining the orientation of the middle principal strain with respect to the solid element local axes.
DirCosMin1: These are three direction cosines defining the orientation of the minimum principal strain with respect to the solid element local axes.
DirCosMin2: These are three direction cosines defining the orientation of the minimum principal strain with respect to the solid element local axes.
DirCosMin3: These are three direction cosines defining the orientation of the minimum principal strain with respect to the solid element local axes.
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, PointElm, LoadCase, StepType, StepNum, E11, E22, E33, G12, G13, G23, EMax, EMid, EMin, EVM, DirCosMax1, DirCosMax2, DirCosMax3, DirCosMid1, DirCosMid2, DirCosMid3, DirCosMin1, DirCosMin2, DirCosMin3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.SolidStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SolidStrain" failed')
        
        return ret

    def SolidStress(self, Name = None, ItemTypeElm = None, NumberResults = None, Obj = None, Elm = None, PointElm = None, LoadCase = None, StepType = None, StepNum = None, S11 = None, S22 = None, S33 = None, S12 = None, S13 = None, S23 = None, SMax = None, SMid = None, SMin = None, SVM = None, DirCosMax1 = None, DirCosMax2 = None, DirCosMax3 = None, DirCosMid1 = None, DirCosMid2 = None, DirCosMid3 = None, DirCosMin1 = None, DirCosMin2 = None, DirCosMin3 = None):
        """
This function reports the stresses for the specified solid elements. Stresses are reported at each point element associated with the solid element.
The function returns zero if the stresses are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing solid object, solid element, or group of objects, depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the solid elements corresponding to the solid object specified by the Name item.
If this item is Element, the result request is for the solid element specified by the Name item.
If this item is GroupElm, the result request is for the solid elements corresponding to all solid objects included in the group specified by the Name item.
If this item is SelectionElm, the result request is for solid elements corresponding to all selected solid objects and the Name item is ignored.
NumberResults: The total number of results returned by the program.
Obj: This is an array that includes the solid object name associated with each result, if any.
Elm: This is an array that includes the solid element name associated with each result.
PointElm: This is an array that includes the name of the point element where the results are reported.
LoadCase: This is an array that includes the name of the analysis case or load combination associated with each result.
StepType: This is an array that includes the step type, if any, for each result.
StepNum: This is an array that includes the step number, if any, for each result.
S11: The solid element internal S11, S22, S33, S12, S13 and S23 stresses at the specified point element location, reported in the solid element local coordinate system. [F/L2]
S22: The solid element internal S11, S22, S33, S12, S13 and S23 stresses at the specified point element location, reported in the solid element local coordinate system. [F/L2]
S33: The solid element internal S11, S22, S33, S12, S13 and S23 stresses at the specified point element location, reported in the solid element local coordinate system. [F/L2]
S12: The solid element internal S11, S22, S33, S12, S13 and S23 stresses at the specified point element location, reported in the solid element local coordinate system. [F/L2]
S13: The solid element internal S11, S22, S33, S12, S13 and S23 stresses at the specified point element location, reported in the solid element local coordinate system. [F/L2]
S23: The solid element internal S11, S22, S33, S12, S13 and S23 stresses at the specified point element location, reported in the solid element local coordinate system. [F/L2]
SMax: The solid element maximum, middle and minimum principal stresses at the specified point element location. [F/L2]
SMid: The solid element maximum, middle and minimum principal stresses at the specified point element location. [F/L2]
SMin: The solid element maximum, middle and minimum principal stresses at the specified point element location. [F/L2]
SVM: The solid element internal Von Mises stress at the specified point element location. [F/L2]
DirCosMax1: These are three direction cosines defining the orientation of the maximum principal stress with respect to the solid element local axes.
DirCosMax2: These are three direction cosines defining the orientation of the maximum principal stress with respect to the solid element local axes.
DirCosMax3: These are three direction cosines defining the orientation of the maximum principal stress with respect to the solid element local axes.
DirCosMid1: These are three direction cosines defining the orientation of the middle principal stress with respect to the solid element local axes.
DirCosMid2: These are three direction cosines defining the orientation of the middle principal stress with respect to the solid element local axes.
DirCosMid3: These are three direction cosines defining the orientation of the middle principal stress with respect to the solid element local axes.
DirCosMin1: These are three direction cosines defining the orientation of the minimum principal stress with respect to the solid element local axes.
DirCosMin2: These are three direction cosines defining the orientation of the minimum principal stress with respect to the solid element local axes.
DirCosMin3: These are three direction cosines defining the orientation of the minimum principal stress with respect to the solid element local axes.
        """

        all_args = [Name, ItemTypeElm, NumberResults, Obj, Elm, PointElm, LoadCase, StepType, StepNum, S11, S22, S33, S12, S13, S23, SMax, SMid, SMin, SVM, DirCosMax1, DirCosMax2, DirCosMax3, DirCosMid1, DirCosMid2, DirCosMid3, DirCosMin1, DirCosMin2, DirCosMin3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.SolidStress(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SolidStress" failed')
        
        return ret

    def StepLabel(self, LoadCase = None, StepNum = None, Label = None):
        """
This function generates the step label for analyzed linear multi-step, nonlinear multi-step, or staged-construction load cases. For other load case types, the label will be blank.
The function returns zero if the step label is successfully generated; otherwise it returns a nonzero value.

LoadCase: The name of an existing linear multi-step, nonlinear multi-step, or staged-construction load case.
StepNum: This is an overall step number from the specified load case. The range of values of StepNum for a given load case can be obtained from most analysis results calls, such as SapObject.SapModel.Results.JointDispl
Label: The is the step label, including the name or number of the stage, the step number within the stage, and the age of the structure for time-dependent load cases
        """

        all_args = [LoadCase, StepNum, Label]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.StepLabel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"StepLabel" failed')
        
        return ret

    def AssembledJointMass(self, Name = None, ItemTypeElm = None, NumberResults = None, PointElm = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None):
        """
This function reports the assembled joint masses for the specified point elements.
The function returns zero if the masses are successfully recovered, otherwise it returns a nonzero value.
See Analysis Results Remarks for more information.

Name: The name of an existing point element or group of objects, depending on the value of the ItemTypeElm item.
ItemTypeElm: This is one of the following items in the eItemTypeElm enumeration:
ObjectElm = 0
Element = 1
GroupElm = 2
SelectionElm = 3

If this item is ObjectElm, the result request is for the point element corresponding to the point object specified by the Name item.
If this item is Element, the result request is for the point element specified by the Name item.
If this item is GroupElm, the result request is for all point elements directly or indirectly specified in the group specified by the Name item.
If this item is SelectionElm, the result request is for all point elements directly or indirectly selected and the Name item is ignored.
See Item Type for Elements for more information.
NumberResults: The total number of results returned by the program.
PointElm: This is an array that includes the point element name associated with each result.
U1: These are one dimensional arrays that include the translational mass in the point element local 1, 2 and 3 axes directions, respectively, for each result. [M]
U2: These are one dimensional arrays that include the translational mass in the point element local 1, 2 and 3 axes directions, respectively, for each result. [M]
U3: These are one dimensional arrays that include the translational mass in the point element local 1, 2 and 3 axes directions, respectively, for each result. [M]
R1: These are one dimensional arrays that include the rotational mass moment of inertia about the point element local 1, 2 and 3 axes, respectively, for each result. [ML2]
R2: These are one dimensional arrays that include the rotational mass moment of inertia about the point element local 1, 2 and 3 axes, respectively, for each result. [ML2]
R3: These are one dimensional arrays that include the rotational mass moment of inertia about the point element local 1, 2 and 3 axes, respectively, for each result. [ML2]
        """

        all_args = [Name, ItemTypeElm, NumberResults, PointElm, U1, U2, U3, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.AssembledJointMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AssembledJointMass" failed')
        
        return ret

class Setup:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def DeselectAllCasesAndCombosForOutput(self):
        """
The function deselects all load cases and response combinations for output.
The function returns zero if the cases and combos are successfully deselected, otherwise it returns a nonzero value.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.DeselectAllCasesAndCombosForOutput(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeselectAllCasesAndCombosForOutput" failed')
        
        return ret

    def GetCaseSelectedForOutput(self, Name = None, Selected = None):
        """
This function checks if an load case is selected for output.
The function returns 0 if the selected flag is successfully retrieved, otherwise it returns nonzero.

Name: The name of an existing load case.
Selected: This item is True if the specified load case is selected for output.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetCaseSelectedForOutput(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCaseSelectedForOutput" failed')
        
        return ret

    def GetComboSelectedForOutput(self, Name = None, Selected = None):
        """
This function checks if a load combination is selected for output.
The function returns 0 if the selected flag is successfully retrieved, otherwise it returns nonzero.

Name: The name of an existing load combination.
Selected: This item is True if the specified load combination is selected for output.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetComboSelectedForOutput(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetComboSelectedForOutput" failed')
        
        return ret

    def GetOptionBaseReactLoc(self, gx = None, gy = None, gz = None):
        """
This function retrieves the global coordinates of the location at which the base reactions are reported.
The function returns 0 if the coordinates are successfully retrieved, otherwise it returns nonzero.

gx: The global coordinates of the location at which the base reactions are reported.
gy: The global coordinates of the location at which the base reactions are reported.
gz: The global coordinates of the location at which the base reactions are reported.
        """

        all_args = [gx, gy, gz]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetOptionBaseReactLoc(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOptionBaseReactLoc" failed')
        
        return ret

    def GetOptionBucklingMode(self, BuckModeStart = None, BuckModeEnd = None, BuckModeAll = None):
        """
This function retrieves the buckling modes for which buckling factors are reported.
The function returns 0 if the modes are successfully retrieved, otherwise it returns nonzero.

BuckModeStart: The first buckling mode for which the buckling factor is reported when the BuckModeAll item is False.
BuckModeEnd: The last buckling mode for which the buckling factor is reported when the BuckModeAll item is False.
BuckModeAll: If this item is True, buckling factors are reported for all calculated buckling modes. If it is False, buckling factors are reported for the buckling modes indicated by the BuckModeStart and BuckModeEnd items.
        """

        all_args = [BuckModeStart, BuckModeEnd, BuckModeAll]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetOptionBucklingMode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOptionBucklingMode" failed')
        
        return ret

    def GetOptionDirectHist(self, Value = None):
        """
This function retrieves the output option for direct history results.
The function returns 0 if the output option is successfully retrieved, otherwise it returns nonzero.

Value: This item is either 1, 2 or 3
1 = Envelopes
2 = Step-by-Step
3 = Last Step
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetOptionDirectHist(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOptionDirectHist" failed')
        
        return ret

    def GetOptionModalHist(self, Value = None):
        """
This function retrieves the output option for modal history results.
The function returns 0 if the output option is successfully retrieved, otherwise it returns nonzero.

Value: This item is either 1, 2 or 3
1 = Envelopes
2 = Step-by-Step
3 = Last Step
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetOptionModalHist(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOptionModalHist" failed')
        
        return ret

    def GetOptionModeShape(self, ModeShapeStart = None, ModeShapeEnd = None, ModeShapesAll = None):
        """
This function retrieves the modes for which mode shape results are reported.
The function returns 0 if the modes are successfully retrieved, otherwise it returns nonzero.

ModeShapeStart: The first mode for which results are reported when the ModeShapesAll item is False.
ModeShapeEnd: The last mode for which results are reported when the ModeShapesAll item is False.
ModeShapesAll: If this item is True, results are reported for all calculated modes. If it is False, results are reported for the modes indicated by the ModeShapeStart and ModeShapeEnd items.
        """

        all_args = [ModeShapeStart, ModeShapeEnd, ModeShapesAll]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetOptionModeShape(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOptionModeShape" failed')
        
        return ret

    def GetOptionMultiStepStatic(self, Value = None):
        """
This function retrieves the output option for multistep static linear results.
The function returns 0 if the output option is successfully retrieved, otherwise it returns nonzero.

Value: This item is either 1, 2 or 3
1 = Envelopes
2 = Step-by-Step
3 = Last Step
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetOptionMultiStepStatic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOptionMultiStepStatic" failed')
        
        return ret

    def GetOptionMultiValuedCombo(self, Value = None):
        """
This function retrieves the output option for multi-valued load combination results.
The function returns 0 if the output option is successfully retrieved, otherwise it returns nonzero.

Value: This item is either 1, 2, or 3
1 = Envelopes
2 = Multiple values, if possible
3 = Correspondence
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetOptionMultiValuedCombo(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOptionMultiValuedCombo" failed')
        
        return ret

    def GetOptionNLStatic(self, Value = None):
        """
This function retrieves the output option for nonlinear static results.
The function returns 0 if the output option is successfully retrieved, otherwise it returns nonzero.

Value: This item is either 1, 2 or 3
1 = Envelopes
2 = Step-by-Step
3 = Last Step
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetOptionNLStatic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOptionNLStatic" failed')
        
        return ret

    def GetOptionPSD(self, Value = None):
        """
This function retrieves the output option for power spectral density results.
The function returns 0 if the output option is successfully retrieved, otherwise it returns nonzero.

Value: This item is either 1 or 2
1 = RMS
2 = sqrt(PSD)
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetOptionPSD(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOptionPSD" failed')
        
        return ret

    def GetOptionSteadyState(self, Value = None, SteadyStateOption = None):
        """
This function retrieves the output option for steady state results.
The function returns 0 if the output option is successfully retrieved, otherwise it returns nonzero.

Value: This item is either 1 or 2
1 = Envelopes
2 = At Frequencies
SteadyStateOption: This item is 1, 2 or 3
1 = In and Out of Phase
2 = Magnitude
3 = All
        """

        all_args = [Value, SteadyStateOption]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetOptionSteadyState(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOptionSteadyState" failed')
        
        return ret

    def GetSectionCutSelectedForOutput(self):
        """
This function retrieves whether a defined section cut is selected for output.
The function returns 0 if the selected flag is successfully retrieved, otherwise it returns nonzero.
Please note that all section cuts are, by default, selected for output when they are created.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.GetSectionCutSelectedForOutput(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSectionCutSelectedForOutput" failed')
        
        return ret

    def SelectAllSectionCutsForOutput(self):
        """
This function selects or deselects all section cuts for output.
The function returns 0 if the selected flag is successfully set, otherwise it returns nonzero.
Please note that all section cuts are, by default, selected for output when they are created.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SelectAllSectionCutsForOutput(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SelectAllSectionCutsForOutput" failed')
        
        return ret

    def SetCaseSelectedForOutput(self, Name = None, Selected = None):
        """
This function sets an load case selected for output flag.
The function returns 0 if the selected flag is successfully set, otherwise it returns nonzero.

Name: The name of an existing load case.
Selected: This item is True if the specified load case is to be selected for output, otherwise it is False.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetCaseSelectedForOutput(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCaseSelectedForOutput" failed')
        
        return ret

    def SetComboSelectedForOutput(self, Name = None, Selected = None):
        """
This function sets a load combination selected for output flag.
The function returns 0 if the selected flag is successfully set, otherwise it returns nonzero.

Name: The name of an existing load combination.
Selected: This item is True if the specified load combination is to be selected for output, otherwise it is False.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetComboSelectedForOutput(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetComboSelectedForOutput" failed')
        
        return ret

    def SetOptionBaseReactLoc(self, gx = None, gy = None, gz = None):
        """
This function sets the global coordinates of the location at which the base reactions are reported.
The function returns 0 if the coordinates are successfully set, otherwise it returns nonzero.

gx: The global coordinates of the location at which the base reactions are reported.
gy: The global coordinates of the location at which the base reactions are reported.
gz: The global coordinates of the location at which the base reactions are reported.
        """

        all_args = [gx, gy, gz]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetOptionBaseReactLoc(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOptionBaseReactLoc" failed')
        
        return ret

    def SetOptionBucklingMode(self, BuckModeStart = None, BuckModeEnd = None, BuckModeAll = None):
        """
This function sets the buckling modes for which buckling factors are reported.
The function returns 0 if the modes are successfully set, otherwise it returns nonzero.

BuckModeStart: The first buckling mode for which the buckling factor is reported when the BuckModeAll item is False.
BuckModeEnd: The last buckling mode for which the buckling factor is reported when the BuckModeAll item is False.
BuckModeAll: If this item is True, buckling factors are reported for all calculated buckling modes. If it is False, buckling factors are reported for the buckling modes indicated by the BuckModeStart and BuckModeEnd items.
        """

        all_args = [BuckModeStart, BuckModeEnd, BuckModeAll]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetOptionBucklingMode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOptionBucklingMode" failed')
        
        return ret

    def SetOptionDirectHist(self, Value = None):
        """
This function sets the output option for direct history results.
The function returns 0 if the output option is successfully set, otherwise it returns nonzero.

Value: This item is 1, 2 or 3
1 = Envelopes
2 = Step-by-Step
3 = Last Step
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetOptionDirectHist(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOptionDirectHist" failed')
        
        return ret

    def SetOptionModalHist(self, Value = None):
        """
This function sets the output option for modal history results.
The function returns 0 if the output option is successfully set, otherwise it returns nonzero.

Value: This item is 1, 2 or 3
1 = Envelopes
2 = Step-by-Step
3 = Last Step
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetOptionModalHist(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOptionModalHist" failed')
        
        return ret

    def SetOptionModeShape(self, ModeShapeStart = None, ModeShapeEnd = None, ModeShapesAll = None):
        """
This function sets the modes for which mode shape results are reported.
The function returns 0 if the modes are successfully set, otherwise it returns nonzero.

ModeShapeStart: The first mode for which results are reported when the ModeShapesAll item is False.
ModeShapeEnd: The last mode for which results are reported when the ModeShapesAll item is False.
ModeShapesAll: If this item is True, results are reported for all calculated modes. If it is False, results are reported for the modes indicated by the ModeShapeStart and ModeShapeEnd items.
        """

        all_args = [ModeShapeStart, ModeShapeEnd, ModeShapesAll]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetOptionModeShape(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOptionModeShape" failed')
        
        return ret

    def SetOptionMultiStepStatic(self, Value = None):
        """
This function sets the output option for multistep static linear results.
The function returns 0 if the output option is successfully set, otherwise it returns nonzero.

Value: This item is 1, 2 or 3
1 = Envelopes
2 = Step-by-Step
3 = Last Step
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetOptionMultiStepStatic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOptionMultiStepStatic" failed')
        
        return ret

    def SetOptionMultiValuedCombo(self, Value = None):
        """
This function sets the output option for multi-valued load combination results.
The function returns 0 if the output option is successfully set, otherwise it returns nonzero.

Value: This item is either 1, 2, or 3.
1 = Envelopes
2 = Multiple values, if possible
3 = Correspondence
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetOptionMultiValuedCombo(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOptionMultiValuedCombo" failed')
        
        return ret

    def SetOptionNLStatic(self, Value = None):
        """
This function sets the output option for nonlinear static results.
The function returns 0 if the output option is successfully set, otherwise it returns nonzero.

Value: This item is 1, 2 or 3
1 = Envelopes
2 = Step-by-Step
3 = Last Step
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetOptionNLStatic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOptionNLStatic" failed')
        
        return ret

    def SetOptionPSD(self, Value = None):
        """
This function sets the output option for power spectral density results.
The function returns 0 if the output option is successfully set, otherwise it returns nonzero.

Value: This item is either 1 or 2
1 = RMS
2 = sqrt(PSD)
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetOptionPSD(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOptionPSD" failed')
        
        return ret

    def SetOptionSteadyState(self, Value = None, SteadyStateOption = None):
        """
This function sets the output option for steady state results.
The function returns 0 if the output option is successfully set, otherwise it returns nonzero.

Value: This item is either 1 or 2
1 = Envelopes
2 = At Frequencies
SteadyStateOption: This item is 1, 2 or 3
1 = In and Out of Phase
2 = Magnitude
3 = All
        """

        all_args = [Value, SteadyStateOption]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetOptionSteadyState(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOptionSteadyState" failed')
        
        return ret

    def SetSectionCutSelectedForOutput(self):
        """
This function selects or deselects a defined section cut for output.
The function returns 0 if the selected flag is successfully set, otherwise it returns nonzero.
Please note that all section cuts are, by default, selected for output when they are created.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Results.Setup.SetSectionCutSelectedForOutput(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSectionCutSelectedForOutput" failed')
        
        return ret

class Analyze:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetSolverOption_3(self, SolverType = None, SolverProcessType = None, NumberParallelRuns = None, ResponseFileSizeMaxMB = None, NumberAnalysisThreads = None, StiffCase = None):
        """
This function retrieves the model solver options.
The function returns zero if the options are successfully 
 retrieved; otherwise it returns a nonzero value.

SolverType: This is 0, 1 or 2, indicating the solver type.
0 = Standard solver
1 = Advanced solver
2 = Multi-threaded solver
SolverProcessType: This is 0, 1 or 2, indicating the process the analysis 
 is run.
0 = Auto (program determined)
1 = GUI process
2 = Separate process
NumberParallelRuns: This is an integer between -8 and 8, inclusive, not 
 including -1 or 0.
-8 to -2 = The negative 
 of the program determined value when the assigned value is 0 
 = Auto parallel (use up to all physical cores - max 8).
1 = Serial.
2 to 8 = User defined parallel (use up to this fixed number of cores - 
 max 8
ResponseFileSizeMaxMB: The maximum size of a response file in MB before a new 
 response file is created. Positive if user specified, negative if program 
 determined.
NumberAnalysisThreads: Number of threads that the analysis can use. Positive 
 if user specified, negative if program determined.
StiffCase: The name of the load case used when outputting the mass 
 and stiffness matrices to text files. If this item is blank, no matrices 
 are output.
        """

        all_args = [SolverType, SolverProcessType, NumberParallelRuns, ResponseFileSizeMaxMB, NumberAnalysisThreads, StiffCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.GetSolverOption_3(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSolverOption_3" failed')
        
        return ret

    def SetSolverOption_3(self, SolverType = None, SolverProcessType = None, NumberParallelRuns = None, ResponseFileSizeMaxMB = None, NumberAnalysisThreads = None, StiffCase = None):
        """
This function sets the model solver options.
The function returns zero if the options are successfully 
 set; otherwise it returns a nonzero value.

SolverType: This is 0, 1 or 2, indicating the solver type.
0 = Standard 
 solver
1 = Advanced solver
2 = Multi-threaded solver
SolverProcessType: This is 0, 1 or 2, indicating the process the analysis 
 is run.
0 = Auto 
 (program determined)
1 = GUI process
2 = Separate process
NumberParallelRuns: This is an integer between -8 and 8, inclusive, not 
 including -1.
-8 
 to -2 = Auto parallel (use up to all physical cores - max 8). Treated 
 the same as 0.
-1 
 = Illegal value; will return an error.
0 
 = Auto parallel (use up to all physical cores).
1 
 = Serial.
2 
 to 8 = User defined parallel (use up to this fixed number of cores- 
 max 8).
ResponseFileSizeMaxMB: The maximum size of a response file in MB before a new 
 response file is created. Positive if user specified, negative if program 
 determined.
NumberAnalysisThreads: Number of threads that the analysis can use. Positive 
 if user specified, negative if program determined.
StiffCase: The name of the load case used when outputting the mass 
 and stiffness matrices to text files If this item is blank, no matrices 
 are output.
        """

        all_args = [SolverType, SolverProcessType, NumberParallelRuns, ResponseFileSizeMaxMB, NumberAnalysisThreads, StiffCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.SetSolverOption_3(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSolverOption_3" failed')
        
        return ret

    def CreateAnalysisModel(self):
        """
This function creates the analysis model. If the analysis model is already created and current, nothing is done.
The function returns zero if the analysis model is successfully created or it already exists and is current, otherwise it returns a nonzero value.
It is not necessary to call this function before running an analysis. The analysis model is automatically created, if necessary, when the model is run.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.CreateAnalysisModel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CreateAnalysisModel" failed')
        
        return ret

    def DeleteResults(self, Name = None, All = None):
        """
This function deletes results for load cases.
The function returns zero if the results are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing load case that is to have its results deleted.
This item is ignored when the All item is True.
All: If this item is True, the results are deleted for all load cases, and the Name item is ignored.
        """

        all_args = [Name, All]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.DeleteResults(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteResults" failed')
        
        return ret

    def GetActiveDOF(self, DOF = None):
        """
This function retrieves the model global degrees of freedom.
The function returns zero if the degrees of freedom are successfully retrieved; otherwise it returns a nonzero value.

DOF: This is an array of 6 boolean values, indicating if the specified model global degree of freedom is active.
DOF(0) = UX
DOF(1) = UY
DOF(2) = UZ
DOF(3) = RX
DOF(4) = RY
DOF(5) = RZ
        """

        all_args = [DOF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.GetActiveDOF(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetActiveDOF" failed')
        
        return ret

    def GetCaseStatus(self, NumberItems = None, CaseName = None, Status = None):
        """
This function retrieves the status for all load cases.
The function returns zero if the status is successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of load cases for which the status is reported.
CaseName: This is an array that includes the name of each analysis case for which the status is reported.
Status: This is an array of that includes 1, 2, 3 or 4, indicating the load case status.
1 = Not run
2 = Could not start
3 = Not finished
4 = Finished
        """

        all_args = [NumberItems, CaseName, Status]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.GetCaseStatus(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCaseStatus" failed')
        
        return ret

    def GetRunCaseFlag(self, NumberItems = None, CaseName = None, Run = None):
        """
This function retrieves the run flags for all analysis cases.
The function returns zero if the flags are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of load cases for which the run flag is reported.
CaseName: This is an array that includes the name of each analysis case for which the run flag is reported.
Run: This is an array of boolean values indicating if the specified load case is to be run.
        """

        all_args = [NumberItems, CaseName, Run]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.GetRunCaseFlag(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetRunCaseFlag" failed')
        
        return ret

    def MergeAnalysisResults(self, FileName = None):
        """
See “Merging Analysis Results” section in program help 
 file for requirements and limitations.
The analysis model is automatically created as part 
 of this function.
The function returns zero if analysis results are successfully 
 merged, otherwise it returns a nonzero value.
IMPORTANT NOTE: Your model must have a file path defined 
 before merging analysis results. If the model is opened from an existing 
 file, a file path is defined. If the model is created from scratch, the 
 File.Save function must be called with a file name before merging analysis 
 results. Saving the file creates the file path.

FileName: The full path of a model file from which the analysis 
 results are to be merged.
        """

        all_args = [FileName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.MergeAnalysisResults(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"MergeAnalysisResults" failed')
        
        return ret

    def ModifyUnDeformedGeometry(self, CaseName = None, SF = None, Stage = None, Original = None):
        """
This function modifies the undeformed geometry based on displacements obtained from a specified load case.
The function returns zero if it is successful; otherwise it returns a nonzero value.

CaseName: The name of the static load case from which displacements are obtained.
SF: The scale factor applied to the displacements.
Stage: This item applies only when the specified load case is a staged construction load case. It is the stage number from which the displacements are obtained. Specifying a -1 for this item means to use the last run stage.
Original: If this item is True, all other input items in this function are ignored and the original undeformed geometry data is reinstated.
        """

        all_args = [CaseName, SF, Stage, Original]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.ModifyUnDeformedGeometry(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ModifyUnDeformedGeometry" failed')
        
        return ret

    def ModifyUnDeformedGeometryModeShape(self, CaseName = None, Mode = None, MaxDisp = None, Direction = None, Original = None):
        """
This function modifies the undeformed geometry based on the shape of a specified mode from a specified modal or buckling load case.
The function returns zero if it is successful; otherwise it returns a nonzero value.

CaseName: The name of a modal or buckling load case.
Mode: The mode shape to consider.
MaxDisp: The maximum displacement to which the mode shape will be scaled.
Direction: The direction in which to apply the geometry modification.
Original: If this item is True, all other input items in this function are ignored and the original undeformed geometry data is reinstated.
        """

        all_args = [CaseName, Mode, MaxDisp, Direction, Original]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.ModifyUnDeformedGeometryModeShape(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ModifyUnDeformedGeometryModeShape" failed')
        
        return ret

    def RunAnalysis(self):
        """
This function runs the analysis. The analysis model is automatically created as part of this function.
The function returns zero if the analysis model is successfully run, otherwise it returns a nonzero value.
IMPORTANT NOTE: Your model must have a file path defined before running the analysis. If the model is opened from an existing file, a file path is defined. If the model is created from scratch, the File.Save function must be called with a file name before running the analysis. Saving the file creates the file path.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.RunAnalysis(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"RunAnalysis" failed')
        
        return ret

    def SetActiveDOF(self, DOF = None):
        """
This function sets the model global degrees of freedom.
The function returns zero if the degrees of freedom are successfully set; otherwise it returns a nonzero value.

DOF: This is an array of 6 boolean values, indicating if the specified model global degree of freedom is active.
DOF(0) = UX
DOF(1) = UY
DOF(2) = UZ
DOF(3) = RX
DOF(4) = RY
DOF(5) = RZ
        """

        all_args = [DOF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.SetActiveDOF(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetActiveDOF" failed')
        
        return ret

    def SetRunCaseFlag(self, Name = None, Run = None, All = None):
        """
This function sets the run flag for load cases.
The function returns zero if the flag is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing load case that is to have its run flag set.
This item is ignored when the All item is True.
Run: If this item is True, the specified load case is to be run.
All: If this item is True, the run flag is set as specified by the Run item for all load cases, and the Name item is ignored.
        """

        all_args = [Name, Run, All]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.SetRunCaseFlag(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetRunCaseFlag" failed')
        
        return ret

    def GetSolverOption_2(self, SolverType = None, SolverProcessType = None, NumberParallelRuns = None, StiffCase = None):
        """
This function retrieves the model solver options.
The function returns zero if the options are successfully 
 retrieved; otherwise it returns a nonzero value.

SolverType: This is 0, 1 or 2, indicating the solver type.
0 = Standard solver
1 = Advanced solver
2 = Multi-threaded solver
SolverProcessType: This is 0, 1 or 2, indicating the process the analysis 
 is run.
0 = Auto (program determined)
1 = GUI process
2 = Separate process
NumberParallelRuns: This is an integer between -8 and 8, inclusive, not 
 including -1 or 0.
-8 to -2 = The negative 
 of the program determined value when the assigned value is 0 
 = Auto parallel (use up to all physical cores - max 8).
1 = Serial.
2 to 8 = User defined parallel (use up to this fixed number of cores - 
 max 8
StiffCase: The name of the load case used when outputting the mass 
 and stiffness matrices to text files. If this item is blank, no matrices 
 are output.
        """

        all_args = [SolverType, SolverProcessType, NumberParallelRuns, StiffCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.GetSolverOption_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSolverOption_2" failed')
        
        return ret

    def SetSolverOption_2(self, SolverType = None, SolverProcessType = None, NumberParallelRuns = None, StiffCase = None):
        """
This function sets the model solver options.
The function returns zero if the options are successfully 
 set; otherwise it returns a nonzero value.

SolverType: This is 0, 1 or 2, indicating the solver type.
0 = Standard 
 solver
1 = Advanced solver
2 = Multi-threaded solver
SolverProcessType: This is 0, 1 or 2, indicating the process the analysis 
 is run.
0 = Auto 
 (program determined)
1 = GUI process
2 = Separate process
NumberParallelRuns: This is an integer between -8 and 8, inclusive, not 
 including -1.
-8 
 to -2 = Auto parallel (use up to all physical cores - max 8). Treated 
 the same as 0.
-1 
 = Illegal value; will return an error.
0 
 = Auto parallel (use up to all physical cores).
1 
 = Serial.
2 
 to 8 = User defined parallel (use up to this fixed number of cores- 
 max 8).
StiffCase: The name of the load case used when outputting the mass 
 and stiffness matrices to text files If this item is blank, no matrices 
 are output.
        """

        all_args = [SolverType, SolverProcessType, NumberParallelRuns, StiffCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.SetSolverOption_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSolverOption_2" failed')
        
        return ret

    def SetSolverOption(self, SolverType = None, Force32BitSolver = None, StiffCase = None):
        """
This function sets the model solver options.
The function returns zero if the options are successfully set; otherwise it returns a nonzero value.

SolverType: This is 0 or 1, indicating the solver type.
0 = Standard solver
1 = Advanced solver
Force32BitSolver: This is True if the analysis is always run using 32-bit, even on 64-bit computers.
StiffCase: The name of the load case used when outputting the mass and stiffness matrices to text files. If this item is blank, no matrices are output.
        """

        all_args = [SolverType, Force32BitSolver, StiffCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.SetSolverOption(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSolverOption" failed')
        
        return ret

    def SetSolverOption_1(self, SolverType = None, SolverProcessType = None, Force32BitSolver = None, StiffCase = None):
        """
This function sets the model solver options.
The function returns zero if the options are successfully 
 set; otherwise it returns a nonzero value.

SolverType: This is 0, 1 or 2, indicating the solver type.
0 = Standard solver
1 = Advanced solver
2 
 = Multi-threaded solver
SolverProcessType: This is 0, 1 or 2, indicating the process the analysis 
 is run.
0 = Auto (program determined)
1 = GUI process
2 
 = Separate process
Force32BitSolver: This is True if the analysis is always run using 32-bit, 
 even on 64-bit computers.
StiffCase: The name of the load case used when outputting the mass 
 and stiffness matrices to text files If this item is blank, no matrices 
 are output.
        """

        all_args = [SolverType, SolverProcessType, Force32BitSolver, StiffCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Analyze.SetSolverOption_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSolverOption_1" failed')
        
        return ret

class BridgeAdvancedSuper:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.BASConcBox = BASConcBox(strict, api)

    def CountSuperCut(self, Name = None, Count = None):
        """
This function returns the number of superstructure section cuts that are available for getting analysis results and performing design.
The function returns zero if the count is successfully retrieved, otherwise it returns a nonzero value.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
Count: The number of section cuts in this bridge object. They will be identified in subsequent API functions using the indices 0 to Count-1. There may be one or two section cuts at each output station along the length of the superstructure.
        """

        all_args = [Name, Count]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.CountSuperCut(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountSuperCut" failed')
        
        return ret

    def CountSuperCutStressPoint(self, Name = None, CutIndex = None, Count = None):
        """
This function returns the number of stress points at the specified superstructure section cut.
The function returns zero if the count is successfully retrieved, otherwise it returns a nonzero value.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
CutIndex: The index number of section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by function CountSuperCut.
Count: The number of stress points for this section cut in this bridge object. They will be identified in subsequent API functions using the indices 0 to Count-1.
        """

        all_args = [Name, CutIndex, Count]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.CountSuperCutStressPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountSuperCutStressPoint" failed')
        
        return ret

    def GetSuperCutLocation(self, Name = None, CutIndex = None, Location = None, Station = None, XRefPt = None, YRefPt = None, Skew = None, Grade = None, SuperElev = None):
        """
This function returns location and orientation information about a single superstructure section cut in a bridge object.
The function returns zero if the information is successfully retrieved, otherwise it returns a nonzero value.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
CutIndex: The index number of section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by function CountSuperCut. Section cuts will be in order of increasing Station and increasing SuperCutType.
Location: This is 1 or 2, indicating whether the CutIndex section cut occurs before or after the associated station.
1 = Before the specified station.
2 = After the specified station.
Station: The station ordinate of the CutIndex section cut at the reference line of the superstructure. [L]
XRefPt: The transverse and vertical coordinates in the section of the reference point that corresponds to the layout line in the bridge object. XRefPt is positive to the right when looking upstation. YRefPt is positive upward. Coordinates are measured from the lower-left corner of the section bounding-box before skew, grade, and superelevation are applied. The rotations of the section due to skew, grade, and superelevation occur about the reference point. [L]
YRefPt: The transverse and vertical coordinates in the section of the reference point that corresponds to the layout line in the bridge object. XRefPt is positive to the right when looking upstation. YRefPt is positive upward. Coordinates are measured from the lower-left corner of the section bounding-box before skew, grade, and superelevation are applied. The rotations of the section due to skew, grade, and superelevation occur about the reference point. [L]
Skew: The skew angle, in degrees, of the section cut, measured from the horizontal normal to the superstructure reference line, with positive being about the upward vertical axis.
Grade: The grade, as a slope (abs(Grade) < 1.0), giving the vertical rise per distance along the superstructure reference line.
SuperElev: The superelevation, as a slope (abs(SuperElev) < 1.0), giving the vertical rise per distance along the transverse normal to the superstructure reference line.
        """

        all_args = [Name, CutIndex, Location, Station, XRefPt, YRefPt, Skew, Grade, SuperElev]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.GetSuperCutLocation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSuperCutLocation" failed')
        
        return ret

    def GetSuperCutStressPoint(self, Name = None, CutIndex = None, PointIndex = None, X = None, Y = None, MatProp = None, Note = None):
        """
This function returns location and material information about a single stress point at a superstructure section cut in a bridge object.
The function returns zero if the information is successfully retrieved, otherwise it returns a nonzero value.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
CutIndex: The index number of section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by function CountSuperCut.
PointIndex: The index number of the stress point in this section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by function CountSuperCutStressPoint.
X: The transverse and vertical coordinates of the stress point in the section, measured from the bottom left corner of the section. X is positive to the right when looking upstation. Y is positive upward. [L]
Y: The transverse and vertical coordinates of the stress point in the section, measured from the bottom left corner of the section. X is positive to the right when looking upstation. Y is positive upward. [L]
MatProp: The name of the material property at this stress point.
Note: A description of the stress point that may be used for identification. Points that are pre-defined by the program will have prescribed notes.
        """

        all_args = [Name, CutIndex, PointIndex, X, Y, MatProp, Note]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.GetSuperCutStressPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSuperCutStressPoint" failed')
        
        return ret

class BASConcBox:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def CountSuperCutWebStressPoint(self, Name = None, CutIndex = None, WebIndex = None, Count = None):
        """
This function returns the number of stress points at the specified web of the specified superstructure section cut.
The function returns zero if the count is successfully retrieved; otherwise it returns a nonzero value.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
CutIndex: The index number of section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by function CountSuperCut.
WebIndex: The index number of the web in this section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by function GetSuperCutSectionValues.
Count: The number of stress points in this web for this section cut in this bridge object. They will be identified in subsequent API functions using the indices 0 to Count-1.
        """

        all_args = [Name, CutIndex, WebIndex, Count]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.BASConcBox.CountSuperCutWebStressPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountSuperCutWebStressPoint" failed')
        
        return ret

    def GetSuperCutSectionPropsAtY(self, Name = None, CutIndex = None, Y = None, AboveY = None, Ycg = None, Area = None, Inertia = None):
        """
This function returns section properties for the region above or below a given Y coordinate value at a single superstructure section cut in a bridge object. These properties are calculated for the section before skew, grade, and superelevation are applied. Coordinate values are measured from the lower-left corner of the section bounding-box. X is positive to the right when looking upstation, and Y is positive upward.
The function returns zero if the information is successfully retrieved; otherwise it returns a nonzero value.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
CutIndex: The index number of the section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by the function CountSuperCut. Section cuts will be in order of increasing Station and increasing SuperCutType.
Y: The Y coordinate in the section local coordinate system above or below which the section properties are calculated.
AboveY: Boolean indicating whether properties are to be computed for the region above (if true) or below (if false) the specified coordinate Y.
Ycg: Y coordinate of the centroid of the region above/below specified coordinate Y. [L]
Area: Area of the region above/below specified coordinate Y. [L2]
Inertia: Moment of inertia of the region above/below specified coordinate Y, taken about a horizontal axis at Ycg. [L4]
        """

        all_args = [Name, CutIndex, Y, AboveY, Ycg, Area, Inertia]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.BASConcBox.GetSuperCutSectionPropsAtY(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSuperCutSectionPropsAtY" failed')
        
        return ret

    def GetSuperCutSectionValues(self, Name = None, CutIndex = None, Item = None, Value = None):
        """
This function returns an individual section property at a single superstructure section cut in a bridge object. These properties are calculated for the section before skew, grade, and superelevation are applied. Coordinate values are measured from the lower-left corner of the section bounding-box. X is positive to the right when looking upstation, and Y is positive upward.
The function returns zero if the information is successfully retrieved; otherwise it returns a nonzero value.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
CutIndex: The index number of the section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by the function CountSuperCut. Section cuts will be in order of increasing Station and increasing SuperCutType.
Item: This is an integer from 1 to 12, inclusive, indicating the type of property value to be gotten:
1 = Number of girders or webs
2 = Design area of top slab, ASlabTop
3 = Design area of bottom slab, ASlabBot
4 = Width of top slab, BSlabTop
5 = Width of bottom slab, BSlabBot
6 = X coordinate of top slab centroid, XSlabTop
7 = X coordinate of bottom slab centroid, XSlabBot
8 = Y coordinate of top slab centroid, YSlabTop
9 = Y coordinate of bottom slab centroid, YSlabBot
10 = Area inside torsion circuit, ATorsion
11 = Length of torsion circuit, LTorsion
12 = Number of tendons
13 = Top outside width of torsion circuit, BTorsionTop
14 = Bottom outside width of torsion circuit, BTorsionBot
15 = Left outside length of torsion circuit (along slope), HTorsionLeft
16 = Right outside length of torsion circuit (along slope), HTorsionRight
Value: The value of the requested item:
1 = Number of girders or webs
Value >= 0, integral.
2 = Design area of top slab, ASlabTop
Value > 0. [L2]
3 = Design area of bottom slab, ASlabBot
Value >= 0. [L2]
4 = Width of top slab, BSlabTop
Value > 0. [L]
5 = Width of bottom slab, BSlabBot
Value >= 0. [L]
6 = X coordinate of top slab centroid, XSlabTop
Any value is valid. [L]
7 = X coordinate of bottom slab centroid, XSlabBot
Any value is valid. [L]
8 = Y coordinate of top slab centroid, YSlabTop
Value >= 0. [L]
9 = Y coordinate of bottom slab centroid, YSlabBot
Value <= 0. [L]
10 = Area inside torsion circuit, ATorsion
Value >= 0. [L2]
11 = Length of torsion circuit, LTorsion
Value >= 0. [L]
12 = Number of tendons
Value >= 0.
13 = Top outside width of torsion circuit, BTorsionTop
Value > 0. [L]
14 = Bottom outside width of torsion circuit, BTorsionBot
Value > 0. [L]
15 = Left outside length of torsion circuit (along slope), HTorsionLeft
Value > 0. [L]
16 = Right outside length of torsion circuit (along slope), HTorsionRight
Value > 0. [L]
        """

        all_args = [Name, CutIndex, Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.BASConcBox.GetSuperCutSectionValues(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSuperCutSectionValues" failed')
        
        return ret

    def GetSuperCutSlabCoordsAtX(self, Name = None, CutIndex = None, X = None, Status = None, y1 = None, y2 = None, y3 = None, y4 = None):
        """
This function returns information about the box girder slab thicknesses at a given horizontal location across the box girder section.
The function returns zero if the information is successfully retrieved; otherwise it returns a nonzero value.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
CutIndex: The index number of the section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by function CountSuperCut. Section cuts will be in order of increasing Station and increasing SuperCutType.
X: The X coordinate in the section local coordinate system at which a vertical line is passed through the section and the slab coordinates are returned.
Status: This is 0, 1, or 2.
0 = No portion of the section is cut.
1 = Only the section is cut; no interior cell is cut.
2 = The section and an interior cell are cut.
y1: The topmost Y coordinate where the vertical line cuts the section.This item is returned as zero when Status < 1.
y2: The bottommost Y coordinate where the vertical line cuts the section.This item is returned as zero when Status < 1.
y3: The topmost Y coordinate where the vertical line cuts an interior cell.This item is returned as zero when Status < 2.
y4: The bottommost Y coordinate where the vertical line cuts an interior cell.This item is returned as zero when Status < 2.
        """

        all_args = [Name, CutIndex, X, Status, y1, y2, y3, y4]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.BASConcBox.GetSuperCutSlabCoordsAtX(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSuperCutSlabCoordsAtX" failed')
        
        return ret

    def GetSuperCutTendonNames(self, Name = None, CutIndex = None, TendonIndex = None, BridgeTendon = None, TendonObj = None):
        """
This function returns the name of a single tendon object, giving access to tendon assignments, tendon section, and material property.
The function returns zero if the information is successfully retrieved; otherwise it returns a nonzero value.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
CutIndex: The index number of the section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by the function CountSuperCut. Section cuts will be in order of increasing Station and increasing SuperCutType.
TendonIndex: The index number of a tendon in this section cut of this bridge object. This must be from 0 to CountTendon-1, where CountTendon is the number of tendons returned by function GetSuperCutSectionValues using Item = 12.
BridgeTendon: The name of the tendon inside of the bridge object corresponding to TendonIndex.
TendonObj: The name of the tendon object created by the program from the bridge object tendon corresponding to TendonIndex.
        """

        all_args = [Name, CutIndex, TendonIndex, BridgeTendon, TendonObj]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.BASConcBox.GetSuperCutTendonNames(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSuperCutTendonNames" failed')
        
        return ret

    def GetSuperCutTendonValues(self, Name = None, CutIndex = None, TendonIndex = None, Item = None, Value = None):
        """
This function returns an individual section property for a single tendon at a single superstructure section cut in a bridge object. These properties are calculated for the section before skew, grade, and superelevation are applied. Coordinate values are measured from the lower-left corner of the section bounding-box. X is positive to the right when looking upstation, and Y is positive upward.
The function returns zero if the information is successfully retrieved; otherwise it returns a nonzero value.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
CutIndex: The index number of the section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by the function CountSuperCut. Section cuts will be in order of increasing Station and increasing SuperCutType.
TendonIndex: The index number of a tendon in this section cut of this bridge object. This must be from 0 to CountTendon-1, where CountTendon is the number of tendons returned by the function GetSuperCutSectionValues using Item = 12.
Item: This is an integer from 1 to 4, inclusive, indicating the type of property value to be gotten:
1 = X coordinate of tendon centroid, Xcg
2 = Y coordinate of tendon centroid, Ycg
3 = Duct diameter for tendon
4 = Bonding type for tendon
5 = Tendon slope
Value: The value of the requested item:
1 = X coordinate of tendon centroid, Xcg
Any value OK. [L]
2 = Y coordinate of tendon centroid, Ycg
Any value OK. [L]
3 = Duct diameter for tendon
Value >= 0. [L]
4 = Bonding type for tendon
1 = Bonded
2 = Unbonded
5 = Tendon slope
Any value OK. [L/L]
        """

        all_args = [Name, CutIndex, TendonIndex, Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.BASConcBox.GetSuperCutTendonValues(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSuperCutTendonValues" failed')
        
        return ret

    def GetSuperCutWebCoordsAtY(self, Name = None, CutIndex = None, Y = None, NumberWebs = None, WebIsCut = None, WebLeft = None, WebRight = None):
        """
This function returns information about the box girder web thicknesses at a given elevation in the box girder section.
The function returns zero if the information is successfully retrieved; otherwise it returns a nonzero value.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
CutIndex: The index number of the section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by the function CountSuperCut. Section cuts will be in order of increasing Station and increasing SuperCutType.
Y: The Y coordinate in the section local coordinate system at which the web coordinates are returned.
NumberWebs: The number of webs in the section.
WebIsCut: This is a array of booleans indicating if each web is cut by a horizontal line at the specified Y coordinate.
WebLeft: This is a array of X coordinates of the left side of each web. If the web is not cut by a horizontal line at the specified Y coordinate, this value is returned as zero.
WebRight: This is a array of X coordinates of the right side of each web. If the web is not cut by a horizontal line at the specified Y coordinate, this value is returned as zero.
        """

        all_args = [Name, CutIndex, Y, NumberWebs, WebIsCut, WebLeft, WebRight]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.BASConcBox.GetSuperCutWebCoordsAtY(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSuperCutWebCoordsAtY" failed')
        
        return ret

    def GetSuperCutWebStressPoint(self, Name = None, CutIndex = None, WebIndex = None, PointIndex = None, X = None, Y = None, MatProp = None, Note = None):
        """
This function returns location and material information about a single stress point in a web at a superstructure section cut in a bridge object. The function returns zero if the information is successfully retrieved; otherwise it returns a nonzero value.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
CutIndex: The index number of section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by function CountSuperCut.
WebIndex: The index number of the web in this section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by function GetSuperCutSectionValues.
PointIndex: The index number of the stress point in this web of this section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by function CountSuperCutWebStressPoint.
X: The transverse and vertical coordinates of the stress point in the section, measured from the bottom left corner of the section. X is positive to the right when looking upstation. Y is positive upward. [L]
Y: The transverse and vertical coordinates of the stress point in the section, measured from the bottom left corner of the section. X is positive to the right when looking upstation. Y is positive upward. [L]
MatProp: The name of the material property at this stress point.
Note: A description of the stress point that may be used for identification. Points that are pre-defined by the program will have prescribed notes.
        """

        all_args = [Name, CutIndex, WebIndex, PointIndex, X, Y, MatProp, Note]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.BASConcBox.GetSuperCutWebStressPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSuperCutWebStressPoint" failed')
        
        return ret

    def GetSuperCutWebValues(self, Name = None, CutIndex = None, WebIndex = None, Item = None, Value = None):
        """
This function returns an individual section property for a single web at a single superstructure section cut in a bridge object. These properties are calculated for the section before skew, grade, and superelevation are applied. Coordinate values are measured from the lower-left corner of the section bounding-box. X is positive to the right when looking upstation, and Y is positive upward
The function returns zero if the information is successfully retrieved; otherwise it returns a nonzero value. An error is returned for items 3, 4, 5 and 6 if the WebIndex is specified as 0.
If the bridge object is not currently linked to existing objects in the model, an error is returned.

Name: The name of an existing bridge object.
CutIndex: The index number of the section cut in this bridge object. This must be from 0 to Count-1, where Count is the value returned by the function CountSuperCut. Section cuts will be in order of increasing Station and increasing SuperCutType.
WebIndex: The index number of a web in this section cut of this bridge object. This must be from 0 to CountWeb-1, where CountWeb is the number of webs returned by thenfunction GetSuperCutSectionValues using Item = 1. Webs count from left to right when looking upstation.
Item: This is an integer from 1 to 6, inclusive, indicating the type of property value to be gotten:
1 = Angle from vertical (Y) axis, clockwise is positive
2 = Minimum horizontal (X) web thickness
3 = Minimum top slab thickness above cell to left of web
4 = Minimum bottom slab thickness above cell to left of web
5 = Top width of cell to left of web measured from centerline of girders on each side of cell
6 = Bottom width of cell to left of web measured from centerline of girders on each side of cell.
Value: The value of the requested item:
1 = Angle from vertical (Y) axis, clockwise is positive
Abs(Value) < 90. [deg]
2 = Minimum horizontal (X) web thickness
Value > 0. [L]
3 = Minimum top slab thickness
Value < 0. [L]
4 = Minimum bottom slab thickness
Value > 0. [L]
5 = Top width of cell
Value >= 0. [L]
6 = Bottom width of cell
Value >= 0. [L]
        """

        all_args = [Name, CutIndex, WebIndex, Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeAdvancedSuper.BASConcBox.GetSuperCutWebValues(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSuperCutWebValues" failed')
        
        return ret

class BridgeObj:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetBridgeUpdateData(self, Name = None, LinkedModelExists = None, ModelType = None, MaxDeckSegLength = None, MaxCapSegLength = None, MaxColSegLength = None, SubMeshSize = None):
        """
This function returns a flag indicating if the specified bridge object is currently linked to existing objects in the model. If the bridge object is linked, it returns the model type (spine, area or solid) and meshing data used when the linked bridge model was updated.
The function returns zero if the information is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing bridge object.
LinkedModelExists: This item is True if a linked bridge model exists for the specified bridge object.
ModelType: This is 1, 2 or 3, indicating the linked bridge model type. This item applies only when the LinkedModelExists item is True.
1 = Spine model (frame).
2 = Area model.
3 = Solid model.
MaxDeckSegLength: The maximum length for the deck objects in the linked bridge model. This item applies only when the LinkedModelExists item is True. [L]
MaxCapSegLength: The maximum length for the cap beam objects in the linked bridge model. This item applies only when the LinkedModelExists item is True. [L]
MaxColSegLength: The maximum length for the column objects in the linked bridge model. This item applies only when the LinkedModelExists item is True. [L]
SubMeshSize: The maximum submesh size for area and solid objects in the linked bridge model. This item applies only when the LinkedModelExists item is True and the ModelType item is 2 or 3 (area or solid model). [L]
        """

        all_args = [Name, LinkedModelExists, ModelType, MaxDeckSegLength, MaxCapSegLength, MaxColSegLength, SubMeshSize]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeObj.GetBridgeUpdateData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetBridgeUpdateData" failed')
        
        return ret

    def GetBridgeUpdateForAnalysisFlag(self):
        """
When this flag is True, the program automatically updates bridge objects before running an analysis if it detects anything has been changed that might affect the bridge analysis.
This flag is by default set to True for each new Sap2000 Object.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeObj.GetBridgeUpdateForAnalysisFlag(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetBridgeUpdateForAnalysisFlag" failed')
        
        return ret

    def SetBridgeUpdateData(self, Name = None, Action = None, ModelType = None, MaxDeckSegLength = None, MaxCapSegLength = None, MaxColSegLength = None, SubMeshSize = None):
        """
This function updates a linked bridge model, clears all objects from a linked bridge model, or converts a linked bridge model to an unlinked model.
The function returns zero if it is successful.

Name: The name of an existing bridge object.
Action: This is 1, 2 or 3, indicating the action to be taken.
1 = Update linked model.
2 = Clear all from linked model.
3 = Convert to unlinked model.
ModelType: This is 1, 2 or 3, indicating the linked bridge model type. This item applies only when the Action item is 1 (update linked model).
1 = Spine model (frame).
2 = Area model.
3 = Solid model.
MaxDeckSegLength: The maximum length for the deck objects in the linked bridge model. This item applies only when the Action item is 1 (update linked model). [L]
MaxCapSegLength: The maximum length for the cap beam objects in the linked bridge model. This item applies only when the Action item is 1 (update linked model). [L]
MaxColSegLength: The maximum length for the column objects in the linked bridge model. This item applies only when the Action item is 1 (update linked model). [L]
SubMeshSize: The maximum submesh size for area and solid objects in the linked bridge model. This item applies only when the Action item is 1 (update linked model) and the ModelType item is 2 or 3 (area or solid model). [L]
        """

        all_args = [Name, Action, ModelType, MaxDeckSegLength, MaxCapSegLength, MaxColSegLength, SubMeshSize]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeObj.SetBridgeUpdateData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetBridgeUpdateData" failed')
        
        return ret

    def SetBridgeUpdateForAnalysisFlag(self, Value = None):
        """
This function returns zero if the flag is successfully set, otherwise it returns a nonzero value.
This flag is by default set to True for each new Sap2000 Object.

Value: A boolean (True or False) value. When this item is True the program automatically updates bridge objects before running an analysis if it detects anything has been changed that might affect the bridge analysis.
        """

        all_args = [Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.BridgeObj.SetBridgeUpdateForAnalysisFlag(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetBridgeUpdateForAnalysisFlag" failed')
        
        return ret

class RespCombo:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def AddDesignDefaultCombos(self, DesignSteel = None, DesignConcrete = None, DesignAluminum = None, DesignColdFormed = None):
        """
This function adds a new default design load combinations to the model.
The function returns zero if the load combinations are successfully added, otherwise it returns a nonzero value.

DesignSteel: If this item is True, default steel design combinations are to be added to the model.
DesignConcrete: If this item is True, default concrete design combinations are to be added to the model.
DesignAluminum: If this item is True, default aluminum design combinations are to be added to the model.
DesignColdFormed: If this item is True, default cold formed design combinations are to be added to the model.
        """

        all_args = [DesignSteel, DesignConcrete, DesignAluminum, DesignColdFormed]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.AddDesignDefaultCombos(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddDesignDefaultCombos" failed')
        
        return ret

    def Add(self, Name = None, ComboType = None):
        """
This function adds a new load combination.
The function returns zero if the load combination is successfully added, otherwise it returns a nonzero value.
The new load combination must have a different name from all other load combinations and all load cases. If the name is not unique, an error will be returned.

Name: The name of a new load combination.
ComboType: This is 0, 1, 2, 3 or 4 indicating the load combination type.
0 = Linear Additive
1 = Envelope
2 = Absolute Additive
3 = SRSS
4 = Range Additive
        """

        all_args = [Name, ComboType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.Add(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Add" failed')
        
        return ret

    def ChangeName(self, Name = None, NewName = None):
        """
The function returns zero if the new name is successfully applied, otherwise it returns a nonzero value.
The new load combination name must be different from all other load combinations and all load cases. If the name is not unique, an error will be returned.

Name: The existing name of a defined load combination.
NewName: The new name for the combination.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def CountCase(self, Name = None, Count = None):
        """
This function retrieves the total number of load case and/or combinations included in a specified load combination.
The function returns zero if the count is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing load combination.
Count: The number of load case and/or combinations included in the specified combination.
        """

        all_args = [Name, Count]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.CountCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountCase" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of load combinations defined in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def DeleteCase(self, Name = None, CType = None, CName = None):
        """
This function deletes one load case or load combination from the list of cases included in the specified load combination.
The function returns zero if the item is successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing load combination.
CType: This is one of the following items in the eCNameType enumeration:
LoadCase = 0
LoadCombo = 1

This item indicates whether the CName item is an analysis case (LoadCase) or a load combination (LoadCombo).
CName: The name of the load case or load combination to be deleted from the specified combination.
        """

        all_args = [Name, CType, CName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.DeleteCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteCase" failed')
        
        return ret

    def Delete(self, Name = None):
        """
This function deletes the specified load combination.
The function returns zero if the combination is successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing load combination.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetCaseList(self, Name = None, NumberItems = None, CType = None, CName = None, SF = None):
        """
This function returns all load cases and response combinations included in the load combination specified by the Name item.
The function returns zero if the data is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing load combination.
NumberItems: The total number of load cases and load combinations included in the load combination specified by the Name item.
CType: This is an array of one of the following items in the eCNameType enumeration:
LoadCase = 0
LoadCombo = 1

This item indicates if the associated CName item is an load case (LoadCase) or a load combination (LoadCombo).
CName: This is an array of the names of the load cases or load combinations included in the load combination specified by the Name item.
SF: The scale factor multiplying the case or combination indicated by the CName item.
        """

        all_args = [Name, NumberItems, CType, CName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.GetCaseList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCaseList" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined response combinations.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of load combination names retrieved by the program.
MyName: This is a one-dimensional array of load combination names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetNote(self, Name = None, Note = None):
        """
This function retrieves the user note for specified response combination. The note may be blank.
The function returns zero if the note is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing load combination.
Note: The user note, if any, included with the specified combination.
        """

        all_args = [Name, Note]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.GetNote(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNote" failed')
        
        return ret

    def GetTypeOAPI(self, Name = None, ComboType = None):
        """
This function retrieves the combination type for specified load combination.
The function returns zero if the type is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing load combination.
ComboType: This is 0, 1, 2, 3 or 4 indicating the load combination type.
0 = Linear Additive
1 = Envelope
2 = Absolute Additive
3 = SRSS
4 = Range Additive
        """

        all_args = [Name, ComboType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.GetTypeOAPI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTypeOAPI" failed')
        
        return ret

    def SetCaseList(self, Name = None, CNameType = None, CName = None, SF = None):
        """
This function adds or modifies one load case or response combination in the list of cases included in the load combination specified by the Name item.
The function returns zero if the item is successfully added or modified, otherwise it returns a nonzero value.

Name: The name of an existing load combination.
CNameType: This is one of the following items in the eCNameType enumeration:
LoadCase = 0
LoadCombo = 1

This item indicates if the CName item is an load case (LoadCase) or a load combination (LoadCombo).
CName: The name of the load case or load combination to be added to or modified in the combination specified by the Name item. If the load case or combination already exists in the combination specified by the Name item, the scale factor is modified as indicated by the SF item for that load case or combination. If the analysis case or combination does not exist in the combination specified by the Name item, it is added.
SF: The scale factor multiplying the case or combination indicated by the CName item.
        """

        all_args = [Name, CNameType, CName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.SetCaseList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCaseList" failed')
        
        return ret

    def SetNote(self, Name = None, Note = None):
        """
This function sets the user note for specified response combination. The note may be blank.
The function returns zero if the note is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing load combination.
Note: The user note included with the specified combination. It may be a blank string.
        """

        all_args = [Name, Note]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.SetNote(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNote" failed')
        
        return ret

    def SetTypeOAPI(self, Name = None, ComboType = None):
        """
This function sets the combination type for specified load combination.
The function returns zero if the type is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing load combination.
ComboType: This is 0, 1, 2, 3 or 4 indicating the load combination type.
0 = Linear Additive
1 = Envelope
2 = Absolute Additive
3 = SRSS
4 = Range Additive
        """

        all_args = [Name, ComboType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.RespCombo.SetTypeOAPI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTypeOAPI" failed')
        
        return ret

class ConstraintDef:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
The function returns zero if the new name is successfully applied, otherwise it returns a nonzero value.

Name: The existing name of a defined constraint.
NewName: The new name for the constraint.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self, ConstraintType = None):
        """
If the ConstraintType item is specified,  the function returns the number of defined constraints of the specified type. Otherwise it returns the total number of defined constraints without regard for type.

ConstraintType: This optional value is one of the following items in the eConstraintType enumeration.
CONSTRAINT_BODY = 1
CONSTRAINT_DIAPHRAGM = 2
CONSTRAINT_PLATE = 3
CONSTRAINT_ROD = 4
CONSTRAINT_BEAM = 5
CONSTRAINT_EQUAL = 6
CONSTRAINT_LOCAL = 7
CONSTRAINT_WELD = 8
CONSTRAINT_LINE = 13
        """

        all_args = [ConstraintType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes the specified constraint. All constraint assignments for that constraint are also deleted.
The function returns zero if the constraint is successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetBeam(self, Name = None, Axis = None, CSys = None):
        """
The function returns the definition for the specified constraint.
The function returns zero if the constraint data is successfully obtained, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Axis: This is one of the following items from the eConstraintAxis enumeration. It specifies the axis in the specified coordinate system that is parallel to the axis of the constraint. If AutoAxis is specified, the axis of the constraint is automatically determined from the joints assigned to the constraint.
X = 1
Y = 2
Z = 3
AutoAxis = 4
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Axis, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.GetBeam(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetBeam" failed')
        
        return ret

    def GetBody(self, Name = None, Value = None, CSys = None):
        """
The function returns the definition for the specified constraint.
The function returns zero if the constraint data is successfully obtained, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Value: Value is an array of six booleans that indicate which joint degrees of freedom are included in the constraint. In order, the degrees of freedom addressed in the array are UX, UY, UZ, RX, RY and RZ.
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Value, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.GetBody(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetBody" failed')
        
        return ret

    def GetConstraintType(self, Name = None, ConstraintType = None):
        """
The function returns the constraint type for the specified constraint.
The function returns zero if the constraint type is successfully obtained, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
ConstraintType: This value is one of the following items in the eConstraintType enumeration.
CONSTRAINT_BODY = 1
CONSTRAINT_DIAPHRAGM = 2
CONSTRAINT_PLATE = 3
CONSTRAINT_ROD = 4
CONSTRAINT_BEAM = 5
CONSTRAINT_EQUAL = 6
CONSTRAINT_LOCAL = 7
CONSTRAINT_WELD = 8
CONSTRAINT_LINE = 13
        """

        all_args = [Name, ConstraintType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.GetConstraintType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetConstraintType" failed')
        
        return ret

    def GetDiaphragm(self, Name = None, Axis = None, CSys = None):
        """
The function returns the definition for the specified constraint.
The function returns zero if the constraint data is successfully obtained, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Axis: This is one of the following items from the eConstraintAxis enumeration. It specifies the axis in the specified coordinate system that is perpendicular to the plane of the constraint. If AutoAxis is specified, the axis of the constraint is automatically determined from the joints assigned to the constraint.
X = 1
Y = 2
Z = 3
AutoAxis = 4
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Axis, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.GetDiaphragm(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDiaphragm" failed')
        
        return ret

    def GetEqual(self, Name = None, Value = None, CSys = None):
        """
The function returns the definition for the specified constraint.
The function returns zero if the constraint data is successfully obtained, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Value: Value is an array of six booleans that indicate which joint degrees of freedom are included in the constraint. In order, the degrees of freedom addressed in the array are UX, UY, UZ, RX, RY and RZ.
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Value, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.GetEqual(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEqual" failed')
        
        return ret

    def GetLine(self, Name = None, Value = None, CSys = None):
        """
The function returns the definition for the specified constraint.
The function returns zero if the constraint data is successfully obtained, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Value: Value is an array of six booleans that indicate which joint degrees of freedom are included in the constraint. In order, the degrees of freedom addressed in the array are UX, UY, UZ, RX, RY and RZ.
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Value, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.GetLine(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLine" failed')
        
        return ret

    def GetLocal(self, Name = None, Value = None):
        """
The function returns the definition for the specified constraint.
The function returns zero if the constraint data is successfully obtained, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Value: Value is an array of six booleans that indicate which joint degrees of freedom are included in the constraint. In order, the degrees of freedom addressed in the array are U1, U2, U3, R1, R2 and R3.
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.GetLocal(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocal" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined joint constraints.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of joint constraint names retrieved by the program.
MyName: This is a one-dimensional array of joint constraint names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetPlate(self, Name = None, Axis = None, CSys = None):
        """
The function returns the definition for the specified constraint.
The function returns zero if the constraint data is successfully obtained, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Axis: This is one of the following items from the eConstraintAxis enumeration. It specifies the axis in the specified coordinate system that is perpendicular to the plane of the constraint. If AutoAxis is specified, the axis of the constraint is automatically determined from the joints assigned to the constraint.
X = 1
Y = 2
Z = 3
AutoAxis = 4
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Axis, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.GetPlate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPlate" failed')
        
        return ret

    def GetRod(self, Name = None, Axis = None, CSys = None):
        """
The function returns the definition for the specified constraint.
The function returns zero if the constraint data is successfully obtained, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Axis: This is one of the following items from the eConstraintAxis enumeration. It specifies the axis in the specified coordinate system that is parallel to the axis of the constraint. If AutoAxis is specified, the axis of the constraint is automatically determined from the joints assigned to the constraint.
X = 1
Y = 2
Z = 3
AutoAxis = 4
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Axis, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.GetRod(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetRod" failed')
        
        return ret

    def GetWeld(self, Name = None, Value = None, Tolerance = None, CSys = None):
        """
The function returns the definition for the specified constraint.
The function returns zero if the constraint data is successfully obtained, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Value: Value is an array of six booleans that indicate which joint degrees of freedom are included in the constraint. In order, the degrees of freedom addressed in the array are UX, UY, UZ, RX, RY and RZ.
Tolerance: Joints within this distance of each other are constrained together.
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Value, Tolerance, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.GetWeld(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetWeld" failed')
        
        return ret

    def SetBeam(self, Name = None, Axis = None, CSys = None):
        """
This function defines a Beam constraint. If the specified name is not used for a constraint, a new constraint is defined using the specified name. If the specified name is already used for another Beam constraint, the definition of that constraint is modified. If the specified name is already used for some constraint that is not a Beam constraint, an error is returned.
The function returns zero if the constraint data is successfully added or modified, otherwise it returns a nonzero value.

Name: The name of a constraint.
Axis: This is one of the following items from the eConstraintAxis enumeration. It specifies the axis in the specified coordinate system that is parallel to the axis of the constraint. If AutoAxis is specified, the axis of the constraint is automatically determined from the joints assigned to the constraint.
X = 1
Y = 2
Z = 3
AutoAxis = 4
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Axis, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.SetBeam(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetBeam" failed')
        
        return ret

    def SetBody(self, Name = None, Value = None, CSys = None):
        """
This function defines a Body constraint. If the specified name is not used for a constraint, a new constraint is defined using the specified name. If the specified name is already used for another Body constraint, the definition of that constraint is modified. If the specified name is already used for some constraint that is not a Body constraint, an error is returned.
The function returns zero if the constraint data is successfully added or modified, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Value: Value is an array of six booleans that indicate which joint degrees of freedom are included in the constraint. In order, the degrees of freedom addressed in the array are UX, UY, UZ, RX, RY and RZ.
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Value, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.SetBody(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetBody" failed')
        
        return ret

    def SetDiaphragm(self, Name = None, Axis = None, CSys = None):
        """
This function defines a Diaphragm constraint. If the specified name is not used for a constraint, a new constraint is defined using the specified name. If the specified name is already used for another Diaphragm constraint, the definition of that constraint is modified. If the specified name is already used for some constraint that is not a Diaphragm constraint, an error is returned.
The function returns zero if the constraint data is successfully added or modified, otherwise it returns a nonzero value.

Name: The name of a constraint.
Axis: This is one of the following items from the eConstraintAxis enumeration. It specifies the axis in the specified coordinate system that is perpendicular to the plane of the constraint. If AutoAxis is specified, the axis of the constraint is automatically determined from the joints assigned to the constraint.
X = 1
Y = 2
Z = 3
AutoAxis = 4
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Axis, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.SetDiaphragm(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDiaphragm" failed')
        
        return ret

    def SetEqual(self, Name = None, Value = None, CSys = None):
        """
This function defines an Equal constraint. If the specified name is not used for a constraint, a new constraint is defined using the specified name. If the specified name is already used for another Equal constraint, the definition of that constraint is modified. If the specified name is already used for some constraint that is not an Equal constraint, an error is returned.
The function returns zero if the constraint data is successfully added or modified, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Value: Value is an array of six booleans that indicate which joint degrees of freedom are included in the constraint. In order, the degrees of freedom addressed in the array are UX, UY, UZ, RX, RY and RZ.
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Value, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.SetEqual(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEqual" failed')
        
        return ret

    def SetLine(self, Name = None, Value = None, CSys = None):
        """
This function defines a Line constraint. If the specified name is not used for a constraint, a new constraint is defined using the specified name. If the specified name is already used for another Line constraint, the definition of that constraint is modified. If the specified name is already used for some constraint that is not a Line constraint, an error is returned.
The function returns zero if the constraint data is successfully added or modified, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Value: Value is an array of six booleans that indicate which joint degrees of freedom are included in the constraint. In order, the degrees of freedom addressed in the array are UX, UY, UZ, RX, RY and RZ.
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Value, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.SetLine(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLine" failed')
        
        return ret

    def SetLocal(self, Name = None, Value = None):
        """
This function defines a Local constraint. If the specified name is not used for a constraint, a new constraint is defined using the specified name. If the specified name is already used for another Local constraint, the definition of that constraint is modified. If the specified name is already used for some constraint that is not a Local constraint, an error is returned.
The function returns zero if the constraint data is successfully added or modified, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Value: Value is an array of six booleans that indicate which joint degrees of freedom are included in the constraint. In order, the degrees of freedom addressed in the array are U1, U2, U3, R1, R2 and R3.
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.SetLocal(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocal" failed')
        
        return ret

    def SetPlate(self, Name = None, Axis = None, CSys = None):
        """
This function defines a Plate constraint. If the specified name is not used for a constraint, a new constraint is defined using the specified name. If the specified name is already used for another Plate constraint, the definition of that constraint is modified. If the specified name is already used for some constraint that is not a Plate constraint, an error is returned.
The function returns zero if the constraint data is successfully added or modified, otherwise it returns a nonzero value.

Name: The name of a constraint.
Axis: This is one of the following items from the eConstraintAxis enumeration. It specifies the axis in the specified coordinate system that is perpendicular to the plane of the constraint. If AutoAxis is specified, the axis of the constraint is automatically determined from the joints assigned to the constraint.
X = 1
Y = 2
Z = 3
AutoAxis = 4
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Axis, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.SetPlate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPlate" failed')
        
        return ret

    def SetRod(self, Name = None, Axis = None, CSys = None):
        """
This function defines a Rod constraint. If the specified name is not used for a constraint, a new constraint is defined using the specified name. If the specified name is already used for another Rod constraint, the definition of that constraint is modified. If the specified name is already used for some constraint that is not a Rod constraint, an error is returned.
The function returns zero if the constraint data is successfully added or modified, otherwise it returns a nonzero value.

Name: The name of a constraint.
Axis: This is one of the following items from the eConstraintAxis enumeration. It specifies the axis in the specified coordinate system that is parallel to the axis of the constraint. If AutoAxis is specified, the axis of the constraint is automatically determined from the joints assigned to the constraint.
X = 1
Y = 2
Z = 3
AutoAxis = 4
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Axis, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.SetRod(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetRod" failed')
        
        return ret

    def SetWeld(self, Name = None, Value = None, Tolerance = None, CSys = None):
        """
This function defines a Weld constraint. If the specified name is not used for a constraint, a new constraint is defined using the specified name. If the specified name is already used for another Weld constraint, the definition of that constraint is modified. If the specified name is already used for some constraint that is not a Weld constraint, an error is returned.
The function returns zero if the constraint data is successfully added or modified, otherwise it returns a nonzero value.

Name: The name of an existing constraint.
Value: Value is an array of six booleans that indicate which joint degrees of freedom are included in the constraint. In order, the degrees of freedom addressed in the array are UX, UY, UZ, RX, RY and RZ.
Tolerance: Joints within this distance of each other are constrained together.
CSys: The name of the coordinate system in which the constraint is defined.
        """

        all_args = [Name, Value, Tolerance, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ConstraintDef.SetWeld(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetWeld" failed')
        
        return ret

class CoordSys:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
The function returns zero if the new name is successfully applied, otherwise it returns a nonzero value.
Changing the name of the Global coordinate system will fail and return an error.

Name: The existing name of a defined coordinate system.
NewName: The new name for the coordinate system.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CoordSys.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
The function returns the number of defined coordinate systems.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CoordSys.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes the specified coordinate system. Attempting to delete the Global coordinate system will fail and return an error.
The function returns zero if the coordinate system is successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing coordinate system.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CoordSys.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetCoordSys(self, Name = None, x = None, y = None, z = None, RZ = None, RY = None, RX = None):
        """
The function returns zero if the coordinate system data is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing coordinate system.
x: The global X coordinate of the origin of the coordinate system. [L]
y: The global Y coordinate of the origin of the coordinate system. [L]
z: The global Z coordinate of the origin of the coordinate system. [L]
RZ: The rotation of an axis of the new coordinate system relative to the global coordinate system is defined as follows: (1) Rotate the coordinate system about the positive global Z-axis as defined by the RZ item. (2) Rotate the coordinate system about the positive global Y-axis as defined by the RY item. (3) Rotate the coordinate system about the positive global X-axis as defined by the RX item.Note that the order in which these rotations are performed is important.RX, RY and RZ are angles in degrees [deg].
RY: The rotation of an axis of the new coordinate system relative to the global coordinate system is defined as follows: (1) Rotate the coordinate system about the positive global Z-axis as defined by the RZ item. (2) Rotate the coordinate system about the positive global Y-axis as defined by the RY item. (3) Rotate the coordinate system about the positive global X-axis as defined by the RX item.Note that the order in which these rotations are performed is important.RX, RY and RZ are angles in degrees [deg].
RX: The rotation of an axis of the new coordinate system relative to the global coordinate system is defined as follows: (1) Rotate the coordinate system about the positive global Z-axis as defined by the RZ item. (2) Rotate the coordinate system about the positive global Y-axis as defined by the RY item. (3) Rotate the coordinate system about the positive global X-axis as defined by the RX item.Note that the order in which these rotations are performed is important.RX, RY and RZ are angles in degrees [deg].
        """

        all_args = [Name, x, y, z, RZ, RY, RX]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CoordSys.GetCoordSys(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCoordSys" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined coordinate systems.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of coordinate system names retrieved by the program.
MyName: This is a one-dimensional array of coordinate system names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CoordSys.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetTransformationMatrix(self, Name = None, Value = None):
        """
The function returns zero if the coordinate system transformation matrix is successfully returned, otherwise it returns a nonzero value.

Name: The name of an existing coordinate system.
Value: Value is an array of nine direction cosines that define the transformation matrix from the specified global coordinate system to the global coordinate system.
The following matrix equation shows how the transformation matrix is used to convert coordinates from a coordinate system to the global coordinate system.

In the equation, c0 through c8 are the nine values from the transformation array; (x, y, z) are the coordinates of a point in the CSys coordinate system; (ux, uy, uz) are the offset of the origin of the CSys coordinate system from the global coordinate system; and (gx, gy, gz) are the global coordinates of the point.
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CoordSys.GetTransformationMatrix(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTransformationMatrix" failed')
        
        return ret

    def SetCoordSys(self, Name = None, x = None, y = None, z = None, RZ = None, RY = None, RX = None):
        """
The function returns zero if the coordinate system is successfully added or modified, otherwise it returns a nonzero value.
Modifying the Global coordinate system will fail and return an error.

Name: This is the name of a coordinate system. If this is the name of an existing coordinate system, that coordinate system is modified, otherwise a new coordinate system is added.
x: The global X coordinate of the origin of the coordinate system. [L]
y: The global Y coordinate of the origin of the coordinate system. [L]
z: The global Z coordinate of the origin of the coordinate system. [L]
RZ: The rotation of an axis of the new coordinate system relative to the global coordinate system is defined as follows: (1) Rotate the coordinate system about the positive global Z-axis as defined by the RZ item. (2) Rotate the coordinate system about the positive global Y-axis as defined by the RY item. (3) Rotate the coordinate system about the positive global X-axis as defined by the RX item.Note that the order in which these rotations are performed is important.RX, RY and RZ are angles in degrees [deg].
RY: The rotation of an axis of the new coordinate system relative to the global coordinate system is defined as follows: (1) Rotate the coordinate system about the positive global Z-axis as defined by the RZ item. (2) Rotate the coordinate system about the positive global Y-axis as defined by the RY item. (3) Rotate the coordinate system about the positive global X-axis as defined by the RX item.Note that the order in which these rotations are performed is important.RX, RY and RZ are angles in degrees [deg].
RX: The rotation of an axis of the new coordinate system relative to the global coordinate system is defined as follows: (1) Rotate the coordinate system about the positive global Z-axis as defined by the RZ item. (2) Rotate the coordinate system about the positive global Y-axis as defined by the RY item. (3) Rotate the coordinate system about the positive global X-axis as defined by the RX item.Note that the order in which these rotations are performed is important.RX, RY and RZ are angles in degrees [deg].
        """

        all_args = [Name, x, y, z, RZ, RY, RX]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CoordSys.SetCoordSys(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCoordSys" failed')
        
        return ret

class LoadCases:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.ExternalResults = ExternalResults(strict, api)
        self.Buckling = Buckling(strict, api)
        self.DirHistLinear = DirHistLinear(strict, api)
        self.DirHistNonlinear = DirHistNonlinear(strict, api)
        self.HyperStatic = HyperStatic(strict, api)
        self.ModalEigen = ModalEigen(strict, api)
        self.ModalRitz = ModalRitz(strict, api)
        self.ModHistLinear = ModHistLinear(strict, api)
        self.ModHistNonlinear = ModHistNonlinear(strict, api)
        self.Moving = Moving(strict, api)
        self.PSD = PSD(strict, api)
        self.ResponseSpectrum = ResponseSpectrum(strict, api)
        self.StaticNonlinearStaged = StaticNonlinearStaged(strict, api)
        self.StaticLinear = StaticLinear(strict, api)
        self.StaticLinearMultistep = StaticLinearMultistep(strict, api)
        self.StaticNonlinear = StaticNonlinear(strict, api)
        self.StaticNonlinearMultistep = StaticNonlinearMultistep(strict, api)
        self.SteadyState = SteadyState(strict, api)

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing load case.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined load case.
NewName: The new name for the load case.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of defined load cases in the model. If desired, counts can be returned for all load cases of a specified type in the model.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes the specified load case.
The function returns zero if the load case is successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing load case.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetNameList_1(self):
        """
This function retrieves the names of all defined load cases of the specified type.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.GetNameList_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList_1" failed')
        
        return ret

    def GetTypeOAPI_2(self, Name = None, CaseType = None, SubType = None, DesignType = None, DesignTypeOption = None, Auto = None):
        """
This function retrieves the case type, design type, and auto flag for the specified load case.
The function returns zero if the type is successfully retrieved; otherwise it returns nonzero.
This function supersedes. GetTypeOAPI_1 {LoadCase}.

Name: The name of an existing load case.
CaseType: This is one of the following items in the eLoadCaseType enumeration.
LinearStatic = 1
NonlinearStatic = 2
Modal = 3
ResponseSpectrum = 4
LinearHistory = 5 (Modal Time History)
NonlinearHistory = 6 (Modal Time History)
LinearDynamic = 7 (Direct Integration Time History)
NonlinearDynamic = 8 (Direct Integration Time History)
MovingLoad = 9
Buckling = 10
SteadyState = 11
PowerSpectralDensity = 12
LinearStaticMultistep = 13
Hyperstatic = 14
ExternalResults = 15
StagedConstruction = 16
NonlinearStaticMultiStep = 17
SubType: This is an integer representing the load case sub type. This item applies only for certain case types.
For CASE_MODAL:
1 = Eigen
2 = Ritz
For CASE_LINEAR_HISTORY:
1 = Transient
2 = Periodic
DesignType: This is one of the following items in the eLoadPatternType enumeration.
Dead = 1
SuperDead = 2
Live = 3
ReduceLive = 4
Quake = 5
Wind = 6
Snow = 7
Other = 8
Move = 9
Temperature = 10
RoofLive = 11
Notional = 12
PatternLive = 13
Wave= 14
Braking = 15
Centrifugal = 16
Friction = 17
Ice = 18
WindOnLiveLoad = 19
HorizontalEarthPressure = 20
VerticalEarthPressure = 21
EarthSurcharge = 22
DownDrag = 23
VehicleCollision = 24
VesselCollision = 25
TemperatureGradient = 26
Settlement = 27
Shrinkage = 28
Creep = 29
WaterLoadPressure = 30
LiveLoadSurcharge = 31
LockedInForces = 32
PedestrianLL = 33
Prestress = 34
Hyperstatic = 35
Bouyancy = 36
StreamFlow = 37
Impact = 38
Construction = 39
DeadWearing = 40
DeadWater = 41
DeadManufacture = 42
EarthHydrostatic = 43
PassiveEarthPressure = 44
ActiveEarthPressure = 45
PedestrianLLReduced = 46
SnowHighAltitude = 47
EuroLm1Char = 48
EuroLm1Freq = 49
EuroLm2 = 50
EuroLm3 = 51
EuroLm4 = 52

DesignTypeOption: This is one of the following options for the DesignType item.
0 = Program determined
1 = User specified
Auto: This is one of the following values indicating if the load case has been automatically created.
0 = Not automatically created
1 = Automatically created by the bridge construction scheduler
        """

        all_args = [Name, CaseType, SubType, DesignType, DesignTypeOption, Auto]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.GetTypeOAPI_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTypeOAPI_2" failed')
        
        return ret

    def GetTypeOAPI_1(self, Name = None, CaseType = None, SubType = None, DesignType = None, DesignTypeOption = None, Auto = None):
        """
This function retrieves the case type, design type, and auto flag for the specified load case.
The function returns zero if the type is successfully retrieved; otherwise it returns nonzero.
This function supersedes .GetType (LoadCases).

Name: The name of an existing load case.
CaseType: This is one of the following items in the eLoadCaseType enumeration.
LinearStatic = 1
NonlinearStatic = 2
Modal = 3
ResponseSpectrum = 4
LinearHistory = 5 (Modal Time History)
NonlinearHistory = 6 (Modal Time History)
LinearDynamic = 7 (Direct Integration Time History)
NonlinearDynamic = 8 (Direct Integration Time History)
MovingLoad = 9
Buckling = 10
SteadyState = 11
PowerSpectralDensity = 12
LinearStaticMultistep = 13
Hyperstatic = 14
ExternalResults = 15
SubType: This is an integer representing the load case sub type. This item applies only for certain case types.
For CASE_NONLINEAR_STATIC:
1 = Nonlinear
2 = Nonlinear staged construction
3 = Nonlinear static multi-step
For CASE_MODAL:
1 = Eigen
2 = Ritz
For CASE_LINEAR_HISTORY:
1 = Transient
2 = Periodic
DesignType: This is one of the following items in the eLoadPatternType enumeration.
Dead = 1
SuperDead = 2
Live = 3
ReduceLive = 4
Quake = 5
Wind = 6
Snow = 7
Other = 8
Move = 9
Temperature = 10
RoofLive = 11
Notional = 12
PatternLive = 13
Wave= 14
Braking = 15
Centrifugal = 16
Friction = 17
Ice = 18
WindOnLiveLoad = 19
HorizontalEarthPressure = 20
VerticalEarthPressure = 21
EarthSurcharge = 22
DownDrag = 23
VehicleCollision = 24
VesselCollision = 25
TemperatureGradient = 26
Settlement = 27
Shrinkage = 28
Creep = 29
WaterLoadPressure = 30
LiveLoadSurcharge = 31
LockedInForces = 32
PedestrianLL = 33
Prestress = 34
Hyperstatic = 35
Bouyancy = 36
StreamFlow = 37
Impact = 38
Construction = 39
DeadWearing = 40
DeadWater = 41
DeadManufacture = 42
EarthHydrostatic = 43
PassiveEarthPressure = 44
ActiveEarthPressure = 45
PedestrianLLReduced = 46
SnowHighAltitude = 47
EuroLm1Char = 48
EuroLm1Freq = 49
EuroLm2 = 50
EuroLm3 = 51
EuroLm4 = 52

DesignTypeOption: This is one of the following options for the DesignType item.
0 = Program determined
1 = User specified
Auto: This is one of the following values indicating if the load case has been automatically created.
0 = Not automatically created
1 = Automatically created by the bridge construction scheduler
        """

        all_args = [Name, CaseType, SubType, DesignType, DesignTypeOption, Auto]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.GetTypeOAPI_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTypeOAPI_1" failed')
        
        return ret

    def SetDesignType(self, Name = None, DesignTypeOption = None, DesignType = None):
        """
This function sets the design type for the specified load case.
The function returns zero if the type is successfully set; otherwise it returns nonzero.

Name: The name of an existing load case.
DesignTypeOption: This is one of the following options for the DesignType item.
0 = Program determined
1 = User specified
DesignType: This item only applies when the DesignTypeOption is 1 (user specified). It is one of the following items in the eLoadPatternType enumeration.
LTYPE_DEAD = 1
LTYPE_SUPERDEAD = 2
LTYPE_LIVE = 3
LTYPE_REDUCELIVE = 4
LTYPE_QUAKE = 5
LTYPE_WIND= 6
LTYPE_SNOW = 7
LTYPE_OTHER = 8
LTYPE_MOVE = 9
LTYPE_TEMPERATURE = 10
LTYPE_ROOFLIVE = 11
LTYPE_NOTIONAL = 12
LTYPE_PATTERNLIVE = 13
LTYPE_WAVE= 14
LTYPE_BRAKING = 15
LTYPE_CENTRIFUGAL = 16
LTYPE_FRICTION = 17
LTYPE_ICE = 18
LTYPE_WINDONLIVELOAD = 19
LTYPE_HORIZONTALEARTHPRESSURE = 20
LTYPE_VERTICALEARTHPRESSURE = 21
LTYPE_EARTHSURCHARGE = 22
LTYPE_DOWNDRAG = 23
LTYPE_VEHICLECOLLISION = 24
LTYPE_VESSELCOLLISION = 25
LTYPE_TEMPERATUREGRADIENT = 26
LTYPE_SETTLEMENT = 27
LTYPE_SHRINKAGE = 28
LTYPE_CREEP = 29
LTYPE_WATERLOADPRESSURE = 30
LTYPE_LIVELOADSURCHARGE = 31
LTYPE_LOCKEDINFORCES = 32
LTYPE_PEDESTRIANLL = 33
LTYPE_PRESTRESS = 34
LTYPE_HYPERSTATIC = 35
LTYPE_BOUYANCY = 36
LTYPE_STREAMFLOW = 37
LTYPE_IMPACT = 38
LTYPE_CONSTRUCTION = 39
        """

        all_args = [Name, DesignTypeOption, DesignType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SetDesignType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDesignType" failed')
        
        return ret

    def GetNameList(self):
        """
This function retrieves the names of all defined load cases of the specified type.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetTypeOAPI(self, Name = None, CaseType = None, SubType = None):
        """
This function retrieves the case type for the specified load case.
The function returns zero if the type is successfully retrieved; otherwise it returns nonzero.

Name: The name of an existing load case.
CaseType: This is one of the following items in the eLoadCaseType enumeration.
CASE_LINEAR_STATIC = 1
CASE_NONLINEAR_STATIC = 2
CASE_MODAL = 3
CASE_RESPONSE_SPECTRUM = 4
CASE_LINEAR_HISTORY = 5(Modal Time History)
CASE_NONLINEAR_HISTORY = 6(Modal Time History)
CASE_LINEAR_DYNAMIC = 7(Direct Integration Time History)
CASE_NONLINEAR_DYNAMIC = 8(Direct Integration Time History)
CASE_MOVING_LOAD = 9
CASE_BUCKLING = 10
CASE_STEADY_STATE = 11
CASE_POWER_SPECTRAL_DENSITY = 12
CASE_LINEAR_STATIC_MULTISTEP = 13
CASE_HYPERSTATIC = 14
SubType: This is an integer representing the load case sub type. This item only applies for certain case types.
For CASE_NONLINEAR_STATIC:
1 = Nonlinear
2 = Nonlinear staged construction

For CASE_MODAL:
1 = Eigen
2 = Ritz

For CASE_LINEAR_HISTORY:
1 = Transient
2 = Periodic
        """

        all_args = [Name, CaseType, SubType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.GetTypeOAPI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTypeOAPI" failed')
        
        return ret

class ExternalResults:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def SetCase(self, Name = None):
        """
This function initializes an external results load case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case for which user-supplied external analysis results are available for some frame objects. If this is an existing case, that case is modified; otherwise, a new case is added.

        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ExternalResults.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetNumberSteps(self, Name = None, FirstStep = None, LastStep = None):
        """
In the absence of a call to this function, the default values are FirstStep = 1 and LastStep = 1.
The number of steps available for this load case will be LastStep – FirstStep + 1.
The function returns zero if the number of steps is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing external results load case.
FirstStep: The number of the first step for which external results are to be subsequently provided for frame objects in conjunction with this load case. The value may be 0 or 1. A value of zero is typically used for cases that include the initial conditions, such as time-history cases.
LastStep: The number of the last step for which external results are to be subsequently provided for frame objects in conjunction with this load case. The value must be greater than or equal to FirstStep.
        """

        all_args = [Name, FirstStep, LastStep]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ExternalResults.SetNumberSteps(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNumberSteps" failed')
        
        return ret

class Func:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.FuncPSD = FuncPSD(strict, api)
        self.FuncRS = FuncRS(strict, api)
        self.FuncSS = FuncSS(strict, api)
        self.FuncTH = FuncTH(strict, api)

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing function.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined function.
NewName: The new name for the function.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def ConvertToUser(self, Name = None):
        """
This function converts an existing function to a user defined function.
The function returns zero if the function definition is successfully converted; otherwise it returns a nonzero value. An error is returned if the specified function is already a user defined function.

Name: The name of an existing function that is not a user defined function.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.ConvertToUser(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ConvertToUser" failed')
        
        return ret

    def Count(self, FuncType = None):
        """
This function returns the total number of defined functions in the model of the specified type.

FuncType: This optional value is one of the following numbers, indicating the type of function for which the count is desired.
0 = All function types
1 = Response spectrum
2 = Time history
3 = Power spectral density
4 = Steady state
        """

        all_args = [FuncType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified function.
The function returns zero if the function is successfully deleted; otherwise it returns a nonzero value. It returns an error if the specified function can not be deleted if, for example, it is being used in an load case.

Name: The name of an existing function.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None, FuncType = None):
        """
This function retrieves the names of all defined functions of the specified type.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of function names retrieved by the program.
MyName: This is a one-dimensional array of function names. The MyName array is created as a dynamic, zero-based array by the API user:
Dim MyName() as String
The array is dimensioned to (NumberNames - 1) inside the SAP2000 program, filled with the names, and returned to the API user.
FuncType: This is one of the following numbers, indicating the type of function for which the name list is desired.
0 = All function types
1 = Response spectrum
2 = Time history
3 = Power spectral density
4 = Steady state
        """

        all_args = [NumberNames, MyName, FuncType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetTypeOAPI(self, Name = None, FuncType = None, AddType = None):
        """
This function retrieves the function type for the specified function.
The function returns zero if the type is successfully retrieved; otherwise it returns nonzero.

Name: The name of an existing function.
FuncType: This is one of the following numbers, indicating the type of function.
1 = Response spectrum
2 = Time history
3 = Power spectral density
4 = Steady state
AddType: The is one of the following items, indicating the function subtype.
Response Spectrum Functions
0 = From file
1 = User
2 = UBC 94
3 = UBC 97
4 = BOCA 96
5 = NBCC 95
6 = IBC 2003
7 = NEHRP 97
8 = Eurocode 8-1998
9 = NZS4203 1992
10 = Chinese 2010
11 = Italian Ordinanza 3274
12 = IS1893:2002
13 = AASHTO LRFD 2006
14 = NCHRP Project 20-07
15 = IBC 2006
16 = NBCC 2005
17 = Eurocode 8-2004
18 = AS 1170.4-2007
19 = NZS 1170.5-2004
20 = AASHTO 2007
21 = Chinese JTG/T B02-2013
22 = Chinese GB 50111-2006
23 = IBC 2009
24 = NBCC 2010
25 = NTC 2008
26 = AASHTO 2012
27 = IBC 2012
28 = TSC 2007
29 = SI 413(1995)
30 = Argentina INPRES-CIRSOC 103
31 = Chile Norma NCh433+DS61
32 = Chile Norma NCh2369-2003
33 = Colombia NSR-10
34 = Ecuador NEC-11 Capitulo 2
35 = Guatemala AGIES NSE 2-10
36 = Mexico NTC 2004
37 = Peru Norma E.030
38 = Dominican Republic R-001
39 = Venezuela COVENIN 1756-2:2001
40 = KBC 2009
41 = Mexico CFE-93
42 = Peru NTE E.030 2014
43 = Mexico CFE-2008
44 = Ecuado Norma NEC-SE-DS 2015
45 = Costa Rica Seismic Code 2010
46 = SP 14.13330.2014
47 = Chinese CJJ 166-2011
48 = NBCC 2015
49 = IS 1893:2016
50 = ASCE 7-16
51 = KBC 2016
52 = NTC 2018
53 = TSC 2018
Time History Functions
0 = From file
1 = User
2 = Sine
3 = Cosine
4 = Ramp
5 = Sawtooth
6 = Triangular
7 = User periodic
Power Spectral Density Functions
0 = From file
1 = User

Steady State Functions
0 = From file
1 = User
        """

        all_args = [Name, FuncType, AddType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.GetTypeOAPI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTypeOAPI" failed')
        
        return ret

    def GetValues(self, Name = None, NumberItems = None, MyTime = None, Value = None):
        """
This function retrieves the time and function values for any defined function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing function.
NumberItems: The number of time and function value pairs retrieved.
MyTime: This is an array that includes the time value for each data point. [s] for response spectrum and time history functions, [cyc/s] for power spectral density and steady state functions
Value: This is an array that includes the function value for each data point.
        """

        all_args = [Name, NumberItems, MyTime, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.GetValues(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetValues" failed')
        
        return ret

class FuncPSD:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetFromFile(self, Name = None, FileName = None, HeadLines = None, PreChars = None, PointsPerLine = None, ValueType = None, FreeFormat = None, NumberFixed = None, FreqTypeInFile = None):
        """
This function retrieves the definition of a power spectral density function from file.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined power spectral density function specified to be from a text file.
FileName: The full path of the text file containing the function data.
HeadLines: The number of header lines in the text file to be skipped before starting to read function data.
PreChars: The number of prefix characters to be skipped on each line in the text file.
PointsPerLine: The number of function points included on each text file line.
ValueType: This is either 1 or 2, indicating value type.
1 = Values at equal time intervals
2 = Time and function values
FreeFormat: This item is True if the data is provided in a free format. It is False if it is in a fixed format.
NumberFixed: This item applies only when the FreeFormat item is False. It is the number of characters per item.
FreqTypeInFile: This is either 1 or 2, indicating frequency type.
1 = Hz
2 = RPM
        """

        all_args = [Name, FileName, HeadLines, PreChars, PointsPerLine, ValueType, FreeFormat, NumberFixed, FreqTypeInFile]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncPSD.GetFromFile(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetFromFile" failed')
        
        return ret

    def GetUser(self, Name = None, NumberItems = None, Frequency = None, Value = None):
        """
This function retrieves the definition of a user defined power spectral density function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a user defined power spectral density function.
NumberItems: The number of frequency and value pairs defined.
Frequency: This is an array that includes the frequency in Hz for each data point. [cyc/s]
Value: This is an array that includes the function value for each data point.
        """

        all_args = [Name, NumberItems, Frequency, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncPSD.GetUser(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUser" failed')
        
        return ret

    def SetFromFile(self, Name = None, FileName = None, HeadLines = None, PreChars = None, PointsPerLine = None, ValueType = None, FreeFormat = None, NumberFixed = None, FreqTypeInFile = None):
        """
This function defines a power spectral density function from file.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
FileName: The full path of the text file containing the function data.
HeadLines: The number of header lines in the text file to be skipped before starting to read function data.
PreChars: The number of prefix characters to be skipped on each line in the text file.
PointsPerLine: The number of function points included on each text file line.
ValueType: This is either 1 or 2, indicating value type.
1 = Values at equal time intervals
2 = Time and function values
FreeFormat: This item is True if the data is provided in a free format. It is False if it is in a fixed format.
NumberFixed: This item only applies when the FreeFormat item is False. It is the number of characters per item.
FreqTypeInFile: This is either 1 or 2, indicating frequency type.
1 = Hz
2 = RPM
        """

        all_args = [Name, FileName, HeadLines, PreChars, PointsPerLine, ValueType, FreeFormat, NumberFixed, FreqTypeInFile]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncPSD.SetFromFile(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFromFile" failed')
        
        return ret

    def SetUser(self, Name = None, NumberItems = None, Frequency = None, Value = None):
        """
This function defines a user power spectral density function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
NumberItems: The number of frequency and value pairs defined.
Frequency: This is an array that includes the frequency in Hz for each data point. [cyc/s]
Value: This is an array that includes the function value for each data point.
        """

        all_args = [Name, NumberItems, Frequency, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncPSD.SetUser(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUser" failed')
        
        return ret

class FuncRS:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetAASHTO2006(self, Name = None, AASHTO2006A = None, AASHTO2006SoilProfileType = None, DampRatio = None):
        """
This function retrieves the definition of an AASHTO2006 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an AASHTO2006 response spectrum function.
AASHTO2006A: The acceleration coefficient, A.
AASHTO2006SoilProfileType: This is 1, 2, 3 or 4, indicating the soil profile type.
1 = I
2 = II
3 = III
4 = IV
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, AASHTO2006A, AASHTO2006SoilProfileType, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetAASHTO2006(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAASHTO2006" failed')
        
        return ret

    def GetAASHTO2007(self, Name = None, AASHTO2007Option = None, AASHTO2007Latitude = None, AASHTO2007Longitude = None, AASHTO2007ZipCode = None, AASHTO2007SS = None, AASHTO2007S1 = None, AASHTO2007PGA = None, AASHTO2007SiteClass = None, AASHTO2007Fa = None, AASHTO2007Fv = None, AASHTO2007Fpga = None, DampRatio = None):
        """
This function retrieves the definition of a AASHTO 20-07 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an AASHTO 20-07 response spectrum function.
AASHTO2007Option: This is 0, 1, or 2, indicating the seismic coefficient option.
0 = Ss and S1 from USGS by latitude and longitude
1 = Ss and S1 from USGS by zip code
2 = Ss and S1 are user defined
AASHTO2007Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when AASHTO2007Option = 0.
AASHTO2007Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when AASHTO2007Option = 0.
AASHTO2007ZipCode: The zip code for which the seismic coefficients are obtained. This item is used only when AASHTO2007Option = 1.
AASHTO2007SS: The seismic coefficients Ss, S1 and PGA. These items are used only when AASHTO2007Option = 2.
AASHTO2007S1: The seismic coefficients Ss, S1 and PGA. These items are used only when AASHTO2007Option = 2.
AASHTO2007PGA: The seismic coefficients Ss, S1 and PGA. These items are used only when AASHTO2007Option = 2.
AASHTO2007SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
AASHTO2007Fa: The site coefficients Fa, Fv and Fpga. These items are used only when AASHTO2007SiteClass= 6.
AASHTO2007Fv: The site coefficients Fa, Fv and Fpga. These items are used only when AASHTO2007SiteClass= 6.
AASHTO2007Fpga: The site coefficients Fa, Fv and Fpga. These items are used only when AASHTO2007SiteClass= 6.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, AASHTO2007Option, AASHTO2007Latitude, AASHTO2007Longitude, AASHTO2007ZipCode, AASHTO2007SS, AASHTO2007S1, AASHTO2007PGA, AASHTO2007SiteClass, AASHTO2007Fa, AASHTO2007Fv, AASHTO2007Fpga, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetAASHTO2007(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAASHTO2007" failed')
        
        return ret

    def GetAS11702007(self, Name = None, AS2007SiteClass = None, AS2007kp = None, AS2007Z = None, AS2007Sp = None, AS2007Mu = None, DampRatio = None):
        """
This function retrieves the definition of an AS 1170 2007 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a AS 1170 2007 response spectrum function.
AS2007SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
AS2007kp: The probability factor, kp.
AS2007Z: The hazard factor, Z.
AS2007Sp: The structural performance factor, Sp.
AS2007Mu: The structural ductility factor, u.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, AS2007SiteClass, AS2007kp, AS2007Z, AS2007Sp, AS2007Mu, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetAS11702007(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAS11702007" failed')
        
        return ret

    def GetBOCA96(self, Name = None, BOCA96Aa = None, BOCA96Av = None, BOCA96S = None, BOCA96R = None, DampRatio = None):
        """
This function retrieves the definition of a BOCA96 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a BOCA96 response spectrum function.
BOCA96Aa: The effective peak acceleration, Aa.
BOCA96Av: The effective peak velocity, Av.
BOCA96S: The soil profile coefficient, S.
BOCA96R: The response modification factor, R.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, BOCA96Aa, BOCA96Av, BOCA96S, BOCA96R, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetBOCA96(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetBOCA96" failed')
        
        return ret

    def GetChinese2010(self, Name = None, JGJ32010AlphaMax = None, JGJ32010SI = None, JGJ32010Tg = None, JGJ32010PTDF = None, DampRatio = None):
        """
This function retrieves the definition of a Chinese 2010 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a Chinese 2010 response spectrum function.
JGJ32010AlphaMax: The maximum influence factor.
JGJ32010SI: This is 1, 2, 3, 4, 5 or 6, indicating the seismic intensity.
1 = 6 (0.05g)
2 = 7 (0.10g)
3 = 7 (0.15g)
4 = 8 (0.20g)
5 = 8 (0.30g)
6 = 9 (0.40g)
JGJ32010Tg: The characteristic ground period, Tg > 0.1. [s]
JGJ32010PTDF: The period time discount factor.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, JGJ32010AlphaMax, JGJ32010SI, JGJ32010Tg, JGJ32010PTDF, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetChinese2010(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetChinese2010" failed')
        
        return ret

    def GetCJJ1662011(self, Name = None, Direction = None, PeakAccel = None, Tg = None, DampRatio = None):
        """
This function retrieves the definition of a CJJ 166-2011 response spectrum function.
The function returns zero if the function is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a CJJ 166-2011 response spectrum function.
Direction: This is 1 or 2, indicating the response spectrum direction.
1 = Horizontal
2 = Vertical

PeakAccel: The peak acceleration, A.

Tg: The characteristic ground period , Tg > 0.1. [s]

DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, Direction, PeakAccel, Tg, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetCJJ1662011(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCJJ1662011" failed')
        
        return ret

    def GetEuroCode8(self, Name = None, EuroCode8AG = None, EuroCode8S = None, EuroCode8n = None, DampRatio = None):
        """
This function retrieves the definition of a EuroCode8 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a EuroCode8 response spectrum function.
EuroCode8AG: The design ground acceleration, Ag.
EuroCode8S: This is 1, 2 or 3, indicating the subsoil class.
1 = A
2 = B
3 = C
EuroCode8n: The damping correction factor, n, where n >= 0.7.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, EuroCode8AG, EuroCode8S, EuroCode8n, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetEuroCode8(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEuroCode8" failed')
        
        return ret

    def GetEurocode82004_1(self, Name = None, EURO2004Country = None, EURO2004Direction = None, EURO2004SpectrumType = None, EURO2004GroundType = None, EURO2004ag = None, EURO2004S = None, EURO2004AvgoverAg = None, EURO2004Tb = None, EURO2004Tc = None, EURO2004Td = None, EURO2004Beta = None, EURO2004q = None, DampRatio = None):
        """
This function retrieves the definition of a Eurocode 8 2004 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a Eurocode 8 2004 response spectrum function.
EURO2004Country: This is 0, 1, 5, 6, or 10 indicating the country for which the Nationally Determined Parameters (NDPs) are specified.
0 = Other (NDPs are user specified)
1 = CEN Default
5 = Norway
6 = Singapore
10 = Portugal

EURO2004Direction: This is 1 or 2, indicating the ground motion direction.
1 = Horizontal
2 = Vertical (Does not apply when EURO2004Country = 6)
EURO2004SpectrumType: This is 1 or 2, indicating the spectrum type.
1 = Type 1
2 = Type 2 (Does not apply when EURO2004Country = 5 or 6)
EURO2004GroundType: This is 1, 2, 3, 4, 5 or 6, indicating the ground type.This item only applies when the EURO2004Direction item is 1 (horizontal).
1 = A (Does not apply when EURO2004Country = 6)
2 = B (Does not apply when EURO2004Country = 6)
3 = C
4 = D
5 = E (Does not apply when EURO2004Country = 6)
6 = S1 (Only applies when EURO2004Country = 6)
EURO2004ag: The design ground acceleration in g, ag.
EURO2004S: The soil factor, S. This item only applies when the EURO2004Direction item is 1 (horizontal).
EURO2004AvgoverAg: The vertical ground acceleration divided by the horizontal ground acceleration, Avg/Ag. This item only applies when the EURO2004Direction item is 2 (vertical).
EURO2004Tb: The lower limit of period of the constant spectral acceleration branch, Tb.
EURO2004Tc: The upper limit of period of the constant spectral acceleration branch, Tc.
EURO2004Td: The period defining the start of the constant displacement range, Td.
EURO2004Beta: The lower bound factor, Beta.
EURO2004q: The behavior factor, q.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, EURO2004Country, EURO2004Direction, EURO2004SpectrumType, EURO2004GroundType, EURO2004ag, EURO2004S, EURO2004AvgoverAg, EURO2004Tb, EURO2004Tc, EURO2004Td, EURO2004Beta, EURO2004q, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetEurocode82004_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEurocode82004_1" failed')
        
        return ret

    def GetFromFile(self, Name = None, FileName = None, HeadLines = None, DampRatio = None, ValueType = None):
        """
This function retrieves the definition of a response spectrum function from file.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined response spectrum function specified to be from a text file.
FileName: The full path of the text file containing the function data.
HeadLines: The number of header lines in the text file to be skipped before starting to read function data.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
ValueType: This is either 1 or 2, indicating time value type.
1 = Frequency
2 = Period
        """

        all_args = [Name, FileName, HeadLines, DampRatio, ValueType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetFromFile(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetFromFile" failed')
        
        return ret

    def GetIBC2003(self, Name = None, IBC2003SS = None, IBC2003S1 = None, DampRatio = None):
        """
This function retrieves the definition of a IBC2003 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a IBC2003 response spectrum function.
IBC2003SS: The design spectral acceleration at short periods, Sds.
IBC2003S1: The design spectral acceleration at a one second period, Sd1.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, IBC2003SS, IBC2003S1, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetIBC2003(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetIBC2003" failed')
        
        return ret

    def GetIBC2006(self, Name = None, IBC2006Option = None, IBC2006Latitude = None, IBC2006Longitude = None, IBC2006ZipCode = None, IBC2006SS = None, IBC2006S1 = None, IBC2006TL = None, IBC2006SiteClass = None, IBC2006Fa = None, IBC2006Fv = None, DampRatio = None):
        """
This function retrieves the definition of a IBC2006 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a IBC2006 response spectrum function.
IBC2006Option: This is 0, 1 or 2, indicating the seismic coefficient option.
0 = Ss and S1 from USGS by latitiude and longitude
1 = Ss and S1 from USGS by zip code
2 = Ss and S1 are user defined
IBC2006Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when IBC2006Option = 0.
IBC2006Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when IBC2006Option = 0.
IBC2006ZipCode: The zip code for which the seismic coefficients are obtained. This item is used only when IBC2006Option = 1.
IBC2006SS: The seismic coefficients Ss and S1. This item is used only when IBC2006Option = 2.
IBC2006S1: The seismic coefficients Ss and S1. This item is used only when IBC2006Option = 2.
IBC2006TL: The long-period transition period. [s]
IBC2006SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
IBC2006Fa: The site coefficients Fa and Fv. These items are used only when IBC2006SiteClass= 6.
IBC2006Fv: The site coefficients Fa and Fv. These items are used only when IBC2006SiteClass= 6.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, IBC2006Option, IBC2006Latitude, IBC2006Longitude, IBC2006ZipCode, IBC2006SS, IBC2006S1, IBC2006TL, IBC2006SiteClass, IBC2006Fa, IBC2006Fv, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetIBC2006(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetIBC2006" failed')
        
        return ret

    def GetIS18932002(self, Name = None, INZ = None, INS = None, DampRatio = None):
        """
This function retrieves the definition of a IS1893-2002 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a IS1893-2002 response spectrum function.
INZ: The seismic zone factor, Z.
INS: This is 1, 2 or 3, indicating the soil type.
1 = I
2 = II
3 = III
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, INZ, INS, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetIS18932002(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetIS18932002" failed')
        
        return ret

    def GetItalian3274(self, Name = None, Italag = None, ItalSoilType = None, Italq = None, ItalLevel = None, DampRatio = None):
        """
This function retrieves the definition of a Italian 3274 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a Italian 3274 response spectrum function.
Italag: The peak ground acceleration.
ItalSoilType: This is 1, 2, 3, 4 or 5, indicating the seismic intensity.
1 = A
2 = B
3 = C
4 = E
5 = D
Italq: The structure factor.
ItalLevel: This is 0, 1, 2, 3, 4, 5, 6 or 7, indicating the spectral level, direction and building type.
0 = SLU/H/Building
1 = SLU/H/Bridge
2 = SLU/V/Building
3 = SLU/V/Bridge
4 = EL/H/Building
5 = EL/H/Bridge
6 = EL/V/Building
7 = EL/V/Bridge

SLU refers to ultimate strength design and EL refers to elastic design. H and V are horizontal and vertical, respectively.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, Italag, ItalSoilType, Italq, ItalLevel, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetItalian3274(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetItalian3274" failed')
        
        return ret

    def GetJTGB022013(self, Name = None, Direction = None, PeakAccel = None, Tg = None, Ci = None, Cs = None, DampRatio = None):
        """
This function retrieves the definition of a JTG B02-2013 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a JTG B02-2013 response spectrum function.
Direction: This is 1, 2 or 3, indicating the response spectrum direction.
1 = Horizontal
2 = Vertical-Rock
3 = Vertical-Soil
PeakAccel: The peak acceleration, A.
Tg: The characteristic ground period, Tg > 0.1. [s]
Ci: The importance coefficient.
Cs: The site soil coefficient.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, Direction, PeakAccel, Tg, Ci, Cs, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetJTGB022013(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetJTGB022013" failed')
        
        return ret

    def GetJTGT2231012020(self, Name = None, PeakAccel = None, Tg = None, Ci = None, Cs = None, DampRatio = None):
        """
This function retrieves the definition of a JTGT2231012020 
 response spectrum function.
The function returns zero if the function definition 
 is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a JTGT2231012020 response spectrum function.
PeakAccel: The peak ground acceleration.
Tg: The characteristic ground period, Tg > 0.1 [s]
Ci: The importance coefficient.
Cs: The site soil coefficient.
DampRatio: The damping ratio for the function, 0 <= DampRatio 
 < 1.
        """

        all_args = [Name, PeakAccel, Tg, Ci, Cs, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetJTGT2231012020(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetJTGT2231012020" failed')
        
        return ret

    def GetNBCC2005(self, Name = None, NBCC2005PGA = None, NBCC2005S02 = None, NBCC2005S05 = None, NBCC2005S1 = None, NBCC2005S2 = None, NBCC2005SiteClass = None, NBCC2005Fa = None, NBCC2005Fv = None, DampRatio = None):
        """
This function retrieves the definition of a NBCC2005 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a NBCC2005 response spectrum function.
NBCC2005PGA: The peak ground acceleration.
NBCC2005S02: The spectral acceleration at a 0.2 second period.
NBCC2005S05: The spectral acceleration at a 0.52 second period.
NBCC2005S1: The spectral acceleration at a 1 second period.
NBCC2005S2: The spectral acceleration at a 2 second period.
NBCC2005SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
NBCC2005Fa: The site coefficient, Fa. This item is read when the site class is F only.
NBCC2005Fv: The site coefficient, Fv. This item is read when the site class is F only.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NBCC2005PGA, NBCC2005S02, NBCC2005S05, NBCC2005S1, NBCC2005S2, NBCC2005SiteClass, NBCC2005Fa, NBCC2005Fv, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetNBCC2005(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNBCC2005" failed')
        
        return ret

    def GetNBCC2010(self, Name = None, PGA = None, S02 = None, S05 = None, S1 = None, S2 = None, SiteClass = None, Fa = None, Fv = None, DampRatio = None):
        """
This function retrieves the definition of a NBCC2010 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a NBCC2010 response spectrum function.
PGA: The peak ground acceleration.
S02: The spectral acceleration at a 0.2 second period.
S05: The spectral acceleration at a 0.5 second period.
S1: The spectral acceleration at a 1 second period.
S2: The spectral acceleration at a 2 second period.
SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
Fa: The site coefficient, Fa. This item is read when the site class is F only.
Fv: The site coefficient, Fv. This item is read when the site class is F only.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, PGA, S02, S05, S1, S2, SiteClass, Fa, Fv, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetNBCC2010(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNBCC2010" failed')
        
        return ret

    def GetNBCC2015(self, Name = None, PGA = None, S02 = None, S05 = None, S1 = None, S2 = None, S5 = None, S10 = None, SiteClass = None, F02 = None, F05 = None, F1 = None, F2 = None, F5 = None, F10 = None, DampRatio = None):
        """
This function retrieves the definition of a NBCC2015 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a NBCC2015 response spectrum function.
PGA: The peak ground acceleration.
S02: The spectral acceleration at a 0.2 second period.
S05: The spectral acceleration at a 0.5 second period.
S1: The spectral acceleration at a 1 second period.
S2: The spectral acceleration at a 2 second period.
S5: The spectral acceleration at a 5 second period.
S10: The spectral acceleration at a 10 second period.
SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
F02: The site coefficient at a 0.2 second period. This item is read when the site class is F only.
F05: The site coefficientat a 0.5 second period. This item is read when the site class is F only.
F1: The site coefficient at a 1 second period. This item is read when the site class is F only.
F2: The site coefficient at a 2 second period. This item is read when the site class is F only.
F5: The site coefficient at a 5 second period. This item is read when the site class is F only.
F10: The site coefficient at a 10 second period. This item is read when the site class is F only.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, PGA, S02, S05, S1, S2, S5, S10, SiteClass, F02, F05, F1, F2, F5, F10, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetNBCC2015(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNBCC2015" failed')
        
        return ret

    def GetNBCC95(self, Name = None, NBCC95ZVR = None, NBCC95ZA = None, NBCC95ZV = None, DampRatio = None):
        """
This function retrieves the definition of a NBCC95 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a NBCC95 response spectrum function.
NBCC95ZVR: The zonal velocity ratio.
NBCC95ZA: The acceleration-related seismic zone.
NBCC95ZV: The velocity-related seismic zone.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NBCC95ZVR, NBCC95ZA, NBCC95ZV, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetNBCC95(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNBCC95" failed')
        
        return ret

    def GetNCHRP2007(self, Name = None, NCHRP2007Option = None, NCHRP2007Latitude = None, NCHRP2007Longitude = None, NCHRP2007ZipCode = None, NCHRP2007SS = None, NCHRP2007S1 = None, NCHRP2007SiteClass = None, NCHRP2007Fa = None, NCHRP2007Fv = None, DampRatio = None):
        """
This function retrieves the definition of a NCHRP 20-07 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a NCHRP 20-07 response spectrum function.
NCHRP2007Option: This is 0, 1 or 2, indicating the seismic coefficient option.
0 = Ss and S1 from USGS by latitiude and longitude
1 = Ss and S1 from USGS by zip code
2 = Ss and S1 are user defined
NCHRP2007Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when NCHRP2007Option = 0.
NCHRP2007Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when NCHRP2007Option = 0.
NCHRP2007ZipCode: The zip code for which the seismic coefficients are obtained. This item is used only when NCHRP2007Option = 1.
NCHRP2007SS: The seismic coefficients Ss and S1. This item is used only when NCHRP2007Option = 2.
NCHRP2007S1: The seismic coefficients Ss and S1. This item is used only when NCHRP2007Option = 2.
NCHRP2007SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
NCHRP2007Fa: The site coefficients Fa and Fv. These items are used only when NCHRP2007SiteClass= 6.
NCHRP2007Fv: The site coefficients Fa and Fv. These items are used only when NCHRP2007SiteClass= 6.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NCHRP2007Option, NCHRP2007Latitude, NCHRP2007Longitude, NCHRP2007ZipCode, NCHRP2007SS, NCHRP2007S1, NCHRP2007SiteClass, NCHRP2007Fa, NCHRP2007Fv, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetNCHRP2007(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNCHRP2007" failed')
        
        return ret

    def GetNEHRP97(self, Name = None, NEHRP97SS = None, NEHRP97S1 = None, DampRatio = None):
        """
This function retrieves the definition of a NEHRP97 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a NEHRP97 response spectrum function.
NEHRP97SS: The design spectral acceleration at short periods, Sds.
NEHRP97S1: The design spectral acceleration at a one second period, Sd1.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NEHRP97SS, NEHRP97S1, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetNEHRP97(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNEHRP97" failed')
        
        return ret

    def GetNTC2008(self, Name = None, ParamsOption = None, Latitude = None, Longitude = None, Island = None, LimitState = None, UsageClass = None, NomLife = None, PeakAccel = None, F0 = None, Tcs = None, SpecType = None, SoilType = None, Topography = None, hRatio = None, Damping = None, q = None):
        """
This function retrieves the definition of a NTC2008 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of a NTC2008 response spectrum function.
ParamsOption: This is 1, 2, or 3, indicating the option for defining the parameters.
1 = by latitude and longitude
2 = by island
3 = user specified
Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Island: This is one of the following values. This item is used only when ParamsOption = 2.
1 = Alicudi2 = Arcipelago Toscano3 = Filcudi4 = Isole Egadi5 = Lampedusa6 = Linosa7 = Lipari8 = Palmarola9 = Panarea10 = Pantelleria11 = Ponza12 = Salina13 = Santo Stefano14 = Sardegna15 = Stromboli16 = Tremiti17 = Ustica18 = Ventotene19 = Vulcano20 = Zannone
LimitState: This is 1, 2, 3, or 4, indicating the limit state.
1 = SLO
2 = SLD
3 = SLV
4 = SLC
UsageClass: This is 1, 2, 3, or 4, indicating the usage class.
1 = I
2 = II
3 = III
4 = IV
NomLife: The nominal life to be considered.
PeakAccel: The peak ground acceleration, ag/g.
F0: The magnitude factor, F0.
Tcs: The reference period, Tc* [s].
SpecType: This is 1, 2, 3, or 4, indicating the type of spectrum to consider.
1 = Elastic horizontal
2 = Elastic vertical
3 = Design horizontal
4 = Design vertical
SoilType: This is 1, 2, 3, 4, or 5, indicating the subsoil type.
1 = A
2 = B
3 = C
4 = D
5 = E

Topography: This is 1, 2, 3, or 4, indicating the topography type.
1 = T1
2 = T2
3 = T3
4 = T4
hRatio: The ratio for the site altitude at the base of the hill to the height of the hill.
Damping: The damping, in percent. This is only applicable for SpecType 1 and 2.
q: The behavior correction factor. This is only applicable for SpecType 3 and 4.
        """

        all_args = [Name, ParamsOption, Latitude, Longitude, Island, LimitState, UsageClass, NomLife, PeakAccel, F0, Tcs, SpecType, SoilType, Topography, hRatio, Damping, q]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetNTC2008(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNTC2008" failed')
        
        return ret

    def GetNTC2018(self, Name = None, ParamsOption = None, Latitude = None, Longitude = None, Island = None, LimitState = None, UsageClass = None, NomLife = None, PeakAccel = None, F0 = None, Tcs = None, SpecType = None, SoilType = None, Topography = None, hRatio = None, Damping = None, q = None):
        """
This function retrieves the definition of a NTC2018 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of a NTC2018 response spectrum function.
ParamsOption: This is 1, 2, or 3, indicating the option for defining the parameters.
1 = by latitude and longitude
2 = by island
3 = user specified
Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Island: This is one of the following values. This item is used only when ParamsOption = 2.
1 = Alicudi2 = Arcipelago Toscano3 = Filcudi4 = Isole Egadi5 = Lampedusa6 = Linosa7 = Lipari8 = Palmarola9 = Panarea10 = Pantelleria11 = Ponza12 = Salina13 = Santo Stefano14 = Sardegna15 = Stromboli16 = Tremiti17 = Ustica18 = Ventotene19 = Vulcano20 = Zannone
LimitState: This is 1, 2, 3, or 4, indicating the limit state.
1 = SLO
2 = SLD
3 = SLV
4 = SLC
UsageClass: This is 1, 2, 3, or 4, indicating the usage class.
1 = I
2 = II
3 = III
4 = IV
NomLife: The nominal life to be considered.
PeakAccel: The peak ground acceleration, ag/g.
F0: The magnitude factor, F0.
Tcs: The reference period, Tc* [s].
SpecType: This is 1, 2, 3, or 4, indicating the type of spectrum to consider.
1 = Elastic horizontal
2 = Elastic vertical
3 = Design horizontal
4 = Design vertical
SoilType: This is 1, 2, 3, 4, or 5, indicating the subsoil type.
1 = A
2 = B
3 = C
4 = D
5 = E

Topography: This is 1, 2, 3, or 4, indicating the topography type.
1 = T1
2 = T2
3 = T3
4 = T4
hRatio: The ratio for the site altitude at the base of the hill to the height of the hill.
Damping: The damping, in percent. This is only applicable for SpecType 1 and 2.
q: The behavior correction factor. This is only applicable for SpecType 3 and 4.
        """

        all_args = [Name, ParamsOption, Latitude, Longitude, Island, LimitState, UsageClass, NomLife, PeakAccel, F0, Tcs, SpecType, SoilType, Topography, hRatio, Damping, q]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetNTC2018(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNTC2018" failed')
        
        return ret

    def GetNZS11702004_1(self, Name = None, NZS2004SpectrumType = None, NZS2004SiteClass = None, NZS2004Z = None, NZS2004R = None, NZS2004DIST = None, NZS2004ConsiderTSite = None, NZS2004TSite = None, DampRatio = None):
        """
This function retrieves the definition of an NZS 1170 2004 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a NZS 1170 2004 response spectrum function.
NZS2004SpectrumType: This is 1 or 2, indicating the spectrum type.
1 = Horizontal
2 = Vertical

NZS2004SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
NZS2004Z: The hazard factor, Z.
NZS2004R: The return period factor, R.
NZS2004DIST: Distance to the fault in km, used to calculate the near fault factor.
NZS2004ConsiderTSite: Indicates whether to consider the site period for the spectral shape factor.
NZS2004TSite: The low amplitude site period.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NZS2004SpectrumType, NZS2004SiteClass, NZS2004Z, NZS2004R, NZS2004DIST, NZS2004ConsiderTSite, NZS2004TSite, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetNZS11702004_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNZS11702004_1" failed')
        
        return ret

    def GetNZS42031992(self, Name = None, NZS4203SF = None, NZS4203S = None, DampRatio = None):
        """
This function retrieves the definition of a NZS4203-1992 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a NZS4203-1992 response spectrum function.
NZS4203SF: The scaling factor (Sm * Sp * R * Z * L).
NZS4203S: This is 1, 2 or 3, indicating the site subsoil category.
1 = A
2 = B
3 = C
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NZS4203SF, NZS4203S, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetNZS42031992(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNZS42031992" failed')
        
        return ret

    def GetSP14133302014(self, Name = None, Direction = None, Seismicity = None, SoilCat = None, K0Factor = None, K1Factor = None, KPsiFactor = None, NonlinSoil = None, ASoil = None, DampRatio = None):
        """
This function retrieves the definition of a SP 14.13330.2014 response spectrum function.
The function returns zero if the function is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a SP 14.13330.2014 response spectrum function.
Direction: This is 1, 2, 3, or 4, indicating the direction and structure type for which the response spectrum is generated.
1 = Building Horizontal
2 = Building Vertical
3 = Bridge Horizontal
4 = Bridge Vertical

Seismicity: This is 1, 2, 3, or 4, indicating the region seismicity of the construction site.
1 = 6
2 = 7
3 = 8
4 = 9

SoilCat: This is 1, 2, 3, or 4, indicating the soil category.
1 = I
2 = II
3 = III
4 = IV

K0Factor: The K0Factor, 0 < K0 <= 2.0. This is only applicable when the Direction parameter is 1 or 3 for horizontal spectra.
K1Factor: The K1Factor, 0 < K1 <= 1.0.
KPsiFactor: The KPsiFactor, 0.5 < KPsi <= 1.5. This is only applicable when the Direction parameter is 1 or 3 for horizontal spectra.
NonlinSoil: This item is True if nonlinear soil deformation should be accounted for. This is only applicable when the Direction parameter is 1 or 2 for buildings and the SoilCat parameter is 3 or 4.
ASoil: The nonlinear soil deformation factor, 0 > a_soil <= 1.0. This is only applicable when the NonlinSoil parameter is True, the Direction parameter is 1 or 2 buildings, and the SoilCat parameter is 3 or 4. 
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, Direction, Seismicity, SoilCat, K0Factor, K1Factor, KPsiFactor, NonlinSoil, ASoil, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetSP14133302014(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSP14133302014" failed')
        
        return ret

    def GetUBC94(self, Name = None, UBC94Z = None, UBC94S = None, DampRatio = None):
        """
This function retrieves the definition of a UBC94 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a UBC94 response spectrum function.
UBC94Z: The seismic zone factor, Z.
UBC94S: This is 1, 2 or 3, indicating the soil type.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, UBC94Z, UBC94S, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetUBC94(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUBC94" failed')
        
        return ret

    def GetUBC97(self, Name = None, UBC97Ca = None, UBC97Cv = None, DampRatio = None):
        """
This function retrieves the definition of a UBC97 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a UBC97 response spectrum function.
UBC97Ca: The seismic coefficient, Ca.
UBC97Cv: The seismic coefficient, Cv.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, UBC97Ca, UBC97Cv, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetUBC97(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUBC97" failed')
        
        return ret

    def GetUser(self, Name = None, NumberItems = None, Period = None, Value = None, DampRatio = None):
        """
This function retrieves the definition of a user defined response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a user defined response spectrum function.
NumberItems: The number of frequency and value pairs defined.
Period: This is an array that includes the time for each data point. [s]
Value: This is an array that includes the function value for each data point.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NumberItems, Period, Value, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetUser(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUser" failed')
        
        return ret

    def SetAASHTO2006(self, Name = None, AASHTO2006A = None, AASHTO2006SoilProfileType = None, DampRatio = None):
        """
This function defines an AASHTO2006 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function then that function is modified, otherwise, a new function is added.
AASHTO2006A: The acceleration coefficient, A.
AASHTO2006SoilProfileType: This is 1, 2, 3 or 4, indicating the soil profile type.
1 = I
2 = II
3 = III
4 = IV
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, AASHTO2006A, AASHTO2006SoilProfileType, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetAASHTO2006(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAASHTO2006" failed')
        
        return ret

    def SetAASHTO2007(self, Name = None, AASHTO2007Option = None, AASHTO2007Latitude = None, AASHTO2007Longitude = None, AASHTO2007ZipCode = None, AASHTO2007SS = None, AASHTO2007S1 = None, AASHTO2007PGA = None, AASHTO2007SiteClass = None, AASHTO2007Fa = None, AASHTO2007Fv = None, AASHTO2007Fpga = None, DampRatio = None):
        """
This function defines a AASHTO 2007 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
AASHTO2007Option: This is 0, 1 or 2, indicating the seismic coefficient option.
0 = Ss and S1 from USGS by latitude and longitude
1 = Ss and S1 from USGS by zip code
2 = Ss and S1 are user defined
AASHTO2007Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when AASHTO2007Option = 0.
AASHTO2007Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when AASHTO2007Option = 0.
AASHTO2007ZipCode: The zip code for which the seismic coefficients are obtained. This item is used only when AASHTO2007Option = 1.
AASHTO2007SS: The seismic coefficients Ss, S1 and PGA. These items are used only when AASHTO2007Option = 2.
AASHTO2007S1: The seismic coefficients Ss, S1 and PGA. These items are used only when AASHTO2007Option = 2.
AASHTO2007PGA: The seismic coefficients Ss, S1 and PGA. These items are used only when AASHTO2007Option = 2.
AASHTO2007SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
AASHTO2007Fa: The site coefficients Fa, Fv and Fpga. These items are used only when AASHTO2007SiteClass= 6.
AASHTO2007Fv: The site coefficients Fa, Fv and Fpga. These items are used only when AASHTO2007SiteClass= 6.
AASHTO2007Fpga: The site coefficients Fa, Fv and Fpga. These items are used only when AASHTO2007SiteClass= 6.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, AASHTO2007Option, AASHTO2007Latitude, AASHTO2007Longitude, AASHTO2007ZipCode, AASHTO2007SS, AASHTO2007S1, AASHTO2007PGA, AASHTO2007SiteClass, AASHTO2007Fa, AASHTO2007Fv, AASHTO2007Fpga, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetAASHTO2007(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAASHTO2007" failed')
        
        return ret

    def SetAS11702007(self, Name = None, AS2007SiteClass = None, AS2007kp = None, AS2007Z = None, AS2007Sp = None, AS2007Mu = None, DampRatio = None):
        """
This function defines an AS 1170.4 2007 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function then that function is modified, otherwise, a new function is added.
AS2007SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
AS2007kp: The probability factor, kp.
AS2007Z: The hazard factor, Z.
AS2007Sp: The structural performance factor, Sp.
AS2007Mu: The structural ductility factor, u.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, AS2007SiteClass, AS2007kp, AS2007Z, AS2007Sp, AS2007Mu, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetAS11702007(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAS11702007" failed')
        
        return ret

    def SetBOCA96(self, Name = None, BOCA96Aa = None, BOCA96Av = None, BOCA96S = None, BOCA96R = None, DampRatio = None):
        """
This function defines a BOCA96 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
BOCA96Aa: The effective peak acceleration, Aa.
BOCA96Av: The effective peak velocity, Av.
BOCA96S: The soil profile coefficient, S.
BOCA96R: The response modification factor, R.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, BOCA96Aa, BOCA96Av, BOCA96S, BOCA96R, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetBOCA96(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetBOCA96" failed')
        
        return ret

    def SetChinese2010(self, Name = None, JGJ32010AlphaMax = None, JGJ32010SI = None, JGJ32010Tg = None, JGJ32010PTDF = None, DampRatio = None):
        """
This function defines a Chinese 2010 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
JGJ32010AlphaMax: The maximum influence factor.
JGJ32010SI: This is 1, 2, 3, 4, 5 or 6, indicating the seismic intensity.
1 = 6 (0.05g)
2 = 7 (0.10g)
3 = 7 (0.15g)
4 = 8 (0.20g)
5 = 8 (0.30g)
6 = 9 (0.40g)
JGJ32010Tg: The characteristic ground period, Tg > 0.1. [s]
JGJ32010PTDF: The period time discount factor.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, JGJ32010AlphaMax, JGJ32010SI, JGJ32010Tg, JGJ32010PTDF, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetChinese2010(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetChinese2010" failed')
        
        return ret

    def SetCJJ1662011(self, Name = None, Direction = None, PeakAccel = None, Tg = None, DampRatio = None):
        """
This function defines a CJJ 166-2011 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
Direction: This is 1 or 2, indicating the response spectrum direction.
1 = Horizontal
2 = Vertical

PeakAccel: The peak acceleration, A.
Tg: The characteristic ground period, Tg > 0.1. [s]
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, Direction, PeakAccel, Tg, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetCJJ1662011(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCJJ1662011" failed')
        
        return ret

    def SetEuroCode8(self, Name = None, EuroCode8AG = None, EuroCode8S = None, EuroCode8n = None, DampRatio = None):
        """
This function defines a EuroCode8 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
EuroCode8AG: The design ground acceleration, Ag.
EuroCode8S: This is 1, 2 or 3, indicating the subsoil class.
1 = A
2 = B
3 = C
EuroCode8n: The damping correction factor, n, where n >= 0.7.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, EuroCode8AG, EuroCode8S, EuroCode8n, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetEuroCode8(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEuroCode8" failed')
        
        return ret

    def SetEurocode82004_1(self, Name = None, EURO2004Country = None, EURO2004Direction = None, EURO2004SpectrumType = None, EURO2004GroundType = None, EURO2004ag = None, EURO2004S = None, EURO2004AvgoverAg = None, EURO2004Tb = None, EURO2004Tc = None, EURO2004Td = None, EURO2004Beta = None, EURO2004q = None, DampRatio = None):
        """
This function defines a Eurocode 8 2004 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function,n that function is modified; otherwise, a new function is added.
EURO2004Country: This is 0, 1, 5, 6, or 10 indicating the country for which the Nationally Determined Parameters (NDPs) are specified.
0 = Other (NDPs are user specified)
1 = CEN Default
5 = Norway
6 = Singapore
10 = Portugal

EURO2004Direction: This is 1 or 2, indicating the ground motion direction.
1 = Horizontal
2 = Vertical (Does not apply when EURO2004Country = 6)
EURO2004SpectrumType: This is 1 or 2, indicating the spectrum type.
1 = Type 1
2 = Type 2 (Does not apply when EURO2004Country = 5 or 6)
EURO2004GroundType: This is 1, 2, 3, 4, 5 or 6, indicating the ground type.This item only applies when the EURO2004Direction item is 1 (horizontal).
1 = A (Does not apply when EURO2004Country = 6)
2 = B (Does not apply when EURO2004Country = 6)
3 = C
4 = D
5 = E (Does not apply when EURO2004Country = 6)
6 = S1 (Only applies when EURO2004Country = 6)
EURO2004ag: The design ground acceleration in g, ag.
EURO2004S: The soil factor, S. This item only applies when the EURO2004Direction item is 1 (horizontal).If the EURO2004Country item is not 0, then the input value for this item is ignored.
EURO2004AvgoverAg: The vertical ground acceleration divided by the horizontal ground acceleration, Avg/Ag. This item only applies when the EURO2004Direction item is 2 (vertical).If the EURO2004Country item is not 0, then the input value for this item is ignored.
EURO2004Tb: The lower limit of period of the constant spectral acceleration branch, Tb. If the EURO2004Country item is not 0, then the input value for this item is ignored.
EURO2004Tc: The upper limit of period of the constant spectral acceleration branch, Tc. If the EURO2004Country item is not 0, then the input value for this item is ignored.
EURO2004Td: The period defining the start of the constant displacement range, Td. If the EURO2004Country item is not 0, then the input value for this item is ignored.
EURO2004Beta: The lower bound factor, Beta. If the EURO2004Country item is not 0, then the input value for this item is ignored.
EURO2004q: The behavior factor, q.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, EURO2004Country, EURO2004Direction, EURO2004SpectrumType, EURO2004GroundType, EURO2004ag, EURO2004S, EURO2004AvgoverAg, EURO2004Tb, EURO2004Tc, EURO2004Td, EURO2004Beta, EURO2004q, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetEurocode82004_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEurocode82004_1" failed')
        
        return ret

    def SetFromFile(self, Name = None, FileName = None, HeadLines = None, DampRatio = None, ValueType = None):
        """
This function defines a response spectrum function from file.
The function returns zero if the function is successfully defined, otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function. that function is modified; otherwise, a new function is added.
FileName: The full path of the text file containing the function data.
HeadLines: The number of header lines in the text file to be skipped before starting to read function data.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
ValueType: This is either 1 or 2, indicating time value type.
1 = Frequency
2 = Period
        """

        all_args = [Name, FileName, HeadLines, DampRatio, ValueType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetFromFile(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFromFile" failed')
        
        return ret

    def SetIBC2003(self, Name = None, IBC2003SS = None, IBC2003S1 = None, DampRatio = None):
        """
This function defines a IBC2003 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function then that function is modified, otherwise, a new function is added.
IBC2003SS: The design spectral acceleration at short periods, Sds.
IBC2003S1: The design spectral acceleration at a one second period, Sd1.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, IBC2003SS, IBC2003S1, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetIBC2003(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetIBC2003" failed')
        
        return ret

    def SetIBC2006(self, Name = None, IBC2006Option = None, IBC2006Latitude = None, IBC2006Longitude = None, IBC2006ZipCode = None, IBC2006SS = None, IBC2006S1 = None, IBC2006TL = None, IBC2006SiteClass = None, IBC2006Fa = None, IBC2006Fv = None, DampRatio = None):
        """
This function defines a IBC2006 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function then that function is modified; otherwise, a new function is added.
IBC2006Option: This is 0, 1 or 2, indicating the seismic coefficient option.
0 = Ss and S1 from USGS by latitiude and longitude
1 = Ss and S1 from USGS by zip code
2 = Ss and S1 are user defined
IBC2006Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when IBC2006Option = 0.
IBC2006Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when IBC2006Option = 0.
IBC2006ZipCode: The zip code for which the seismic coefficients are obtained. This item is used only when IBC2006Option = 1.
IBC2006SS: The seismic coefficients Ss and S1. This item is used only when IBC2006Option = 2.
IBC2006S1: The seismic coefficients Ss and S1. This item is used only when IBC2006Option = 2.
IBC2006TL: The long-period transition period. [s]
IBC2006SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
IBC2006Fa: The site coefficients Fa and Fv. These items are used only when IBC2006SiteClass= 6.
IBC2006Fv: The site coefficients Fa and Fv. These items are used only when IBC2006SiteClass= 6.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, IBC2006Option, IBC2006Latitude, IBC2006Longitude, IBC2006ZipCode, IBC2006SS, IBC2006S1, IBC2006TL, IBC2006SiteClass, IBC2006Fa, IBC2006Fv, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetIBC2006(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetIBC2006" failed')
        
        return ret

    def SetIS18932002(self, Name = None, INZ = None, INS = None, DampRatio = None):
        """
This function defines a IS1893-2002 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
INZ: The seismic zone factor, Z.
INS: This is 1, 2 or 3, indicating the soil type.
1 = I
2 = II
3 = III
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, INZ, INS, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetIS18932002(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetIS18932002" failed')
        
        return ret

    def SetItalian3274(self, Name = None, Italag = None, ItalSoilType = None, Italq = None, ItalLevel = None, DampRatio = None):
        """
This function defines a Italian 3274 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
Italag: The peak ground acceleration.
ItalSoilType: This is 1, 2, 3, 4 or 5, indicating the seismic intensity.
1 = A
2 = B
3 = C
4 = E
5 = D
Italq: The structure factor.
ItalLevel: This is 0, 1, 2, 3, 4, 5, 6 or 7, indicating the spectral level, direction and building type.
0 = SLU/H/Building
1 = SLU/H/Bridge
2 = SLU/V/Building
3 = SLU/V/Bridge
4 = EL/H/Building
5 = EL/H/Bridge
6 = EL/V/Building
7 = EL/V/Bridge

SLU refers to ultimate strength design and EL refers to elastic design. H and V are horizontal and vertical, respectively.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, Italag, ItalSoilType, Italq, ItalLevel, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetItalian3274(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetItalian3274" failed')
        
        return ret

    def SetJTGB022013(self, Name = None, Direction = None, PeakAccel = None, Tg = None, Ci = None, Cs = None, DampRatio = None):
        """
This function defines a JTG B02-2013 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
Direction: This is 1, 2 or 3, indicating the response spectrum direction.
1 = Horizontal
2 = Vertical-Rock
3 = Vertical-Soil
PeakAccel: The peak acceleration, A.
Tg: The characteristic ground period, Tg > 0.1. [s]
Ci: The importance coefficient.
Cs: The site soil coefficient.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, Direction, PeakAccel, Tg, Ci, Cs, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetJTGB022013(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetJTGB022013" failed')
        
        return ret

    def SetJTGT2231012020(self, Name = None, PeakAccel = None, Tg = None, Ci = None, Cs = None, DampRatio = None):
        """
This function retrieves the definition of a JTGT2231012020 
 response spectrum function.
The function returns zero if the function definition 
 is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a JTGT2231012020 response spectrum function.
PeakAccel: The peak ground acceleration.
Tg: The characteristic ground period, Tg > 0.1 [s]
Ci: The importance coefficient.
Cs: The site soil coefficient.
DampRatio: The damping ratio for the function, 0 <= DampRatio 
 < 1.
        """

        all_args = [Name, PeakAccel, Tg, Ci, Cs, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetJTGT2231012020(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetJTGT2231012020" failed')
        
        return ret

    def SetNBCC2005(self, Name = None, NBCC2005PGA = None, NBCC2005S02 = None, NBCC2005S05 = None, NBCC2005S1 = None, NBCC2005S2 = None, NBCC2005SiteClass = None, NBCC2005Fa = None, NBCC2005Fv = None, DampRatio = None):
        """
This function defines a NBCC2005 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
NBCC2005PGA: The peak ground acceleration.
NBCC2005S02: The spectral acceleration at a 0.2 second period.
NBCC2005S05: The spectral acceleration at a 0.52 second period.
NBCC2005S1: The spectral acceleration at a 1 second period.
NBCC2005S2: The spectral acceleration at a 2 second period.
NBCC2005SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
NBCC2005Fa: The site coefficient, Fa. This item is read when the site class is F only.
NBCC2005Fv: The site coefficient, Fv. This item is read when the site class is F only.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NBCC2005PGA, NBCC2005S02, NBCC2005S05, NBCC2005S1, NBCC2005S2, NBCC2005SiteClass, NBCC2005Fa, NBCC2005Fv, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetNBCC2005(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNBCC2005" failed')
        
        return ret

    def SetNBCC2010(self, Name = None, PGA = None, S02 = None, S05 = None, S1 = None, S2 = None, SiteClass = None, Fa = None, Fv = None, DampRatio = None):
        """
This function defines a NBCC2010 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
PGA: The peak ground acceleration.
S02: The spectral acceleration at a 0.2 second period.
S05: The spectral acceleration at a 0.5 second period.
S1: The spectral acceleration at a 1 second period.
S2: The spectral acceleration at a 2 second period.
SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
Fa: The site coefficient, Fa. This item is read when the site class is F only.
Fv: The site coefficient, Fv. This item is read when the site class is F only.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, PGA, S02, S05, S1, S2, SiteClass, Fa, Fv, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetNBCC2010(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNBCC2010" failed')
        
        return ret

    def SetNBCC2015(self, Name = None, PGA = None, S02 = None, S05 = None, S1 = None, S2 = None, S5 = None, S10 = None, SiteClass = None, F02 = None, F05 = None, F1 = None, F2 = None, F5 = None, F10 = None, DampRatio = None):
        """
This function retrieves the definition of a NBCC2015 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
PGA: The peak ground acceleration.
S02: The spectral acceleration at a 0.2 second period.
S05: The spectral acceleration at a 0.5 second period.
S1: The spectral acceleration at a 1 second period.
S2: The spectral acceleration at a 2 second period.
S5: The spectral acceleration at a 5 second period.
S10: The spectral acceleration at a 10 second period.
SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
F02: The site coefficient at a 0.2 second period. This item is read when the site class is F only.
F05: The site coefficientat a 0.5 second period. This item is read when the site class is F only.
F1: The site coefficient at a 1 second period. This item is read when the site class is F only.
F2: The site coefficient at a 2 second period. This item is read when the site class is F only.
F5: The site coefficient at a 5 second period. This item is read when the site class is F only.
F10: The site coefficient at a 10 second period. This item is read when the site class is F only.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, PGA, S02, S05, S1, S2, S5, S10, SiteClass, F02, F05, F1, F2, F5, F10, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetNBCC2015(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNBCC2015" failed')
        
        return ret

    def SetNBCC95(self, Name = None, NBCC95ZVR = None, NBCC95ZA = None, NBCC95ZV = None, DampRatio = None):
        """
This function defines a NBCC95 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function then that function is modified; otherwise, a new function is added.
NBCC95ZVR: The zonal velocity ratio.
NBCC95ZA: The acceleration-related seismic zone.
NBCC95ZV: The velocity-related seismic zone.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NBCC95ZVR, NBCC95ZA, NBCC95ZV, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetNBCC95(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNBCC95" failed')
        
        return ret

    def SetNCHRP2007(self, Name = None, NCHRP2007Option = None, NCHRP2007Latitude = None, NCHRP2007Longitude = None, NCHRP2007ZipCode = None, NCHRP2007SS = None, NCHRP2007S1 = None, NCHRP2007SiteClass = None, NCHRP2007Fa = None, NCHRP2007Fv = None, DampRatio = None):
        """
This function defines a NCHRP 20-07 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
NCHRP2007Option: This is 0, 1 or 2, indicating the seismic coefficient option.
0 = Ss and S1 from USGS by latitiude and longitude
1 = Ss and S1 from USGS by zip code
2 = Ss and S1 are user defined
NCHRP2007Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when NCHRP2007Option = 0.
NCHRP2007Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when NCHRP2007Option = 0.
NCHRP2007ZipCode: The zip code for which the seismic coefficients are obtained. This item is used only when NCHRP2007Option = 1.
NCHRP2007SS: The seismic coefficients Ss and S1. This item is used only when NCHRP2007Option = 2.
NCHRP2007S1: The seismic coefficients Ss and S1. This item is used only when NCHRP2007Option = 2.
NCHRP2007SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
NCHRP2007Fa: The site coefficients Fa and Fv. These items are used only when NCHRP2007SiteClass= 6.
NCHRP2007Fv: The site coefficients Fa and Fv. These items are used only when NCHRP2007SiteClass= 6.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NCHRP2007Option, NCHRP2007Latitude, NCHRP2007Longitude, NCHRP2007ZipCode, NCHRP2007SS, NCHRP2007S1, NCHRP2007SiteClass, NCHRP2007Fa, NCHRP2007Fv, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetNCHRP2007(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNCHRP2007" failed')
        
        return ret

    def SetNEHRP97(self, Name = None, NEHRP97SS = None, NEHRP97S1 = None, DampRatio = None):
        """
This function defines a NEHRP97 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function then that function is modified; otherwise, a new function is added.
NEHRP97SS: The design spectral acceleration at short periods, Sds.
NEHRP97S1: The design spectral acceleration at a one second period, Sd1.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NEHRP97SS, NEHRP97S1, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetNEHRP97(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNEHRP97" failed')
        
        return ret

    def SetNTC2008(self, Name = None, ParamsOption = None, Latitude = None, Longitude = None, Island = None, LimitState = None, UsageClass = None, NomLife = None, PeakAccel = None, F0 = None, Tcs = None, SpecType = None, SoilType = None, Topography = None, hRatio = None, Damping = None, q = None):
        """
This function defines a NTC2008 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
ParamsOption: This is 1, 2, or 3, indicating the option for defining the parameters.
1 = by latitude and longitude
2 = by island
3 = user specified
Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Island: This is one of the following values. This item is used only when ParamsOption = 2.
1 = Alicudi2 = Arcipelago Toscano3 = Filcudi4 = Isole Egadi5 = Lampedusa6 = Linosa7 = Lipari8 = Palmarola9 = Panarea10 = Pantelleria11 = Ponza12 = Salina13 = Santo Stefano14 = Sardegna15 = Stromboli16 = Tremiti17 = Ustica18 = Ventotene19 = Vulcano20 = Zannone
LimitState: This is 1, 2, 3, or 4, indicating the limit state.
1 = SLO
2 = SLD
3 = SLV
4 = SLC
UsageClass: This is 1, 2, 3, or 4, indicating the usage class.
1 = I
2 = II
3 = III
4 = IV
NomLife: The nominal life to be considered.
PeakAccel: The peak ground acceleration, ag/g.
F0: The magnitude factor, F0.
Tcs: The reference period, Tc* [s].
SpecType: This is 1, 2, 3, or 4, indicating the type of spectrum to consider.
1 = Elastic horizontal
2 = Elastic vertical
3 = Design horizontal
4 = Design vertical
SoilType: This is 1, 2, 3, 4, or 5, indicating the subsoil type.
1 = A
2 = B
3 = C
4 = D
5 = E

Topography: This is 1, 2, 3, or 4, indicating the topography type.
1 = T1
2 = T2
3 = T3
4 = T4
hRatio: The ratio for the site altitude at the base of the hill to the height of the hill.
Damping: The damping, in percent. This is only applicable for SpecType 1 and 2.
q: The behavior correction factor. This is only applicable for SpecType 3 and 4.
        """

        all_args = [Name, ParamsOption, Latitude, Longitude, Island, LimitState, UsageClass, NomLife, PeakAccel, F0, Tcs, SpecType, SoilType, Topography, hRatio, Damping, q]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetNTC2008(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNTC2008" failed')
        
        return ret

    def SetNTC2018(self, Name = None, ParamsOption = None, Latitude = None, Longitude = None, Island = None, LimitState = None, UsageClass = None, NomLife = None, PeakAccel = None, F0 = None, Tcs = None, SpecType = None, SoilType = None, Topography = None, hRatio = None, Damping = None, q = None):
        """
This function defines a NTC2018 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
ParamsOption: This is 1, 2, or 3, indicating the option for defining the parameters.
1 = by latitude and longitude
2 = by island
3 = user specified
Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Island: This is one of the following values. This item is used only when ParamsOption = 2.
1 = Alicudi2 = Arcipelago Toscano3 = Filcudi4 = Isole Egadi5 = Lampedusa6 = Linosa7 = Lipari8 = Palmarola9 = Panarea10 = Pantelleria11 = Ponza12 = Salina13 = Santo Stefano14 = Sardegna15 = Stromboli16 = Tremiti17 = Ustica18 = Ventotene19 = Vulcano20 = Zannone
LimitState: This is 1, 2, 3, or 4, indicating the limit state.
1 = SLO
2 = SLD
3 = SLV
4 = SLC
UsageClass: This is 1, 2, 3, or 4, indicating the usage class.
1 = I
2 = II
3 = III
4 = IV
NomLife: The nominal life to be considered.
PeakAccel: The peak ground acceleration, ag/g.
F0: The magnitude factor, F0.
Tcs: The reference period, Tc* [s].
SpecType: This is 1, 2, 3, or 4, indicating the type of spectrum to consider.
1 = Elastic horizontal
2 = Elastic vertical
3 = Design horizontal
4 = Design vertical
SoilType: This is 1, 2, 3, 4, or 5, indicating the subsoil type.
1 = A
2 = B
3 = C
4 = D
5 = E

Topography: This is 1, 2, 3, or 4, indicating the topography type.
1 = T1
2 = T2
3 = T3
4 = T4
hRatio: The ratio for the site altitude at the base of the hill to the height of the hill.
Damping: The damping, in percent. This is only applicable for SpecType 1 and 2.
q: The behavior correction factor. This is only applicable for SpecType 3 and 4.
        """

        all_args = [Name, ParamsOption, Latitude, Longitude, Island, LimitState, UsageClass, NomLife, PeakAccel, F0, Tcs, SpecType, SoilType, Topography, hRatio, Damping, q]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetNTC2018(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNTC2018" failed')
        
        return ret

    def SetNZS11702004_1(self, Name = None, NZS2004SpectrumType = None, NZS2004SiteClass = None, NZS2004Z = None, NZS2004R = None, NZS2004DIST = None, NZS2004ConsiderTSite = None, NZS2004TSite = None, DampRatio = None):
        """
This function defines an NZS 1170.5 2004 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
NZS2004SpectrumType: This is 1 or 2, indicating the spectrum type.
1 = Horizontal
2 = Vertical

NZS2004SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
NZS2004Z: The hazard factor, Z.
NZS2004R: The return period factor, R.
NZS2004DIST: Distance to the fault in kim, used to calculate the near fault factor.
NZS2004ConsiderTSite: Indicates whether to consider the site period for the spectral shape factor.
NZS2004TSite: The low amplitude site period.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NZS2004SpectrumType, NZS2004SiteClass, NZS2004Z, NZS2004R, NZS2004DIST, NZS2004ConsiderTSite, NZS2004TSite, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetNZS11702004_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNZS11702004_1" failed')
        
        return ret

    def SetNZS42031992(self, Name = None, NZS4203SF = None, NZS4203S = None, DampRatio = None):
        """
This function defines a NZS4203-1992 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
NZS4203SF: The scaling factor (Sm * Sp * R * Z * L).
NZS4203S: This is 1, 2 or 3, indicating the site subsoil category.
1 = A
2 = B
3 = C
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NZS4203SF, NZS4203S, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetNZS42031992(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNZS42031992" failed')
        
        return ret

    def SetSP14133302014(self, Name = None, Direction = None, Seismicity = None, SoilCat = None, K0Factor = None, K1Factor = None, KPsiFactor = None, NonlinSoil = None, ASoil = None, DampRatio = None):
        """
This function retrieves the definition of a SP 14.13330.2014 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
Direction: This is 1, 2, 3, or 4, indicating the direction and structure type for which the response spectrum is generated.
1 = Building Horizontal
2 = Building Vertical
3 = Bridge Horizontal
4 = Bridge Vertical

Seismicity: This is 1, 2, 3, or 4, indicating the region seismicity of the construction site.
1 = 6
2 = 7
3 = 8
4 = 9

SoilCat: This is 1, 2, 3, or 4, indicating the soil category.
1 = I
2 = II
3 = III
4 = IV

K0Factor: The K0Factor, 0 < K0 <= 2.0. This is only applicable when the Direction parameter is 1 or 3 for horizontal spectra.
K1Factor: The K1Factor, 0 < K1 <= 1.0.
KPsiFactor: The KPsiFactor, 0.5 < KPsi <= 1.5. This is only applicable when the Direction parameter is 1 or 3 for horizontal spectra.
NonlinSoil: This item is True if nonlinear soil deformation should be accounted for. This is only applicable when the Direction parameter is 1 or 2 for buildings and the SoilCat parameter is 3 or 4.
ASoil: The nonlinear soil deformation factor, 0 > a_soil <= 1.0. This is only applicable when the NonlinSoil parameter is True, the Direction parameter is 1 or 2 buildings, and the SoilCat parameter is 3 or 4. 
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, Direction, Seismicity, SoilCat, K0Factor, K1Factor, KPsiFactor, NonlinSoil, ASoil, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetSP14133302014(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSP14133302014" failed')
        
        return ret

    def SetUBC94(self, Name = None, UBC94Z = None, UBC94S = None, DampRatio = None):
        """
This function defines a UBC94 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
UBC94Z: The seismic zone factor, Z.
UBC94S: This is 1, 2 or 3, indicating the soil type.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, UBC94Z, UBC94S, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetUBC94(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUBC94" failed')
        
        return ret

    def SetUBC97(self, Name = None, UBC97Ca = None, UBC97Cv = None, DampRatio = None):
        """
This function defines a UBC97 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
UBC97Ca: The seismic coefficient, Ca.
UBC97Cv: The seismic coefficient, Cv.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, UBC97Ca, UBC97Cv, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetUBC97(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUBC97" failed')
        
        return ret

    def SetUser(self, Name = None, NumberItems = None, Period = None, Value = None, DampRatio = None):
        """
This function defines a user response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
NumberItems: The number of period and value pairs defined.
Period: This is an array that includes the period for each data point. [s]
Value: This is an array that includes the function value for each data point.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NumberItems, Period, Value, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetUser(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUser" failed')
        
        return ret

    def GetChinese2002(self, Name = None, JGJ32002AlphaMax = None, JGJ32002SI = None, JGJ32002Tg = None, JGJ32002PTDF = None, DampRatio = None):
        """
This function retrieves the definition of a Chinese 2002 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a Chinese 2002 response spectrum function.
JGJ32002AlphaMax: The maximum influence factor.
JGJ32002SI: This is 1, 2, 3, 4, 5 or 6, indicating the seismic intensity.
1 = 6 (0.05g)
2 = 7 (0.10g)
3 = 7 (0.15g)
4 = 8 (0.20g)
5 = 8 (0.30g)
6 = 9 (0.40g)
JGJ32002Tg: The characteristic ground period, Tg > 0.1. [s]
JGJ32002PTDF: The period time discount factor.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, JGJ32002AlphaMax, JGJ32002SI, JGJ32002Tg, JGJ32002PTDF, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetChinese2002(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetChinese2002" failed')
        
        return ret

    def GetEurocode82004(self, Name = None, EURO2004GroundType = None, EURO2004SpectrumType = None, EURO2004ag = None, EURO2004Beta = None, EURO2004q = None, DampRatio = None):
        """
This function retrieves the definition of a Eurocode 8 2004 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a Eurocode 8 2004 response spectrum function.
EURO2004GroundType: This is 1, 2, 3, 4 or 5, indicating the ground type.
1 = A
2 = B
3 = C
4 = D
5 = E
EURO2004SpectrumType: This is 1 or 2, indicating the spectrum type.
1 = Type 1
2 = Type 2
EURO2004ag: The design ground acceleration in g, ag.
EURO2004Beta: The lower bound factor, Beta.
EURO2004q: The behavior factor, q.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, EURO2004GroundType, EURO2004SpectrumType, EURO2004ag, EURO2004Beta, EURO2004q, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetEurocode82004(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEurocode82004" failed')
        
        return ret

    def GetNZS11702004(self, Name = None, NZS2004SiteClass = None, NZS2004Z = None, NZS2004R = None, NZS2004DIST = None, DampRatio = None):
        """
This function retrieves the definition of an NZS 1170 2004 response spectrum function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a NZS 1170 2004 response spectrum function.
NZS2004SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
NZS2004Z: The hazard factor, Z.
NZS2004R: The return period factor, R.
NZS2004DIST: Distance to the fault in km, used to calculate the near fault factor.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NZS2004SiteClass, NZS2004Z, NZS2004R, NZS2004DIST, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.GetNZS11702004(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNZS11702004" failed')
        
        return ret

    def SetChinese2002(self, Name = None, JGJ32002AlphaMax = None, JGJ32002SI = None, JGJ32002Tg = None, JGJ32002PTDF = None, DampRatio = None):
        """
This function defines a Chinese 2002 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
JGJ32002AlphaMax: The maximum influence factor.
JGJ32002SI: This is 1, 2, 3, 4, 5 or 6, indicating the seismic intensity.
1 = 6 (0.05g)
2 = 7 (0.10g)
3 = 7 (0.15g)
4 = 8 (0.20g)
5 = 8 (0.30g)
6 = 9 (0.40g)
JGJ32002Tg: The characteristic ground period, Tg > 0.1. [s]
JGJ32002PTDF: The period time discount factor.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, JGJ32002AlphaMax, JGJ32002SI, JGJ32002Tg, JGJ32002PTDF, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetChinese2002(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetChinese2002" failed')
        
        return ret

    def SetEurocode82004(self, Name = None, EURO2004GroundType = None, EURO2004SpectrumType = None, EURO2004ag = None, EURO2004Beta = None, EURO2004q = None, DampRatio = None):
        """
This function defines a Eurocode 8 2004 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function,n that function is modified; otherwise, a new function is added.
EURO2004GroundType: This is 1, 2, 3, 4 or 5, indicating the ground type.
1 = A
2 = B
3 = C
4 = D
5 = E
EURO2004SpectrumType: This is 1 or 2, indicating the spectrum type.
1 = Type 1
2 = Type 2
EURO2004ag: The design ground acceleration in g, ag.
EURO2004Beta: The lower bound factor, Beta.
EURO2004q: The behavior factor, q.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, EURO2004GroundType, EURO2004SpectrumType, EURO2004ag, EURO2004Beta, EURO2004q, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetEurocode82004(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEurocode82004" failed')
        
        return ret

    def SetNZS11702004(self, Name = None, NZS2004SiteClass = None, NZS2004Z = None, NZS2004R = None, NZS2004DIST = None, DampRatio = None):
        """
This function defines an NZS 1170.5 2004 response spectrum function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
NZS2004SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
NZS2004Z: The hazard factor, Z.
NZS2004R: The return period factor, R.
NZS2004DIST: Distance to the fault in kim, used to calculate the near fault factor.
DampRatio: The damping ratio for the function, 0 <= DampRatio < 1.
        """

        all_args = [Name, NZS2004SiteClass, NZS2004Z, NZS2004R, NZS2004DIST, DampRatio]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncRS.SetNZS11702004(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNZS11702004" failed')
        
        return ret

class FuncSS:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetFromFile(self, Name = None, FileName = None, HeadLines = None, PreChars = None, PointsPerLine = None, ValueType = None, FreeFormat = None, NumberFixed = None, FreqTypeInFile = None):
        """
This function retrieves the definition of a steady state function from file.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined steady state function specified to be from a text file.
FileName: The full path of the text file containing the function data.
HeadLines: The number of header lines in the text file to be skipped before starting to read function data.
PreChars: The number of prefix characters to be skipped on each line in the text file.
PointsPerLine: The number of function points included on each text file line.
ValueType: This is either 1 or 2, indicating value type.
1 = Values at equal time intervals
2 = Time and function values
FreeFormat: This item is True if the data is provided in a free format. It is False if it is in a fixed format.
NumberFixed: This item only applies when the FreeFormat item is False. It is the number of characters per item.
FreqTypeInFile: This is either 1 or 2, indicating frequency type.
1 = Hz
2 = RPM
        """

        all_args = [Name, FileName, HeadLines, PreChars, PointsPerLine, ValueType, FreeFormat, NumberFixed, FreqTypeInFile]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncSS.GetFromFile(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetFromFile" failed')
        
        return ret

    def GetUser(self, Name = None, NumberItems = None, Frequency = None, Value = None):
        """
This function retrieves the definition of a user defined steady state function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a user defined steady state function.
NumberItems: The number of frequency and value pairs defined.
Frequency: This is an array that includes the frequency in Hz for each data point. [cyc/s]
Value: This is an array that includes the function value for each data point.
        """

        all_args = [Name, NumberItems, Frequency, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncSS.GetUser(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUser" failed')
        
        return ret

    def SetFromFile(self, Name = None, FileName = None, HeadLines = None, PreChars = None, PointsPerLine = None, ValueType = None, FreeFormat = None, NumberFixed = None, FreqTypeInFile = None):
        """
This function defines a steady state function from file.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
FileName: The full path of the text file containing the function data.
HeadLines: The number of header lines in the text file to be skipped before starting to read function data.
PreChars: The number of prefix characters to be skipped on each line in the text file.
PointsPerLine: The number of function points included on each text file line.
ValueType: This is either 1 or 2, indicating value type.
1 = Values at equal time intervals
2 = Time and function values
FreeFormat: This item is True if the data is provided in a free format. It is False if it is in a fixed format.
NumberFixed: This item only applies when the FreeFormat item is False. It is the number of characters per item.
FreqTypeInFile: This is either 1 or 2, indicating frequency type.
1 = Hz
2 = RPM
        """

        all_args = [Name, FileName, HeadLines, PreChars, PointsPerLine, ValueType, FreeFormat, NumberFixed, FreqTypeInFile]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncSS.SetFromFile(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFromFile" failed')
        
        return ret

    def SetUser(self, Name = None, NumberItems = None, Frequency = None, Value = None):
        """
This function defines a user steady state function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
NumberItems: The number of frequency and value pairs defined.
Frequency: This is an array that includes the frequency in Hz for each data point. [cyc/s]
Value: This is an array that includes the function value for each data point.
        """

        all_args = [Name, NumberItems, Frequency, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncSS.SetUser(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUser" failed')
        
        return ret

class FuncTH:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetCosine(self, Name = None, CosineP = None, CosineSteps = None, CosineCycles = None, CosineAmp = None):
        """
This function retrieves the definition of a cosine-type time history function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a cosine-type time history function.
CosineP: The period of the cosine function. [s]
CosineSteps: The number of steps in the cosine function. This item can not be less than 8.
CosineCycles: The number of cycles in the cosine function.
CosineAmp: The amplitude of the cosine function.
        """

        all_args = [Name, CosineP, CosineSteps, CosineCycles, CosineAmp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.GetCosine(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCosine" failed')
        
        return ret

    def GetFromFile_1(self, Name = None, FileName = None, HeadLines = None, PreChars = None, PointsPerLine = None, ValueType = None, FreeFormat = None, NumberFixed = None, DT = None):
        """
This function retrieves the definition of a time history function from file.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined time history function specified to be from a text file.
FileName: The full path of the text file containing the function data.
HeadLines: The number of header lines in the text file to be skipped before starting to read function data.
PreChars: The number of prefix characters to be skipped on each line in the text file.
PointsPerLine: The number of function points included on each text file line.
ValueType: This is 1 or 2, indicating value type.
1 = Values at equal time intervals
2 = Time and function values
FreeFormat: This item is True if the data is provided in a free format. It is False if it is in a fixed format.
NumberFixed: This item applies only when the FreeFormat item is False. It is the number of characters per item.
DT: This item applies only when the ValueType item is 1 (equal time intervals). It is the time interval between function points.
        """

        all_args = [Name, FileName, HeadLines, PreChars, PointsPerLine, ValueType, FreeFormat, NumberFixed, DT]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.GetFromFile_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetFromFile_1" failed')
        
        return ret

    def GetRamp(self, Name = None, RampTime = None, RampAmp = None, RampMaxTime = None):
        """
This function retrieves the definition of a ramp-type time history function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a ramp-type time history function.
RampTime: The time it takes for the ramp function to initially reach its maximum value. [s]
RampAmp: The maximum amplitude of the ramp function.
RampMaxTime: The time at the end of the ramp function. This time must be greater than the RampTime. [s]
        """

        all_args = [Name, RampTime, RampAmp, RampMaxTime]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.GetRamp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetRamp" failed')
        
        return ret

    def GetSawtooth(self, Name = None, SawP = None, SawTime = None, SawCycles = None, SawAmp = None):
        """
This function retrieves the definition of a sawtooth-type time history function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a sawtooth-type time history function.
SawP: The period of the sawtooth function. [s]
SawTime: The time it takes for the sawtooth function to ramp up from a function value of zero to its maximum amplitude. [s]
SawCycles: The number of cycles in the function.
SawAmp: The maximum amplitude of the sawtooth function.
        """

        all_args = [Name, SawP, SawTime, SawCycles, SawAmp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.GetSawtooth(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSawtooth" failed')
        
        return ret

    def GetSine(self, Name = None, SineP = None, SineSteps = None, SineCycles = None, SineAmp = None):
        """
This function retrieves the definition of a sine-type time history function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a sine-type time history function.
SineP: The period of the sine function. [s]
SineSteps: The number of steps in the sine function. This item can not be less than 8.
SineCycles: The number of cycles in the sine function.
SineAmp: The amplitude of the sine function.
        """

        all_args = [Name, SineP, SineSteps, SineCycles, SineAmp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.GetSine(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSine" failed')
        
        return ret

    def GetTriangular(self, Name = None, TriP = None, TriCycles = None, TriAmp = None):
        """
This function retrieves the definition of a triangular-type time history function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a triangular-type time history function.
TriP: The period of the triangular function. [s]
TriCycles: The number of cycles in the function.
TriAmp: The maximum amplitude of the triangular function.
        """

        all_args = [Name, TriP, TriCycles, TriAmp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.GetTriangular(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTriangular" failed')
        
        return ret

    def GetUserPeriodic(self, Name = None, UPCycles = None, NumberItems = None, MyTime = None, Value = None):
        """
This function retrieves the definition of a user periodic time history function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a user periodic time history function.
UPCycles: The number of cycles in the function.
NumberItems: The number of frequency and value pairs defined.
MyTime: This is an array that includes the time for each data point. [s]
Value: This is an array that includes the function value for each data point.
        """

        all_args = [Name, UPCycles, NumberItems, MyTime, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.GetUserPeriodic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUserPeriodic" failed')
        
        return ret

    def GetUser(self, Name = None, NumberItems = None, MyTime = None, Value = None):
        """
This function retrieves the definition of a user defined time history function.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a user defined time history function.
NumberItems: The number of frequency and value pairs defined.
MyTime: This is an array that includes the time for each data point. [s]
Value: This is an array that includes the function value for each data point.
        """

        all_args = [Name, NumberItems, MyTime, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.GetUser(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUser" failed')
        
        return ret

    def SetCosine(self, Name = None, CosineP = None, CosineSteps = None, CosineCycles = None, CosineAmp = None):
        """
This function defines a cosine-type time history function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
CosineP: The period of the cosine function. [s]
CosineSteps: The number of steps in the cosine function. This item can not be less than 8.
CosineCycles: The number of cycles in the cosine function.
CosineAmp: The amplitude of the cosine function.
        """

        all_args = [Name, CosineP, CosineSteps, CosineCycles, CosineAmp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.SetCosine(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCosine" failed')
        
        return ret

    def SetFromFile_1(self, Name = None, FileName = None, HeadLines = None, PreChars = None, PointsPerLine = None, ValueType = None, FreeFormat = None, NumberFixed = None, DT = None):
        """
This function defines a time history function from file.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
FileName: The full path of the text file containing the function data.
HeadLines: The number of header lines in the text file to be skipped before starting to read function data.
PreChars: The number of prefix characters to be skipped on each line in the text file.
PointsPerLine: The number of function points included on each text file line.
ValueType: This is 1 or 2, indicating value type.
1 = Values at equal time intervals
2 = Time and function values
FreeFormat: This item is True if the data is provided in a free format. It is False if it is in a fixed format.
NumberFixed: This item applies only when the FreeFormat item is False. It is the number of characters per item.
DT: This item applies only when the ValueType item is 1 (equal time intervals). It is the time interval between function points.
        """

        all_args = [Name, FileName, HeadLines, PreChars, PointsPerLine, ValueType, FreeFormat, NumberFixed, DT]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.SetFromFile_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFromFile_1" failed')
        
        return ret

    def SetRamp(self, Name = None, RampTime = None, RampAmp = None, RampMaxTime = None):
        """
This function defines a ramp-type time history function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
RampTime: The time it takes for the ramp function to initially reach its maximum value. [s]
RampAmp: The maximum amplitude of the ramp function.
RampMaxTime: The time at the end of the ramp function. This time must be greater than the RampTime. [s]
        """

        all_args = [Name, RampTime, RampAmp, RampMaxTime]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.SetRamp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetRamp" failed')
        
        return ret

    def SetSawtooth(self, Name = None, SawP = None, SawTime = None, SawCycles = None, SawAmp = None):
        """
This function defines a sawtooth-type time history function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
SawP: The period of the sawtooth function. [s]
SawTime: The time it takes for the sawtooth function to ramp up from a function value of zero to its maximum amplitude. [s]
SawCycles: The number of cycles in the function.
SawAmp: The maximum amplitude of the sawtooth function.
        """

        all_args = [Name, SawP, SawTime, SawCycles, SawAmp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.SetSawtooth(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSawtooth" failed')
        
        return ret

    def SetSine(self, Name = None, SineP = None, SineSteps = None, SineCycles = None, SineAmp = None):
        """
This function defines a sine-type time history function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
SineP: The period of the sine function. [s]
SineSteps: The number of steps in the sine function. This item can not be less than 8.
SineCycles: The number of cycles in the sine function.
SineAmp: The amplitude of the sine function.
        """

        all_args = [Name, SineP, SineSteps, SineCycles, SineAmp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.SetSine(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSine" failed')
        
        return ret

    def SetTriangular(self, Name = None, TriP = None, TriCycles = None, TriAmp = None):
        """
This function defines a triangular-type time history function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
TriP: The period of the triangular function. [s]
TriCycles: The number of cycles in the function.
TriAmp: The maximum amplitude of the triangular function.
        """

        all_args = [Name, TriP, TriCycles, TriAmp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.SetTriangular(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTriangular" failed')
        
        return ret

    def SetUserPeriodic(self, Name = None, UPCycles = None, NumberItems = None, MyTime = None, Value = None):
        """
This function defines a user periodic time history function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
UPCycles: The number of cycles in the function.
NumberItems: The number of time and value pairs defined.
MyTime: This is an array that includes the time for each data point. [s]
Value: This is an array that includes the function value for each data point.
        """

        all_args = [Name, UPCycles, NumberItems, MyTime, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.SetUserPeriodic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUserPeriodic" failed')
        
        return ret

    def SetUser(self, Name = None, NumberItems = None, MyTime = None, Value = None):
        """
This function defines a user time history function.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
NumberItems: The number of time and value pairs defined.
MyTime: This is an array that includes the time for each data point. [s]
Value: This is an array that includes the function value for each data point.
        """

        all_args = [Name, NumberItems, MyTime, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.SetUser(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUser" failed')
        
        return ret

    def GetFromFile(self, Name = None, FileName = None, HeadLines = None, PreChars = None, PointsPerLine = None, ValueType = None, FreeFormat = None, NumberFixed = None):
        """
This function retrieves the definition of a time history function from file.
The function returns zero if the function definition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined time history function specified to be from a text file.
FileName: The full path of the text file containing the function data.
HeadLines: The number of header lines in the text file to be skipped before starting to read function data.
PreChars: The number of prefix characters to be skipped on each line in the text file.
PointsPerLine: The number of function points included on each text file line.
ValueType: This is either 1 or 2, indicating value type.
1 = Values at equal time intervals
2 = Time and function values
FreeFormat: This item is True if the data is provided in a free format. It is False if it is in a fixed format.
NumberFixed: This item applies only when the FreeFormat item is False. It is the number of characters per item.
        """

        all_args = [Name, FileName, HeadLines, PreChars, PointsPerLine, ValueType, FreeFormat, NumberFixed]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.GetFromFile(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetFromFile" failed')
        
        return ret

    def SetFromFile(self, Name = None, FileName = None, HeadLines = None, PreChars = None, PointsPerLine = None, ValueType = None, FreeFormat = None, NumberFixed = None):
        """
This function defines a time history function from file.
The function returns zero if the function is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new function. If this is an existing function, that function is modified; otherwise, a new function is added.
FileName: The full path of the text file containing the function data.
HeadLines: The number of header lines in the text file to be skipped before starting to read function data.
PreChars: The number of prefix characters to be skipped on each line in the text file.
PointsPerLine: The number of function points included on each text file line.
ValueType: This is either 1 or 2, indicating value type.
1 = Values at equal time intervals
2 = Time and function values
FreeFormat: This item is True if the data is provided in a free format. It is False if it is in a fixed format.
NumberFixed: This item applies only when the FreeFormat item is False. It is the number of characters per item.
        """

        all_args = [Name, FileName, HeadLines, PreChars, PointsPerLine, ValueType, FreeFormat, NumberFixed]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Func.FuncTH.SetFromFile(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFromFile" failed')
        
        return ret

class GDispl:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def Add(self, Name = None, MyType = None):
        """
This function adds a new generalized displacement with the specified name and type.
The function returns zero if the generalized displacement is successfully added, otherwise it returns a nonzero value.
The new generalized displacement must have a different name from all other generalized displacements. If the name is not unique, an error will be returned.

Name: The name of a new generalized displacement.
MyType: This is 1 or 2 indicating the generalized displacement type.
1 = Translational
2 = Rotational
        """

        all_args = [Name, MyType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GDispl.Add(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Add" failed')
        
        return ret

    def ChangeName(self, Name = None, NewName = None):
        """
The function returns zero if the new name is successfully applied, otherwise it returns a nonzero value.
The new generalized displacement name must be different from all other generalized displacement names. If the name is not unique, an error will be returned.

Name: The existing name of a defined generalized displacement.
NewName: The new name for the generalized displacement.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GDispl.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def CountPoint(self, Name = None, Count = None):
        """
This function retrieves the total number of point objects included in a specified generalized displacement.
The function returns zero if the count is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing generalized displacement.
Count: The number of point objects included in the specified generalized displacement.
        """

        all_args = [Name, Count]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GDispl.CountPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountPoint" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of generalized displacements defined in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GDispl.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def DeletePoint(self, Name = None, PointName = None):
        """
This function deletes one point object from a generalized displacement definition.
The function returns zero if the point is successfully deleted from the generalized displacement definition, otherwise it returns a nonzero value.

Name: The name of an existing generalized displacement.
PointName: The name of a point object included in the generalized displacement that is to be deleted.
        """

        all_args = [Name, PointName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GDispl.DeletePoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeletePoint" failed')
        
        return ret

    def Delete(self, Name = None):
        """
This function deletes the specified generalized displacement.
The function returns zero if the generalized displacement is successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing generalized displacement.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GDispl.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined generalized displacements.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of generalized displacement names retrieved by the program.
MyName: This is a one-dimensional array of generalized displacement names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GDispl.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetPoint(self, Name = None, NumberItems = None, PointName = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None):
        """
This function retrieves the point objects and their scale factors from a generalized displacement definition.
The function returns zero if the data is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing generalized displacement.
NumberItems: The number of point objects included in the generalized displacement definition.
PointName: This is an array that includes the name of the point objects included in the generalized displacement definition.
U1: These are arrays that include the unitless scale factors for each of the displacement degrees of freedom of the associated point objects that are included in the generalized displacement definition.
U2: These are arrays that include the unitless scale factors for each of the displacement degrees of freedom of the associated point objects that are included in the generalized displacement definition.
U3: These are arrays that include the unitless scale factors for each of the displacement degrees of freedom of the associated point objects that are included in the generalized displacement definition.
R1: These are arrays that include the unitless scale factors for each of the displacement degrees of freedom of the associated point objects that are included in the generalized displacement definition.
R2: These are arrays that include the unitless scale factors for each of the displacement degrees of freedom of the associated point objects that are included in the generalized displacement definition.
R3: These are arrays that include the unitless scale factors for each of the displacement degrees of freedom of the associated point objects that are included in the generalized displacement definition.
        """

        all_args = [Name, NumberItems, PointName, U1, U2, U3, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GDispl.GetPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPoint" failed')
        
        return ret

    def GetTypeOAPI(self, Name = None, MyType = None):
        """
This function retrieves the generalized displacement type.
The function returns zero if the type is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing generalized displacement.
MyType: This is 1 or 2, indicating the generalized displacement type.
1 = Translational
2 = Rotational
        """

        all_args = [Name, MyType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GDispl.GetTypeOAPI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTypeOAPI" failed')
        
        return ret

    def SetPoint(self, Name = None, PointName = None, SF = None):
        """
This function adds a point object and its scale factors to a generalized displacement definition, or, if the point object already exists in the generalized displacement definition, it modifies the scale factors.
The function returns zero if the data is successfully added or modified, otherwise it returns a nonzero value.

Name: The name of an existing generalized displacement.
PointName: The name of a point object to be included in the generalized displacement definition.
SF: This is an array of six unitless scale factors for the point object displacement degrees of freedom.
SF(0) = U1 scale factor
SF(1) = U2 scale factor
SF(2) = U3 scale factor
SF(3) = R1 scale factor
SF(4) = R2 scale factor
SF(5) = R3 scale factor
        """

        all_args = [Name, PointName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GDispl.SetPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPoint" failed')
        
        return ret

    def SetTypeOAPI(self, Name = None, MyType = None):
        """
This function sets the generalized displacement type.
The function returns zero if the type is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing generalized displacement.
MyType: This is 1 or 2, indicating the generalized displacement type.
1 = Translational
2 = Rotational
        """

        all_args = [Name, MyType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GDispl.SetTypeOAPI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTypeOAPI" failed')
        
        return ret

class GenRefLine:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ConvertLineToBLL(self):
        """
This function converts an existing general reference line to a new bridge layout line, with the ability to specify offset values.
The function returns zero if the bridge layout line is successfully created; otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GenRefLine.ConvertLineToBLL(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ConvertLineToBLL" failed')
        
        return ret

    def Count(self):
        """
The function returns the number of defined general reference lines.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GenRefLine.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes the specified general reference line.
The function returns zero if the general reference line is successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing general reference line.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GenRefLine.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetLineElevPoints(self, Name = None, NumberPoints = None, CurveType = None, Value1 = None, Value3 = None, s = None, z = None):
        """
This function retrieves the general reference line elevation points and the associated parameters.
The function returns zero if the general reference line parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing general reference line.
NumberPoints: The number of points used to define the general reference line elevation layout.
CurveType: This is an array of values indicating the general reference line elevation layout curve type for each point.
0 = None
1 = Circular Curve
2 = Highway Curve
3 = Parabolic Curve
4 = Bezier Curve
5 = BSpline Curve
6 = Bezier Curve Child Point
7 = BSpline Curve Child Point
Value1: This is the value of a parameter used to define the general reference line layout. The item that Value1 represents depends on the CurveType item.
CurveType = 0: Not Used
CurveType = 1: Curve Radius [L]
CurveType = 2: Curve Radius [L]
CurveType = 3: Angle measured from the horizontal, up station axis, to the axis of symmetry of the parabolic curve. [deg]
CurveType = 4: Number of control points. This is currently hard-wired internally to 4.
CurveType = 5: Number of control points.
CurveType = 6: Not Used
CurveType = 7: Not Used
Value2
This is the value of a parameter used to define the general reference line layout. The item that Value2 represents depends on the CurveType item.
CurveType = 0: Not Used
CurveType = 1: Not Used
CurveType = 2: Curve length, including length of spirals on either end. [L]
CurveType = 3: Rate at which the slope of a parabolic curve is changing in percent. [1/L]
CurveType = 4: Number of discretization points.
CurveType = 5: Number of discretization points.
CurveType = 6: Not Used
CurveType = 7: Not Used
Value3: This is the value of a parameter used to define the general reference line layout. The item that Value3 represents depends on the CurveType item.
CurveType = 0: Not Used
CurveType = 1: Not Used
CurveType = 2: Not Used
CurveType = 3: Not Used
CurveType = 4: Not Used
CurveType = 5: Curve order.
CurveType = 6: Not Used
CurveType = 7: Not Used
s: This is an array of the station coordinate of each point in the coordinate system specified for the general reference line. [L]
z: This is an array of the Z coordinate of each point in the coordinate system specified for the general reference line. [L]
        """

        all_args = [Name, NumberPoints, CurveType, Value1, Value3, s, z]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GenRefLine.GetLineElevPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLineElevPoints" failed')
        
        return ret

    def GetLinePlanPoints(self, Name = None, NumberPoints = None, CurveType = None, Value1 = None, Value2 = None, Value3 = None, x = None, y = None):
        """
This function retrieves the general reference line plan points and the associated parameters.
The function returns zero if the general reference line parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing general reference line.
NumberPoints: The number of points used to define the general reference line plan layout.
CurveType: This is an array of values indicating the general reference line plan layout curve type for each point.
0 = None
1 = Circular Curve
2 = Highway Curve
3 = Parabolic Curve
4 = Bezier Curve
5 = BSpline Curve
6 = Bezier Curve Child Point
7 = BSpline Curve Child Point
Value1: This is the value of a parameter used to define the general reference line layout. The item that Value1 represents depends on the CurveType item.
CurveType = 0: Not Used
CurveType = 1: Curve Radius [L]
CurveType = 2: Curve Radius [L]
CurveType = 3: Angle measured from the X-axis of the coordinate system in which the general reference line is defined, to the axis of symmetry of the parabolic curve. [deg]
CurveType = 4: Number of control points. This is currently hard-wired internally to 4.
CurveType = 5: Number of control points.
CurveType = 6: Not Used
CurveType = 7: Not Used
Value2: This is the value of a parameter used to define the general reference line layout. The item that Value2 represents depends on the CurveType item.
CurveType = 0: Not Used
CurveType = 1: Not Used
CurveType = 2: Curve length, including length of spirals on either end. [L]
CurveType = 3: Rate at which the slope of a parabolic curve is changing in percent. [1/L]
CurveType = 4: Number of discretization points.
CurveType = 5: Number of discretization points.
CurveType = 6: Not Used
CurveType = 7: Not Used
Value3: This is the value of a parameter used to define the general reference line layout. The item that Value3 represents depends on the CurveType item.
CurveType = 0: Not Used
CurveType = 1: Not Used
CurveType = 2: Not Used
CurveType = 3: Not Used
CurveType = 4: Not Used
CurveType = 5: Curve order.
CurveType = 6: Not Used
CurveType = 7: Not Used
x: This is an array of the X coordinate of each point in the coordinate system specified for the general reference line. [L]
y: This is an array of the Y coordinate of each point in the coordinate system specified for the general reference line. [L]
        """

        all_args = [Name, NumberPoints, CurveType, Value1, Value2, Value3, x, y]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GenRefLine.GetLinePlanPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLinePlanPoints" failed')
        
        return ret

    def GetLine(self, Name = None, DiscLength = None, DiscAngle = None, Color = None, Visible = None):
        """
The function returns zero if the general reference line data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing general reference line.
DiscLength: The maximum segment discretization length of the segments used to define curves in the general reference line. [L]
DiscAngle: The maximum discretization angle in degrees for the general reference line. [deg]
Color: The display color assigned to the general reference line.
Visible: Specifies whether the general reference line will be displayed in windows displaying the model.
        """

        all_args = [Name, DiscLength, DiscAngle, Color, Visible]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GenRefLine.GetLine(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLine" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined general reference lines.
The function returns the names; otherwise it returns a nonzero value.

NumberNames: The number of general reference line names retrieved by the program.
MyName: This is a one-dimensional array of general reference line names. The MyName array is created as a dynamic, zero-based array by the API user:
Dim MyName() As String

The array is dimensioned to (NumberNames – 1) inside the SAP2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GenRefLine.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def SetLineElevPoints(self, Name = None, NumberPoints = None, CurveType = None, Value1 = None, Value2 = None, Value3 = None, x = None, y = None):
        """
This function assigns the general reference line elevation layout parameters.
A minimum of three points is required for the Circular, Highway, and Parabolic curves. The Bezier curve requires a minimum of four points. The BSpline curve requires a minimum of two points.
The Bezier and BSpline curve types require additional control points as specified by Value2. These control points are considered to be defined directly after the point specifying the Bezier or BSpline curve. Any Value1, Value2, or Value3 parameters defined on these control points are ignored.
The function returns zero if the general reference line parameters are successfully defined; otherwise it returns a nonzero value.

Name: The name of a defined general reference line.
NumberPoints: The number of points used to define the general reference line elevation layout.
CurveType: This is an array of values indicating the general reference line elevation layout curve type for each point.
0 = None
1 = Circular Curve
2 = Highway Curve
3 = Parabolic Curve
4 = Bezier Curve
5 = BSpline Curve
6 = Bezier Curve Child Point
7 = BSpline Curve Child Point
Value1: This is the value of a parameter used to define the general reference line layout. The item that Value1 represents depends on the CurveType item.
CurveType = 0: Not Used
CurveType = 1: Curve Radius [L]
CurveType = 2: Curve Radius [L]
CurveType = 3: Angle measured from the horizontal, up station axis, to the axis of symmetry of the parabolic curve. [deg]
CurveType = 4: Number of control points. This is currently hard-wired internally to 4.
CurveType = 5: Number of control points.
CurveType = 6: Not Used
CurveType = 7: Not Used
Value2: This is the value of a parameter used to define the general reference line layout. The item that Value2 represents depends on the CurveType item.
CurveType = 0: Not Used
CurveType = 1: Not Used
CurveType = 2: Curve length, including length of spirals on either end. [L]
CurveType = 3: Rate at which the slope of a parabolic curve is changing in percent. [1/L]
CurveType = 4: Number of discretization points.
CurveType = 5: Number of discretization points.
CurveType = 6: Not Used
CurveType = 7: Not Used
Value3: This is the value of a parameter used to define the general reference line layout. The item that Value3 represents depends on the CurveType item.
CurveType = 0: Not Used
CurveType = 1: Not Used
CurveType = 2: Not Used
CurveType = 3: Not Used
CurveType = 4: Not Used
CurveType = 5: Curve order.
CurveType = 6: Not Used
CurveType = 7: Not Used
x: This is an array of the station coordinate of each point in the coordinate system specified for the general reference line. [L]
y: This is an array of the Z coordinate of each point in the coordinate system specified for the general reference line. [L]
        """

        all_args = [Name, NumberPoints, CurveType, Value1, Value2, Value3, x, y]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GenRefLine.SetLineElevPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLineElevPoints" failed')
        
        return ret

    def SetLinePlanPoints(self, Name = None, NumberPoints = None, CurveType = None, Value1 = None, Value2 = None, Value3 = None, x = None, y = None):
        """
This function assigns the general reference line plan layout parameters.
A minimum of three points is required for the Circular, Highway, and Parabolic curves. The Bezier curve requires a minimum of four points. The BSpline curve requires a minimum of two points.
The Bezier and BSpline curve types require additional control points as specified by Value2. These control points are considered to be defined directly after the point specifying the Bezier or BSpline curve. Any Value1, Value2, or Value3 parameters defined on these control points are ignored.
The function returns zero if the general reference line parameters are successfully defined; otherwise it returns a nonzero value.

Name: The name of a defined general reference line.
NumberPoints: The number of points used to define the general reference line plan layout.
CurveType: This is an array of values indicating the general reference line plan layout curve type for each point.
0 = None
1 = Circular Curve
2 = Highway Curve
3 = Parabolic Curve
4 = Bezier Curve
5 = BSpline Curve
6 = Bezier Curve Child Point
7 = BSpline Curve Child Point
Value1: This is the value of a parameter used to define the general reference line layout. The item that Value1 represents depends on the CurveType item.
CurveType = 0: Not Used
CurveType = 1: Curve Radius [L]
CurveType = 2: Curve Radius [L]
CurveType = 3: Angle measured from the X-axis of the coordinate system in which the general reference line is defined, to the axis of symmetry of the parabolic curve. [deg]
CurveType = 4: Number of control points. This is currently hard-wired internally to 4.
CurveType = 5: Number of control points.
CurveType = 6: Not Used
CurveType = 7: Not Used
Value2: This is the value of a parameter used to define the general reference line layout. The item that Value2 represents depends on the CurveType item.
CurveType = 0: Not Used
CurveType = 1: Not Used
CurveType = 2: Curve length, including length of spirals on either end. [L]
CurveType = 3: Rate at which the slope of a parabolic curve is changing in percent. [1/L]
CurveType = 4: Number of discretization points.
CurveType = 5: Number of discretization points.
CurveType = 6: Not Used
CurveType = 7: Not Used
Value3: This is the value of a parameter used to define the general reference line layout. The item that Value3 represents depends on the CurveType item.
CurveType = 0: Not Used
CurveType = 1: Not Used
CurveType = 2: Not Used
CurveType = 3: Not Used
CurveType = 4: Not Used
CurveType = 5: Curve order.
CurveType = 6: Not Used
CurveType = 7: Not Used
x: This is an array of the X coordinate of each point in the coordinate system specified for the general reference line. [L]
y: This is an array of the Y coordinate of each point in the coordinate system specified for the general reference line. [L]
        """

        all_args = [Name, NumberPoints, CurveType, Value1, Value2, Value3, x, y]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GenRefLine.SetLinePlanPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLinePlanPoints" failed')
        
        return ret

    def SetLine(self, Name = None, DiscLength = None, DiscAngle = None, CSys = None, Color = None, Visible = None):
        """
The function returns zero if the general reference line is successfully added or modified; otherwise it returns a nonzero value.

Name: This is the name of a general reference line. If this is the name of an existing general reference line, that general reference line is modified; otherwise a new general reference line is added.
DiscLength: The maximum segment discretization length of the segments used to define curves in the general reference line. [L]
DiscAngle: The maximum discretization angle in degrees for the general reference line. [deg]
CSys: The name of the coordinate system in which the general reference line is defined.
Color: The display color assigned to the general reference line. If Color is specified as -1, the program will automatically assign a color.
Visible: The item is True if the general reference line should be displayed in windows displaying the model.
        """

        all_args = [Name, DiscLength, DiscAngle, CSys, Color, Visible]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GenRefLine.SetLine(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLine" failed')
        
        return ret

class GroupDef:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
The function returns zero if the new name is successfully applied, otherwise it returns a nonzero value.
Changing the name of group ALL will fail and return an error.

Name: The existing name of a defined group.
NewName: The new name for the group.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GroupDef.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Clear(self, Name = None):
        """
This function clears (removes) all assignments from the specified group.
The function returns zero if the group assignment is successfully cleared, otherwise it returns a nonzero value.

Name: The name of an existing group.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GroupDef.Clear(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Clear" failed')
        
        return ret

    def Count(self):
        """
The function returns the number of defined groups.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GroupDef.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes the specified group. It will return an error if an attempt is made to delete the Group named ALL.
The function returns zero if the group is successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing group.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GroupDef.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetAssignments(self, Name = None, NumberItems = None, ObjectType = None, ObjectName = None):
        """
This function retrieves the assignments to a specified group.
The function returns zero if the group assignment is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing group.
NumberItems: The number of assignments made to the specified group.
ObjectType: This is an array that includes the object type of each item in the group.
1 = Point object
2 = Frame object
3 = Cable object
4 = Tendon object
5 = Area object
6 = Solid object
7 = Link object
ObjectName: This is an array that includes the name of each item in the group.
        """

        all_args = [Name, NumberItems, ObjectType, ObjectName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GroupDef.GetAssignments(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAssignments" failed')
        
        return ret

    def GetGroup(self, Name = None, color = None, SpecifiedForSelection = None, SpecifiedForSectionCutDefinition = None, SpecifiedForSteelDesign = None, SpecifiedForConcreteDesign = None, SpecifiedForAluminumDesign = None, SpecifiedForColdFormedDesign = None, SpecifiedForStaticNLActiveStage = None, SpecifiedForBridgeResponseOutput = None, SpecifiedForAutoSeismicOutput = None, SpecifiedForAutoWindOutput = None, SpecifiedForMassAndWeight = None):
        """
The function returns zero if the group data is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing group.
color: The display color for the group specified as a Long.
SpecifiedForSelection: This item is True if the group is specified to be used for selection; otherwise it is False.
SpecifiedForSectionCutDefinition: This item is True if the group is specified to be used for defining section cuts; otherwise it is False.
SpecifiedForSteelDesign: This item is True if the group is specified to be used for defining steel frame design groups; otherwise it is False.
SpecifiedForConcreteDesign: This item is True if the group is specified to be used for defining concrete frame design groups; otherwise it is False.
SpecifiedForAluminumDesign: This item is True if the group is specified to be used for defining aluminum frame design groups; otherwise it is False.
SpecifiedForColdFormedDesign: This item is True if the group is specified to be used for defining cold formed frame design groups; otherwise it is False.
SpecifiedForStaticNLActiveStage: This item is True if the group is specified to be used for defining stages for nonlinear static analysis; otherwise it is False.
SpecifiedForBridgeResponseOutput: This item is True if the group is specified to be used for reporting bridge response output; otherwise it is False.
SpecifiedForAutoSeismicOutput: This item is True if the group is specified to be used for reporting auto seismic loads; otherwise it is False.
SpecifiedForAutoWindOutput: This item is True if the group is specified to be used for reporting auto wind loads; otherwise it is False.
SpecifiedForMassAndWeight: This item is True if the group is specified to be used for reporting group masses and weight; otherwise it is False.
        """

        all_args = [Name, color, SpecifiedForSelection, SpecifiedForSectionCutDefinition, SpecifiedForSteelDesign, SpecifiedForConcreteDesign, SpecifiedForAluminumDesign, SpecifiedForColdFormedDesign, SpecifiedForStaticNLActiveStage, SpecifiedForBridgeResponseOutput, SpecifiedForAutoSeismicOutput, SpecifiedForAutoWindOutput, SpecifiedForMassAndWeight]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GroupDef.GetGroup(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGroup" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined groups.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of group names retrieved by the program.
MyName: This is a one-dimensional array of group names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GroupDef.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def SetGroup(self, Name = None, color = None, SpecifiedForSelection = None, SpecifiedForSectionCutDefinition = None, SpecifiedForSteelDesign = None, SpecifiedForConcreteDesign = None, SpecifiedForAluminumDesign = None, SpecifiedForColdFormedDesign = None, SpecifiedForStaticNLActiveStage = None, SpecifiedForBridgeResponseOutput = None, SpecifiedForAutoSeismicOutput = None, SpecifiedForAutoWindOutput = None, SpecifiedForMassAndWeight = None):
        """
The function returns zero if the group data is successfully set, otherwise it returns a nonzero value.

Name: This is the name of a group.If this is the name of an existing group, that group is modified, otherwise a new group is added.
color: The display color for the group specified as a Long. If this value is input as –1, the program automatically selects a display color for the group.
SpecifiedForSelection: This item is True if the group is specified to be used for selection; otherwise it is False.
SpecifiedForSectionCutDefinition: This item is True if the group is specified to be used for defining section cuts; otherwise it is False.
SpecifiedForSteelDesign: This item is True if the group is specified to be used for defining steel frame design groups; otherwise it is False.
SpecifiedForConcreteDesign: This item is True if the group is specified to be used for defining concrete frame design groups; otherwise it is False.
SpecifiedForAluminumDesign: This item is True if the group is specified to be used for defining aluminum frame design groups; otherwise it is False.
SpecifiedForColdFormedDesign: This item is True if the group is specified to be used for defining cold formed frame design groups; otherwise it is False.
SpecifiedForStaticNLActiveStage: This item is True if the group is specified to be used for defining stages for nonlinear static analysis; otherwise it is False.
SpecifiedForBridgeResponseOutput: This item is True if the group is specified to be used for reporting bridge response output; otherwise it is False.
SpecifiedForAutoSeismicOutput: This item is True if the group is specified to be used for reporting auto seismic loads; otherwise it is False.
SpecifiedForAutoWindOutput: This item is True if the group is specified to be used for reporting auto wind loads; otherwise it is False.
SpecifiedForMassAndWeight: This item is True if the group is specified to be used for reporting group masses and weight; otherwise it is False.
        """

        all_args = [Name, color, SpecifiedForSelection, SpecifiedForSectionCutDefinition, SpecifiedForSteelDesign, SpecifiedForConcreteDesign, SpecifiedForAluminumDesign, SpecifiedForColdFormedDesign, SpecifiedForStaticNLActiveStage, SpecifiedForBridgeResponseOutput, SpecifiedForAutoSeismicOutput, SpecifiedForAutoWindOutput, SpecifiedForMassAndWeight]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.GroupDef.SetGroup(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGroup" failed')
        
        return ret

class PatternDef:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
The function returns zero if the new name is successfully applied, otherwise it returns a nonzero value.

Name: The existing name of a defined joint pattern.
NewName: The new name for the joint pattern.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PatternDef.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
The function returns the number of defined joint patterns.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PatternDef.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes the specified joint pattern. At least one joint pattern must be defined. The function will return an error if an attempt is made to delete the last joint pattern.
The function returns zero if the joint pattern is successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing joint pattern.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PatternDef.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined joint patterns.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of joint pattern names retrieved by the program.
MyName: This is a one-dimensional array of joint pattern names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PatternDef.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def SetPattern(self, Name = None):
        """
The function defines a new joint pattern. It returns an error if the specified joint pattern name is already in use.
The function returns zero if the new joint pattern is successfully defined, otherwise it returns a nonzero value.

Name: The name of a new joint pattern.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PatternDef.SetPattern(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPattern" failed')
        
        return ret

class Buckling:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing buckling load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else then zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Buckling.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, SF = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing buckling load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for Accel UX UY and UZ; otherwise unitless
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Buckling.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def GetParameters(self, Name = None, NumBucklingModes = None, EigenTol = None):
        """
This function retrieves various parameters for the specified load case.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing buckling load case.
NumBucklingModes: The number of buckling modes requested.
EigenTol: The relative convergence tolerance for eigenvalues.
        """

        all_args = [Name, NumBucklingModes, EigenTol]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Buckling.GetParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetParameters" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a buckling load case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case then that case is modified, otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Buckling.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing buckling load case.
InitialCase: This is blank, None or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Buckling.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, SF = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing buckling load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Acce, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for Accel UX UY and UZ; otherwise unitless
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Buckling.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

    def SetParameters(self, Name = None, NumBucklingModes = None, EigenTol = None):
        """
This function sets various parameters for the specified buckling load case.
The function returns zero if the parameters are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing buckling load case.
NumBucklingModes: The number of buckling modes requested.
EigenTol: The relative convergence tolerance for eigenvalues.
        """

        all_args = [Name, NumBucklingModes, EigenTol]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Buckling.SetParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetParameters" failed')
        
        return ret

class DirHistLinear:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetDampProportional(self, Name = None, DampType = None, Dampa = None, Dampb = None, Dampf1 = None, Dampf2 = None, Dampd1 = None, Dampd2 = None):
        """
This function retrieves the proportional modal damping data assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear direct integration time history load case that has proportional damping.
DampType: This is 1, 2 or 3, indicating the proportional modal damping type.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
Dampa: The mass proportional damping coefficient.
Dampb: The stiffness proportional damping coefficient.
Dampf1: This is the period or the frequency (depending on the value of the DampType item) for point 1. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampf2: This is the period or the frequency (depending on the value of the DampType item) for point 2. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampd1: This is the damping at point 1 (0 <= Dampd1 < 1).
This item applies only when DampType = 2 or 3.
Dampd2: This is the damping at point 2 (0 <= Dampd2 < 1).
This item applies only when DampType = 2 or 3.
        """

        all_args = [Name, DampType, Dampa, Dampb, Dampf1, Dampf2, Dampd1, Dampd2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistLinear.GetDampProportional(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampProportional" failed')
        
        return ret

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear direct integration time history load case.
InitialCase: This is blank, None or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistLinear.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, Func = None, SF = None, TF = None, AT = None, CSys = None, Ang = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear direct integration time history load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the time history function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
TF: This is an array that includes the time scale factor of each load assigned to the load case.
AT: This is an array that includes the arrival time of each load assigned to the load case.
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
This item applies only when the LoadType item is Accel.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
This item applies only when the LoadType item is Accel.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, Func, SF, TF, AT, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistLinear.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def GetTimeIntegration(self, Name = None, IntegrationType = None, Alpha = None, Beta = None, Gamma = None, Theta = None, m = None):
        """
This function retrieves the time integration data assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear direct integration time history load case.
IntegrationType: This is 1, 2, 3, 4 or 5, indicating the time integration type.
1 = Newmark
2 = Wilson
3 = Collocation
4 = Hilber-Hughes-Taylor
5 = Chung and Hulbert
Alpha: The alpha factor (-1/3 <= Alpha <= 0).
This item applies only when IntegrationType = 4 or 5.
Beta: The beta factor (Beta >= 0).
This item applies only when IntegrationType = 1, 3 or 5. It is returned for informational purposes when IntegrationType = 4.
Gamma: The gamma factor (Gamma >= 0.5).
This item applies only when IntegrationType = 1, 3 or 5. It is returned for informational purposes when IntegrationType = 4.
Theta: The theta factor (Theta > 0).
This item applies only when IntegrationType = 2 or 3.
m: The alpha-m factor.
This item only applies when IntegrationType = 5.
        """

        all_args = [Name, IntegrationType, Alpha, Beta, Gamma, Theta, m]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistLinear.GetTimeIntegration(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTimeIntegration" failed')
        
        return ret

    def GetTimeStep(self, Name = None, nstep = None, DT = None):
        """
This function retrieves the time step data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear direct integration time history load case.
nstep: The number of output time steps.
DT: The output time step size.
        """

        all_args = [Name, nstep, DT]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistLinear.GetTimeStep(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTimeStep" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a linear direct integration time history load case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistLinear.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetDampProportional(self, Name = None, DampType = None, Dampa = None, Dampb = None, Dampf1 = None, Dampf2 = None, Dampd1 = None, Dampd2 = None):
        """
This function sets proportional modal damping data for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing linear direct integration time history load case.
DampType: This is 1, 2 or 3, indicating the proportional modal damping type.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
Dampa: The mass proportional damping coefficient. This item applies only when DampType = 1.
Dampb: The stiffness proportional damping coefficient. This item applies only when DampType = 1.
Dampf1: This is the period or the frequency (depending on the value of the DampType item) for point 1. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampf2: This is either the period or the frequency (depending on the value of the DampType item) for point 2. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampd1: This is the damping at point 1 (0 <= Dampd1 < 1).
This item applies only when DampType = 2 or 3.
Dampd2: This is the damping at point 2 (0 <= Dampd2 < 1).
This item applies only when DampType = 2 or 3.
        """

        all_args = [Name, DampType, Dampa, Dampb, Dampf1, Dampf2, Dampd1, Dampd2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistLinear.SetDampProportional(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampProportional" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing linear direct integration time history load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case. the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistLinear.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, Func = None, SF = None, TF = None, AT = None, CSys = None, Ang = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing linear direct integration time history load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the time history function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
TF: This is an array that includes the time scale factor of each load assigned to the load case.
AT: This is an array that includes the arrival time of each load assigned to the load case.
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
This item applies only when the LoadType item is Accel.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
This item applies only when the LoadType item is Accel.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, Func, SF, TF, AT, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistLinear.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

    def SetTimeIntegration(self, Name = None, IntegrationType = None, Alpha = None, Beta = None, Gamma = None, Theta = None, m = None):
        """
This function sets time integration data for the specified load case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing linear direct integration time history load case.
IntegrationType: This is 1, 2, 3, 4 or 5, indicating the time integration type.
1 = Newmark
2 = Wilson
3 = Collocation
4 = Hilber-Hughes-Taylor
5 = Chung and Hulbert
Alpha: The alpha factor (-1/3 <= Alpha <= 0).
This item applies only when IntegrationType = 4 or 5.
Beta: The beta factor (Beta >= 0).
This item applies only when IntegrationType = 1, 3 or 5.
Gamma: The gamma factor (Gamma >= 0.5).
This item applies only when IntegrationType = 1, 3 or 5.
Theta: The theta factor (Theta > 0).
This item applies only when IntegrationType = 2 or 3.
m: The alpha-m factor.
This item applies only when IntegrationType = 5.
        """

        all_args = [Name, IntegrationType, Alpha, Beta, Gamma, Theta, m]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistLinear.SetTimeIntegration(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTimeIntegration" failed')
        
        return ret

    def SetTimeStep(self, Name = None, nstep = None, DT = None):
        """
This function sets the time step data for the specified load case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing linear direct integration time history load case.
nstep: The number of output time steps.
DT: The output time step size.
        """

        all_args = [Name, nstep, DT]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistLinear.SetTimeStep(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTimeStep" failed')
        
        return ret

class DirHistNonlinear:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetDampProportional(self, Name = None, DampType = None, Dampa = None, Dampb = None, Dampf1 = None, Dampf2 = None, Dampd1 = None, Dampd2 = None):
        """
This function retrieves the proportional modal damping data assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case that has proportional damping.
DampType: This is 1, 2 or 3, indicating the proportional modal damping type.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
Dampa: The mass proportional damping coefficient.
Dampb: The stiffness proportional damping coefficient.
Dampf1: This is the period or the frequency (depending on the value of the DampType item) for point 1. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampf2: This is the period or the frequency (depending on the value of the DampType item) for point 2. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampd1: This is the damping at point 1 (0 <= Dampd1 < 1).
This item applies only when DampType = 2 or 3.
Dampd2: This is the damping at point 2 (0 <= Dampd2 < 1).
This item applies only when DampType = 2 or 3.
        """

        all_args = [Name, DampType, Dampa, Dampb, Dampf1, Dampf2, Dampd1, Dampd2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.GetDampProportional(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampProportional" failed')
        
        return ret

    def GetGeometricNonlinearity(self, Name = None, NLGeomType = None):
        """
This function retrieves the geometric nonlinearity option for the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
NLGeomType: This is 0, 1 or 2, indicating the geometric nonlinearity option selected for the load case.
0 = None
1 = P-delta
2 = P-delta plus large displacements
        """

        all_args = [Name, NLGeomType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.GetGeometricNonlinearity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGeometricNonlinearity" failed')
        
        return ret

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
InitialCase: This is blank, None or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts from the state at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the state at the end of that case is used. If the initial case is anything else then zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, Func = None, SF = None, TF = None, AT = None, CSys = None, Ang = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the time history function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
TF: This is an array that includes the time scale factor of each load assigned to the load case.
AT: This is an array that includes the arrival time of each load assigned to the load case.
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
This item applies only when the LoadType item is Accel.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
This item applies only when the LoadType item is Accel.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, Func, SF, TF, AT, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def GetMassSource(self, Name = None, Source = None):
        """
This function sets the mass source to be used for the specified load case.
The function returns zero if the mass source is data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
Source: This is the name of an existing mass source or a blank string. Blank indicates to use the mass source from the previous load case or the default mass source if the load case starts from zero initial conditions.
        """

        all_args = [Name, Source]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.GetMassSource(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMassSource" failed')
        
        return ret

    def GetSolControlParameters(self, Name = None, DTMax = None, DTMin = None, MaxIterCS = None, MaxIterNR = None, TolConvD = None, UseEventStepping = None, TolEventD = None, MaxLineSearchPerIter = None, TolLineSearch = None, LineSearchStepFact = None):
        """
This function retrieves the solution control parameters for the specified load case.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
DTMax: The maximum substep size.
DTMin: The minimum substep size.
MaxIterCS: The maximum constant-stiffness iterations per step.
MaxIterNR: The maximum Newton_Raphson iterations per step.
TolConvD: The relative iteration convergence tolerance.
UseEventStepping: This item is True if event-to-event stepping is used.
TolEventD: The relative event lumping tolerance.
MaxLineSearchPerIter: The maximum number of line searches per iteration.
TolLineSearch: The relative line-search acceptance tolerance.
LineSearchStepFact: The line-search step factor.
        """

        all_args = [Name, DTMax, DTMin, MaxIterCS, MaxIterNR, TolConvD, UseEventStepping, TolEventD, MaxLineSearchPerIter, TolLineSearch, LineSearchStepFact]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.GetSolControlParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSolControlParameters" failed')
        
        return ret

    def GetTimeIntegration(self, Name = None, IntegrationType = None, Alpha = None, Beta = None, Gamma = None, Theta = None, m = None):
        """
This function retrieves the time integration data assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
IntegrationType: This is 1, 2, 3, 4 or 5; indicating the time integration type.
1 = Newmark
2 = Wilson
3 = Collocation
4 = Hilber-Hughes-Taylor
5 = Chung and Hulbert
Alpha: The alpha factor (-1/3 <= Alpha <= 0).
This item applies only when IntegrationType = 4 or 5.
Beta: The beta factor (Beta >= 0).
This item applies only when IntegrationType = 1, 3 or 5. It is returned for informational purposes when IntegrationType = 4.
Gamma: The gamma factor (Gamma >= 0.5).
This item applies only when IntegrationType = 1, 3 or 5. It is returned for informational purposes when IntegrationType = 4.
Theta: The theta factor (Theta > 0).
This item applies only when IntegrationType = 2 or 3.
m: The alpha-m factor.
This item applies only when IntegrationType = 5.
        """

        all_args = [Name, IntegrationType, Alpha, Beta, Gamma, Theta, m]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.GetTimeIntegration(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTimeIntegration" failed')
        
        return ret

    def GetTimeStep(self, Name = None, nstep = None, DT = None):
        """
This function retrieves the time step data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
nstep: The number of output time steps.
DT: The output time step size.
        """

        all_args = [Name, nstep, DT]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.GetTimeStep(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTimeStep" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a nonlinear direct integration time history load case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetDampProportional(self, Name = None, DampType = None, Dampa = None, Dampb = None, Dampf1 = None, Dampf2 = None, Dampd1 = None, Dampd2 = None):
        """
This function sets proportional modal damping data for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
DampType: This is 1, 2 or 3, indicating the proportional modal damping type.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
Dampa: The mass proportional damping coefficient. This item applies only when DampType = 1.
Dampb: The stiffness proportional damping coefficient. This item applies only when DampType = 1.
Dampf1: This is the period or the frequency (depending on the value of the DampType item) for point 1. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampf2: This is the period or the frequency (depending on the value of the DampType item) for point 2. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampd1: This is the damping at point 1 (0 <= Dampd1 < 1).
This item applies only when DampType = 2 or 3.
Dampd2: This is the damping at point 2 (0 <= Dampd2 < 1).
This item applies only when DampType = 2 or 3.
        """

        all_args = [Name, DampType, Dampa, Dampb, Dampf1, Dampf2, Dampd1, Dampd2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.SetDampProportional(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampProportional" failed')
        
        return ret

    def SetGeometricNonlinearity(self, Name = None, NLGeomType = None):
        """
This function sets the geometric nonlinearity option for the specified load case.
The function returns zero if the option is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
NLGeomType: This is 0, 1 or 2, indicating the geometric nonlinearity option selected for the load case.
0 = None
1 = P-delta
2 = P-delta plus large displacements
        """

        all_args = [Name, NLGeomType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.SetGeometricNonlinearity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGeometricNonlinearity" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
InitialCase: This is blank, None or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts from the state at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the state at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, Func = None, SF = None, TF = None, AT = None, CSys = None, Ang = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the time history function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
TF: This is an array that includes the time scale factor of each load assigned to the load case.
AT: This is an array that includes the arrival time of each load assigned to the load case.
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
This item applies only when the LoadType item is Accel.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
This item applies only when the LoadType item is Accel.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, Func, SF, TF, AT, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

    def SetMassSource(self, Name = None, Source = None):
        """
This function sets the mass source to be used for the specified load case.
The function returns zero if the mass source is data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
Source: This is the name of an existing mass source or a blank string. Blank indicates to use the mass source from the previous load case or the default mass source if the load case starts from zero initial conditions.
        """

        all_args = [Name, Source]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.SetMassSource(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMassSource" failed')
        
        return ret

    def SetSolControlParameters(self, Name = None, DTMax = None, DTMin = None, MaxIterCS = None, MaxIterNR = None, TolConvD = None, UseEventStepping = None, TolEventD = None, MaxLineSearchPerIter = None, TolLineSearch = None, LineSearchStepFact = None):
        """
This function sets the solution control parameters for the specified load case.
The function returns zero if the parameters are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
DTMax: The maximum substep size.
DTMin: The minimum substep size.
MaxIterCS: The maximum constant-stiffness iterations per step.
MaxIterNR: The maximum Newton_Raphson iterations per step.
TolConvD: The relative iteration convergence tolerance.
UseEventStepping: This item is True if event-to-event stepping is used.
TolEventD: The relative event lumping tolerance.
MaxLineSearchPerIter: The maximum number of line searches per iteration.
TolLineSearch: The relative line-search acceptance tolerance.
LineSearchStepFact: The line-search step factor.
        """

        all_args = [Name, DTMax, DTMin, MaxIterCS, MaxIterNR, TolConvD, UseEventStepping, TolEventD, MaxLineSearchPerIter, TolLineSearch, LineSearchStepFact]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.SetSolControlParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSolControlParameters" failed')
        
        return ret

    def SetTimeIntegration(self, Name = None, IntegrationType = None, Alpha = None, Beta = None, Gamma = None, Theta = None, m = None):
        """
This function sets time integration data for the specified load case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
IntegrationType: This is 1, 2, 3, 4 or 5, indicating the time integration type.
1 = Newmark
2 = Wilson
3 = Collocation
4 = Hilber-Hughes-Taylor
5 = Chung and Hulbert
Alpha: The alpha factor (-1/3 <= Alpha <= 0).
This item applies only when IntegrationType = 4 or 5.
Beta: The beta factor (Beta >= 0).
This item applies only when IntegrationType = 1, 3 or 5.
Gamma: The gamma factor (Gamma >= 0.5).
This item applies only when IntegrationType = 1, 3 or 5.
Theta: The theta factor (Theta > 0).
This item applies only when IntegrationType = 2 or 3.
m: The alpha-m factor.
This item applies only when IntegrationType = 5.
        """

        all_args = [Name, IntegrationType, Alpha, Beta, Gamma, Theta, m]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.SetTimeIntegration(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTimeIntegration" failed')
        
        return ret

    def SetTimeStep(self, Name = None, nstep = None, DT = None):
        """
This function sets the time step data for the specified load case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear direct integration time history load case.
nstep: The number of output time steps.
DT: The output time step size.
        """

        all_args = [Name, nstep, DT]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.DirHistNonlinear.SetTimeStep(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTimeStep" failed')
        
        return ret

class HyperStatic:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetBaseCase(self, Name = None, BaseCase = None):
        """
This function retrieves the base case for the specified hyperstatic load case.
The function returns zero if the base case is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing hyperstatic load case.
BaseCase: The name of an existing static linear load case that is the base case for the specified hyperstatic load case.
        """

        all_args = [Name, BaseCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.HyperStatic.GetBaseCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetBaseCase" failed')
        
        return ret

    def SetBaseCase(self, Name = None, BaseCase = None):
        """
This function sets the base case for the specified hyperstatic load case.
The function returns zero if the base case is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing hyperstatic load case.
BaseCase: The name of an existing static linear load case that is the base case for the specified hyperstatic load case.
        """

        all_args = [Name, BaseCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.HyperStatic.SetBaseCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetBaseCase" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a hyperstatic load case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.HyperStatic.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

class ModalEigen:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing modal eigen load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalEigen.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, TargetPar = None, StaticCorrect = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing modal eigen load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes Load, Accel or Link, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
If the LoadType item is Link, this item is not used.
TargetPar: This is an array that includes the target mass participation ratio.
StaticCorrect: This is an array that includes either 0 or 1, indicating if static correction modes are to be calculated.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, TargetPar, StaticCorrect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalEigen.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def GetNumberModes(self, Name = None, MaxModes = None, MinModes = None):
        """
This function retrieves the number of modes requested for the specified load case.
The function returns zero if the number of modes is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing modal eigen load case.
MaxModes: The maximum number of modes requested.
MinModes: The minimum number of modes requested.
        """

        all_args = [Name, MaxModes, MinModes]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalEigen.GetNumberModes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNumberModes" failed')
        
        return ret

    def GetParameters(self, Name = None, EigenShiftFreq = None, EigenCutOff = None, EigenTol = None, AllowAutoFreqShift = None):
        """
This function retrieves various parameters for the specified load case.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing modal eigen load case.
EigenShiftFreq: The eigenvalue shift frequency. [cyc/s]
EigenCutOff: The eigencutoff frequency radius. [cyc/s]
EigenTol: The relative convergence tolerance for eigenvalues.
AllowAutoFreqShift: This is either 0 or 1, indicating if automatic frequency shifting is allowed.
0 = Automatic frequency shifting is NOT allowed
1 = Automatic frequency shifting is allowed
        """

        all_args = [Name, EigenShiftFreq, EigenCutOff, EigenTol, AllowAutoFreqShift]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalEigen.GetParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetParameters" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a modal eigen load case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalEigen.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing modal eigen load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalEigen.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, TargetPar = None, StaticCorrect = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing modal eigen load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes Load, Accel or Link, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
If the LoadType item is Link, this item is not used.
TargetPar: This is an array that includes the target mass participation ratio.
StaticCorrect: This is an array that includes either 0 or 1, indicating if static correction modes are to be calculated.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, TargetPar, StaticCorrect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalEigen.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

    def SetNumberModes(self, Name = None, MaxModes = None, MinModes = None):
        """
This function sets the number of modes requested for the specified load case.
The function returns zero if the number of modes is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing modal eigen load case.
MaxModes: The maximum number of modes requested.
MinModes: The minimum number of modes requested.
        """

        all_args = [Name, MaxModes, MinModes]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalEigen.SetNumberModes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNumberModes" failed')
        
        return ret

    def SetParameters(self, Name = None, EigenShiftFreq = None, EigenCutOff = None, EigenTol = None, AllowAutoFreqShift = None):
        """
This function sets various parameters for the specified modal eigen load case.
The function returns zero if the parameters are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing modal eigen load case.
EigenShiftFreq: The eigenvalue shift frequency. [cyc/s]
EigenCutOff: The eigencutoff frequency radius. [cyc/s]
EigenTol: The relative convergence tolerance for eigenvalues.
AllowAutoFreqShift: This is either 0 or 1, indicating if automatic frequency shifting is allowed.
0 = Automatic frequency shifting is NOT allowed
1 = Automatic frequency shifting is allowed
        """

        all_args = [Name, EigenShiftFreq, EigenCutOff, EigenTol, AllowAutoFreqShift]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalEigen.SetParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetParameters" failed')
        
        return ret

class ModalRitz:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing modal ritz load case.
InitialCase: This is blank, None or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalRitz.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, RitzMaxCyc = None, TargetPar = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing modal ritz load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes Load, Accel or Link, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
If the LoadType item is Link, this item is not used.
RitzMaxCyc: This is an array that includes the maximum number of generation cycles to be performed for the specified ritz starting vector. A value of 0 means there is no limit on the number of cycles.
TargetPar: This is an array that includes the target dynamic participation ratio.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, RitzMaxCyc, TargetPar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalRitz.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def GetNumberModes(self, Name = None, MaxModes = None, MinModes = None):
        """
This function retrieves the number of modes requested for the specified load case.
The function returns zero if the number of modes is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing modal ritz load case.
MaxModes: The maximum number of modes requested.
MinModes: The minimum number of modes requested.
        """

        all_args = [Name, MaxModes, MinModes]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalRitz.GetNumberModes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNumberModes" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a modal ritz load case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalRitz.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing modal ritz load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalRitz.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, RitzMaxCyc = None, TargetPar = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing modal ritz load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes Load, Accel or Link, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
If the LoadType item is Link, this item is not used.
RitzMaxCyc: This is an array that includes the maximum number of generation cycles to be performed for the specified ritz starting vector. A value of 0 means there is no limit on the number of cycles.
TargetPar: This is an array that includes the target dynamic participation ratio.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, RitzMaxCyc, TargetPar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalRitz.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

    def SetNumberModes(self, Name = None, MaxModes = None, MinModes = None):
        """
This function sets the number of modes requested for the specified load case.
The function returns zero if the number of modes is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing modal ritz load case.
MaxModes: The maximum number of modes requested.
MinModes: The minimum number of modes requested.
        """

        all_args = [Name, MaxModes, MinModes]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModalRitz.SetNumberModes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNumberModes" failed')
        
        return ret

class ModHistLinear:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetDampConstant(self, Name = None, Damp = None):
        """
This function retrieves the constant modal damping for all modes assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case that has constant damping.
Damp: The constant damping for all modes (0 <= Damp < 1).
        """

        all_args = [Name, Damp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.GetDampConstant(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampConstant" failed')
        
        return ret

    def GetDampProportional(self, Name = None, DampType = None, Dampa = None, Dampb = None, Dampf1 = None, Dampf2 = None, Dampd1 = None, Dampd2 = None):
        """
This function retrieves the proportional modal damping data assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case that has proportional damping.
DampType: This is 1, 2 or 3, indicating the proportional modal damping type.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
Dampa: The mass proportional damping coefficient.
Dampb: The stiffness proportional damping coefficient.
Dampf1: This is the period or the frequency (depending on the value of the DampType item) for point 1. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampf2: This is the period or the frequency (depending on the value of the DampType item) for point 2. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampd1: This is the damping at point 1 (0 <= Dampd1 < 1).
This item applies only when DampType = 2 or 3.
Dampd2: This is the damping at point 2 (0 <= Dampd2 < 1).
This item applies only when DampType = 2 or 3.
        """

        all_args = [Name, DampType, Dampa, Dampb, Dampf1, Dampf2, Dampd1, Dampd2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.GetDampProportional(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampProportional" failed')
        
        return ret

    def GetDampType(self, Name = None, DampType = None):
        """
This function retrieves the modal damping type for the specified load case.
The function returns zero if the type is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case.
DampType: This is 1, 2, 3, 4, 5 or 6, indicating the modal damping type for the load case.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
4 = Constant damping for all modes
5 = Interpolated damping by period
6 = Interpolated damping by frequency
        """

        all_args = [Name, DampType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.GetDampType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampType" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, Func = None, SF = None, TF = None, AT = None, CSys = None, Ang = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the time history function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
TF: This is an array that includes the time scale factor of each load assigned to the load case.
AT: This is an array that includes the arrival time of each load assigned to the load case.
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
This item applies only when the LoadType item is Accel.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
This item applies only when the LoadType item is Accel.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, Func, SF, TF, AT, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def GetModalCase(self, Name = None, ModalCase = None):
        """
This function retrieves the modal case assigned to the specified load case.
The function returns zero if the modal case is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case.
ModalCase: This is None or the name of an existing modal analysis case. It specifies the modal load case on which any mode-type load assignments to the specified load case are based.
        """

        all_args = [Name, ModalCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.GetModalCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModalCase" failed')
        
        return ret

    def GetMotionType(self, Name = None, MotionType = None):
        """
This function retrieves the motion type for the specified load case.
The function returns zero if the motion type is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case.
MotionType: This is 1 or 2, indicating the time history motion type.
1 = Transient
2 = Periodic
        """

        all_args = [Name, MotionType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.GetMotionType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMotionType" failed')
        
        return ret

    def GetTimeStep(self, Name = None, nstep = None, DT = None):
        """
This function retrieves the time step data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case.
nstep: The number of output time steps.
DT: The output time step size.
        """

        all_args = [Name, nstep, DT]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.GetTimeStep(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTimeStep" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a linear modal history analysis case. If this function is called for an existing load case then all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetDampConstant(self, Name = None, Damp = None):
        """
This function sets constant modal damping for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case.
Damp: The constant damping for all modes (0 <= Damp < 1).
        """

        all_args = [Name, Damp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.SetDampConstant(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampConstant" failed')
        
        return ret

    def SetDampInterpolated(self, Name = None, DampType = None, NumberItems = None, Time = None, Damp = None):
        """
This function sets interpolated modal damping data for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case.
DampType: This is 5 or 6, indicating the interpolated modal damping type.
5 = Interpolated damping by period
6 = Interpolated damping by frequency
NumberItems: The number of Time and Damp pairs.
Time: This is an array that includes the period or the frequency, depending on the value of the DampType item. [s] for DampType = 5 and [cyc/s] for DampType = 6
Damp: This is an array that includes the damping for the specified period of frequency (0 <= Damp < 1).
        """

        all_args = [Name, DampType, NumberItems, Time, Damp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.SetDampInterpolated(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampInterpolated" failed')
        
        return ret

    def SetDampOverrides(self, Name = None, NumberItems = None, Mode = None, Damp = None):
        """
This function sets the modal damping overrides for the specified load case.
The function returns zero if the overrides are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case.
NumberItems: The number of Mode and Damp pairs.
Mode: This is an array that includes a mode number.
Damp: This is an array that includes the damping for the specified mode (0 <= Damp < 1).
        """

        all_args = [Name, NumberItems, Mode, Damp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.SetDampOverrides(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampOverrides" failed')
        
        return ret

    def SetDampProportional(self, Name = None, DampType = None, Dampa = None, Dampb = None, Dampf1 = None, Dampf2 = None, Dampd1 = None, Dampd2 = None):
        """
This function sets proportional modal damping data for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case.
DampType: This is 1, 2 or 3, indicating the proportional modal damping type.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
Dampa: The mass proportional damping coefficient. This item applies only when DampType = 1.
Dampb: The stiffness proportional damping coefficient. This item applies only when DampType = 1.
Dampf1: This is the period or the frequency (depending on the value of the DampType item) for point 1. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampf2: This is the period or the frequency (depending on the value of the DampType item) for point 2. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampd1: This is the damping at point 1 (0 <= Dampd1 < 1).
This item applies only when DampType = 2 or 3.
Dampd2: This is the damping at point 2 (0 <= Dampd2 < 1).
This item applies only when DampType = 2 or 3.
        """

        all_args = [Name, DampType, Dampa, Dampb, Dampf1, Dampf2, Dampd1, Dampd2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.SetDampProportional(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampProportional" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, Func = None, SF = None, TF = None, AT = None, CSys = None, Ang = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the time history function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
TF: This is an array that includes the time scale factor of each load assigned to the load case.
AT: This is an array that includes the arrival time of each load assigned to the load case.
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
This item applies only when the LoadType item is Accel.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
This item applies only when the LoadType item is Accel.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, Func, SF, TF, AT, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

    def SetModalCase(self, Name = None, ModalCase = None):
        """
This function sets the modal case for the specified analysis case.
The function returns zero if the modal case is successfully set; otherwise it returns a nonzero value.
If the specified modal case is not actually a modal case, the program automatically replaces it with the first modal case it can find. If no modal load cases exist, an error is returned.

Name: The name of an existing linear modal history analysis case.
ModalCase: This is the name of an existing modal load case. It specifies the modal load case on which any mode-type load assignments to the specified load case are based.
        """

        all_args = [Name, ModalCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.SetModalCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModalCase" failed')
        
        return ret

    def SetMotionType(self, Name = None, MotionType = None):
        """
This function sets the motion type for the specified analysis case.
The function returns zero if the motion type is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case.
MotionType: This is 1 or 2, indicating the time history motion type.
1 = Transient
2 = Periodic
        """

        all_args = [Name, MotionType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.SetMotionType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMotionType" failed')
        
        return ret

    def SetTimeStep(self, Name = None, nstep = None, DT = None):
        """
This function sets the time step data for the specified load case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing linear modal history analysis case.
nstep: The number of output time steps.
DT: The output time step size.
        """

        all_args = [Name, nstep, DT]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistLinear.SetTimeStep(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTimeStep" failed')
        
        return ret

class ModHistNonlinear:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetDampConstant(self, Name = None, Damp = None):
        """
This function retrieves the constant modal damping for all modes assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case that has constant damping.
Damp: The constant damping for all modes (0 <= Damp < 1).
        """

        all_args = [Name, Damp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.GetDampConstant(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampConstant" failed')
        
        return ret

    def GetDampProportional(self, Name = None, DampType = None, Dampa = None, Dampb = None, Dampf1 = None, Dampf2 = None, Dampd1 = None, Dampd2 = None):
        """
This function retrieves the proportional modal damping data assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case that has proportional damping.
DampType: This is 1, 2 or 3, indicating the proportional modal damping type.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
Dampa: The mass proportional damping coefficient.
Dampb: The stiffness proportional damping coefficient.
Dampf1: This is the period or the frequency (depending on the value of the DampType item) for point 1. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampf2: This is the period or the frequency (depending on the value of the DampType item) for point 2. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampd1: This is the damping at point 1 (0 <= Dampd1 < 1).
This item applies only when DampType = 2 or 3.
Dampd2: This is the damping at point 2 (0 <= Dampd2 < 1).
This item applies only when DampType = 2 or 3.
        """

        all_args = [Name, DampType, Dampa, Dampb, Dampf1, Dampf2, Dampd1, Dampd2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.GetDampProportional(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampProportional" failed')
        
        return ret

    def GetDampType(self, Name = None, DampType = None):
        """
This function retrieves the modal damping type for the specified load case.
The function returns zero if the type is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case.
DampType: This is 1, 2, 3, 4, 5 or 6, indicating the modal damping type for the load case.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
4 = Constant damping for all modes
5 = Interpolated damping by period
6 = Interpolated damping by frequency
        """

        all_args = [Name, DampType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.GetDampType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampType" failed')
        
        return ret

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case.
InitialCase: This is blank, None or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it continues from the end of another nonlinear modal time history load case.
If the specified initial case is not a nonlinear modal time history load case, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, Func = None, SF = None, TF = None, AT = None, CSys = None, Ang = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the time history function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
TF: This is an array that includes the time scale factor of each load assigned to the load case.
AT: This is an array that includes the arrival time of each load assigned to the load case.
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
This item applies only when the LoadType item is Accel.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
This item applies only when the LoadType item is Accel.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, Func, SF, TF, AT, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def GetModalCase(self, Name = None, ModalCase = None):
        """
This function retrieves the modal case assigned to the specified load case.
The function returns zero if the modal case is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case.
ModalCase: This is None or the name of an existing modal analysis case. It specifies the modal load case on which any mode-type load assignments to the specified load case are based.
        """

        all_args = [Name, ModalCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.GetModalCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModalCase" failed')
        
        return ret

    def GetSolControlParameters(self, Name = None, tstat = None, dtmax = None, dtmin = None, ftol = None, etol = None, itmax = None, itmin = None, Cf = None):
        """
This function retrieves the solution control parameters for the specified load case.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal time history analysis case.
tstat: The static period.
dtmax: The maximum substep size.
dtmin: The minimum substep size.
ftol: The relative force convergence tolerance.
etol: The relative energy convergence tolerance.
itmax: The maximum iteration limit.
itmin: The minimum iteration limit.
Cf: The convergence factor.
        """

        all_args = [Name, tstat, dtmax, dtmin, ftol, etol, itmax, itmin, Cf]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.GetSolControlParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSolControlParameters" failed')
        
        return ret

    def GetTimeStep(self, Name = None, nstep = None, DT = None):
        """
This function retrieves the time step data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case.
nstep: The number of output time steps.
DT: The output time step size.
        """

        all_args = [Name, nstep, DT]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.GetTimeStep(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTimeStep" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a nonlinear modal history analysis case. If this function is called for an existing load case, all items for the case are reset to their default values.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetDampConstant(self, Name = None, Damp = None):
        """
This function sets constant modal damping for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case.
Damp: The constant damping for all modes (0 <= Damp < 1).
        """

        all_args = [Name, Damp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.SetDampConstant(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampConstant" failed')
        
        return ret

    def SetDampInterpolated(self, Name = None, DampType = None, NumberItems = None, Time = None, Damp = None):
        """
This function sets interpolated modal damping data for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case.
DampType: This is 5 or 6, indicating the interpolated modal damping type.
5 = Interpolated damping by period
6 = Interpolated damping by frequency
NumberItems: The number of Time and Damp pairs.
Time: This is an array that includes the period or the frequency, depending on the value of the DampType item. [s] for DampType = 5 and [cyc/s] for DampType = 6
Damp: This is an array that includes the damping for the specified period of frequency (0 <= Damp < 1).
        """

        all_args = [Name, DampType, NumberItems, Time, Damp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.SetDampInterpolated(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampInterpolated" failed')
        
        return ret

    def SetDampOverrides(self, Name = None, NumberItems = None, Mode = None, Damp = None):
        """
This function sets the modal damping overrides for the specified load case.
The function returns zero if the overrides are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case.
NumberItems: The number of Mode and Damp pairs.
Mode: This is an array that includes a mode number.
Damp: This is an array that includes the damping for the specified mode (0 <= Damp < 1).
        """

        all_args = [Name, NumberItems, Mode, Damp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.SetDampOverrides(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampOverrides" failed')
        
        return ret

    def SetDampProportional(self, Name = None, DampType = None, Dampa = None, Dampb = None, Dampf1 = None, Dampf2 = None, Dampd1 = None, Dampd2 = None):
        """
This function sets proportional modal damping data for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case.
DampType: This is 1, 2 or 3, indicating the proportional modal damping type.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
Dampa: The mass proportional damping coefficient. This item applies only when DampType = 1.
Dampb: The stiffness proportional damping coefficient. This item applies only when DampType = 1.
Dampf1: This is the period or the frequency (depending on the value of the DampType item) for point 1. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampf2: This is the period or the frequency (depending on the value of the DampType item) for point 2. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampd1: This is the damping at point 1 (0 <= Dampd1 < 1).
This item applies only when DampType = 2 or 3.
Dampd2: This is the damping at point 2 (0 <= Dampd2 < 1).
This item applies only when DampType = 2 or 3.
        """

        all_args = [Name, DampType, Dampa, Dampb, Dampf1, Dampf2, Dampd1, Dampd2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.SetDampProportional(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampProportional" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case.
InitialCase: This is blank, None or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it continues from the end of another nonlinear modal time history load case.
If the specified initial case is not a nonlinear modal time history load case, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, Func = None, SF = None, TF = None, AT = None, CSys = None, Ang = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the time history function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
TF: This is an array that includes the time scale factor of each load assigned to the load case.
AT: This is an array that includes the arrival time of each load assigned to the load case.
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
This item applies only when the LoadType item is Accel.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
This item applies only when the LoadType item is Accel.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, Func, SF, TF, AT, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

    def SetModalCase(self, Name = None, ModalCase = None):
        """
This function sets the modal case for the specified analysis case.
The function returns zero if the modal case is successfully set; otherwise it returns a nonzero value.
If the specified modal case is not actually a modal case, the program automatically replaces it with the first modal case it can find. If no modal load cases exist, an error is returned.

Name: The name of an existing nonlinear modal history analysis case.
ModalCase: This is the name of an existing modal load case. It specifies the modal load case on which any mode-type load assignments to the specified load case are based.
        """

        all_args = [Name, ModalCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.SetModalCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModalCase" failed')
        
        return ret

    def SetSolControlParameters(self, Name = None, tstat = None, dtmax = None, dtmin = None, ftol = None, etol = None, itmax = None, itmin = None, Cf = None):
        """
This function sets the solution control parameters for the specified load case.
The function returns zero if the parameters are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal time history analysis case.
tstat: The static period.
dtmax: The maximum substep size.
dtmin: The minimum substep size.
ftol: The relative force convergence tolerance.
etol: The relative energy convergence tolerance.
itmax: The maximum iteration limit.
itmin: The minimum iteration limit.
Cf: The convergence factor.
        """

        all_args = [Name, tstat, dtmax, dtmin, ftol, etol, itmax, itmin, Cf]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.SetSolControlParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSolControlParameters" failed')
        
        return ret

    def SetTimeStep(self, Name = None, nstep = None, DT = None):
        """
This function sets the time step data for the specified load case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing nonlinear modal history analysis case.
nstep: The number of output time steps.
DT: The output time step size.
        """

        all_args = [Name, nstep, DT]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ModHistNonlinear.SetTimeStep(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTimeStep" failed')
        
        return ret

class Moving:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetDirectionalFactors(self, Name = None, Vertical = None, Braking = None, Centrifugal = None):
        """
This function retrieves the directional factors for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing moving load case.
Vertical: The moving load directional factor for vertical load.
Braking: The moving load directional factor.
Centrifugal: The moving directional factor for centrifugal load.
        """

        all_args = [Name, Vertical, Braking, Centrifugal]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Moving.GetDirectionalFactors(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDirectionalFactors" failed')
        
        return ret

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing moving load load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Moving.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLanesLoaded(self, Name = None, LoadNumber = None, NumberItems = None, MyName = None):
        """
This function retrieves the lanes loaded data for a specified load assignment number in a specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing moving load case.
LoadNumber: The load assignment number.
NumberItems: The number of lanes loaded for the specified load assignment number.
MyName: This is an array that includes the name of each lane loaded for the specified load assignment number.
        """

        all_args = [Name, LoadNumber, NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Moving.GetLanesLoaded(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLanesLoaded" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, MyClass = None, SF = None, Min = None, Max = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing moving load case.
NumberLoads: The number of loads assigned to the specified analysis case.
MyClass: This is an array that includes the vehicle class for each load assigned to the load case.
SF: This is an array that includes the scale factor for each load assigned to the load case.
Min: This is an array that includes the minimum number of lanes loaded for each load assigned to the load case.
Max: This is an array that includes the maximum number of lanes loaded for each load assigned to the load case. This item must be 0, or it must be greater than or equal to Min. If this item is 0, all available lanes are loaded.
        """

        all_args = [Name, NumberLoads, MyClass, SF, Min, Max]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Moving.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def GetMultiLaneSF(self, Name = None, NumberItems = None, SF = None):
        """
This function retrieves the multilane scale factor data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing moving load case.
NumberItems: The number of lanes loaded up to which reduction scale factors are provided.
SF: This is an array that includes the reduction scale factor for the number of lanes loaded from 1 up to NumberItems.
        """

        all_args = [Name, NumberItems, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Moving.GetMultiLaneSF(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMultiLaneSF" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a moving load load case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case then that case is modified, otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Moving.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetDirectionalFactors(self, Name = None, Vertical = None, Braking = None, Centrifugal = None):
        """
This function sets the directional factors for the specified load case. Calling this function is optional. By default, the directional factors are set to Vertical = 1, Braking = 0, and Centrifugal = 0 when the moving load case is defied or re-defined. If this function is called, the three directional factors must be nonnegative, and at least one must be positive.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing moving load case.
Vertical: The moving load directional factor for vertical load.
Braking: The moving load directional factor.
Centrifugal: The moving directional factor for centrifugal load.
        """

        all_args = [Name, Vertical, Braking, Centrifugal]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Moving.SetDirectionalFactors(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDirectionalFactors" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing moving load load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Moving.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, MyClass = None, SF = None, Min = None, Max = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing moving load case.
NumberLoads: The number of loads assigned to the specified analysis case.
MyClass: This is an array that includes the vehicle class for each load assigned to the load case.
SF: This is an array that includes the scale factor for each load assigned to the load case.
Min: This is an array that includes the minimum number of lanes loaded for each load assigned to the load case.
Max: This is an array that includes the maximum number of lanes loaded for each load assigned to the load case. This item must be 0, or it must be greater than or equal to Min. If this item is 0, all available lanes are loaded.
        """

        all_args = [Name, NumberLoads, MyClass, SF, Min, Max]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.Moving.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

class PSD:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetDampConstant(self, Name = None, HysConMassCoeff = None, HysConStiffCoeff = None):
        """
This function retrieves the constant hysteretic damping for all frequencies assigned to the specified load case.
The function returns zero if the damping is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing power spectral density analysis case that has constant damping.
HysConMassCoeff: The mass proportional damping coefficient.
HysConStiffCoeff: The stiffness proportional damping coefficient.
        """

        all_args = [Name, HysConMassCoeff, HysConStiffCoeff]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.PSD.GetDampConstant(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampConstant" failed')
        
        return ret

    def GetDampInterpolated(self, Name = None, HysIntFreqUnits = None, HysIntNumFreqs = None, HysIntFreq = None, HysIntMassCoeff = None, HysIntStiffCoeff = None):
        """
This function retrieves the interpolated hysteretic damping by frequency assigned to the specified load case.
The function returns zero if the damping is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing power spectral density analysis case that has interpolated damping.
HysIntFreqUnits: This is 1 or 2, indicating the units for the frequency.
1 = Hz [cyc/s]
2 = RPM
HysIntNumFreqs: The number of sets of frequency, mass coefficient and stiffness coefficient data.
HysIntFreq: This is an array of frequencies. The frequency is either in Hz or RPM depending on the value of HysIntFreqUnits.
HysIntMassCoeff: This is an array that includes the mass proportional damping coefficient.
HysIntStiffCoeff: This is an array that includes the stiffness proportional damping coefficient.
        """

        all_args = [Name, HysIntFreqUnits, HysIntNumFreqs, HysIntFreq, HysIntMassCoeff, HysIntStiffCoeff]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.PSD.GetDampInterpolated(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampInterpolated" failed')
        
        return ret

    def GetDampType(self, Name = None, DampType = None):
        """
This function retrieves the hysteretic damping type for the specified load case.
The function returns zero if the type is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing power spectral density analysis case.
DampType: This is 1 or 2, indicating the hysteretic damping type for the load case.
1 = Constant hysteretic damping for all frequencies
2 = Interpolated hysteretic damping by frequency
        """

        all_args = [Name, DampType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.PSD.GetDampType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampType" failed')
        
        return ret

    def GetFreqData(self, Name = None, FreqFirst = None, FreqLast = None, FreqNumIncs = None, FreqAddModal = None, FreqAddModalDev = None, FreqAddSpecified = None, ModalCase = None, FreqNumModalDev = None, FreqModalDev = None, FreqNumSpecified = None, FreqSpecified = None):
        """
This function retrieves the frequency data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing power spectral density analysis case.
FreqFirst: The first frequency. [cyc/s]
FreqLast: The last frequency. [cyc/s]
FreqNumIncs: The number of frequency increments.
FreqAddModal: If this item is True, modal frequencies are added.
FreqAddModalDev: If this item is True, signed fractional deviations from modal frequencies are added.
FreqAddSpecified: If this item is True, specified frequencies are added.
ModalCase: This is the name of an existing modal load case. It specifies the modal load case on which modal frequencies and modal frequency deviations are based.
FreqNumModalDev: The number of signed fractional deviations from modal frequencies that are added. This item applies only when FreqAddModalDev = True.
FreqModalDev: This is an array that includes the added signed fractional deviations from modal frequencies. This item applies only when FreqAddModalDev = True.
FreqNumSpecified: The number of specified frequencies that are added. This item applies only when FreqAddSpecified = True.
FreqSpecified: This is an array that includes the added specified frequencies. This item applies only when FreqAddModalDev = True.
        """

        all_args = [Name, FreqFirst, FreqLast, FreqNumIncs, FreqAddModal, FreqAddModalDev, FreqAddSpecified, ModalCase, FreqNumModalDev, FreqModalDev, FreqNumSpecified, FreqSpecified]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.PSD.GetFreqData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetFreqData" failed')
        
        return ret

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing power spectral density analysis case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.PSD.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, Func = None, SF = None, PhaseAngle = None, CSys = None, Ang = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing power spectral density analysis case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the power spectral density function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
PhaseAngle: This is an array that includes the phase angle. [deg]
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
This item applies only when the LoadType item is Accel.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
This item applies only when the LoadType item is Accel.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, Func, SF, PhaseAngle, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.PSD.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a power spectral density analysis case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.PSD.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetDampConstant(self, Name = None, HysConMassCoeff = None, HysConStiffCoeff = None):
        """
This function sets constant hysteretic damping for all frequencies for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing power spectral density analysis case.
HysConMassCoeff: The mass proportional damping coefficient.
HysConStiffCoeff: The stiffness proportional damping coefficient.
        """

        all_args = [Name, HysConMassCoeff, HysConStiffCoeff]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.PSD.SetDampConstant(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampConstant" failed')
        
        return ret

    def SetDampInterpolated(self, Name = None, HysIntFreqUnits = None, HysIntNumFreqs = None, HysIntFreq = None, HysIntMassCoeff = None, HysIntStiffCoeff = None):
        """
This function sets interpolated hysteretic damping by frequency for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing power spectral density analysis case.
HysIntFreqUnits: This is either 1 or 2, indicating the units for the frequency.
1 = Hz [cyc/s]
2 = RPM
HysIntNumFreqs: The number of sets of frequency, mass coefficient and stiffness coefficient data.
HysIntFreq: This is an array of frequencies. The frequency is either in Hz or RPM depending on the value of HysIntFreqUnits.
HysIntMassCoeff: This is an array that includes the mass proportional damping coefficient.
HysIntStiffCoeff: This is an array that includes the stiffness proportional damping coefficient.
        """

        all_args = [Name, HysIntFreqUnits, HysIntNumFreqs, HysIntFreq, HysIntMassCoeff, HysIntStiffCoeff]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.PSD.SetDampInterpolated(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampInterpolated" failed')
        
        return ret

    def SetFreqData(self, Name = None, FreqFirst = None, FreqLast = None, FreqNumIncs = None, FreqAddModal = None, FreqAddModalDev = None, FreqAddSpecified = None, ModalCase = None, FreqNumModalDev = None, FreqModalDev = None, FreqNumSpecified = None, FreqSpecified = None):
        """
This function sets the frequency data for the specified load case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing power spectral density analysis case.
FreqFirst: The first frequency. [cyc/s]
FreqLast: The last frequency. [cyc/s]
FreqNumIncs: The number of frequency increments.
FreqAddModal: If this item is True, modal frequencies are added.
FreqAddModalDev: If this item is True, signed fractional deviations from modal frequencies are added.
FreqAddSpecified: If this item is True, specified frequencies are added.
ModalCase: This is the name of an existing modal load case. It specifies the modal load case on which modal frequencies and modal frequency deviations are based.
FreqNumModalDev: The number of signed fractional deviations from modal frequencies that are added. This item applies only when FreqAddModalDev = True.
FreqModalDev: This is an array that includes the added signed fractional deviations from modal frequencies. This item applies only when FreqAddModalDev = True.
FreqNumSpecified: The number of specified frequencies that are added. This item applies only when FreqAddSpecified = True.
FreqSpecified: This is an array that includes the added specified frequencies. This item applies only when FreqAddModalDev = True.
        """

        all_args = [Name, FreqFirst, FreqLast, FreqNumIncs, FreqAddModal, FreqAddModalDev, FreqAddSpecified, ModalCase, FreqNumModalDev, FreqModalDev, FreqNumSpecified, FreqSpecified]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.PSD.SetFreqData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFreqData" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing power spectral density analysis case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.PSD.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, Func = None, SF = None, PhaseAngle = None, CSys = None, Ang = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing power spectral density analysis case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the power spectral density function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
PhaseAngle: This is an array that includes the phase angle. [deg]
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
This item applies pnly when the LoadType item is Accel.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
This item applies only when the LoadType item is Accel.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, Func, SF, PhaseAngle, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.PSD.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

class ResponseSpectrum:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetDampConstant(self, Name = None, Damp = None):
        """
This function retrieves the constant modal damping for all modes assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case that has constant damping.
Damp: The constant damping for all modes (0 <= Damp < 1).
        """

        all_args = [Name, Damp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.GetDampConstant(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampConstant" failed')
        
        return ret

    def GetDampProportional(self, Name = None, DampType = None, Dampa = None, Dampb = None, Dampf1 = None, Dampf2 = None, Dampd1 = None, Dampd2 = None):
        """
This function retrieves the proportional modal damping data assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case that has proportional damping.
DampType: This is 1, 2 or 3, indicating the proportional modal damping type.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
Dampa: The mass proportional damping coefficient.
Dampb: The stiffness proportional damping coefficient.
Dampf1: This is the period or the frequency (depending on the value of the DampType item) for point 1. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampf2: This is the period or the frequency (depending on the value of the DampType item) for point 2. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampd1: This is the damping at point 1 (0 <= Dampd1 < 1).
This item applies only when DampType = 2 or 3.
Dampd2: This is the damping at point 2 (0 <= Dampd2 < 1).
This item applies only when DampType = 2 or 3.
        """

        all_args = [Name, DampType, Dampa, Dampb, Dampf1, Dampf2, Dampd1, Dampd2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.GetDampProportional(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampProportional" failed')
        
        return ret

    def GetDampType(self, Name = None, DampType = None):
        """
This function retrieves the modal damping type for the specified load case.
The function returns zero if the type is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
DampType: This is 1, 2, 3, 4, 5 or 6, indicating the modal damping type for the load case.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
4 = Constant damping for all modes
5 = Interpolated damping by period
6 = Interpolated damping by frequency
        """

        all_args = [Name, DampType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.GetDampType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampType" failed')
        
        return ret

    def GetDiaphragmEccentricityOverride(self, Name = None, Num = None, Diaph = None, Eccen = None):
        """
This function retrieves the diaphragm eccentricity overrides for a response spectrum load case.
The function returns zero if the overrides are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
Num: The number of diaphragm eccentricity overrides for the specified load case.
Diaph: This is an array that includes the names of the diaphragms that have eccentricity overrides.
Eccen: This is an array that includes the eccentricity applied to each diaphragm. [L]
        """

        all_args = [Name, Num, Diaph, Eccen]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.GetDiaphragmEccentricityOverride(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDiaphragmEccentricityOverride" failed')
        
        return ret

    def GetDirComb(self, Name = None, MyType = None, SF = None):
        """
This function retrieves the directional combination option assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
MyType: This is 1, 2, or 3, indicating the directional combination option.
1 = SRSS
2 = ABS
3 = CQC3
SF: This item applies only when MyType = 2. It is the ABS scale factor.
        """

        all_args = [Name, MyType, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.GetDirComb(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDirComb" failed')
        
        return ret

    def GetEccentricity(self, Name = None, Eccen = None):
        """
This function retrieves the eccentricity ratio that applies to all diaphragms for the specified load case.
The function returns zero if the ratio is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
Eccen: The eccentricity ratio that applies to all diaphragms.
        """

        all_args = [Name, Eccen]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.GetEccentricity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEccentricity" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadName = None, Func = None, SF = None, CSys = None, Ang = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadName: This is an array that includes U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the response spectrum function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
        """

        all_args = [Name, NumberLoads, LoadName, Func, SF, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def GetModalCase(self, Name = None, ModalCase = None):
        """
This function retrieves the modal case assigned to the specified load case.
The function returns zero if the modal case is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
ModalCase: This is None or the name of an existing modal analysis case. It specifies the modal load case on which any mode-type load assignments to the specified load case are based.
        """

        all_args = [Name, ModalCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.GetModalCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModalCase" failed')
        
        return ret

    def GetModalComb_1(self, Name = None, MyType = None, F1 = None, F2 = None, PeriodicRigidCombType = None, td = None):
        """
This function retrieves the modal combination option assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
MyType: This is 1, 2, 3, 4, 5 or 6, indicating the modal combination option.
1 = CQC
2 = SRSS
3 = Absolute
4 = GMC
5 = NRC 10 percent
6 = Double sum
F1: The GMC f1 factor. This item does not apply when MyType = 3. [cyc/s]
F2: The GMC f2 factor. This item does not apply when MyType = 3. [cyc/s]
PeriodicRigidCombType: This is 1 or 2, indicating the periodic plus rigid modal combination option.
1 = SRSS
2 = Absolute
td: This item applies only when MyType = 6. It is the factor td. [s]
        """

        all_args = [Name, MyType, F1, F2, PeriodicRigidCombType, td]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.GetModalComb_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModalComb_1" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a response spectrum analysis case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetDampConstant(self, Name = None, Damp = None):
        """
This function sets constant modal damping for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
Damp: The constant damping for all modes (0 <= Damp < 1).
        """

        all_args = [Name, Damp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.SetDampConstant(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampConstant" failed')
        
        return ret

    def SetDampInterpolated(self, Name = None, DampType = None, NumberItems = None, Time = None, Damp = None):
        """
This function sets interpolated modal damping data for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
DampType: This is either 5 or 6, indicating the interpolated modal damping type.
5 = Interpolated damping by period
6 = Interpolated damping by frequency
NumberItems: The number of Time and Damp pairs.
Time: This is an array that includes the period or the frequency depending on the value of the DampType item. [s] for DampType = 5 and [cyc/s] for DampType = 6
Damp: This is an array that includes the damping for the specified period of frequency (0 <= Damp < 1).
        """

        all_args = [Name, DampType, NumberItems, Time, Damp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.SetDampInterpolated(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampInterpolated" failed')
        
        return ret

    def SetDampOverrides(self, Name = None, NumberItems = None, Mode = None, Damp = None):
        """
This function sets the modal damping overrides for the specified load case.
The function returns zero if the overrides are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
NumberItems: The number of Mode and Damp pairs.
Mode: This is an array that includes a mode number.
Damp: This is an array that includes the damping for the specified mode (0 <= Damp < 1).
        """

        all_args = [Name, NumberItems, Mode, Damp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.SetDampOverrides(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampOverrides" failed')
        
        return ret

    def SetDampProportional(self, Name = None, DampType = None, Dampa = None, Dampb = None, Dampf1 = None, Dampf2 = None, Dampd1 = None, Dampd2 = None):
        """
This function sets proportional modal damping data for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
DampType: This is 1, 2 or 3, indicating the proportional modal damping type.
1 = Mass and stiffness proportional damping by direct specification
2 = Mass and stiffness proportional damping by period
3 = Mass and stiffness proportional damping by frequency
Dampa: The mass proportional damping coefficient. This item applies only when DampType = 1.
Dampb: The stiffness proportional damping coefficient. This item applies only when DampType = 1.
Dampf1: This is the period or the frequency (depending on the value of the DampType item) for point 1. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampf2: This is the period or the frequency (depending on the value of the DampType item) for point 2. [s] for DampType = 2 and [cyc/s] for DampType = 3
This item applies only when DampType = 2 or 3.
Dampd1: This is the damping at point 1 (0 <= Dampd1 < 1).
This item applies only when DampType = 2 or 3.
Dampd2: This is the damping at point 2 (0 <= Dampd2 < 1).
This item applies only when DampType = 2 or 3.
        """

        all_args = [Name, DampType, Dampa, Dampb, Dampf1, Dampf2, Dampd1, Dampd2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.SetDampProportional(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampProportional" failed')
        
        return ret

    def SetDiaphragmEccentricityOverride(self, Name = None, Diaph = None, Eccen = None, Delete = None):
        """
This function assigns diaphragm eccentricity overrides for response spectrum load cases.
The function returns zero if the overrides are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
Diaph: The name of an existing special rigid diaphragm constraint, that is, a diaphragm constraint with the following features:
1. The constraint type is CONSTRAINT_DIAPHRAGM = 2.
2. The constraint coordinate system is Global.
3. The constraint axis is Z.
Eccen: The eccentricity applied to the specified diaphragm. [L]
Delete: If this item is True, the eccentricity override for the specified diaphragm is deleted.
        """

        all_args = [Name, Diaph, Eccen, Delete]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.SetDiaphragmEccentricityOverride(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDiaphragmEccentricityOverride" failed')
        
        return ret

    def SetDirComb(self, Name = None, MyType = None, SF = None):
        """
This function sets the directional combination option for the specified load case.
The function returns zero if the option is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
MyType: This is 1, 2, or 3, indicating the directional combination option.
1 = SRSS
2 = ABS
3 = CQC3
SF: This item applies only when MyType = 2. It is the ABS scale factor.
        """

        all_args = [Name, MyType, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.SetDirComb(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDirComb" failed')
        
        return ret

    def SetEccentricity(self, Name = None, Eccen = None):
        """
This function sets the eccentricity ratio that applies to all diaphragms for the specified load case.
The function returns zero if the ratio is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
Eccen: The eccentricity ratio that applies to all diaphragms.
        """

        all_args = [Name, Eccen]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.SetEccentricity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEccentricity" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadName = None, Func = None, SF = None, CSys = None, Ang = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadName: This is an array that includes U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the response spectrum function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
        """

        all_args = [Name, NumberLoads, LoadName, Func, SF, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

    def SetModalCase(self, Name = None, ModalCase = None):
        """
This function sets the modal case for the specified analysis case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.
If the specified modal case is not actually a modal case, the program automatically replaces it with the first modal case it can find. If no modal load cases exist, an error is returned.

Name: The name of an existing response spectrum load case.
ModalCase: This is the name of an existing modal load case. It specifies the modal load case on which any mode-type load assignments to the specified load case are based.
        """

        all_args = [Name, ModalCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.SetModalCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModalCase" failed')
        
        return ret

    def SetModalComb_1(self, Name = None, MyType = None, F1 = None, F2 = None, PeriodicRigidCombType = None, td = None):
        """
This function sets the modal combination option for the specified load case.
The function returns zero if the option is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
MyType: This is 1, 2, 3, 4, 5 or 6, indicating the modal combination option.
1 = CQC
2 = SRSS
3 = Absolute
4 = GMC
5 = NRC 10 percent
6 = Double sum
F1: The GMC f1 factor. This item does not apply when MyType = 3. [cyc/s]
F2: The GMC f2 factor. This item does not apply when MyType = 3. [cyc/s]
PeriodicRigidCombType: This is 1 or 2, indicating the periodic plus rigid modal combination option.
1 = SRSS
2 = Absolute
td: This item applies only when MyType = 6. It is the factor td. [s]
        """

        all_args = [Name, MyType, F1, F2, PeriodicRigidCombType, td]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.SetModalComb_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModalComb_1" failed')
        
        return ret

    def GetModalComb(self, Name = None, MyType = None, F1 = None, F2 = None, td = None):
        """
This function retrieves the modal combination option assigned to the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
MyType: This is 1, 2, 3, 4, 5 or 6, indicating the modal combination option.
1 = CQC
2 = SRSS
3 = ABS
4 = GMC
5 = 10 percent
6 = Double sum
F1: This item applies only when MyType = 4. It is the GMC f1 factor. [cyc/s]
F2: This item applies only when MyType = 4. It is the GMC f2 factor. [cyc/s]
td: This item applies only when MyType = 6. It is the factor td. [s]
        """

        all_args = [Name, MyType, F1, F2, td]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.GetModalComb(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModalComb" failed')
        
        return ret

    def SetModalComb(self, Name = None, MyType = None, F1 = None, F2 = None, td = None):
        """
This function sets the modal combination option for the specified load case.
The function returns zero if the option is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing response spectrum load case.
MyType: This is 1, 2, 3, 4, 5 or 6, indicating the modal combination option.
1 = CQC
2 = SRSS
3 = ABS
4 = GMC
5 = 10 percent
6 = Double sum
F1: This item applies only when MyType = 4. It is the GMC f1 factor. [cyc/s]
F2: This item applies only when MyType = 4. It is the GMC f2 factor. [cyc/s]
td: This item applies only when MyType = 6. It is the factor td. [s]
        """

        all_args = [Name, MyType, F1, F2, td]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.ResponseSpectrum.SetModalComb(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModalComb" failed')
        
        return ret

class StaticNonlinearStaged:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetGeometricNonlinearity(self, Name = None, NLGeomType = None):
        """
This function retrieves the geometric nonlinearity option for the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
NLGeomType: This is 0, 1 or 2, indicating the geometric nonlinearity option selected for the load case.
0 = None
1 = P-delta
2 = P-delta plus large displacements
        """

        all_args = [Name, NLGeomType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.GetGeometricNonlinearity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGeometricNonlinearity" failed')
        
        return ret

    def GetHingeUnloading(self, Name = None, UnloadType = None):
        """
This function retrieves the hinge unloading option for the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
UnloadType: This is 1, 2 or 3, indicating the hinge unloading option selected for the load case.
1 = Unload entire structure
2 = Apply local redistribution
3 = Restart using secant stiffness
        """

        all_args = [Name, UnloadType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.GetHingeUnloading(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetHingeUnloading" failed')
        
        return ret

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
InitialCase: This is blank, None or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts from the state at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the state at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetMaterialNonlinearity(self, Name = None, TimeDepMatProp = None):
        """
This function retrieves the material nonlinearity options for the specified load case.
The function returns zero if the options are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
TimeDepMatProp: When this is True, any specified time dependent material properties are considered in the analysis.
        """

        all_args = [Name, TimeDepMatProp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.GetMaterialNonlinearity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMaterialNonlinearity" failed')
        
        return ret

    def GetResultsSaved(self, Name = None, StagedSaveOption = None, StagedMinSteps = None, StagedMinStepsTD = None):
        """
This function retrieves the results saved parameters for the specified load case.
The function returns zero if the parameters are retrieved successfully; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
StagedSaveOption: This is 0, 1, 2 or 3, indicating the results saved option for the load case.
0 = End of final stage
1 = End of each stage
2 = Start and end of each stage
3 = Two or more times in each stage
StagedMinSteps: The minimum number of steps for application of instantaneous load. This item applies only when StagedSaveOption = 3.
StagedMinStepsTD: The minimum number of steps for analysis of time dependent items. This item applies only when StagedSaveOption = 3.
        """

        all_args = [Name, StagedSaveOption, StagedMinSteps, StagedMinStepsTD]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.GetResultsSaved(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetResultsSaved" failed')
        
        return ret

    def GetSolControlParameters(self, Name = None, MaxTotalSteps = None, MaxFailedSubSteps = None, MaxIterCS = None, MaxIterNR = None, TolConvD = None, UseEventStepping = None, TolEventD = None, MaxLineSearchPerIter = None, TolLineSearch = None, LineSearchStepFact = None):
        """
This function retrieves the solution control parameters for the specified load case.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
MaxTotalSteps: The maximum total steps per stage.
MaxFailedSubSteps: The maximum null (zero) steps per stage.
MaxIterCS: The maximum constant-stiffness iterations per step.
MaxIterNR: The maximum Newton_Raphson iterations per step.
TolConvD: The relative iteration convergence tolerance.
UseEventStepping: This item is True if event-to-event stepping is used.
TolEventD: The relative event lumping tolerance.
MaxLineSearchPerIter: The maximum number of line searches per iteration.
TolLineSearch: The relative line-search acceptance tolerance.
LineSearchStepFact: The line-search step factor.
        """

        all_args = [Name, MaxTotalSteps, MaxFailedSubSteps, MaxIterCS, MaxIterNR, TolConvD, UseEventStepping, TolEventD, MaxLineSearchPerIter, TolLineSearch, LineSearchStepFact]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.GetSolControlParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSolControlParameters" failed')
        
        return ret

    def GetStageData_2(self, Name = None, Stage = None, NumberOperations = None, Operation = None, ObjectType = None, ObjectName = None, Age = None, MyType = None, MyName = None, SF = None):
        """
This function retrieves stage data for the specified 
 stage in the specified load case.
The function returns zero if the data is successfully 
 retrieved; otherwise, it returns a nonzero value.

Name: The name of an existing static nonlinear staged load 
 case.
Stage: The stage in the specified load case for which data 
 is requested. Stages are numbered sequentially starting from 1.
NumberOperations: The number of operations in the specified stage.
Operation: This is an array that includes 1, 2, 3, 4, 5, 6, 7, 
 or 11, indicating an operation type.
1 = Add structure
2 = Remove structure
3 = Load objects if new
4 = Load objects
5 = Change section properties
6 = Change section property 
 modifiers
7 = Change releases
11 = Change section properties 
 and age
ObjectType: This is an array that includes the object type associated 
 with the specified operation. The object type may be one of the following:
Group
Frame
Cable
Tendon
Area
Solid
Link
Point

The following list shows which object types are applicable 
 to each operation type:
Operation = 1 (Add structure):All 
 object types
Operation = 2 (Remove 
 structure):All object types
Operation = 3 (Load objects 
 if new):All object types
Operation = 4 (Load objects):All 
 object types
Operation = 5 (Change 
 section properties):All object types except Point
Operation = 6 (Change 
 section property modifiers):Group, Frame, Cable, Area
Operation = 7 (Change releases):Group, 
 Frame
Operation = 11 (Change section 
 properties and age): All object types except Point
ObjectName: This is an array that includes the name of the object 
 associated with the specified operation. This is the name of a Group, 
 Frame object, Cable object, Tendon object, Area object, Solid object, 
 Link object or Point object, depending on the ObjectType item.
Age: This is an array that includes the age of the added 
 structure, at the time it is added, in days. This item applies only to 
 operations with Operation = 1.
MyType: This is an array that includes a load type or an object 
 type, depending on what is specified for the Operation item. This item 
 applies only to operations with Operation = 3, 4, 5, 6, 7, or 11.
When Operation = 3 or 4, this is an array that includes 
 Load or Accel, indicating the load type of an added load.
When Operation = 5 or 11, and the ObjectType item is 
 Group, this is an array that includes Frame, Cable, Tendon, Area, Solid 
 or Link, indicating the object type for which the section property is 
 changed.
When Operation = 6 and the ObjectType item is Group, 
 this is an array that includes Frame, Cable or Area, indicating the object 
 type for which the section property modifiers are changed.
When Operation = 7 and the ObjectType item is Group, 
 this is an array that includes Frame, indicating the object type for which 
 the releases are changed.
When Operation = 5, 6, 7, or 11, and the ObjectType 
 item is not Group and not Point, this item is ignored and the type is 
 picked up from the ObjectType item.
MyName: This is an array that includes a load assignment or 
 an object name, depending on what is specified for the Operation item. 
 This item applies only to operations with Operation = 3, 4, 5, 6, 7, or 
 11.
When Operation = 3 or 4, this is an array that includes 
 the name of the load assigned to the operation. If the associated LoadType 
 item is Load, this item is the name of a defined load pattern. If the 
 associated LoadType item is Accel , this item is UX, UY, UZ, RX, RY or 
 RZ, indicating the direction of the load.
When Operation = 5 or 11, this is the name of a Frame, 
 Cable, Tendon, Area, Solid or Link object, depending on the object type 
 specified.
When Operation = 6, this is the name of a Frame, Cable 
 or Area object, depending on the object type specified.
When Operation = 7, this is the name of a Frame object.
SF: This is an array that includes the scale factor for 
 the load assigned to the operation, if any. [L/s2] 
 for Accel UX UY and UZ; otherwise unitless
This item applies only to operations with Operation 
 = 3 or 4.
        """

        all_args = [Name, Stage, NumberOperations, Operation, ObjectType, ObjectName, Age, MyType, MyName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.GetStageData_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetStageData_2" failed')
        
        return ret

    def GetStageDefinitions_2(self, Name = None, NumberStages = None, Duration = None, Output = None, OutputName = None, Comment = None):
        """
This function retrieves the stage definition data for 
 the specified load case.
The function returns zero if the data is successfully 
 retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged load 
 case.
NumberStages: The number of stages defined for the specified load 
 case.
Duration: This is an array that includes the duration in days 
 for each stage.
Output: This is an array that includes True or False, indicating 
 if analysis output is to be saved for each stage.
OutputName: This is an array that includes a user-specified output 
 name for each stage.
Comment: This is an array that includes a comment for each stage. 
 The comment may be a blank string.
        """

        all_args = [Name, NumberStages, Duration, Output, OutputName, Comment]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.GetStageDefinitions_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetStageDefinitions_2" failed')
        
        return ret

    def GetTargetForceParameters(self, Name = None, TolConvF = None, MaxIter = None, AccelFact = None, NoStop = None):
        """
This function retrieves the target force iteration parameters for the specified load case.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
TolConvF: The relative convergence tolerance for target force iteration.
MaxIter: The maximum iterations per stage for target force iteration.
AccelFact: The acceleration factor.
NoStop: If this item is True, the analysis is continued when there is no convergence in the target force iteration.
        """

        all_args = [Name, TolConvF, MaxIter, AccelFact, NoStop]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.GetTargetForceParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTargetForceParameters" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a static nonlinear staged analysis case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified, otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetGeometricNonlinearity(self, Name = None, NLGeomType = None):
        """
This function sets the geometric nonlinearity option for the specified load case.
The function returns zero if the option is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
NLGeomType: This is 0, 1 or 2, indicating the geometric nonlinearity option selected for the load case.
0 = None
1 = P-delta
2 = P-delta plus large displacements
        """

        all_args = [Name, NLGeomType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.SetGeometricNonlinearity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGeometricNonlinearity" failed')
        
        return ret

    def SetHingeUnloading(self, Name = None, UnloadType = None):
        """
This function sets the hinge unloading option for the specified load case.
The function returns zero if the option is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
UnloadType: This is 1, 2 or 3, indicating the hinge unloading option selected for the load case.
1 = Unload entire structure
2 = Apply local redistribution
3 = Restart using secant stiffness
        """

        all_args = [Name, UnloadType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.SetHingeUnloading(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetHingeUnloading" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts from the state at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the state at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetMassSource(self, Name = None, Source = None):
        """
This function sets the mass source to be used for the specified load case.
The function returns zero if the mass source is data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
Source: This is the name of an existing mass source or a blank string. Blank indicates to use the mass source from the previous load case or the default mass source if the load case starts from zero initial conditions.
        """

        all_args = [Name, Source]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.SetMassSource(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMassSource" failed')
        
        return ret

    def SetMaterialNonlinearity(self, Name = None, TimeDepMatProp = None):
        """
This function sets the material nonlinearity options for the specified load case.
The function returns zero if the options are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
TimeDepMatProp: When this is True, any specified time dependent material properties are considered in the analysis.
        """

        all_args = [Name, TimeDepMatProp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.SetMaterialNonlinearity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMaterialNonlinearity" failed')
        
        return ret

    def SetResultsSaved(self, Name = None, StagedSaveOption = None, StagedMinSteps = None, StagedMinStepsTD = None):
        """
This function sets the results saved parameters for the specified load case.
The function returns zero if the parameters are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
StagedSaveOption: This is 0, 1, 2 or 3, indicating the results saved option for the load case.
0 = End of final stage
1 = End of each stage
2 = Start and end of each stage
3 = Two or more times in each stage
StagedMinSteps: The minimum number of steps for application of instantaneous load. This item applies only when StagedSaveOption = 3.
StagedMinStepsTD: The minimum number of steps for analysis of time dependent items. This item applies only when StagedSaveOption = 3.
        """

        all_args = [Name, StagedSaveOption, StagedMinSteps, StagedMinStepsTD]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.SetResultsSaved(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetResultsSaved" failed')
        
        return ret

    def SetSolControlParameters(self, Name = None, MaxTotalSteps = None, MaxFailedSubSteps = None, MaxIterCS = None, MaxIterNR = None, TolConvD = None, UseEventStepping = None, TolEventD = None, MaxLineSearchPerIter = None, TolLineSearch = None, LineSearchStepFact = None):
        """
This function sets the solution control parameters for the specified load case.
The function returns zero if the parameters are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
MaxTotalSteps: The maximum total steps per stage.
MaxFailedSubSteps: The maximum null (zero) steps per stage.
MaxIterCS: The maximum constant-stiffness iterations per step.
MaxIterNR: The maximum Newton_Raphson iterations per step.
TolConvD: The relative iteration convergence tolerance.
UseEventStepping: This item is True if event-to-event stepping is used.
TolEventD: The relative event lumping tolerance.
MaxLineSearchPerIter: The maximum number of line searches per iteration.
TolLineSearch: The relative line-search acceptance tolerance.
LineSearchStepFact: The line-search step factor.
        """

        all_args = [Name, MaxTotalSteps, MaxFailedSubSteps, MaxIterCS, MaxIterNR, TolConvD, UseEventStepping, TolEventD, MaxLineSearchPerIter, TolLineSearch, LineSearchStepFact]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.SetSolControlParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSolControlParameters" failed')
        
        return ret

    def SetStageData_2(self, Name = None, Stage = None, NumberOperations = None, Operation = None, ObjectType = None, ObjectName = None, Age = None, MyType = None, MyName = None, SF = None):
        """
This function sets the stage data for the specified 
 stage in the specified load case. All previous stage data for the specified 
 stage is cleared when this function is called.
The function returns zero if the data is successfully 
 set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged load 
 case.
Stage: The stage in the specified load case to which the data 
 applies. Stages are numbered sequentially starting from 1.
NumberOperations: The number of operations in the specified stage.
Operation: This is an array that includes 1, 2, 3, 4, 5, 6, 7, 
 or 11, indicating an operation type.
1 = Add structure
2 = Remove structure
3 = Load objects if new
4 = Load objects
5 = Change section properties
6 = Change section property 
 modifiers
7 = Change releases
11 = Change section properties 
 and age
ObjectType: This is an array that includes the object type associated 
 with the specified operation. The object type may be one of the following:
Group
Frame
Cable
Tendon
Area
Solid
Link
Point

The following list shows which object types are applicable 
 to each operation type:
Operation = 1 (Add structure):All 
 object types
Operation = 2 (Remove 
 structure):All object types
Operation = 3 (Load objects 
 if new):All object types
Operation = 4 (Load objects):All 
 object types
Operation = 5 (Change 
 section properties):All object types except Point
Operation = 6 (Change 
 section property modifiers):Group, Frame, Cable, Area
Operation = 7 (Change releases):Group, 
 Frame
Operation = 11 (Change section 
 properties and age): All object types except Point
ObjectName: This is an array that includes the name of the object 
 associated with the specified operation. This is the name of a Group, 
 Frame object, Cable object, Tendon object, Area object, Solid object, 
 Link object or Point object, depending on the ObjectType item.
Age: This is an array that includes the age of the added 
 structure, at the time it is added, in days. This item applies only to 
 operations with Operation = 1.
MyType: This is an array that includes a load type or an object 
 type, depending on what is specified for the Operation item. This item 
 applies only to operations with Operation = 3, 4, 5, 6, 7, or 11.
When Operation = 3 or 4, this is an array that includes 
 Load or Accel, indicating the load type of an added load.
When Operation = 5 or 11, and the ObjectType item is 
 Group, this is an array that includes Frame, Cable, Tendon, Area, Solid 
 or Link, indicating the object type for which the section property is 
 changed.
When Operation = 6 and the ObjectType item is Group, 
 this is an array that includes Frame, Cable or Area, indicating the object 
 type for which the section property modifiers are changed.
When Operation = 7 and the ObjectType item is Group, 
 this is an array that includes Frame, indicating the object type for which 
 the releases are changed.
When Operation = 5, 6, 7, or 11, and the ObjectType 
 item is not Group and not Point, this item is ignored and the type is 
 picked up from the ObjectType item.
MyName: This is an array that includes a load assignment or 
 an object name, depending on what is specified for the Operation item. 
 This item applies only to operations with Operation = 3, 4, 5, 6, 
 7 or 11.
When Operation = 3 or 4, this is an array that includes 
 the name of the load assigned to the operation. If the associated LoadType 
 item is Load, this item is the name of a defined load pattern. If the 
 associated LoadType item is Accel, this item is UX, UY, UZ, RX, RY or 
 RZ, indicating the direction of the load.
When Operation = 5 or 11, this is the name of a Frame, 
 Cable, Tendon, Area, Solid or Link object, depending on the object type 
 specified.
When Operation = 6, this is the name of a Frame, Cable 
 or Area object, depending on the object type specified.
When Operation = 7, this is the name of a Frame object.
SF: This is an array that includes the scale factor for 
 the load assigned to the operation, if any. [L/s2] 
 for Accel UX UY and UZ; otherwise unitless
This item applies only to operations with Operation 
 = 3 or 4.
        """

        all_args = [Name, Stage, NumberOperations, Operation, ObjectType, ObjectName, Age, MyType, MyName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.SetStageData_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetStageData_2" failed')
        
        return ret

    def SetStageDefinitions_2(self, Name = None, NumberStages = None, Duration = None, Output = None, OutputName = None, Comment = None):
        """
This function initializes the stage definition data 
 for the specified load case. All previous stage definition data for the 
 case is cleared when this function is called.
The function returns zero if the data is successfully 
 initialized; otherwise, it returns a nonzero value.

Name: The name of an existing static nonlinear staged load 
 case.
NumberStages: The number of stages defined for the specified load 
 case.
Duration: This is an array that includes the duration in days 
 for each stage.
Output: This is an array that includes True or False, indicating 
 if analysis output is to be saved for each stage.
OutputName: This is an array that includes a user-specified output 
 name for each stage.
Comment: This is an array that includes a comment for each stage. 
 The comment may be a blank string.
        """

        all_args = [Name, NumberStages, Duration, Output, OutputName, Comment]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.SetStageDefinitions_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetStageDefinitions_2" failed')
        
        return ret

    def SetTargetForceParameters(self, Name = None, TolConvF = None, MaxIter = None, AccelFact = None, NoStop = None):
        """
This function sets the target force iteration parameters for the specified load case.
The function returns zero if the parameters are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
TolConvF: The relative convergence tolerance for target force iteration.
MaxIter: The maximum iterations per stage for target force iteration.
AccelFact: The acceleration factor.
NoStop: If this item is True, the analysis is continued when there is no convergence in the target force iteration.
        """

        all_args = [Name, TolConvF, MaxIter, AccelFact, NoStop]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearStaged.SetTargetForceParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTargetForceParameters" failed')
        
        return ret

class StaticLinear:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static linear load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticLinear.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, SF = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static linear load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for Accel UX UY and UZ; otherwise unitless
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticLinear.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a static linear load case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticLinear.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static linear load case.
InitialCase: This is blank, None or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else then zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticLinear.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, SF = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static linear load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for Accel UX UY and UZ; otherwise unitless
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticLinear.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

class StaticLinearMultistep:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise, it returns a nonzero value.

Name: The name of an existing static linear multistep analysis case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticLinearMultistep.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLoads_1(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, SF = None, StepRange = None, FirstLoadStep = None, LastLoadStep = None, StartCaseStep = None, ExtrapolateOption = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise, it returns a nonzero value.

Name: The name of an existing static linear multistep analysis case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for Accel UX UY and UZ; otherwise unitless
StepRange: This is an array that identifies the step range type to consider for each load assigned to the load case. The allowed values are:
0 = All
1 = User

FirstLoadStep: This is an array that specifies the first load step to consider for each load assigned to the load case. This value is only applicable when StepRange = User.
LastLoadStep: This is an array that specifies the last load step to consider for each load assigned to the load case. This value is only applicable when StepRange = User.
StartCaseStep: This is an array that specifies the load case step at which to start applying each load assigned to the load case.
ExtrapolateOption: This is an array that identifies the extrapolation option for each load assigned to the load case. The allowed values are:
0 = None
1 = Last Step
2 = Repeat Range
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, SF, StepRange, FirstLoadStep, LastLoadStep, StartCaseStep, ExtrapolateOption]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticLinearMultistep.GetLoads_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads_1" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a static linear multistep analysis case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise, it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticLinearMultistep.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static linear multistep analysis case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticLinearMultistep.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoads_1(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, SF = None, StepRange = None, FirstLoadStep = None, LastLoadStep = None, StartCaseStep = None, ExtrapolateOption = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static linear multistep analysis case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for Accel UX UY and UZ; otherwise unitless
StepRange: This is an array that identifies the step range type to consider for each load assigned to the load case. The allowed values are:
0 = All
1 = User

FirstLoadStep: This is an array that specifies the first load step to consider for each load assigned to the load case. This value is only applicable when StepRange = User.
LastLoadStep: This is an array that specifies the last load step to consider for each load assigned to the load case. This value is only applicable when StepRange = User.
StartCaseStep: This is an array that specifies the load case step at which to start applying each load assigned to the load case.
ExtrapolateOption: This is an array that identifies the extrapolation option for each load assigned to the load case. The allowed values are:
0 = None
1 = Last Step
2 = Repeat Range
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, SF, StepRange, FirstLoadStep, LastLoadStep, StartCaseStep, ExtrapolateOption]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticLinearMultistep.SetLoads_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads_1" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, SF = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise, it returns a nonzero value.

Name: The name of an existing static linear multistep analysis case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for Accel UX UY and UZ; otherwise unitless
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticLinearMultistep.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, SF = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static linear multistep analysis case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for Accel UX UY and UZ; otherwise unitless
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticLinearMultistep.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

class StaticNonlinear:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetGeometricNonlinearity(self, Name = None, NLGeomType = None):
        """
This function retrieves the geometric nonlinearity option for the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
NLGeomType: This is 0, 1 or 2, indicating the geometric nonlinearity option selected for the load case.
0 = None
1 = P-delta
2 = P-delta plus large displacements
        """

        all_args = [Name, NLGeomType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetGeometricNonlinearity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGeometricNonlinearity" failed')
        
        return ret

    def GetHingeUnloading(self, Name = None, UnloadType = None):
        """
This function retrieves the hinge unloading option for the specified load case.
The function returns zero if the option is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
UnloadType: This is 1, 2 or 3, indicating the hinge unloading option selected for the load case.
1 = Unload entire structure
2 = Apply local redistribution
3 = Restart using secant stiffness
        """

        all_args = [Name, UnloadType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetHingeUnloading(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetHingeUnloading" failed')
        
        return ret

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts from the state at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the state at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLoadApplication(self, Name = None, LoadControl = None, DispType = None, Displ = None, Monitor = None, DOF = None, PointName = None, GDispl = None):
        """
This function retrieves the load application control parameters for the specified load case.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
LoadControl: This is either 1 or 2, indicating the load application control method.
1 = Full load
2 = Displacement control
DispType: This is either 1 or 2, indicating the control displacement type.
1 = Conjugate displacement
2 = Monitored displacement

This item applies only when displacement control is used, that is, LoadControl = 2.
Displ: This item applies only when displacement control is used, that is, LoadControl = 2. The structure is loaded to a monitored displacement of this magnitude. [L] when DOF = 1, 2 or 3 and [rad] when DOF = 4, 5 or 6
Monitor: This is either 1 or 2, indicating the monitored displacement.
1 = Displacement at a specified point object
2 = Generalized displacement
DOF: This is 1, 2, 3, 4, 5 or 6, indicating the degree of freedom for which the displacement at a point object is monitored.
1 = U1
2 = U2
3 = U3
4 = R1
5 = R2
6 = R3

This item applies only when Monitor = 1.
PointName: The name of the point object at which the displacement is monitored. This item applies only when Monitor = 1.
GDispl: The name of the generalized displacement for which the displacement is monitored. This item applies only when Monitor = 2.
        """

        all_args = [Name, LoadControl, DispType, Displ, Monitor, DOF, PointName, GDispl]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetLoadApplication(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadApplication" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, SF = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for Accel UX UY and UZ; otherwise unitless
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def GetModalCase(self, Name = None, ModalCase = None):
        """
This function retrieves the modal case assigned to the specified load case.
The function returns zero if the modal case is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
ModalCase: This is either None or the name of an existing modal analysis case. It specifies the modal load case on which any mode-type load assignments to the specified load case are based.
        """

        all_args = [Name, ModalCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetModalCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModalCase" failed')
        
        return ret

    def GetResultsSaved(self, Name = None, SaveMultipleSteps = None, MinSavedStates = None, MaxSavedStates = None, PositiveOnly = None):
        """
This function retrieves the results saved parameters for the specified load case.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
SaveMultipleSteps: This item is True if multiple states are saved for the nonlinear analysis. It is False only if the final state is saved.
MinSavedStates: This item applies only when SaveMultipleSteps = True. It is the minimum number of saved steps.
MaxSavedStates: This item applies only when SaveMultipleSteps = True. It is the maximum number of saved steps.
PositiveOnly: If this item is True, only positive displacement increments are saved. If it is False, all displacement increments are saved.
        """

        all_args = [Name, SaveMultipleSteps, MinSavedStates, MaxSavedStates, PositiveOnly]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetResultsSaved(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetResultsSaved" failed')
        
        return ret

    def GetSolControlParameters(self, Name = None, MaxTotalSteps = None, MaxFailedSubSteps = None, MaxIterCS = None, MaxIterNR = None, TolConvD = None, UseEventStepping = None, TolEventD = None, MaxLineSearchPerIter = None, TolLineSearch = None, LineSearchStepFact = None):
        """
This function retrieves the solution control parameters for the specified load case.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
MaxTotalSteps: The maximum total steps per stage.
MaxFailedSubSteps: The maximum null (zero) steps per stage.
MaxIterCS: The maximum constant-stiffness iterations per step.
MaxIterNR: The maximum Newton_Raphson iterations per step.
TolConvD: The relative iteration convergence tolerance.
UseEventStepping: This item is True if event-to-event stepping is used.
TolEventD: The relative event lumping tolerance.
MaxLineSearchPerIter: The maximum number of line searches per iteration.
TolLineSearch: The relative line-search acceptance tolerance.
LineSearchStepFact: The line-search step factor.
        """

        all_args = [Name, MaxTotalSteps, MaxFailedSubSteps, MaxIterCS, MaxIterNR, TolConvD, UseEventStepping, TolEventD, MaxLineSearchPerIter, TolLineSearch, LineSearchStepFact]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetSolControlParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSolControlParameters" failed')
        
        return ret

    def GetTargetForceParameters(self, Name = None, TolConvF = None, MaxIter = None, AccelFact = None, NoStop = None):
        """
This function retrieves the target force iteration parameters for the specified load case.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
TolConvF: The relative convergence tolerance for target force iteration.
MaxIter: The maximum iterations per stage for target force iteration.
AccelFact: The acceleration factor.
NoStop: If this item is True, the analysis is continued when there is no convergence in the target force iteration.
        """

        all_args = [Name, TolConvF, MaxIter, AccelFact, NoStop]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetTargetForceParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTargetForceParameters" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a static nonlinear analysis case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetGeometricNonlinearity(self, Name = None, NLGeomType = None):
        """
This function sets the geometric nonlinearity option for the specified load case.
The function returns zero if the option is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
NLGeomType: This is 0, 1 or 2, indicating the geometric nonlinearity option selected for the load case.
0 = None
1 = P-delta
2 = P-delta plus large displacements
        """

        all_args = [Name, NLGeomType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetGeometricNonlinearity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGeometricNonlinearity" failed')
        
        return ret

    def SetHingeUnloading(self, Name = None, UnloadType = None):
        """
This function sets the hinge unloading option for the specified load case.
The function returns zero if the option is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
UnloadType: This is 1, 2 or 3, indicating the hinge unloading option selected for the load case.
1 = Unload entire structure
2 = Apply local redistribution
3 = Restart using secant stiffness
        """

        all_args = [Name, UnloadType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetHingeUnloading(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetHingeUnloading" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts from the state at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the state at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoadApplication(self, Name = None, LoadControl = None, DispType = None, Displ = None, Monitor = None, DOF = None, PointName = None, GDispl = None):
        """
This function sets the load application control parameters for the specified load case.
The function returns zero if the parameters are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
LoadControl: This is either 1 or 2, indicating the load application control method.
1 = Full load
2 = Displacement control
DispType: This is either 1 or 2 indicating the control displacement type.
1 = Conjugate displacement
2 = Monitored displacement

This item applies only when displacement control is used, that is, LoadControl = 2.
Displ: This item applies only when displacement control is used, that is, LoadControl = 2. The structure is loaded to a monitored displacement of this magnitude. [L] when DOF = 1, 2 or 3 and [rad] when DOF = 4, 5 or 6
Monitor: This is either 1 or 2, indicating the monitored displacement.
1 = Displacement at a specified point object
2 = Generalized displacement
DOF: This is 1, 2, 3, 4, 5 or 6, indicating the degree of freedom for which the displacement at a point object is monitored.
1 = U1
2 = U2
3 = U3
4 = R1
5 = R2
6 = R3

This item applies only when Monitor = 1.
PointName: The name of the point object at which the displacement is monitored. This item applies only when Monitor = 1.
GDispl: The name of the generalized displacement for which the displacement is monitored. This item applies only when Monitor = 2.
        """

        all_args = [Name, LoadControl, DispType, Displ, Monitor, DOF, PointName, GDispl]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetLoadApplication(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadApplication" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, SF = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ indicating the direction of the load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for Accel UX UY and UZ; otherwise unitless
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

    def SetMassSource(self, Name = None, Source = None):
        """
This function sets the mass source to be used for the specified load case.
The function returns zero if the mass source is data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
Source: This is the name of an existing mass source or a blank string. Blank indicates to use the mass source from the previous load case or the default mass source if the load case starts from zero initial conditions.
        """

        all_args = [Name, Source]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetMassSource(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMassSource" failed')
        
        return ret

    def SetModalCase(self, Name = None, ModalCase = None):
        """
This function sets the modal case for the specified analysis case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.
If the specified modal case is not actually a modal case, the program automatically replaces it with the first modal case it can find. If no modal load cases exist, an error is returned.

Name: The name of an existing static nonlinear load case.
ModalCase: This is the name of an existing modal load case. It specifies the modal load case on which any mode-type load assignments to the specified load case are based.
        """

        all_args = [Name, ModalCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetModalCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModalCase" failed')
        
        return ret

    def SetResultsSaved(self, Name = None, SaveMultipleSteps = None, MinSavedStates = None, MaxSavedStates = None, PositiveOnly = None):
        """
This function sets the results saved parameters for the specified load case.
The function returns zero if the parameters are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
SaveMultipleSteps: This item is True if multiple states are saved for the nonlinear analysis. It is False only if the final state is saved.
MinSavedStates: This item only applies when SaveMultipleSteps = True. It is the minimum number of saved steps.
MaxSavedStates: This item only applies when SaveMultipleSteps = True. It is the maximum number of saved steps.
PositiveOnly: If this item is True, only positive displacement increments are saved. If it is False, all displacement increments are saved.
        """

        all_args = [Name, SaveMultipleSteps, MinSavedStates, MaxSavedStates, PositiveOnly]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetResultsSaved(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetResultsSaved" failed')
        
        return ret

    def SetSolControlParameters(self, Name = None, MaxTotalSteps = None, MaxFailedSubSteps = None, MaxIterCS = None, MaxIterNR = None, TolConvD = None, UseEventStepping = None, TolEventD = None, MaxLineSearchPerIter = None, TolLineSearch = None, LineSearchStepFact = None):
        """
This function sets the solution control parameters for the specified load case.
The function returns zero if the parameters are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
MaxTotalSteps: The maximum total steps per stage.
MaxFailedSubSteps: The maximum null (zero) steps per stage.
MaxIterCS: The maximum constant-stiffness iterations per step.
MaxIterNR: The maximum Newton_Raphson iterations per step.
TolConvD: The relative iteration convergence tolerance.
UseEventStepping: This item is True if event-to-event stepping is used.
TolEventD: The relative event lumping tolerance.
MaxLineSearchPerIter: The maximum number of line searches per iteration.
TolLineSearch: The relative line-search acceptance tolerance.
LineSearchStepFact: The line-search step factor.
        """

        all_args = [Name, MaxTotalSteps, MaxFailedSubSteps, MaxIterCS, MaxIterNR, TolConvD, UseEventStepping, TolEventD, MaxLineSearchPerIter, TolLineSearch, LineSearchStepFact]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetSolControlParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSolControlParameters" failed')
        
        return ret

    def SetTargetForceParameters(self, Name = None, TolConvF = None, MaxIter = None, AccelFact = None, NoStop = None):
        """
This function sets the target force iteration parameters for the specified load case.
The function returns zero if the parameters are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear load case.
TolConvF: The relative convergence tolerance for target force iteration.
MaxIter: The maximum iterations per stage for target force iteration.
AccelFact: The acceleration factor.
NoStop: If this item is True, the analysis is continued when there is no convergence in the target force iteration.
        """

        all_args = [Name, TolConvF, MaxIter, AccelFact, NoStop]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetTargetForceParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTargetForceParameters" failed')
        
        return ret

    def GetStageData(self, Name = None, Stage = None, NumberOperations = None, Operation = None, GroupName = None, Age = None, LoadType = None, LoadName = None, SF = None):
        """
This function retrieves stage data for the specified stage in the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
Stage: The stage in the specified load case for which data is requested. Stages are numbered sequentially starting from 1.
NumberOperations: The number of operations in the specified stage.
Operation: This is an array that includes 1, 2, 3 or 4, indicating an operation type.
1 = Add structure
2 = Remove structure
3 = Load added items in group
4 = Load all items in group
GroupName: This is an array that includes the name of the group associated with the specified operation.
Age: This is an array that includes the age of the added structure, at the time it is added, in days. This item applies only to operations with Operation = 1.
LoadType: This is an array that includes either Load or Accel, indicating the load type of an added load. This item applies only to operations with Operation = 3 or 4.
LoadName: This is an array that includes the name of the load assigned to the operation. This item applies only to operations with Operation = 3 or 4.
If the associated LoadType item is Load, this item is the name of a defined load pattern.
If the associated LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor for the load assigned to the operation. [L/s2] for Accel UX UY and UZ; otherwise unitless
This item applies only to operations with Operation = 3 or 4.
        """

        all_args = [Name, Stage, NumberOperations, Operation, GroupName, Age, LoadType, LoadName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetStageData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetStageData" failed')
        
        return ret

    def GetStageData_1(self, Name = None, Stage = None, NumberOperations = None, Operation = None, ObjectType = None, ObjectName = None, Age = None, MyType = None, MyName = None, SF = None):
        """
This function retrieves stage data for the specified stage in the specified load case.
The function returns zero if the data is successfully retrieved; otherwise, it returns a nonzero value.

Name: The name of an existing static nonlinear staged load case.
Stage: The stage in the specified load case for which data is requested. Stages are numbered sequentially starting from 1.
NumberOperations: The number of operations in the specified stage.
Operation: This is an array that includes 1, 2, 3, 4, 5, 6, 7, or 11, indicating an operation type.
1 = Add structure
2 = Remove structure
3 = Load objects if new
4 = Load objects
5 = Change section properties
6 = Change section property modifiers
7 = Change releases
11 = Change section properties and age
ObjectType: This is an array that includes the object type associated with the specified operation. The object type may be one of the following:
Group
Frame
Cable
Tendon
Area
Solid
Link
Point

The following list shows which object types are applicable to each operation type:
Operation = 1 (Add structure):All object types
Operation = 2 (Remove structure):All object types
Operation = 3 (Load objects if new):All object types
Operation = 4 (Load objects):All object types
Operation = 5 (Change section properties):All object types except Point
Operation = 6 (Change section property modifiers):Group, Frame, Cable, Area
Operation = 7 (Change releases):Group, Frame
Operation = 11 (Change section properties and age): All object types except Point
ObjectName: This is an array that includes the name of the object associated with the specified operation. This is the name of a Group, Frame object, Cable object, Tendon object, Area object, Solid object, Link object or Point object, depending on the ObjectType item.
Age: This is an array that includes the age of the added structure, at the time it is added, in days. This item applies only to operations with Operation = 1.
MyType: This is an array that includes a load type or an object type, depending on what is specified for the Operation item. This item applies only to operations with Operation = 3, 4, 5, 6, 7, or 11.
When Operation = 3 or 4, this is an array that includes Load or Accel, indicating the load type of an added load.
When Operation = 5 or 11, and the ObjectType item is Group, this is an array that includes Frame, Cable, Tendon, Area, Solid or Link, indicating the object type for which the section property is changed.
When Operation = 6 and the ObjectType item is Group, this is an array that includes Frame, Cable or Area, indicating the object type for which the section property modifiers are changed.
When Operation = 7 and the ObjectType item is Group, this is an array that includes Frame, indicating the object type for which the releases are changed.
When Operation = 5, 6, 7, or 11, and the ObjectType item is not Group and not Point, this item is ignored and the type is picked up from the ObjectType item.
MyName: This is an array that includes a load assignment or an object name, depending on what is specified for the Operation item. This item applies only to operations with Operation = 3, 4, 5, 6, 7, or 11.
When Operation = 3 or 4, this is an array that includes the name of the load assigned to the operation. If the associated LoadType item is Load, this item is the name of a defined load pattern. If the associated LoadType item is Accel , this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
When Operation = 5 or 11, this is the name of a Frame, Cable, Tendon, Area, Solid or Link object, depending on the object type specified.
When Operation = 6, this is the name of a Frame, Cable or Area object, depending on the object type specified.
When Operation = 7, this is the name of a Frame object.
SF: This is an array that includes the scale factor for the load assigned to the operation, if any. [L/s2] for Accel UX UY and UZ; otherwise unitless
This item applies only to operations with Operation = 3 or 4.
        """

        all_args = [Name, Stage, NumberOperations, Operation, ObjectType, ObjectName, Age, MyType, MyName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetStageData_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetStageData_1" failed')
        
        return ret

    def GetStageDefinitions(self, Name = None, NumberStages = None, Duration = None, Comment = None):
        """
This function retrieves the stage definition data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
NumberStages: The number of stages defined for the specified analysis case.
Duration: This is an array that includes the duration in days for each stage.
Comment: This is an array that includes a comment for each stage. The comment may be a blank string.
        """

        all_args = [Name, NumberStages, Duration, Comment]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetStageDefinitions(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetStageDefinitions" failed')
        
        return ret

    def GetStageDefinitions_1(self, Name = None, NumberStages = None, Duration = None, Output = None, OutputName = None, Comment = None):
        """
This function retrieves the stage definition data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged load case.
NumberStages: The number of stages defined for the specified load case.
Duration: This is an array that includes the duration in days for each stage.
Output: This is an array that includes True or False, indicating if analysis output is to be saved for each stage.
OutputName: This is an array that includes a user-specified output name for each stage.
Comment: This is an array that includes a comment for each stage. The comment may be a blank string.
        """

        all_args = [Name, NumberStages, Duration, Output, OutputName, Comment]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.GetStageDefinitions_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetStageDefinitions_1" failed')
        
        return ret

    def SetStageData(self, Name = None, Stage = None, NumberOperations = None, Operation = None, GroupName = None, Age = None, LoadType = None, LoadName = None, SF = None):
        """
This function sets the stage data for the specified stage in the specified load case. All previous stage data for the specified stage is cleared when this function is called.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
Stage: The stage in the specified load case to which the data applies. Stages are numbered sequentially starting from 1.
NumberOperations: The number of operations in the specified stage.
Operation: This is an array that includes 1, 2, 3 or 4, indicating an operation type.
1 = Add structure
2 = Remove structure
3 = Load added items in group
4 = Load all items in group
GroupName: This is an array that includes the name of the group associated with the specified operation.
Age: This is an array that includes the age of the added structure, at the time it is added, in days. This item applies only to operations with Operation = 1.
LoadType: This is an array that includes either Load or Accel, indicating the load type of an added load. This item applies only to operations with Operation = 3 or 4.
LoadName: This is an array that includes the name of the load assigned to the operation. This item applies only to operations with Operation = 3 or 4.
If the associated LoadType item is Load, this item is the name of a defined load pattern.
If the associated LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor for the load assigned to the operation. [L/s2] for Accel UX UY and UZ; otherwise unitless
This item applies only to operations with Operation = 3 or 4.
        """

        all_args = [Name, Stage, NumberOperations, Operation, GroupName, Age, LoadType, LoadName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetStageData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetStageData" failed')
        
        return ret

    def SetStageData_1(self, Name = None, Stage = None, NumberOperations = None, Operation = None, ObjectType = None, ObjectName = None, Age = None, MyType = None, MyName = None, SF = None):
        """
This function sets the stage data for the specified stage in the specified load case. All previous stage data for the specified stage is cleared when this function is called.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged load case.
Stage: The stage in the specified load case to which the data applies. Stages are numbered sequentially starting from 1.
NumberOperations: The number of operations in the specified stage.
Operation: This is an array that includes 1, 2, 3, 4, 5, 6, 7, or 11, indicating an operation type.
1 = Add structure
2 = Remove structure
3 = Load objects if new
4 = Load objects
5 = Change section properties
6 = Change section property modifiers
7 = Change releases
11 = Change section properties and age
ObjectType: This is an array that includes the object type associated with the specified operation. The object type may be one of the following:
Group
Frame
Cable
Tendon
Area
Solid
Link
Point

The following list shows which object types are applicable to each operation type:
Operation = 1 (Add structure):All object types
Operation = 2 (Remove structure):All object types
Operation = 3 (Load objects if new):All object types
Operation = 4 (Load objects):All object types
Operation = 5 (Change section properties):All object types except Point
Operation = 6 (Change section property modifiers):Group, Frame, Cable, Area
Operation = 7 (Change releases):Group, Frame
Operation = 11 (Change section properties and age): All object types except Point
ObjectName: This is an array that includes the name of the object associated with the specified operation. This is the name of a Group, Frame object, Cable object, Tendon object, Area object, Solid object, Link object or Point object, depending on the ObjectType item.
Age: This is an array that includes the age of the added structure, at the time it is added, in days. This item applies only to operations with Operation = 1.
MyType: This is an array that includes a load type or an object type, depending on what is specified for the Operation item. This item applies only to operations with Operation = 3, 4, 5, 6, 7, or 11.
When Operation = 3 or 4, this is an array that includes Load or Accel, indicating the load type of an added load.
When Operation = 5 or 11, and the ObjectType item is Group, this is an array that includes Frame, Cable, Tendon, Area, Solid or Link, indicating the object type for which the section property is changed.
When Operation = 6 and the ObjectType item is Group, this is an array that includes Frame, Cable or Area, indicating the object type for which the section property modifiers are changed.
When Operation = 7 and the ObjectType item is Group, this is an array that includes Frame, indicating the object type for which the releases are changed.
When Operation = 5, 6, 7, or 11, and the ObjectType item is not Group and not Point, this item is ignored and the type is picked up from the ObjectType item.
MyName: This is an array that includes a load assignment or an object name, depending on what is specified for the Operation item. This item applies only to operations with Operation = 3, 4, 5, 6, 7 or 11.
When Operation = 3 or 4, this is an array that includes the name of the load assigned to the operation. If the associated LoadType item is Load, this item is the name of a defined load pattern. If the associated LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
When Operation = 5 or 11, this is the name of a Frame, Cable, Tendon, Area, Solid or Link object, depending on the object type specified.
When Operation = 6, this is the name of a Frame, Cable or Area object, depending on the object type specified.
When Operation = 7, this is the name of a Frame object.
SF: This is an array that includes the scale factor for the load assigned to the operation, if any. [L/s2] for Accel UX UY and UZ; otherwise unitless
This item applies only to operations with Operation = 3 or 4.
        """

        all_args = [Name, Stage, NumberOperations, Operation, ObjectType, ObjectName, Age, MyType, MyName, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetStageData_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetStageData_1" failed')
        
        return ret

    def SetStageDefinitions(self, Name = None, NumberStages = None, Duration = None, Comment = None):
        """
This function initializes the stage definition data for the specified load case. All previous stage definition data for the case is cleared when this function is called.
The function returns zero if the data is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear staged analysis case.
NumberStages: The number of stages defined for the specified analysis case.
Duration: This is an array that includes the duration in days for each stage.
Comment: This is an array that includes a comment for each stage. The comment may be a blank string.
        """

        all_args = [Name, NumberStages, Duration, Comment]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetStageDefinitions(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetStageDefinitions" failed')
        
        return ret

    def SetStageDefinitions_1(self, Name = None, NumberStages = None, Duration = None, Output = None, OutputName = None, Comment = None):
        """
This function initializes the stage definition data for the specified load case. All previous stage definition data for the case is cleared when this function is called.
The function returns zero if the data is successfully initialized; otherwise, it returns a nonzero value.

Name: The name of an existing static nonlinear staged load case.
NumberStages: The number of stages defined for the specified load case.
Duration: This is an array that includes the duration in days for each stage.
Output: This is an array that includes True or False, indicating if analysis output is to be saved for each stage.
OutputName: This is an array that includes a user-specified output name for each stage.
Comment: This is an array that includes a comment for each stage. The comment may be a blank string.
        """

        all_args = [Name, NumberStages, Duration, Output, OutputName, Comment]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinear.SetStageDefinitions_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetStageDefinitions_1" failed')
        
        return ret

class StaticNonlinearMultistep:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear multistep load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the state at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearMultistep.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, SF = None, StepRange = None, FirstLoadStep = None, LastLoadStep = None, StartCaseStep = None, ExtrapolateOption = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear multistep load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for Accel UX UY and UZ; otherwise unitless
StepRange: This is an array that identifies the step range type to consider for each load assigned to the load case. The allowed values are:
0 = All
1 = User

FirstLoadStep: This is an array that specifies the first load step to consider for each load assigned to the load case. This value is only applicable when StepRange = User.
LastLoadStep: This is an array that specifies the last load step to consider for each load assigned to the load case. This value is only applicable when StepRange = User.
StartCaseStep: This is an array that specifies the load case step at which to start applying each load assigned to the load case.
ExtrapolateOption: This is an array that identifies the extrapolation option for each load assigned to the load case. The allowed values are:
0 = None
1 = Last Step
2 = Repeat Range
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, SF, StepRange, FirstLoadStep, LastLoadStep, StartCaseStep, ExtrapolateOption]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearMultistep.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a static nonlinear multistep analysis case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise, it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case, that case is modified; otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearMultistep.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear multistep load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts from the state at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed .
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearMultistep.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, SF = None, StepRange = None, FirstLoadStep = None, LastLoadStep = None, StartCaseStep = None, ExtrapolateOption = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing static nonlinear multistep analysis case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is UX, UY, UZ, RX, RY or RZ, indicating the direction of the load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for Accel UX UY and UZ; otherwise unitless
StepRange: This is an array that identifies the step range type to consider for each load assigned to the load case. The allowed values are:
0 = All
1 = User

FirstLoadStep: This is an array that specifies the first load step to consider for each load assigned to the load case. This value is only applicable when StepRange = User.
LastLoadStep: This is an array that specifies the last load step to consider for each load assigned to the load case. This value is only applicable when StepRange = User.
StartCaseStep: This is an array that specifies the load case step at which to start applying each load assigned to the load case.
ExtrapolateOption: This is an array that identifies the extrapolation option for each load assigned to the load case. The allowed values are:
0 = None
1 = Last Step
2 = Repeat Range
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, SF, StepRange, FirstLoadStep, LastLoadStep, StartCaseStep, ExtrapolateOption]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.StaticNonlinearMultistep.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

class SteadyState:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetDampConstant(self, Name = None, HysConMassCoeff = None, HysConStiffCoeff = None):
        """
This function retrieves the constant hysteretic damping for all frequencies assigned to the specified load case.
The function returns zero if the damping is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing steady state load case that has constant damping.
HysConMassCoeff: The mass proportional damping coefficient.
HysConStiffCoeff: The stiffness proportional damping coefficient.
        """

        all_args = [Name, HysConMassCoeff, HysConStiffCoeff]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SteadyState.GetDampConstant(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampConstant" failed')
        
        return ret

    def GetDampInterpolated(self, Name = None, HysIntFreqUnits = None, HysIntNumFreqs = None, HysIntFreq = None, HysIntMassCoeff = None, HysIntStiffCoeff = None):
        """
This function retrieves the interpolated hysteretic damping by frequency assigned to the specified load case.
The function returns zero if the damping is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing steady state load case that has interpolated damping.
HysIntFreqUnits: This is 1 or 2, indicating the units for the frequency.
1 = Hz [cyc/s]
2 = RPM
HysIntNumFreqs: The number of sets of frequency, mass coefficient and stiffness coefficient data.
HysIntFreq: This is an array of frequencies. The frequency is in Hz or RPM, depending on the value of HysIntFreqUnits.
HysIntMassCoeff: This is an array that includes the mass proportional damping coefficient.
HysIntStiffCoeff: This is an array that includes the stiffness proportional damping coefficient.
        """

        all_args = [Name, HysIntFreqUnits, HysIntNumFreqs, HysIntFreq, HysIntMassCoeff, HysIntStiffCoeff]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SteadyState.GetDampInterpolated(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampInterpolated" failed')
        
        return ret

    def GetDampType(self, Name = None, DampType = None):
        """
This function retrieves the hysteretic damping type for the specified load case.
The function returns zero if the type is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing steady state load case.
DampType: This is 1 or 2, indicating the hysteretic damping type for the load case.
1 = Constant hysteretic damping for all frequencies
2 = Interpolated hysteretic damping by frequency
        """

        all_args = [Name, DampType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SteadyState.GetDampType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDampType" failed')
        
        return ret

    def GetFreqData(self, Name = None, FreqFirst = None, FreqLast = None, FreqNumIncs = None, FreqAddModal = None, FreqAddModalDev = None, FreqAddSpecified = None, ModalCase = None, FreqNumModalDev = None, FreqModalDev = None, FreqNumSpecified = None, FreqSpecified = None):
        """
This function retrieves the frequency data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing steady state load case.
FreqFirst: The first frequency. [cyc/s]
FreqLast: The last frequency. [cyc/s]
FreqNumIncs: The number of frequency increments.
FreqAddModal: If this item is True then modal frequencies are added.
FreqAddModalDev: If this item is True then signed fractional deviations from modal frequencies are added.
FreqAddSpecified: If this item is True, specified frequencies are added.
ModalCase: This is the name of an existing modal load case. It specifies the modal load case on which modal frequencies and modal frequency deviations are based.
FreqNumModalDev: The number of signed fractional deviations from modal frequencies that are added. This item applies only when FreqAddModalDev = True.
FreqModalDev: This is an array that includes the added signed fractional deviations from modal frequencies. This item applies only when FreqAddModalDev = True.
FreqNumSpecified: The number of specified frequencies that are added. This item applies only when FreqAddSpecified = True.
FreqSpecified: This is an array that includes the added specified frequencies. This item applies only when FreqAddModalDev = True.
        """

        all_args = [Name, FreqFirst, FreqLast, FreqNumIncs, FreqAddModal, FreqAddModalDev, FreqAddSpecified, ModalCase, FreqNumModalDev, FreqModalDev, FreqNumSpecified, FreqSpecified]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SteadyState.GetFreqData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetFreqData" failed')
        
        return ret

    def GetInitialCase(self, Name = None, InitialCase = None):
        """
This function retrieves the initial condition assumed for the specified load case.
The function returns zero if the initial condition is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing steady state load case.
InitialCase: This is blank, None, or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SteadyState.GetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInitialCase" failed')
        
        return ret

    def GetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, Func = None, SF = None, PhaseAngle = None, CSys = None, Ang = None):
        """
This function retrieves the load data for the specified load case.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing steady state load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the steady state function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
PhaseAngle: This is an array that includes the phase angle. [deg]
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
This item applies only when the LoadType item is Accel.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
This item applies only when the LoadType item is Accel.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, Func, SF, PhaseAngle, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SteadyState.GetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoads" failed')
        
        return ret

    def SetCase(self, Name = None):
        """
This function initializes a steady state load case. If this function is called for an existing load case, all items for the case are reset to their default value.
The function returns zero if the load case is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new load case. If this is an existing case then that case is modified, otherwise, a new case is added.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SteadyState.SetCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCase" failed')
        
        return ret

    def SetDampConstant(self, Name = None, HysConMassCoeff = None, HysConStiffCoeff = None):
        """
This function sets constant hysteretic damping for all frequencies for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing steady state load case.
HysConMassCoeff: The mass proportional damping coefficient.
HysConStiffCoeff: The stiffness proportional damping coefficient.
        """

        all_args = [Name, HysConMassCoeff, HysConStiffCoeff]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SteadyState.SetDampConstant(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampConstant" failed')
        
        return ret

    def SetDampInterpolated(self, Name = None, HysIntFreqUnits = None, HysIntNumFreqs = None, HysIntFreq = None, HysIntMassCoeff = None, HysIntStiffCoeff = None):
        """
This function sets interpolated hysteretic damping by frequency for the specified load case.
The function returns zero if the damping is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing steady state load case.
HysIntFreqUnits: This is either 1 or 2, indicating the units for the frequency.
1 = Hz [cyc/s]
2 = RPM
HysIntNumFreqs: The number of sets of frequency, mass coefficient and stiffness coefficient data.
HysIntFreq: This is an array of frequencies. The frequency is either in Hz or RPM depending on the value of HysIntFreqUnits.
HysIntMassCoeff: This is an array that includes the mass proportional damping coefficient.
HysIntStiffCoeff: This is an array that includes the stiffness proportional damping coefficient.
        """

        all_args = [Name, HysIntFreqUnits, HysIntNumFreqs, HysIntFreq, HysIntMassCoeff, HysIntStiffCoeff]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SteadyState.SetDampInterpolated(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDampInterpolated" failed')
        
        return ret

    def SetFreqData(self, Name = None, FreqFirst = None, FreqLast = None, FreqNumIncs = None, FreqAddModal = None, FreqAddModalDev = None, FreqAddSpecified = None, ModalCase = None, FreqNumModalDev = None, FreqModalDev = None, FreqNumSpecified = None, FreqSpecified = None):
        """
This function sets the frequency data for the specified load case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing steady state load case.
FreqFirst: The first frequency. [cyc/s]
FreqLast: The last frequency. [cyc/s]
FreqNumIncs: The number of frequency increments.
FreqAddModal: If this item is True, modal frequencies are added.
FreqAddModalDev: If this item is True, signed fractional deviations from modal frequencies are added.
FreqAddSpecified: If this item is True, specified frequencies are added.
ModalCase: This is the name of an existing modal load case. It specifies the modal load case on which modal frequencies and modal frequency deviations are based.
FreqNumModalDev: The number of signed fractional deviations from modal frequencies that are added. This item applies only when FreqAddModalDev = True.
FreqModalDev: This is an array that includes the added signed fractional deviations from modal frequencies. This item applies only when FreqAddModalDev = True.
FreqNumSpecified: The number of specified frequencies that are added. This item applies only when FreqAddSpecified = True.
FreqSpecified: This is an array that includes the added specified frequencies. This item applies only when FreqAddModalDev = True.
        """

        all_args = [Name, FreqFirst, FreqLast, FreqNumIncs, FreqAddModal, FreqAddModalDev, FreqAddSpecified, ModalCase, FreqNumModalDev, FreqModalDev, FreqNumSpecified, FreqSpecified]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SteadyState.SetFreqData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFreqData" failed')
        
        return ret

    def SetInitialCase(self, Name = None, InitialCase = None):
        """
This function sets the initial condition for the specified load case.
The function returns zero if the initial condition is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing steady state load case.
InitialCase: This is blank, None or the name of an existing analysis case. This item specifies if the load case starts from zero initial conditions, that is, an unstressed state, or if it starts using the stiffness that occurs at the end of a nonlinear static or nonlinear direct integration time history load case.
If the specified initial case is a nonlinear static or nonlinear direct integration time history load case, the stiffness at the end of that case is used. If the initial case is anything else, zero initial conditions are assumed.
        """

        all_args = [Name, InitialCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SteadyState.SetInitialCase(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInitialCase" failed')
        
        return ret

    def SetLoads(self, Name = None, NumberLoads = None, LoadType = None, LoadName = None, Func = None, SF = None, PhaseAngle = None, CSys = None, Ang = None):
        """
This function sets the load data for the specified analysis case.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing steady state load case.
NumberLoads: The number of loads assigned to the specified analysis case.
LoadType: This is an array that includes either Load or Accel, indicating the type of each load assigned to the load case.
LoadName: This is an array that includes the name of each load assigned to the load case.
If the LoadType item is Load, this item is the name of a defined load pattern.
If the LoadType item is Accel, this item is U1, U2, U3, R1, R2 or R3, indicating the direction of the load.
Func: This is an array that includes the name of the steady state function associated with each load.
SF: This is an array that includes the scale factor of each load assigned to the load case. [L/s2] for U1 U2 and U3; otherwise unitless
PhaseAngle: This is an array that includes the phase angle. [deg]
CSys: This is an array that includes the name of the coordinate system associated with each load. If this item is a blank string, the Global coordinate system is assumed.
This item applies only when the LoadType item is Accel.
Ang: This is an array that includes the angle between the acceleration local 1 axis and the +X-axis of the coordinate system specified by the CSys item. The rotation is about the Z-axis of the specified coordinate system. [deg]
This item applies only when the LoadType item is Accel.
        """

        all_args = [Name, NumberLoads, LoadType, LoadName, Func, SF, PhaseAngle, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadCases.SteadyState.SetLoads(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoads" failed')
        
        return ret

class LoadPatterns:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.AutoSeastate = AutoSeastate(strict, api)
        self.AutoSeismic = AutoSeismic(strict, api)
        self.AutoWindBridge = AutoWindBridge(strict, api)
        self.AutoWind = AutoWind(strict, api)

    def Add(self, Name = None, MyType = None, SelfWTMultiplier = None, AddLoadCase = None):
        """
This function adds a new load pattern.
The function returns 0 if the load pattern is successfully added; otherwise it returns nonzero. An error is returned if the Name item is already used for an existing load pattern.

Name: The name for the new load pattern.
MyType: This is one of the following items in the eLoadPatternType enumeration:
LTYPE_DEAD = 1
LTYPE_SUPERDEAD = 2
LTYPE_LIVE = 3
LTYPE_REDUCELIVE = 4
LTYPE_QUAKE = 5
LTYPE_WIND= 6
LTYPE_SNOW = 7
LTYPE_OTHER = 8
LTYPE_MOVE = 9
LTYPE_TEMPERATURE = 10
LTYPE_ROOFLIVE = 11
LTYPE_NOTIONAL = 12
LTYPE_PATTERNLIVE = 13
LTYPE_WAVE= 14
LTYPE_BRAKING = 15
LTYPE_CENTRIFUGAL = 16
LTYPE_FRICTION = 17
LTYPE_ICE = 18
LTYPE_WINDONLIVELOAD = 19
LTYPE_HORIZONTALEARTHPRESSURE = 20
LTYPE_VERTICALEARTHPRESSURE = 21
LTYPE_EARTHSURCHARGE = 22
LTYPE_DOWNDRAG = 23
LTYPE_VEHICLECOLLISION = 24
LTYPE_VESSELCOLLISION = 25
LTYPE_TEMPERATUREGRADIENT = 26
LTYPE_SETTLEMENT = 27
LTYPE_SHRINKAGE = 28
LTYPE_CREEP = 29
LTYPE_WATERLOADPRESSURE = 30
LTYPE_LIVELOADSURCHARGE = 31
LTYPE_LOCKEDINFORCES = 32
LTYPE_PEDESTRIANLL = 33
LTYPE_PRESTRESS = 34
LTYPE_HYPERSTATIC = 35
LTYPE_BOUYANCY = 36
LTYPE_STREAMFLOW = 37
LTYPE_IMPACT = 38
LTYPE_CONSTRUCTION = 39
SelfWTMultiplier: The self weight multiplier for the new load pattern.
AddLoadCase: If this item is True, a linear static load case corresponding to the new load pattern is added.
        """

        all_args = [Name, MyType, SelfWTMultiplier, AddLoadCase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.Add(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Add" failed')
        
        return ret

    def ChangeName(self, Name = None, NewName = None):
        """
This function applies a new name to a load pattern.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The name of a defined load pattern.
NewName: The new name for the load pattern.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
The function returns the number of defined load patterns.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes the specified load pattern.
The function returns zero if the load pattern is successfully deleted, otherwise it returns a nonzero value.
The load pattern is not deleted and the function returns an error if the load pattern is assigned to an load case or if it is the only defined load pattern.

Name: The name of an existing load pattern.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetAutoSeismicCode(self, Name = None, CodeName = None):
        """
This function retrieves the code name used for auto seismic parameters in Quake-type load patterns.
The function returns zero if the code is successfully retrieved; otherwise it returns a nonzero value. An error is returned if the specified load pattern is not a Quake-type load pattern.

Name: The name of an existing Quake-type load pattern.
CodeName: This is either blank or the name code used for the auto seismic parameters. Blank means no auto seismic load is specified for the Quake-type load pattern.
        """

        all_args = [Name, CodeName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.GetAutoSeismicCode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAutoSeismicCode" failed')
        
        return ret

    def GetAutoWaveCode(self, Name = None, CodeName = None):
        """
This function retrieves the code name used for auto wave parameters in Wave-type load patterns.
The function returns zero if the code is successfully retrieved; otherwise it returns a nonzero value. An error is returned if the specified load pattern is not a Wave-type load pattern.

Name: The name of an existing Wave-type load pattern.
CodeName: This is either blank or the name code used for the auto wave parameters. Blank means no auto wave load is specified for the Wave-type load pattern.
        """

        all_args = [Name, CodeName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.GetAutoWaveCode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAutoWaveCode" failed')
        
        return ret

    def GetAutoWindCode(self, Name = None, CodeName = None):
        """
This function retrieves the code name used for auto wind parameters in Wind-type load patterns.
The function returns zero if the code is successfully retrieved; otherwise it returns a nonzero value. An error is returned if the specified load pattern is not a Wind-type load pattern.

Name: The name of an existing Wind-type load pattern.
CodeName: This is either blank or the name code used for the auto wind parameters. Blank means no auto wind load is specified for the Wind-type load pattern.
        """

        all_args = [Name, CodeName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.GetAutoWindCode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAutoWindCode" failed')
        
        return ret

    def GetLoadType(self, Name = None, MyType = None):
        """
This function retrieves the load type for a specified load pattern.
The function returns zero if the load type is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing load pattern.
MyType: This is one of the following items in the eLoadPatternType enumeration:
LTYPE_DEAD = 1
LTYPE_SUPERDEAD = 2
LTYPE_LIVE = 3
LTYPE_REDUCELIVE = 4
LTYPE_QUAKE = 5
LTYPE_WIND= 6
LTYPE_SNOW = 7
LTYPE_OTHER = 8
LTYPE_MOVE = 9
LTYPE_TEMPERATURE = 10
LTYPE_ROOFLIVE = 11
LTYPE_NOTIONAL = 12
LTYPE_PATTERNLIVE = 13
LTYPE_WAVE= 14
LTYPE_BRAKING = 15
LTYPE_CENTRIFUGAL = 16
LTYPE_FRICTION = 17
LTYPE_ICE = 18
LTYPE_WINDONLIVELOAD = 19
LTYPE_HORIZONTALEARTHPRESSURE = 20
LTYPE_VERTICALEARTHPRESSURE = 21
LTYPE_EARTHSURCHARGE = 22
LTYPE_DOWNDRAG = 23
LTYPE_VEHICLECOLLISION = 24
LTYPE_VESSELCOLLISION = 25
LTYPE_TEMPERATUREGRADIENT = 26
LTYPE_SETTLEMENT = 27
LTYPE_SHRINKAGE = 28
LTYPE_CREEP = 29
LTYPE_WATERLOADPRESSURE = 30
LTYPE_LIVELOADSURCHARGE = 31
LTYPE_LOCKEDINFORCES = 32
LTYPE_PEDESTRIANLL = 33
LTYPE_PRESTRESS = 34
LTYPE_HYPERSTATIC = 35
LTYPE_BOUYANCY = 36
LTYPE_STREAMFLOW = 37
LTYPE_IMPACT = 38
LTYPE_CONSTRUCTION = 39
        """

        all_args = [Name, MyType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.GetLoadType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadType" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined load cases.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of load pattern names retrieved by the program.
MyName: This is a one-dimensional array of load pattern names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetSelfWtMultiplier(self, Name = None, SelfWTMultiplier = None):
        """
This function retrieves the self weight multiplier for a specified load pattern.
The function returns zero if the multiplier is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing load pattern.
SelfWTMultiplier: The self weight multiplier for the specified load pattern.
        """

        all_args = [Name, SelfWTMultiplier]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.GetSelfWtMultiplier(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSelfWtMultiplier" failed')
        
        return ret

    def SetLoadType(self, Name = None, MyType = None):
        """
This function assigns a load type to a load pattern.
The function returns zero if the load type is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing load pattern.
MyType: This is one of the following items in the eLoadPatternType enumeration:
LTYPE_DEAD = 1
LTYPE_SUPERDEAD = 2
LTYPE_LIVE = 3
LTYPE_REDUCELIVE = 4
LTYPE_QUAKE = 5
LTYPE_WIND= 6
LTYPE_SNOW = 7
LTYPE_OTHER = 8
LTYPE_MOVE = 9
LTYPE_TEMPERATURE = 10
LTYPE_ROOFLIVE = 11
LTYPE_NOTIONAL = 12
LTYPE_PATTERNLIVE = 13
LTYPE_WAVE= 14
LTYPE_BRAKING = 15
LTYPE_CENTRIFUGAL = 16
LTYPE_FRICTION = 17
LTYPE_ICE = 18
LTYPE_WINDONLIVELOAD = 19
LTYPE_HORIZONTALEARTHPRESSURE = 20
LTYPE_VERTICALEARTHPRESSURE = 21
LTYPE_EARTHSURCHARGE = 22
LTYPE_DOWNDRAG = 23
LTYPE_VEHICLECOLLISION = 24
LTYPE_VESSELCOLLISION = 25
LTYPE_TEMPERATUREGRADIENT = 26
LTYPE_SETTLEMENT = 27
LTYPE_SHRINKAGE = 28
LTYPE_CREEP = 29
LTYPE_WATERLOADPRESSURE = 30
LTYPE_LIVELOADSURCHARGE = 31
LTYPE_LOCKEDINFORCES = 32
LTYPE_PEDESTRIANLL = 33
LTYPE_PRESTRESS = 34
LTYPE_HYPERSTATIC = 35
LTYPE_BOUYANCY = 36
LTYPE_STREAMFLOW = 37
LTYPE_IMPACT = 38
LTYPE_CONSTRUCTION = 39
        """

        all_args = [Name, MyType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.SetLoadType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadType" failed')
        
        return ret

    def SetSelfWtMultiplier(self, Name = None, SelfWTMultiplier = None):
        """
This function assigns a self weight multiplier to a load case.
The function returns zero if the multiplier is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing load pattern.
SelfWTMultiplier: The self weight multiplier for the specified load pattern.
        """

        all_args = [Name, SelfWTMultiplier]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.SetSelfWtMultiplier(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSelfWtMultiplier" failed')
        
        return ret

class AutoSeastate:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetAuto(self, Name = None, LoadMethod = None, CSys = None, AdjustGravityLat = None, AdjustGravityLatFactor = None, AdjustGravityVert = None, AdjustGravityVertFactor = None, CenterRotation = None, Parameters = None, IgnorePhase = None):
        """
This function retrieves auto seastate loading parameters.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing seastate-type load pattern.
LoadMethod: This is one of the following three options defining what parameters are being specified.
1 = Rotation / Translations Vertical Input
2 = Rotations / Translations Full Input
3 = Accelerations / Velocities
CSys: The coordinate system used as a reference for specifying the center of rotation location and the inertia load parameters.
AdjustGravityLat: This item only applies when using LoadMethod 1 or 2. It is True if generated lateral loads should include the effects of the rotated structure, otherwise it is False.
AdjustGravityLatFactor: This item only applies when using LoadMethod 1 or 2. This is a scale factor on the lateral effects generated as a result of the rotated structure.
AdjustGravityVert: This item only applies when using LoadMethod 1 or 2. It is True if generated vertical loads should include the effects of the rotated structure, otherwise it is False.
AdjustGravityVertFactor: This item only applies when using LoadMethod 1 or 2. This is a scale factor on the vertical effects generated as a result of the rotated structure.
CenterRotation: This is an array dimensioned to 2 (3 doubles) that defines the coordinates of the center of rotation, with respect to the selected coordinate system.
Parameters: This is an array of the inertia load parameters, based on the specified LoadMethod, as described below.
If LoadMethod = 1, the following 9 parameters should be input:
Parameters(0) - UZ amplitude
Parameters(1) - UZ period
Parameters(2) - UZ phase
Parameters(3) - RX amplitude
Parameters(4) - RX period
Parameters(5) - RX phase
Parameters(6) - RY amplitude
Parameters(7) - RY period
Parameters(8) - RY phase
If the LoadMethod = 2, the following 18 parameters should be input:
Parameters(0) - UX amplitude
Parameters(1) - UX period
Parameters(2) - UX phase
Parameters(3) - UY amplitude
Parameters(4) - UY period
Parameters(5) - UY phase
Parameters(6) - UZ amplitude
Parameters(7) - UZ period
Parameters(8) - UZ phase
Parameters(9) - RX amplitude
Parameters(10) - RX period
Parameters(11) - RX phase
Parameters(12) - RY amplitude
Parameters(13) - RY period
Parameters(14) - RY phase
Parameters(15) - RZ amplitude
Parameters(16) - RZ period
Parameters(17) - RZ phase
If the LoadMethod = 3, the following 9 parameters should be input:
Parameters(0) - Acceleration UX
Parameters(1) - Acceleration UY
Parameters(2) - Acceleration UZ
Parameters(3) - Acceleration RX
Parameters(4) - Acceleration RY
Parameters(5) - Acceleration RZ
Parameters(6) - Velocity RX
Parameters(7) - Velocity RY
Parameters(8) - Velocity RZ
IgnorePhase: This item only applies when using LoadMethod 1 or 2. It is True if the input phases should be ignored, otherwise it is False.
        """

        all_args = [Name, LoadMethod, CSys, AdjustGravityLat, AdjustGravityLatFactor, AdjustGravityVert, AdjustGravityVertFactor, CenterRotation, Parameters, IgnorePhase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeastate.GetAuto(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAuto" failed')
        
        return ret

    def SetAuto(self, Name = None, LoadMethod = None, CSys = None, AdjustGravityLat = None, AdjustGravityLatFactor = None, AdjustGravityVert = None, AdjustGravityVertFactor = None, CenterRotation = None, Parameters = None, IgnorePhase = None):
        """
This function retrieves auto seastate loading parameters.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing seastate-type load pattern.
LoadMethod: This is one of the following three options defining what parameters are being specified.
1 = Rotation / Translations Vertical Input
2 = Rotations / Translations Full Input
3 = Accelerations / Velocities
CSys: The coordinate system used as a reference for specifying the center of rotation location and the inertia load parameters.
AdjustGravityLat: This item only applies when using LoadMethod 1 or 2. It is True if generated lateral loads should include the effects of the rotated structure, otherwise it is False.
AdjustGravityLatFactor: This item only applies when using LoadMethod 1 or 2. This is a scale factor on the lateral effects generated as a result of the rotated structure.
AdjustGravityVert: This item only applies when using LoadMethod 1 or 2. It is True if generated vertical loads should include the effects of the rotated structure, otherwise it is False.
AdjustGravityVertFactor: This item only applies when using LoadMethod 1 or 2. This is a scale factor on the vertical effects generated as a result of the rotated structure.
CenterRotation: This is an array dimensioned to 2 (3 doubles) that defines the coordinates of the center of rotation, with respect to the selected coordinate system.
Parameters: This is an array of the inertia load parameters, based on the specified LoadMethod, as described below.
If LoadMethod = 1, the following 9 parameters should be input:
Parameters(0) - UZ amplitude
Parameters(1) - UZ period
Parameters(2) - UZ phase
Parameters(3) - RX amplitude
Parameters(4) - RX period
Parameters(5) - RX phase
Parameters(6) - RY amplitude
Parameters(7) - RY period
Parameters(8) - RY phase
If the LoadMethod = 2, the following 18 parameters should be input:
Parameters(0) - UX amplitude
Parameters(1) - UX period
Parameters(2) - UX phase
Parameters(3) - UY amplitude
Parameters(4) - UY period
Parameters(5) - UY phase
Parameters(6) - UZ amplitude
Parameters(7) - UZ period
Parameters(8) - UZ phase
Parameters(9) - RX amplitude
Parameters(10) - RX period
Parameters(11) - RX phase
Parameters(12) - RY amplitude
Parameters(13) - RY period
Parameters(14) - RY phase
Parameters(15) - RZ amplitude
Parameters(16) - RZ period
Parameters(17) - RZ phase
If the LoadMethod = 3, the following 9 parameters should be input:
Parameters(0) - Acceleration UX
Parameters(1) - Acceleration UY
Parameters(2) - Acceleration UZ
Parameters(3) - Acceleration RX
Parameters(4) - Acceleration RY
Parameters(5) - Acceleration RZ
Parameters(6) - Velocity RX
Parameters(7) - Velocity RY
Parameters(8) - Velocity RZ
IgnorePhase: This item only applies when using LoadMethod 1 or 2. It is True if the input phases should be ignored, otherwise it is False.
        """

        all_args = [Name, LoadMethod, CSys, AdjustGravityLat, AdjustGravityLatFactor, AdjustGravityVert, AdjustGravityVertFactor, CenterRotation, Parameters, IgnorePhase]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeastate.SetAuto(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAuto" failed')
        
        return ret

    def SetNone(self, Name = None):
        """
This function sets the auto seastate loading type for the specified load pattern to None.
The function returns zero if the loading type is successfully assigned; otherwise it returns a nonzero vale.

Name: The name of an existing seastate-type load pattern.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeastate.SetNone(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNone" failed')
        
        return ret

class AutoSeismic:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetAS11702007(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, AS2007SiteClass = None, AS2007kp = None, AS2007Z = None, AS2007Sp = None, AS2007Mu = None):
        """
This function retrieves auto seismic loading parameters for the AS 1170 2007 code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a AS 1170 2007 auto seismic load assignment.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified kt factor. This item applies when the PeriodFlag item is 1.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
AS2007SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
AS2007kp: The probability factor, kp.
AS2007Z: The hazard factor, Z.
AS2007Sp: The structural performance factor, Sp.
AS2007Mu: The structural ductility factor, u.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, AS2007SiteClass, AS2007kp, AS2007Z, AS2007Sp, AS2007Mu]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetAS11702007(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAS11702007" failed')
        
        return ret

    def GetChinese2010(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, JGJ32010AlphaMax = None, JGJ32010SI = None, JGJ32010DampRatio = None, JGJ32010Tg = None, JGJ32010PTDF = None, EnhancementFactor = None):
        """
This function retrieves auto seismic loading parameters for the Chinese 2010 code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a Chinese 2010 auto seismic load assignment.
DirFlag: This is 1, 2 or 3, indicating the seismic load direction.
1 = Global X
2 = Global Y
3 = Global Z
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is either 2 or 3, indicating the time period option.
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
JGJ32010AlphaMax: The maximum influence factor.
JGJ32010SI: This is 1, 2, 3, 4, 5 or 6, indicating the seismic intensity.
1 = 6(0.05g)
2 = 7(0.10g)
3 = 7(0.15g)
4 = 8(0.20g)
5 = 8(0.30g)
6 = 9(0.40g)
JGJ32010DampRatio: The damping ratio.
JGJ32010Tg: The characteristic ground period. [s]
JGJ32010PTDF: The period time discount factor.
EnhancementFactor: The enhancement factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, UserT, UserZ, TopZ, BottomZ, JGJ32010AlphaMax, JGJ32010SI, JGJ32010DampRatio, JGJ32010Tg, JGJ32010PTDF, EnhancementFactor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetChinese2010(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetChinese2010" failed')
        
        return ret

    def GetDiaphragmEccentricityOverride(self, Name = None, Num = None, Diaph = None, Eccen = None):
        """
This function retrieves diaphragm eccentricity overrides for auto seismic loads. This function does not apply for User Load type auto seismic loads.
The function returns zero if the overrides are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern that has an auto seismic load assigned.
Num: The number of diaphragm eccentricity overrides for the specified load pattern.
Diaph: This is an array that includes the names of the diaphragms which have eccentricity overrides.
Eccen: This is an array that includes the eccentricity applied to each diaphragm. [L]
        """

        all_args = [Name, Num, Diaph, Eccen]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetDiaphragmEccentricityOverride(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDiaphragmEccentricityOverride" failed')
        
        return ret

    def GetEurocode82004_1(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, EURO2004Country = None, EURO2004SpectrumType = None, EURO2004GroundType = None, EURO2004ag = None, EURO2004S = None, EURO2004Tb = None, EURO2004Tc = None, EURO2004Td = None, EURO2004Beta = None, EURO2004q = None, EURO2004Lambda = None):
        """
This function retrieves auto seismic loading parameters for the Eurocode 8 2004 code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a Eurocode 8 2004 auto seismic load assignment.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified Ct factor. This item applies when the PeriodFlag item is 1.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
EURO2004Country: This is 0, 1, 5, 6 or 10 indicating the country for which the Nationally Determined Parameters (NDPs) are specified.
0 = Other (NDPs are user specified)
1 = CEN Default
5 = Norway
6 = Singapore
10 = Portugal
EURO2004SpectrumType: This is 1 or 2, indicating the spectrum type.
1 = Type 1
2 = Type 2 (Does not apply when EURO2004Country = 5 or 6)
EURO2004GroundType: This is 1, 2, 3, 4 or 5, or 6, indicating the ground type.
1 = A (Does not apply when EURO2004Country = 6)
2 = B (Does not apply when EURO2004Country = 6)
3 = C
4 = D
5 = E (Does not apply when EURO2004Country = 6)
6 = S1 (Only applies when EURO2004Country = 6)
EURO2004ag: The design ground acceleration in g, ag.
EURO2004S: The soil factor, S.
EURO2004Tb: The lower limit of period of the constant spectral acceleration branch, Tb.
EURO2004Tc: The upper limit of period of the constant spectral acceleration branch, Tc.
EURO2004Td: The period defining the start of the constant displacement range, Td.
EURO2004Beta: The lower bound factor, Beta.
EURO2004q: The behavior factor, q.
EURO2004Lambda: The correction factor, Lambda.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, EURO2004Country, EURO2004SpectrumType, EURO2004GroundType, EURO2004ag, EURO2004S, EURO2004Tb, EURO2004Tc, EURO2004Td, EURO2004Beta, EURO2004q, EURO2004Lambda]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetEurocode82004_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEurocode82004_1" failed')
        
        return ret

    def GetIBC2003(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, IBC2003SG = None, IBC2003SeismicCoeffFlag = None, IBC2003Site = None, IBC2003SS = None, IBC2003S1 = None, IBC2003Fa = None, IBC2003Fv = None, IBC2003R = None, IBC2003Omega = None, IBC2003Cd = None):
        """
This function retrieves auto seismic loading parameters for the 2003 IBC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a IBC2003 auto seismic load assignment.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified CT factor (ft). This item applies when the PeriodFlag item is 1 or 2.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
IBC2003SG: This is 1, 2 or 3, indicating the seismic group.
1 = I
2 = II
3 = III
IBC2003SeismicCoeffFlag: This is either 1 or 2, indicating the seismic coefficient option.
1 = Coefficients are per code
2 = Coefficients are user defined
IBC2003Site: This is either 1, 2, 3, 4 or 5, indicating the site class. This item is filled only when the IBC2003SeismicCoeffFlag = 1.
1 = A
2 = B
3 = C
4 = D
5 = E
IBC2003SS: The response acceleration for short periods, (g).
IBC2003S1: The response acceleration for a one second period, (g).
IBC2003Fa: The site coefficient Fa.
IBC2003Fv: The site coefficient Fv.
IBC2003R: The response modification factor.
IBC2003Omega: The system overstrength factor.
IBC2003Cd: The deflection amplification factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, IBC2003SG, IBC2003SeismicCoeffFlag, IBC2003Site, IBC2003SS, IBC2003S1, IBC2003Fa, IBC2003Fv, IBC2003R, IBC2003Omega, IBC2003Cd]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetIBC2003(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetIBC2003" failed')
        
        return ret

    def GetIBC2006(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, IBC2006CtType = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, IBC2006R = None, IBC2006Omega = None, IBC2006Cd = None, IBC2006I = None, IBC2006Option = None, IBC2006Latitude = None, IBC2006Longitude = None, IBC2006ZipCode = None, IBC2006SS = None, IBC2006S1 = None, IBC2006TL = None, IBC2006SiteClass = None, IBC2006Fa = None, IBC2006Fv = None):
        """
This function retrieves auto seismic loading parameters for the 2006 IBC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a IBC2006 auto seismic load assignment.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
IBC2006CtType: This is 0, 1, 2 or 3, indicating the values of Ct and x. This item is meaningful when the PeriodFlag item is 1 or 2.
0 = Ct = 0.028 (ft),x = 0.8
1 = Ct = 0.016 (ft),x = 0.9
2 = Ct = 0.03 (ft),x = 0.75
3 = Ct = 0.02 (ft),x = 0.75
UserT: The user specified time period. This item is meaningful when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
IBC2006R: The response modification factor.
IBC2006Omega: The system overstrength factor.
IBC2006Cd: The deflection amplification factor.
IBC2006I: The occupancy importance factor.
IBC2006Option: This is 0, 1 or 2, indicating the seismic coefficient option.
0 = Ss and S1 from USGS by latitude and longitude
1 = Ss and S1 from USGS by zip code
2 = Ss and S1 are user defined
IBC2006Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when IBC2006Option = 0 or 1.
IBC2006Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when IBC2006Option = 0 or 1.
IBC2006ZipCode: The zip code for which the seismic coefficients are obtained. This item is meaningful only when IBC2006Option = 1.
IBC2006SS: The seismic coefficients Ss and S1.
IBC2006S1: The seismic coefficients Ss and S1.
IBC2006TL: The long-period transition period. [s]
IBC2006SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
IBC2006Fa: The site coefficients Fa and Fv.
IBC2006Fv: The site coefficients Fa and Fv.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, IBC2006CtType, UserT, UserZ, TopZ, BottomZ, IBC2006R, IBC2006Omega, IBC2006Cd, IBC2006I, IBC2006Option, IBC2006Latitude, IBC2006Longitude, IBC2006ZipCode, IBC2006SS, IBC2006S1, IBC2006TL, IBC2006SiteClass, IBC2006Fa, IBC2006Fv]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetIBC2006(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetIBC2006" failed')
        
        return ret

    def GetIBC2009(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CtType = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, R = None, Omega = None, Cd = None, I = None, IBC2009Option = None, Latitude = None, Longitude = None, ZipCode = None, SS = None, S1 = None, TL = None, SiteClass = None, Fa = None, Fv = None):
        """
This function retrieves auto seismic loading parameters for the 2009 IBC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a IBC2009 auto seismic load assignment.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CtType: This is 0, 1, 2 or 3, indicating the values of Ct and x. This item is meaningful when the PeriodFlag item is 1 or 2.
0 = Ct = 0.028 (ft),x = 0.8
1 = Ct = 0.016 (ft),x = 0.9
2 = Ct = 0.03 (ft),x = 0.75
3 = Ct = 0.02 (ft),x = 0.75
UserT: The user specified time period. This item is meaningful when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
R: The response modification factor.
Omega: The system overstrength factor.
Cd: The deflection amplification factor.
I: The occupancy importance factor.
IBC2009Option: This is 0, 1 or 2, indicating the seismic coefficient option.
0 = Ss and S1 from USGS by latitude and longitude
1 = Ss and S1 from USGS by zip code
2 = Ss and S1 are user defined
Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when IBC2009Option = 0 or 1.
Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when IBC2009Option = 0 or 1.
ZipCode: The zip code for which the seismic coefficients are obtained. This item is meaningful only when IBC2009Option = 1.
SS: The seismic coefficients Ss and S1.
S1: The seismic coefficients Ss and S1.
TL: The long-period transition period. [s]
SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
Fa: The site coefficients Fa and Fv.
Fv: The site coefficients Fa and Fv.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CtType, UserT, UserZ, TopZ, BottomZ, R, Omega, Cd, I, IBC2009Option, Latitude, Longitude, ZipCode, SS, S1, TL, SiteClass, Fa, Fv]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetIBC2009(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetIBC2009" failed')
        
        return ret

    def GetIBC2012(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CtType = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, R = None, Omega = None, Cd = None, I = None, IBC2012Option = None, Latitude = None, Longitude = None, ZipCode = None, SS = None, S1 = None, TL = None, SiteClass = None, Fa = None, Fv = None):
        """
This function retrieves auto seismic loading parameters for the 2012 IBC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a IBC2012 auto seismic load assignment.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CtType: This is 0, 1, 2 or 3, indicating the values of Ct and x. This item is meaningful when the PeriodFlag item is 1 or 2.
0 = Ct = 0.028 (ft),x = 0.8
1 = Ct = 0.016 (ft),x = 0.9
2 = Ct = 0.03 (ft),x = 0.75
3 = Ct = 0.02 (ft),x = 0.75
UserT: The user specified time period. This item is meaningful when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
R: The response modification factor.
Omega: The system overstrength factor.
Cd: The deflection amplification factor.
I: The occupancy importance factor.
IBC2012Option: This is 0, 1 or 2, indicating the seismic coefficient option.
0 = Ss and S1 from USGS by latitude and longitude
1 = Ss and S1 from USGS by zip code
2 = Ss and S1 are user defined
Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when IBC2012Option = 0 or 1.
Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when IBC2012Option = 0 or 1.
ZipCode: The zip code for which the seismic coefficients are obtained. This item is meaningful only when IBC2012Option = 1.
SS: The seismic coefficients Ss and S1.
S1: The seismic coefficients Ss and S1.
TL: The long-period transition period. [s]
SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
Fa: The site coefficients Fa and Fv.
Fv: The site coefficients Fa and Fv.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CtType, UserT, UserZ, TopZ, BottomZ, R, Omega, Cd, I, IBC2012Option, Latitude, Longitude, ZipCode, SS, S1, TL, SiteClass, Fa, Fv]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetIBC2012(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetIBC2012" failed')
        
        return ret

    def GetIS1893_2002(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, INZFlag = None, INZ = None, INS = None, BOCA96R = None, INR = None):
        """
This function retrieves auto seismic loading parameters for the 2002 IS1893 code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with an IS1893_2002 auto seismic load assignment.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified CT factor (m). This item applies when the PeriodFlag item is 1.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
INZFlag: This is either 1 or 2, indicating if the seismic zone factor is per code or user defined.
1 = Per code
2 = User defined
INZ: The seismic zone factor, Z.
If the seismic zone factor is per code (INZFlag = 1), this item should be one of the following: 0.10, 0.16, 0.24, 0.36.
INS: This is 1, 2 or 3, indicating the soil type.
1 = I
2 = II
3 = III
BOCA96R: The response modification factor.
INR: The response modification factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, INZFlag, INZ, INS, BOCA96R, INR]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetIS1893_2002(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetIS1893_2002" failed')
        
        return ret

    def GetNBCC2005(self, Name = None, DirFlag = None, Eccen = None, NBCC2005CtType = None, NBCC95DS = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, NBCC2005PGA = None, NBCC2005S02 = None, NBCC2005S05 = None, NBCC2005S1 = None, NBCC2005S2 = None, NBCC2005SiteClass = None, NBCC2005Fa = None, NBCC2005Fv = None, NBCC2005I = None, NBCC2005Mv = None, NBCC2005Rd = None, NBCC2005Ro = None):
        """
This function retrieves auto seismic loading parameters for the 2005 NBCC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a NBCC2005 auto seismic load assignment.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
NBCC2005CtType: This is 0, 1, 2, 3 or 4, indicating the structure type.
0 = Steel moment frame
1 = Concrete moment frame
2 = Other moment frame
3 = Braced frame
4 = Shear wall
NBCC95DS: This item applies only when the NBCCPFlag = 2. It is the dimension of the lateral load resisting system in the direction of the applied forces. [L]
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Code
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
NBCC2005PGA: The peak ground acceleration.
NBCC2005S02: The spectral acceleration at a 0.2 second period.
NBCC2005S05: The spectral acceleration at a 0.52 second period.
NBCC2005S1: The spectral acceleration at a 1 second period.
NBCC2005S2: The spectral acceleration at a 2 second period.
NBCC2005SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
NBCC2005Fa: The site coefficient, Fa.
NBCC2005Fv: The site coefficient, Fv.
NBCC2005I: The importance factor.
NBCC2005Mv: The higher mode factor.
NBCC2005Rd: The ductility modifier.
NBCC2005Ro: The overstrength modifier.
        """

        all_args = [Name, DirFlag, Eccen, NBCC2005CtType, NBCC95DS, PeriodFlag, UserT, UserZ, TopZ, BottomZ, NBCC2005PGA, NBCC2005S02, NBCC2005S05, NBCC2005S1, NBCC2005S2, NBCC2005SiteClass, NBCC2005Fa, NBCC2005Fv, NBCC2005I, NBCC2005Mv, NBCC2005Rd, NBCC2005Ro]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetNBCC2005(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNBCC2005" failed')
        
        return ret

    def GetNBCC2010(self, Name = None, DirFlag = None, Eccen = None, CtType = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, PGA = None, S02 = None, S05 = None, S1 = None, S2 = None, S4 = None, SiteClass = None, Fa = None, Fv = None, I = None, Mv = None, Rd = None, Ro = None):
        """
This function retrieves auto seismic loading parameters for the 2010 NBCC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a NBCC2010 auto seismic load assignment.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
CtType: This is 0, 1, 2, 3 or 4, indicating the structure type.
0 = Steel moment frame
1 = Concrete moment frame
2 = Other moment frame
3 = Braced frame
4 = Shear wall
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Code
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
PGA: The peak ground acceleration.
S02: The spectral acceleration at a 0.2 second period.
S05: The spectral acceleration at a 0.5 second period.
S1: The spectral acceleration at a 1 second period.
S2: The spectral acceleration at a 2 second period.
S4: The spectral acceleration at a 4 second period.

SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
Fa: The site coefficient, Fa.
Fv: The site coefficient, Fv.
I: The importance factor.
Mv: The higher mode factor.
Rd: The ductility modifier.
Ro: The overstrength modifier.
        """

        all_args = [Name, DirFlag, Eccen, CtType, PeriodFlag, UserT, UserZ, TopZ, BottomZ, PGA, S02, S05, S1, S2, S4, SiteClass, Fa, Fv, I, Mv, Rd, Ro]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetNBCC2010(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNBCC2010" failed')
        
        return ret

    def GetNBCC2015(self, Name = None, DirFlag = None, Eccen = None, CtType = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, PGA = None, S02 = None, S05 = None, S1 = None, S2 = None, S5 = None, S10 = None, SiteClass = None, F02 = None, F05 = None, F1 = None, F2 = None, F5 = None, F10 = None, I = None, Mv = None, Rd = None, Ro = None):
        """
This function retrieves auto seismic loading parameters for the 2015 NBCC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a NBCC2015 auto seismic load assignment.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
CtType: This is 0, 1, 2, 3 or 4, indicating the structure type.
0 = Steel moment frame
1 = Concrete moment frame
2 = Other moment frame
3 = Braced frame
4 = Shear wall
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Code
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
PGA: The peak ground acceleration.
S02: The spectral acceleration at a 0.2 second period.
S05: The spectral acceleration at a 0.5 second period.
S1: The spectral acceleration at a 1 second period.
S2: The spectral acceleration at a 2 second period.
S5: The spectral acceleration at a 5 second period.
S10: The spectral acceleration at a 10 second period.
SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
F02: The site coefficient at a 0.2 second period. This item is read when the site class is F only.
F05: The site coefficientat a 0.5 second period. This item is read when the site class is F only.
F1: The site coefficient at a 1 second period. This item is read when the site class is F only.
F2: The site coefficient at a 2 second period. This item is read when the site class is F only.
F5: The site coefficient at a 5 second period. This item is read when the site class is F only.
F10: The site coefficient at a 10 second period. This item is read when the site class is F only.
I: The importance factor.
Mv: The higher mode factor.
Rd: The ductility modifier.
Ro: The overstrength modifier.
        """

        all_args = [Name, DirFlag, Eccen, CtType, PeriodFlag, UserT, UserZ, TopZ, BottomZ, PGA, S02, S05, S1, S2, S5, S10, SiteClass, F02, F05, F1, F2, F5, F10, I, Mv, Rd, Ro]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetNBCC2015(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNBCC2015" failed')
        
        return ret

    def GetNBCC95(self, Name = None, DirFlag = None, Eccen = None, NBCCPFlag = None, NBCC95DS = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, NBCC95ZA = None, NBCC95ZV = None, NBCC95ZVFlag = None, NBCC95ZVR = None, NBCC95I = None, NBCC95F = None, NBCC95R = None):
        """
This function retrieves auto seismic loading parameters for the 1995 NBCC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a NBCC95 auto seismic load assignment.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
NBCCPFlag: This is either 1 or 2, indicating the structure type.
1 = Moment frame
2 = Other
NBCC95DS: This item applies only when the NBCCPFlag = 2. It is the dimension of the lateral load resisting system in the direction of the applied forces. [L]
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Code
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
NBCC95ZA: This is 0, 1, 2, 3, 4, 5 or 6, indicating the acceleration related zone, Za.
NBCC95ZV: This is 0, 1, 2, 3, 4, 5 or 6, indicating the velocity related zone, Zv.
NBCC95ZVFlag: This is either 1 or 2, indicating how the zonal velocity ratio, V, is specified.
1 = From code based on Zv
2 = User specified
NBCC95ZVR: The zonal velocity ratio, V.
NBCC95I: The importance factor.
NBCC95F: The foundation factor.
NBCC95R: The force modification factor.
        """

        all_args = [Name, DirFlag, Eccen, NBCCPFlag, NBCC95DS, PeriodFlag, UserT, UserZ, TopZ, BottomZ, NBCC95ZA, NBCC95ZV, NBCC95ZVFlag, NBCC95ZVR, NBCC95I, NBCC95F, NBCC95R]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetNBCC95(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNBCC95" failed')
        
        return ret

    def GetNEHRP97(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, NEHRP97SG = None, NEHRP97SeismicCoeffFlag = None, NEHRP97Site = None, NEHRP97SS = None, NEHRP97S1 = None, NEHRP97Fa = None, NEHRP97Fv = None, NEHRP97R = None):
        """
This function retrieves auto seismic loading parameters for the 1997 NEHRP code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a NEHRP97 auto seismic load assignment.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified CT factor. This item applies when the PeriodFlag item is 1 or 2.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
NEHRP97SG: This is 1, 2 or 3, indicating the seismic group.
1 = I
2 = II
3 = III
NEHRP97SeismicCoeffFlag: This is 1 or 2, indicating the seismic coefficient option.
1 = Coefficients are per code
2 = Coefficients are user defined
NEHRP97Site: This is 1, 2, 3, 4 or 5, indicating the site class. This item is only filled when the NEHRP97SeismicCoeffFlag = 1.
1 = A
2 = B
3 = C
4 = D
5 = E
NEHRP97SS: The response acceleration for short periods, (g).
NEHRP97S1: The response acceleration for a one second period, (g).
NEHRP97Fa: The site coefficient Fa.
NEHRP97Fv: The site coefficient Fv.
NEHRP97R: The response modification factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, NEHRP97SG, NEHRP97SeismicCoeffFlag, NEHRP97Site, NEHRP97SS, NEHRP97S1, NEHRP97Fa, NEHRP97Fv, NEHRP97R]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetNEHRP97(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNEHRP97" failed')
        
        return ret

    def GetNTC2008(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CIType = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, ParamsOption = None, Latitude = None, Longitude = None, Island = None, LimitState = None, UsageClass = None, NomLife = None, PeakAccel = None, F0 = None, Tcs = None, SpecType = None, SoilType = None, Topography = None, hRatio = None, Damping = None, q = None, Lambda = None):
        """
This function retrieves auto seismic loading parameters for the NTC 2008 code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a NTC 2008 auto seismic load assignment.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CIType: This is 0, 1, 2 or 3, indicating the values of C1. This item applies when the PeriodFlag item is 1 or 2.
1 = C1 = 0.085 (m)
2 = C1 = 0.075 (m)
3 = C1 = 0.05 (m)
UserT: The user specified time period. This item is meaningful when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
ParamsOption: This is 1, 2, or 3, indicating the option for defining the parameters.
1 = by latitude and longitude
2 = by island
3 = user specified
Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Island: This is one of the following values. This item is used only when ParamsOption = 2.
1 = Alicudi2 = Arcipelago Toscano3 = Filcudi4 = Isole Egadi5 = Lampedusa6 = Linosa7 = Lipari8 = Palmarola9 = Panarea10 = Pantelleria11 = Ponza12 = Salina13 = Santo Stefano14 = Sardegna15 = Stromboli16 = Tremiti17 = Ustica18 = Ventotene19 = Vulcano20 = Zannone
LimitState: This is 1, 2, 3, or 4, indicating the limit state.
1 = SLO
2 = SLD
3 = SLV
4 = SLC
UsageClass: This is 1, 2, 3, or 4, indicating the usage class.
1 = I
2 = II
3 = III
4 = IV
NomLife: The nominal life to be considered.
PeakAccel: The peak ground acceleration, ag/g.
F0: The magnitude factor, F0.
Tcs: The reference period, Tc* [s].
SpecType: This is 1, 2, 3, or 4, indicating the type of spectrum to consider.
1 = Elastic horizontal
2 = Elastic vertical
3 = Design horizontal
4 = Design vertical
SoilType: This is 1, 2, 3, 4, or 5, indicating the subsoil type.
1 = A
2 = B
3 = C
4 = D
5 = E

Topography: This is 1, 2, 3, or 4, indicating the topography type.
1 = T1
2 = T2
3 = T3
4 = T4
hRatio: The ratio for the site altitude at the base of the hill to the height of the hill.
Damping: The damping, in percent. This is only applicable for SpecType 1 and 2.
q: The behavior correction factor. This is only applicable for SpecType 3 and 4.
Lambda: A correction factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CIType, UserT, UserZ, TopZ, BottomZ, ParamsOption, Latitude, Longitude, Island, LimitState, UsageClass, NomLife, PeakAccel, F0, Tcs, SpecType, SoilType, Topography, hRatio, Damping, q, Lambda]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetNTC2008(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNTC2008" failed')
        
        return ret

    def GetNTC2018(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, ParamsOption = None, Latitude = None, Longitude = None, Island = None, LimitState = None, UsageClass = None, NomLife = None, PeakAccel = None, F0 = None, Tcs = None, SpecType = None, SoilType = None, Topography = None, hRatio = None, Damping = None, q = None, Lambda = None):
        """
This function retrieves auto seismic loading parameters for the NTC 2018 code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a NTC 2018 auto seismic load assignment.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item is meaningful when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
ParamsOption: This is 1, 2, or 3, indicating the option for defining the parameters.
1 = by latitude and longitude
2 = by island
3 = user specified
Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Island: This is one of the following values. This item is used only when ParamsOption = 2.
1 = Alicudi2 = Arcipelago Toscano3 = Filcudi4 = Isole Egadi5 = Lampedusa6 = Linosa7 = Lipari8 = Palmarola9 = Panarea10 = Pantelleria11 = Ponza12 = Salina13 = Santo Stefano14 = Sardegna15 = Stromboli16 = Tremiti17 = Ustica18 = Ventotene19 = Vulcano20 = Zannone
LimitState: This is 1, 2, 3, or 4, indicating the limit state.
1 = SLO
2 = SLD
3 = SLV
4 = SLC
UsageClass: This is 1, 2, 3, or 4, indicating the usage class.
1 = I
2 = II
3 = III
4 = IV
NomLife: The nominal life to be considered.
PeakAccel: The peak ground acceleration, ag/g.
F0: The magnitude factor, F0.
Tcs: The reference period, Tc* [s].
SpecType: This is 1, 2, 3, or 4, indicating the type of spectrum to consider.
1 = Elastic horizontal
2 = Elastic vertical
3 = Design horizontal
4 = Design vertical
SoilType: This is 1, 2, 3, 4, or 5, indicating the subsoil type.
1 = A
2 = B
3 = C
4 = D
5 = E

Topography: This is 1, 2, 3, or 4, indicating the topography type.
1 = T1
2 = T2
3 = T3
4 = T4
hRatio: The ratio for the site altitude at the base of the hill to the height of the hill.
Damping: The damping, in percent. This is only applicable for SpecType 1 and 2.
q: The behavior correction factor. This is only applicable for SpecType 3 and 4.
Lambda: A correction factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, UserT, UserZ, TopZ, BottomZ, ParamsOption, Latitude, Longitude, Island, LimitState, UsageClass, NomLife, PeakAccel, F0, Tcs, SpecType, SoilType, Topography, hRatio, Damping, q, Lambda]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetNTC2018(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNTC2018" failed')
        
        return ret

    def GetUBC94(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, UBC94ZFlag = None, UBC94Z = None, UBC94S = None, UBC94I = None, UBC94RW = None):
        """
This function retrieves auto seismic loading parameters for the 1994 UBC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a UBC94 auto seismic load assignment.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified CT factor. This item applies when the PeriodFlag item is 1 or 2.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
UBC94ZFlag: This is 1 or 2, indicating if the seismic zone factor is per code or user defined.
1 = Per code
2 = User defined
UBC94Z: The seismic zone factor, Z.
If the seismic zone factor is per code (UBC94ZFlag = 1), this item should be one of the following: 0.075, 0.15, 0.20, 0.30, 0.40.
UBC94S: This is 1, 1.2, 1.5 or 2, indicating the site coefficient.
UBC94I: The importance factor.
UBC94RW: The numerical coefficient, Rw.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, UBC94ZFlag, UBC94Z, UBC94S, UBC94I, UBC94RW]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetUBC94(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUBC94" failed')
        
        return ret

    def GetUBC97Iso(self, Name = None, DirFlag = None, Eccen = None, UserZ = None, TopZ = None, BottomZ = None, UBC97IsoSeismicCoeffFlag = None, UBC97IsoSoilProfileType = None, UBC97IsoZ = None, UBC97IsoCv = None, UBC97IsoNearSourceFlag = None, UBC97IsoSourceType = None, UBC97IsoDist = None, UBC97IsoNv = None, UBC97IsoRI = None, UBC97IsoBD = None, UBC97IsoKDmax = None, UBC97IsoKDmin = None):
        """
This function retrieves auto seismic loading parameters for seismically isolated buildings using the 1997 UBC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a UBC97Iso auto seismic load assignment.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
UBC97IsoSeismicCoeffFlag: This is either 1 or 2, indicating if the seismic coefficient Cv is per code or user defined.
1 = Per code
2 = User defined
UBC97IsoSoilProfileType: This is 1, 2, 3, 4 or 5, indicating the soil profile type.
1 = SA
2 = SB
3 = SC
4 = SD
5 = SE

This item is applicable only when the seismic coefficients Ca and Cv are calculated per code (UBC97SeismicCoeffFlag = 1).
UBC97IsoZ: This is 0.075, 0.15, 0.2, 0.3 or 0.4, indicating the seismic zone factor.
This item is applicable only when the seismic coefficient Cv is calculated per code (UBC97IsoSeismicCoeffFlag = 1).
UBC97IsoCv: The seismic coefficient, Cv.
UBC97IsoNearSourceFlag: This is either 1 or 2, indicating if the near source factor coefficient Nv is per code or user defined.
1 = Per code
2 = User defined

This item is applicable only when the seismic coefficient Cv is calculated per code (UBC97IsoSeismicCoeffFlag = 1) and UBC97IsoZ = 0.4.
UBC97IsoSourceType: This is 1, 2 or 3, indicating the seismic source type.
1 = A
2 = B
3 = C

This item is applicable only when the seismic coefficient Cv is calculated per code (UBC97IsoSeismicCoeffFlag = 1), UBC97IsoZ = 0.4, and the near source factor coefficient Nv is calculated per code (UBC97IsoNearSourceFlag = 1).
UBC97IsoDist: This is the distance to the seismic source in kilometers.
This item is applicable only when the seismic coefficient Cv is calculated per code (UBC97IsoSeismicCoeffFlag = 1), UBC97IsoZ = 0.4, and the near source factor coefficient Nv is calculated per code (UBC97IsoNearSourceFlag = 1).
UBC97IsoNv: The near source factor coefficient, Nv.
This item is applicable only when the seismic coefficient Cv is user defined (UBC97IsoSeismicCoeffFlag = 2).
UBC97IsoRI: The overstrength factor, Ri.
UBC97IsoBD: The coefficient for damping.
UBC97IsoKDmax: The maximum effective stiffness of the isolation system. [F/L]
UBC97IsoKDmin: The minimum effective stiffness of the isolation system. [F/L]
        """

        all_args = [Name, DirFlag, Eccen, UserZ, TopZ, BottomZ, UBC97IsoSeismicCoeffFlag, UBC97IsoSoilProfileType, UBC97IsoZ, UBC97IsoCv, UBC97IsoNearSourceFlag, UBC97IsoSourceType, UBC97IsoDist, UBC97IsoNv, UBC97IsoRI, UBC97IsoBD, UBC97IsoKDmax, UBC97IsoKDmin]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetUBC97Iso(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUBC97Iso" failed')
        
        return ret

    def GetUBC97(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, UBC97SeismicCoeffFlag = None, UBC97SoilProfileType = None, UBC97Z = None, UBC97Ca = None, UBC97Cv = None, UBC97NearSourceFlag = None, UBC97SourceType = None, UBC97Dist = None, UBC97Na = None, UBC97Nv = None, UBC97I = None, UBC97R = None):
        """
This function retrieves auto seismic loading parameters for the 1997 UBC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a UBC97 auto seismic load assignment.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified CT factor. This item applies when the PeriodFlag item is 1 or 2.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
UBC97SeismicCoeffFlag: This is either 1 or 2, indicating if the seismic coefficients Ca and Cv are per code or user defined.
1 = Per code
2 = User defined
UBC97SoilProfileType: This is 1, 2, 3, 4 or 5, indicating the soil profile type.
1 = SA
2 = SB
3 = SC
4 = SD
5 = SE

This item is applicable only when the seismic coefficients Ca and Cv are calculated per code (UBC97SeismicCoeffFlag = 1).
UBC97Z: This is 0.075, 0.15, 0.2, 0.3 or 0.4, indicating the seismic zone factor.
This item is applicable only when the seismic coefficients Ca and Cv are calculated in accordance with code (UBC97SeismicCoeffFlag = 1).
UBC97Ca: The seismic coefficient, Ca.
UBC97Cv: The seismic coefficient, Cv.
UBC97NearSourceFlag: This is 1 or 2, indicating if the near source factor coefficients Na and Nv are per code or user defined.
1 = Per code
2 = User defined

This item is applicable only when the seismic coefficients Ca and Cv are calculated per code (UBC97SeismicCoeffFlag = 1) and UBC97Z = 0.4.
UBC97SourceType: This is 1, 2 or 3, indicating the seismic source type.
1 = A
2 = B
3 = C

This item is applicable only when the seismic coefficients Ca and Cv are calculated per code (UBC97SeismicCoeffFlag = 1), UBC97Z = 0.4, and the near source factor coefficients Na and Nv are calculated per code (UBC97NearSourceFlag = 1).
UBC97Dist: This is the distance to the seismic source in kilometers.
This item is only applicable when the seismic coefficients Ca and Cv are calculated per code (UBC97SeismicCoeffFlag = 1), UBC97Z = 0.4, and the near source factor coefficients Na and Nv are calculated per code (UBC97NearSourceFlag = 1).
UBC97Na: The near source factor coefficient, Na.
This item is applicable only when the seismic coefficients Ca and Cv are user defined (UBC97SeismicCoeffFlag = 2).
UBC97Nv: The near source factor coefficient, Nv.
This item is applicable only when the seismic coefficients Ca and Cv are user defined (UBC97SeismicCoeffFlag = 2).
UBC97I: The importance factor.
UBC97R: The overstrength factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, UBC97SeismicCoeffFlag, UBC97SoilProfileType, UBC97Z, UBC97Ca, UBC97Cv, UBC97NearSourceFlag, UBC97SourceType, UBC97Dist, UBC97Na, UBC97Nv, UBC97I, UBC97R]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetUBC97(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUBC97" failed')
        
        return ret

    def GetUserLoad(self, Name = None, MyType = None, Eccen = None, Num = None, Diaph = None, Fx = None, Fy = None, Mz = None, x = None, y = None):
        """
This function retrieves auto seismic loading parameters for User Load type auto seismic loads.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern which has been assigned a User Load auto seismic type.
MyType: This is either 1 or 2, indicating the application point type for the user load.
1 = User specified application point
2 = At center of mass with optional additional eccentricity
Eccen: The eccentricity ratio that applies to all diaphragms. This item is only applicable when MyType = 2.
Num: The number of diaphragms that can be loaded by the auto seismic load.
Diaph: This is an array that includes the names of the diaphragms that can be loaded by the auto seismic load.
Fx: This is an array that includes the global X direction force assigned to each diaphragm. [F]
Fy: This is an array that includes the global Y direction force assigned to each diaphragm. [F]
Mz: This is an array that includes the moment about the global Z axis for each diaphragm. [FL]
x: This is an array that includes the global X-coordinate of the point where the seismic force is applied to each diaphragm. [L]
This item is applicable only when MyType = 1.
y: This is an array that includes the global Y-coordinate of the point where the seismic force is applied to each diaphragm. [L]
This item is applicable only when MyType = 1.
        """

        all_args = [Name, MyType, Eccen, Num, Diaph, Fx, Fy, Mz, x, y]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetUserLoad(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUserLoad" failed')
        
        return ret

    def GetNZS11702004_2(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, NZS2004SiteClass = None, NZS2004Z = None, NZS2004R = None, NZS2004DIST = None, NZS2004Sp = None, NZS2004Mu = None, NZS2004ConsiderTSite = None, NZS2004TSite = None, NZS2004ConsiderSingleStory = None):
        """
This function retrieves auto seismic loading parameters 
 for the NZS 1170 2004 code.
The function returns zero if the parameters are successfully 
 retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with 
 a NZS 1170 2004 auto seismic load assignment.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when 
 the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of 
 the seismic load are user specified. It is False if the elevations are 
 determined by the program.
TopZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the highest level where auto seismic 
 loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the lowest level where auto seismic loads 
 are applied. [L]
NZS2004SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
NZS2004Z: The hazard factor, Z.
NZS2004R: The return period factor, R.
NZS2004DIST: Distance to the fault in km, used to calculate the near 
 fault factor..
NZS2004Sp: The structural performance factor, Sp.
NZS2004Mu: The structural ductility factor, u.
NZS2004ConsiderTSite: Indicates whether to consider the site period for the 
 spectral shape factor.
NZS2004TSite: The low amplitude site period.
NZS2004ConsiderSingleStory: Indicates whether to consider the structure as a single 
 story, in which case Ft 
 = 0.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, UserT, UserZ, TopZ, BottomZ, NZS2004SiteClass, NZS2004Z, NZS2004R, NZS2004DIST, NZS2004Sp, NZS2004Mu, NZS2004ConsiderTSite, NZS2004TSite, NZS2004ConsiderSingleStory]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetNZS11702004_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNZS11702004_2" failed')
        
        return ret

    def SetNZS11702004_2(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, NZS2004SiteClass = None, NZS2004Z = None, NZS2004R = None, NZS2004DIST = None, NZS2004Sp = None, NZS2004Mu = None, NZS2004ConsiderTSite = None, NZS2004TSite = None, NZS2004ConsiderSingleStory = None):
        """
This function assigns auto seismic loading parameters 
 for the NZS 1170.5 2004 code.
The function returns zero if the parameters are successfully 
 assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when 
 the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of 
 the seismic load are user specified. It is False if the elevations are 
 determined by the program.
TopZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the highest level where auto seismic 
 loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the lowest level where auto seismic loads 
 are applied. [L]
NZS2004SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
NZS2004Z: The hazard factor, Z.
NZS2004R: The return period factor, R.
NZS2004DIST: Distance to the fault in km, used to calculate the near 
 fault factor.
NZS2004Sp: The structural performance factor, Sp.
NZS2004Mu: The structural ductility factor, u.
NZS2004ConsiderTSite: Indicates whether to consider the site period for the 
 spectral shape factor.
NZS2004TSite: The low amplitude site period.
NZS2004ConsiderSingleStory: Indicates whether to consider the structure as a single 
 story, in which case Ft = 0.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, UserT, UserZ, TopZ, BottomZ, NZS2004SiteClass, NZS2004Z, NZS2004R, NZS2004DIST, NZS2004Sp, NZS2004Mu, NZS2004ConsiderTSite, NZS2004TSite, NZS2004ConsiderSingleStory]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetNZS11702004_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNZS11702004_2" failed')
        
        return ret

    def SetAS11702007(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, AS2007SiteClass = None, AS2007kp = None, AS2007Z = None, AS2007Sp = None, AS2007Mu = None):
        """
This function assigns auto seismic loading parameters for the AS 1170.4 2007 code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified kt factor. This item applies when the PeriodFlag item is 1.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
AS2007SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
AS2007kp: The probability factor, kp.
AS2007Z: The hazard factor, Z.
AS2007Sp: The structural performance factor, Sp.
AS2007Mu: The structural ductility factor, u.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, AS2007SiteClass, AS2007kp, AS2007Z, AS2007Sp, AS2007Mu]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetAS11702007(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAS11702007" failed')
        
        return ret

    def SetBOCA96(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, BOCA96Aa = None, BOCA96Av = None, BOCA96S = None, BOCA96R = None):
        """
This function assigns auto seismic loading parameters for the 1996 BOCA code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified CT factor. This item applies when the PeriodFlag item is 1 or 2.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
BOCA96Aa: The effective peak acceleration coefficient.
BOCA96Av: The effective peak velocity-related coefficient.
BOCA96S: This is 1, 1.2, 1.5 or 2, indicating the site coefficient.
BOCA96R: The response modification factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, BOCA96Aa, BOCA96Av, BOCA96S, BOCA96R]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetBOCA96(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetBOCA96" failed')
        
        return ret

    def SetChinese2010(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, JGJ32010AlphaMax = None, JGJ32010SI = None, JGJ32010DampRatio = None, JGJ32010Tg = None, JGJ32010PTDF = None, EnhancementFactor = None):
        """
This function assigns auto seismic loading parameters for the Chinese 2010 code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is 1, 2 or 3, indicating the seismic load direction.
1 = Global X
2 = Global Y
3 = Global Z
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is either 2 or 3, indicating the time period option.
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
JGJ32010AlphaMax: The maximum influence factor.
JGJ32010SI: This is 1, 2, 3, 4, 5 or 6, indicating the seismic intensity.
1 = 6(0.05g)
2 = 7(0.10g)
3 = 7(0.15g)
4 = 8(0.20g)
5 = 8(0.30g)
6 = 9(0.40g)
JGJ32010DampRatio: The damping ratio.
JGJ32010Tg: The characteristic ground period. [s]
JGJ32010PTDF: The period time discount factor.
EnhancementFactor: The enhancement factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, UserT, UserZ, TopZ, BottomZ, JGJ32010AlphaMax, JGJ32010SI, JGJ32010DampRatio, JGJ32010Tg, JGJ32010PTDF, EnhancementFactor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetChinese2010(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetChinese2010" failed')
        
        return ret

    def SetDiaphragmEccentricityOverride(self, Name = None, Diaph = None, Eccen = None, Delete = None):
        """
This function assigns diaphragm eccentricity overrides for auto seismic loads. This function does not apply for User Load type auto seismic loads.
The function returns zero if the overrides are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern that has an auto seismic load assigned.
Diaph: The name of an existing special rigid diaphragm constraint, that is, a diaphragm constraint with the following features:
1. The constraint type is CONSTRAINT_DIAPHRAGM = 2.
2. The constraint coordinate system is Global.
3. The constraint axis is Z.
Eccen: The eccentricity applied to the specified diaphragm. [L]
Delete: If this item is True, the eccentricity override for the specified diaphragm is deleted.
        """

        all_args = [Name, Diaph, Eccen, Delete]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetDiaphragmEccentricityOverride(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDiaphragmEccentricityOverride" failed')
        
        return ret

    def SetEurocode82004_1(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, EURO2004Country = None, EURO2004SpectrumType = None, EURO2004GroundType = None, EURO2004ag = None, EURO2004S = None, EURO2004Tb = None, EURO2004Tc = None, EURO2004Td = None, EURO2004Beta = None, EURO2004q = None, EURO2004Lambda = None):
        """
This function assigns auto seismic loading parameters for the Eurocode 8 2004 code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified Ct factor. This item applies when the PeriodFlag item is 1.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3.[s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
EURO2004Country: This is 0, 1, 5, 6, or 10 indicating the country for which the Nationally Determined Parameters (NDPs) are specified.
0 = Other (NDPs are user specified)
1 = CEN Default
5 = Norway
6 = Singapore
10 = Portugal

EURO2004SpectrumType: This is 1 or 2, indicating the spectrum type.
1 = Type 1
2 = Type 2 (Does not apply when EURO2004Country = 6)
EURO2004GroundType: This is 1, 2, 3, 4, 5, or 6, indicating the ground type.
1 = A (Does not apply when EURO2004Country = 6)
2 = B (Does not apply when EURO2004Country = 6)
3 = C
4 = D
5 = E (Does not apply when EURO2004Country = 6)
6 = S1 (Only applies when EURO2004Country = 6)

EURO2004ag: The design ground acceleration in g, ag.
EURO2004S: The soil factor, S. If the EURO2004Country item is not 0, the input value for this item is ignored.
EURO2004Tb: The lower limit of period of the constant spectral acceleration branch, Tb. If the EURO2004Country item is not 0, the input value for this item is ignored.
EURO2004Tc: The upper limit of period of the constant spectral acceleration branch, Tc. If the EURO2004Country item is not 0, the input value for this item is ignored.
EURO2004Td: The period defining the start of the constant displacement range, Td. If the EURO2004Country item is not 0, the input value for this item is ignored.
EURO2004Beta: The lower bound factor, Beta. If the EURO2004Country item is not 0, the input value for this item is ignored.
EURO2004q: The behavior factor, q.
EURO2004Lambda: The correction factor, Lambda.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, EURO2004Country, EURO2004SpectrumType, EURO2004GroundType, EURO2004ag, EURO2004S, EURO2004Tb, EURO2004Tc, EURO2004Td, EURO2004Beta, EURO2004q, EURO2004Lambda]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetEurocode82004_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEurocode82004_1" failed')
        
        return ret

    def SetIBC2003(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, IBC2003SG = None, IBC2003SeismicCoeffFlag = None, IBC2003Site = None, IBC2003SS = None, IBC2003S1 = None, IBC2003Fa = None, IBC2003Fv = None, IBC2003R = None, IBC2003Omega = None, IBC2003Cd = None):
        """
This function assigns auto seismic loading parameters for the 2003 IBC code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified CT factor (ft). This item applies when the PeriodFlag item is 1 or 2.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
IBC2003SG: This is 1, 2 or 3, indicating the seismic group.
1 = I
2 = II
3 = III
IBC2003SeismicCoeffFlag: This is either 1 or 2, indicating the seismic coefficient option.
1 = Coefficients are per code
2 = Coefficients are user defined
IBC2003Site: This is 1, 2, 3, 4 or 5, indicating the site class. This item is only used when the IBC2003SeismicCoeffFlag = 1.
1 = A
2 = B
3 = C
4 = D
5 = E
IBC2003SS: The response acceleration for short periods, (g).
IBC2003S1: The response acceleration for a one second period, (g).
IBC2003Fa: The site coefficient Fa. This item is used only when the IBC2003SeismicCoeffFlag = 2.
IBC2003Fv: The site coefficient Fv. This item is used only when the IBC2003SeismicCoeffFlag = 2
IBC2003R: The response modification factor.
IBC2003Omega: The system overstrength factor.
IBC2003Cd: The deflection amplification factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, IBC2003SG, IBC2003SeismicCoeffFlag, IBC2003Site, IBC2003SS, IBC2003S1, IBC2003Fa, IBC2003Fv, IBC2003R, IBC2003Omega, IBC2003Cd]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetIBC2003(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetIBC2003" failed')
        
        return ret

    def SetIBC2006(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, IBC2006CtType = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, IBC2006R = None, IBC2006Omega = None, IBC2006Cd = None, IBC2006I = None, IBC2006Option = None, IBC2006Latitude = None, IBC2006Longitude = None, IBC2006ZipCode = None, IBC2006SS = None, IBC2006S1 = None, IBC2006TL = None, IBC2006SiteClass = None, IBC2006Fa = None, IBC2006Fv = None):
        """
This function assigns auto seismic loading parameters for the 2006 IBC code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
IBC2006CtType: This is 0, 1, 2 or 3, indicating the values of Ct and x. This item applies when the PeriodFlag item is 1 or 2.
0 = Ct = 0.028 (ft),x = 0.8
1 = Ct = 0.016 (ft),x = 0.9
2 = Ct = 0.03 (ft),x = 0.75
3 = Ct = 0.02 (ft),x = 0.75
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
IBC2006R: The response modification factor.
IBC2006Omega: The system overstrength factor.
IBC2006Cd: The deflection amplification factor.
IBC2006I: The occupancy importance factor.
IBC2006Option: This is 0, 1 or 2, indicating the seismic coefficient option.
0 = Ss and S1 from USGS by latitude and longitude
1 = Ss and S1 from USGS by zip code
2 = Ss and S1 are user defined
IBC2006Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when IBC2006Option = 0.
IBC2006Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when IBC2006Option = 0.
IBC2006ZipCode: The zip code for which the seismic coefficients are obtained. This item is used only when IBC2006Option = 1.
IBC2006SS: The seismic coefficients Ss and S1. This item is used only when IBC2006Option = 2.
IBC2006S1: The seismic coefficients Ss and S1. This item is used only when IBC2006Option = 2.
IBC2006TL: The long-period transition period. [s]
IBC2006SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
IBC2006Fa: The site coefficients Fa and Fv. These items are used only when IBC2006SiteClass= 6.
IBC2006Fv: The site coefficients Fa and Fv. These items are used only when IBC2006SiteClass= 6.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, IBC2006CtType, UserT, UserZ, TopZ, BottomZ, IBC2006R, IBC2006Omega, IBC2006Cd, IBC2006I, IBC2006Option, IBC2006Latitude, IBC2006Longitude, IBC2006ZipCode, IBC2006SS, IBC2006S1, IBC2006TL, IBC2006SiteClass, IBC2006Fa, IBC2006Fv]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetIBC2006(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetIBC2006" failed')
        
        return ret

    def SetIBC2009(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CtType = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, R = None, Omega = None, Cd = None, I = None, IBC2009Option = None, Latitude = None, Longitude = None, ZipCode = None, SS = None, S1 = None, TL = None, SiteClass = None, Fa = None, Fv = None):
        """
This function assigns auto seismic loading parameters for the 2009 IBC code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CtType: This is 0, 1, 2 or 3, indicating the values of Ct and x. This item applies when the PeriodFlag item is 1 or 2.
0 = Ct = 0.028 (ft),x = 0.8
1 = Ct = 0.016 (ft),x = 0.9
2 = Ct = 0.03 (ft),x = 0.75
3 = Ct = 0.02 (ft),x = 0.75
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
R: The response modification factor.
Omega: The system overstrength factor.
Cd: The deflection amplification factor.
I: The occupancy importance factor.
IBC2009Option: This is 0, 1 or 2, indicating the seismic coefficient option.
0 = Ss and S1 from USGS by latitude and longitude
1 = Ss and S1 from USGS by zip code
2 = Ss and S1 are user defined
Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when IBC2009Option = 0.
Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when IBC2009Option = 0.
ZipCode: The zip code for which the seismic coefficients are obtained. This item is used only when IBC2009Option = 1.
SS: The seismic coefficients Ss and S1. This item is used only when IBC2009Option = 2.
S1: The seismic coefficients Ss and S1. This item is used only when IBC2009Option = 2.
TL: The long-period transition period. [s]
SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
Fa: The site coefficients Fa and Fv. These items are used only when IBC2009SiteClass= 6.
Fv: The site coefficients Fa and Fv. These items are used only when IBC2009SiteClass= 6.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CtType, UserT, UserZ, TopZ, BottomZ, R, Omega, Cd, I, IBC2009Option, Latitude, Longitude, ZipCode, SS, S1, TL, SiteClass, Fa, Fv]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetIBC2009(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetIBC2009" failed')
        
        return ret

    def SetIBC2012(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CtType = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, R = None, Omega = None, Cd = None, I = None, IBC2012Option = None, Latitude = None, Longitude = None, ZipCode = None, SS = None, S1 = None, TL = None, SiteClass = None, Fa = None, Fv = None):
        """
This function assigns auto seismic loading parameters for the 2012 IBC code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CtType: This is 0, 1, 2 or 3, indicating the values of Ct and x. This item applies when the PeriodFlag item is 1 or 2.
0 = Ct = 0.028 (ft),x = 0.8
1 = Ct = 0.016 (ft),x = 0.9
2 = Ct = 0.03 (ft),x = 0.75
3 = Ct = 0.02 (ft),x = 0.75
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
R: The response modification factor.
Omega: The system overstrength factor.
Cd: The deflection amplification factor.
I: The occupancy importance factor.
IBC2012Option: This is 0, 1 or 2, indicating the seismic coefficient option.
0 = Ss and S1 from USGS by latitude and longitude
1 = Ss and S1 from USGS by zip code
2 = Ss and S1 are user defined
Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when IBC2012Option = 0.
Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are used only when IBC2012Option = 0.
ZipCode: The zip code for which the seismic coefficients are obtained. This item is used only when IBC2012Option = 1.
SS: The seismic coefficients Ss and S1. This item is used only when IBC2012Option = 2.
S1: The seismic coefficients Ss and S1. This item is used only when IBC2012Option = 2.
TL: The long-period transition period. [s]
SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
Fa: The site coefficients Fa and Fv. These items are used only when IBC2012SiteClass= 6.
Fv: The site coefficients Fa and Fv. These items are used only when IBC2012SiteClass= 6.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CtType, UserT, UserZ, TopZ, BottomZ, R, Omega, Cd, I, IBC2012Option, Latitude, Longitude, ZipCode, SS, S1, TL, SiteClass, Fa, Fv]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetIBC2012(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetIBC2012" failed')
        
        return ret

    def SetIS1893_2002(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, INZFlag = None, INZ = None, INS = None, BOCA96R = None, INR = None):
        """
This function assigns auto seismic loading parameters for the 2002 IS1893 code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified CT factor (m). This item applies when the PeriodFlag item is 1.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
INZFlag: This is either 1 or 2, indicating if the seismic zone factor is per code or user defined.
1 = Per code
2 = User defined
INZ: The seismic zone factor, Z.
If the seismic zone factor is per code (INZFlag = 1), this item should be one of the following: 0.10, 0.16, 0.24, 0.36.
INS: This is 1, 2 or 3, indicating the soil type.
1 = I
2 = II
3 = III
BOCA96R: The response modification factor.
INR: The response modification factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, INZFlag, INZ, INS, BOCA96R, INR]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetIS1893_2002(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetIS1893_2002" failed')
        
        return ret

    def SetNBCC2005(self, Name = None, DirFlag = None, Eccen = None, NBCC2005CtType = None, NBCC95DS = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, NBCC2005PGA = None, NBCC2005S02 = None, NBCC2005S05 = None, NBCC2005S1 = None, NBCC2005S2 = None, NBCC2005SiteClass = None, NBCC2005Fa = None, NBCC2005Fv = None, NBCC2005I = None, NBCC2005Mv = None, NBCC2005Rd = None, NBCC2005Ro = None):
        """
This function assigns auto seismic loading parameters for the 2005 NBCC code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
NBCC2005CtType: This is 0, 1, 2, 3 or 4, indicating the structure type.
0 = Steel moment frame
1 = Concrete moment frame
2 = Other moment frame
3 = Braced frame
4 = Shear wall
NBCC95DS: This item applies only when the NBCCPFlag = 2. It is the dimension of the lateral load resisting system in the direction of the applied forces. [L]
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Code
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
NBCC2005PGA: The peak ground acceleration.
NBCC2005S02: The spectral acceleration at a 0.2 second period.
NBCC2005S05: The spectral acceleration at a 0.52 second period.
NBCC2005S1: The spectral acceleration at a 1 second period.
NBCC2005S2: The spectral acceleration at a 2 second period.
NBCC2005SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
NBCC2005Fa: The site coefficient, Fa. This item is read when the site class is F only.
NBCC2005Fv: The site coefficient, Fv. This item is read when the site class is F only.
NBCC2005I: The importance factor.
NBCC2005Mv: The higher mode factor.
NBCC2005Rd: The ductility modifier.
NBCC2005Ro: The overstrength modifier.
        """

        all_args = [Name, DirFlag, Eccen, NBCC2005CtType, NBCC95DS, PeriodFlag, UserT, UserZ, TopZ, BottomZ, NBCC2005PGA, NBCC2005S02, NBCC2005S05, NBCC2005S1, NBCC2005S2, NBCC2005SiteClass, NBCC2005Fa, NBCC2005Fv, NBCC2005I, NBCC2005Mv, NBCC2005Rd, NBCC2005Ro]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetNBCC2005(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNBCC2005" failed')
        
        return ret

    def SetNBCC2010(self, Name = None, DirFlag = None, Eccen = None, CtType = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, PGA = None, S02 = None, S05 = None, S1 = None, S2 = None, S4 = None, SiteClass = None, Fa = None, Fv = None, I = None, Mv = None, Rd = None, Ro = None):
        """
This function retrieves auto seismic loading parameters for the 2010 NBCC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a NBCC2010 auto seismic load assignment.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
CtType: This is 0, 1, 2, 3 or 4, indicating the structure type.
0 = Steel moment frame
1 = Concrete moment frame
2 = Other moment frame
3 = Braced frame
4 = Shear wall
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Code
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
PGA: The peak ground acceleration.
S02: The spectral acceleration at a 0.2 second period.
S05: The spectral acceleration at a 0.5 second period.
S1: The spectral acceleration at a 1 second period.
S2: The spectral acceleration at a 2 second period.
S4: The spectral acceleration at a 4 second period.

SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
Fa: The site coefficient, Fa. This item is read when the site class is F only.
Fv: The site coefficient, Fv. This item is read when the site class is F only.
I: The importance factor.
Mv: The higher mode factor.
Rd: The ductility modifier.
Ro: The overstrength modifier.
        """

        all_args = [Name, DirFlag, Eccen, CtType, PeriodFlag, UserT, UserZ, TopZ, BottomZ, PGA, S02, S05, S1, S2, S4, SiteClass, Fa, Fv, I, Mv, Rd, Ro]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetNBCC2010(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNBCC2010" failed')
        
        return ret

    def SetNBCC2015(self, Name = None, DirFlag = None, Eccen = None, CtType = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, PGA = None, S02 = None, S05 = None, S1 = None, S2 = None, S5 = None, S10 = None, SiteClass = None, F02 = None, F05 = None, F1 = None, F2 = None, F5 = None, F10 = None, I = None, Mv = None, Rd = None, Ro = None):
        """
This function retrieves auto seismic loading parameters for the 2015 NBCC code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
CtType: This is 0, 1, 2, 3 or 4, indicating the structure type.
0 = Steel moment frame
1 = Concrete moment frame
2 = Other moment frame
3 = Braced frame
4 = Shear wall
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Code
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
PGA: The peak ground acceleration.
S02: The spectral acceleration at a 0.2 second period.
S05: The spectral acceleration at a 0.5 second period.
S1: The spectral acceleration at a 1 second period.
S2: The spectral acceleration at a 2 second period.
S5: The spectral acceleration at a 5 second period.
S10: The spectral acceleration at a 10 second period.
SiteClass: This is 1, 2, 3, 4, 5 or 6, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F
F02: The site coefficient at a 0.2 second period. This item is read when the site class is F only.
F05: The site coefficientat a 0.5 second period. This item is read when the site class is F only.
F1: The site coefficient at a 1 second period. This item is read when the site class is F only.
F2: The site coefficient at a 2 second period. This item is read when the site class is F only.
F5: The site coefficient at a 5 second period. This item is read when the site class is F only.
F10: The site coefficient at a 10 second period. This item is read when the site class is F only.
I: The importance factor.
Mv: The higher mode factor.
Rd: The ductility modifier.
Ro: The overstrength modifier.
        """

        all_args = [Name, DirFlag, Eccen, CtType, PeriodFlag, UserT, UserZ, TopZ, BottomZ, PGA, S02, S05, S1, S2, S5, S10, SiteClass, F02, F05, F1, F2, F5, F10, I, Mv, Rd, Ro]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetNBCC2015(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNBCC2015" failed')
        
        return ret

    def SetNBCC95(self, Name = None, DirFlag = None, Eccen = None, NBCCPFlag = None, NBCC95DS = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, NBCC95ZA = None, NBCC95ZV = None, NBCC95ZVFlag = None, NBCC95ZVR = None, NBCC95I = None, NBCC95F = None, NBCC95R = None):
        """
This function assigns auto seismic loading parameters for the 1995 NBCC code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
NBCCPFlag: This is either 1 or 2, indicating the structure type.
1 = Moment frame
2 = Other
NBCC95DS: This item applies only when the NBCCPFlag = 2. It is the dimension of the lateral load resisting system in the direction of the applied forces. [L]
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Code
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
NBCC95ZA: This is 0, 1, 2, 3, 4, 5 or 6, indicating the acceleration related zone, Za.
NBCC95ZV: This is 0, 1, 2, 3, 4, 5 or 6, indicating the velocity related zone, Zv.
NBCC95ZVFlag: This is either 1 or 2, indicating how the zonal velocity ratio, V, is specified.
1 = From code based on Zv
2 = User specified
NBCC95ZVR: The zonal velocity ratio, V. This item is used only when NBCC95ZVFlag = 2.
NBCC95I: The importance factor.
NBCC95F: The foundation factor.
NBCC95R: The force modification factor.
        """

        all_args = [Name, DirFlag, Eccen, NBCCPFlag, NBCC95DS, PeriodFlag, UserT, UserZ, TopZ, BottomZ, NBCC95ZA, NBCC95ZV, NBCC95ZVFlag, NBCC95ZVR, NBCC95I, NBCC95F, NBCC95R]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetNBCC95(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNBCC95" failed')
        
        return ret

    def SetNEHRP97(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, NEHRP97SG = None, NEHRP97SeismicCoeffFlag = None, NEHRP97Site = None, NEHRP97SS = None, NEHRP97S1 = None, NEHRP97Fa = None, NEHRP97Fv = None, NEHRP97R = None):
        """
This function assigns auto seismic loading parameters for the 1997 NEHRP code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified CT factor. This item applies when the PeriodFlag item is 1 or 2.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
NEHRP97SG: This is 1, 2 or 3, indicating the seismic group.
1 = I
2 = II
3 = III
NEHRP97SeismicCoeffFlag: This is either 1 or 2, indicating the seismic coefficient option.
1 = Coefficients are per code
2 = Coefficients are user defined
NEHRP97Site: This is 1, 2, 3, 4 or 5, indicating the site class. This item is used only when the NEHRP97SeismicCoeffFlag = 1.
1 = A
2 = B
3 = C
4 = D
5 = E
NEHRP97SS: The response acceleration for short periods, (g).
NEHRP97S1: The response acceleration for a one second period, (g).
NEHRP97Fa: The site coefficient Fa. This item is used only when the NEHRP97SeismicCoeffFlag = 2.
NEHRP97Fv: The site coefficient Fv. This item is used only when the NEHRP97SeismicCoeffFlag = 2
NEHRP97R: The response modification factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, NEHRP97SG, NEHRP97SeismicCoeffFlag, NEHRP97Site, NEHRP97SS, NEHRP97S1, NEHRP97Fa, NEHRP97Fv, NEHRP97R]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetNEHRP97(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNEHRP97" failed')
        
        return ret

    def SetNone(self, Name = None):
        """
This function sets the auto seismic loading type for the specified load pattern to None.
The function returns zero if the loading type is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetNone(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNone" failed')
        
        return ret

    def SetNTC2008(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CIType = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, ParamsOption = None, Latitude = None, Longitude = None, Island = None, LimitState = None, UsageClass = None, NomLife = None, PeakAccel = None, F0 = None, Tcs = None, SpecType = None, SoilType = None, Topography = None, hRatio = None, Damping = None, q = None, Lambda = None):
        """
This function assigns auto seismic loading parameters for the NTC 2008 code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CIType: This is 0, 1, 2 or 3, indicating the values of C1. This item applies when the PeriodFlag item is 1 or 2.
1 = C1 = 0.085 (m)
2 = C1 = 0.075 (m)
3 = C1 = 0.05 (m)
UserT: The user specified time period. This item is meaningful when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
ParamsOption: This is 1, 2, or 3, indicating the option for defining the parameters.
1 = by latitude and longitude
2 = by island
3 = user specified
Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Island: This is one of the following values. This item is used only when ParamsOption = 2.
1 = Alicudi2 = Arcipelago Toscano3 = Filcudi4 = Isole Egadi5 = Lampedusa6 = Linosa7 = Lipari8 = Palmarola9 = Panarea10 = Pantelleria11 = Ponza12 = Salina13 = Santo Stefano14 = Sardegna15 = Stromboli16 = Tremiti17 = Ustica18 = Ventotene19 = Vulcano20 = Zannone
LimitState: This is 1, 2, 3, or 4, indicating the limit state.
1 = SLO
2 = SLD
3 = SLV
4 = SLC
UsageClass: This is 1, 2, 3, or 4, indicating the usage class.
1 = I
2 = II
3 = III
4 = IV
NomLife: The nominal life to be considered.
PeakAccel: The peak ground acceleration, ag/g.
F0: The magnitude factor, F0.
Tcs: The reference period, Tc* [s].
SpecType: This is 1, 2, 3, or 4, indicating the type of spectrum to consider.
1 = Elastic horizontal
2 = Elastic vertical
3 = Design horizontal
4 = Design vertical
SoilType: This is 1, 2, 3, 4, or 5, indicating the subsoil type.
1 = A
2 = B
3 = C
4 = D
5 = E

Topography: This is 1, 2, 3, or 4, indicating the topography type.
1 = T1
2 = T2
3 = T3
4 = T4
hRatio: The ratio for the site altitude at the base of the hill to the height of the hill.
Damping: The damping, in percent. This is only applicable for SpecType 1 and 2.
q: The behavior correction factor. This is only applicable for SpecType 3 and 4.
Lambda: A correction factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CIType, UserT, UserZ, TopZ, BottomZ, ParamsOption, Latitude, Longitude, Island, LimitState, UsageClass, NomLife, PeakAccel, F0, Tcs, SpecType, SoilType, Topography, hRatio, Damping, q, Lambda]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetNTC2008(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNTC2008" failed')
        
        return ret

    def SetNTC2018(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, ParamsOption = None, Latitude = None, Longitude = None, Island = None, LimitState = None, UsageClass = None, NomLife = None, PeakAccel = None, F0 = None, Tcs = None, SpecType = None, SoilType = None, Topography = None, hRatio = None, Damping = None, q = None, Lambda = None):
        """
This function assigns auto seismic loading parameters for the NTC 2018 code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item is meaningful when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
ParamsOption: This is 1, 2, or 3, indicating the option for defining the parameters.
1 = by latitude and longitude
2 = by island
3 = user specified
Latitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Longitude: The latitude and longitude for which the seismic coefficients are obtained. These items are meaningful only when ParamsOption = 1.
Island: This is one of the following values. This item is used only when ParamsOption = 2.
1 = Alicudi2 = Arcipelago Toscano3 = Filcudi4 = Isole Egadi5 = Lampedusa6 = Linosa7 = Lipari8 = Palmarola9 = Panarea10 = Pantelleria11 = Ponza12 = Salina13 = Santo Stefano14 = Sardegna15 = Stromboli16 = Tremiti17 = Ustica18 = Ventotene19 = Vulcano20 = Zannone
LimitState: This is 1, 2, 3, or 4, indicating the limit state.
1 = SLO
2 = SLD
3 = SLV
4 = SLC
UsageClass: This is 1, 2, 3, or 4, indicating the usage class.
1 = I
2 = II
3 = III
4 = IV
NomLife: The nominal life to be considered.
PeakAccel: The peak ground acceleration, ag/g.
F0: The magnitude factor, F0.
Tcs: The reference period, Tc* [s].
SpecType: This is 1, 2, 3, or 4, indicating the type of spectrum to consider.
1 = Elastic horizontal
2 = Elastic vertical
3 = Design horizontal
4 = Design vertical
SoilType: This is 1, 2, 3, 4, or 5, indicating the subsoil type.
1 = A
2 = B
3 = C
4 = D
5 = E

Topography: This is 1, 2, 3, or 4, indicating the topography type.
1 = T1
2 = T2
3 = T3
4 = T4
hRatio: The ratio for the site altitude at the base of the hill to the height of the hill.
Damping: The damping, in percent. This is only applicable for SpecType 1 and 2.
q: The behavior correction factor. This is only applicable for SpecType 3 and 4.
Lambda: A correction factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, UserT, UserZ, TopZ, BottomZ, ParamsOption, Latitude, Longitude, Island, LimitState, UsageClass, NomLife, PeakAccel, F0, Tcs, SpecType, SoilType, Topography, hRatio, Damping, q, Lambda]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetNTC2018(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNTC2018" failed')
        
        return ret

    def SetUBC94(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, UBC94ZFlag = None, UBC94Z = None, UBC94S = None, UBC94I = None, UBC94RW = None):
        """
This function assigns auto seismic loading parameters for the 1994 UBC code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified CT factor. This item applies when the PeriodFlag item is 1 or 2.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
UBC94ZFlag: This is either 1 or 2, indicating if the seismic zone factor is per code or user defined.
1 = Per code
2 = User defined
UBC94Z: The seismic zone factor, Z.
If the seismic zone factor is per code (UBC94ZFlag = 1), this item should be one of the following: 0.075, 0.15, 0.20, 0.30, 0.40.
UBC94S: This is 1, 1.2, 1.5 or 2, indicating the site coefficient.
UBC94I: The importance factor.
UBC94RW: The numerical coefficient, Rw.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, UBC94ZFlag, UBC94Z, UBC94S, UBC94I, UBC94RW]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetUBC94(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUBC94" failed')
        
        return ret

    def SetUBC97Iso(self, Name = None, DirFlag = None, Eccen = None, UserZ = None, TopZ = None, BottomZ = None, UBC97IsoSeismicCoeffFlag = None, UBC97IsoSoilProfileType = None, UBC97IsoZ = None, UBC97IsoCv = None, UBC97IsoNearSourceFlag = None, UBC97IsoSourceType = None, UBC97IsoDist = None, UBC97IsoNv = None, UBC97IsoRI = None, UBC97IsoBD = None, UBC97IsoKDmax = None, UBC97IsoKDmin = None):
        """
This function assigns auto seismic loading parameters for seismically isolated buildings using the 1997 UBC code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
UBC97IsoSeismicCoeffFlag: This is either 1 or 2, indicating if the seismic coefficient Cv is per code or user defined.
1 = Per code
2 = User defined
UBC97IsoSoilProfileType: This is 1, 2, 3, 4 or 5, indicating the soil profile type.
1 = SA
2 = SB
3 = SC
4 = SD
5 = SE

This item is applicable only when the seismic coefficients Ca and Cv are calculated in accordance with code (UBC97SeismicCoeffFlag = 1).
UBC97IsoZ: This is 0.075, 0.15, 0.2, 0.3 or 0.4, indicating the seismic zone factor.
This item is applicable only when the seismic coefficient Cv is calculated in accordance with code (UBC97IsoSeismicCoeffFlag = 1).
UBC97IsoCv: The seismic coefficient, Cv.
This item is applicable only when the seismic coefficient Cv is user defined (UBC97IsoSeismicCoeffFlag = 2).
UBC97IsoNearSourceFlag: This is either 1 or 2, indicating if the near source factor coefficient Nv is per code or user defined.
1 = Per code
2 = User defined

This item is applicable only when the seismic coefficient Cv is calculated per code (UBC97IsoSeismicCoeffFlag = 1) and UBC97IsoZ = 0.4.
UBC97IsoSourceType: This is 1, 2 or 3, indicating the seismic source type.
1 = A
2 = B
3 = C

This item is applicable only when the seismic coefficient Cv is calculated in accordance with code (UBC97IsoSeismicCoeffFlag = 1), UBC97IsoZ = 0.4, and the near source factor coefficient Nv is calculated in accordance with code (UBC97IsoNearSourceFlag = 1).
UBC97IsoDist: This is the distance to the seismic source in kilometers.
This item is only applicable when the seismic coefficient Cv is calculated in accordance with code (UBC97IsoSeismicCoeffFlag = 1), UBC97IsoZ = 0.4, and the near source factor coefficient Nv is calculated in accordance with code (UBC97IsoNearSourceFlag = 1).
UBC97IsoNv: The near source factor coefficient, Nv.
This item is applicable only when the seismic coefficient Cv is user defined (UBC97IsoSeismicCoeffFlag = 2) and the near source factor coefficient Nv is user defined (UBC97IsoNearSourceFlag = 2).
UBC97IsoRI: The overstrength factor, Ri.
UBC97IsoBD: The coefficient for damping.
UBC97IsoKDmax: The maximum effective stiffness of the isolation system. [F/L]
UBC97IsoKDmin: The minimum effective stiffness of the isolation system. [F/L]
        """

        all_args = [Name, DirFlag, Eccen, UserZ, TopZ, BottomZ, UBC97IsoSeismicCoeffFlag, UBC97IsoSoilProfileType, UBC97IsoZ, UBC97IsoCv, UBC97IsoNearSourceFlag, UBC97IsoSourceType, UBC97IsoDist, UBC97IsoNv, UBC97IsoRI, UBC97IsoBD, UBC97IsoKDmax, UBC97IsoKDmin]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetUBC97Iso(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUBC97Iso" failed')
        
        return ret

    def SetUBC97(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, UBC97SeismicCoeffFlag = None, UBC97SoilProfileType = None, UBC97Z = None, UBC97Ca = None, UBC97Cv = None, UBC97NearSourceFlag = None, UBC97SourceType = None, UBC97Dist = None, UBC97Na = None, UBC97Nv = None, UBC97I = None, UBC97R = None):
        """
This function assigns auto seismic loading parameters for the 1997 UBC code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified CT factor. This item applies when the PeriodFlag item is 1 or 2.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
UBC97SeismicCoeffFlag: This is either 1 or 2, indicating if the seismic coefficients Ca and Cv are per code or user defined.
1 = Per code
2 = User defined
UBC97SoilProfileType: This is 1, 2, 3, 4 or 5, indicating the soil profile type.
1 = SA
2 = SB
3 = SC
4 = SD
5 = SE

This item is applicable only when the seismic coefficients Ca and Cv are calculated in accordance with the code (UBC97SeismicCoeffFlag = 1).
UBC97Z: This is 0.075, 0.15, 0.2, 0.3 or 0.4, indicating the seismic zone factor.
This item is applicable only when the seismic coefficients Ca and Cv are calculated in accordance with code (UBC97SeismicCoeffFlag = 1).
UBC97Ca: The seismic coefficient, Ca.
This item is applicable only when the seismic coefficients Ca and Cv are user defined (UBC97SeismicCoeffFlag = 2).
UBC97Cv: The seismic coefficient, Cv.
This item is applicable only when the seismic coefficients Ca and Cv are user defined (UBC97SeismicCoeffFlag = 2).
UBC97NearSourceFlag: This is either 1 or 2, indicating if the near source factor coefficients Na and Nv are per code or user defined.
1 = Per code
2 = User defined

This item is applicable only when the seismic coefficients Ca and Cv are calculated in accordance with the code (UBC97SeismicCoeffFlag = 1) and UBC97Z = 0.4.
UBC97SourceType: This is 1, 2 or 3, indicating the seismic source type.
1 = A
2 = B
3 = C

This item is applicable only when the seismic coefficients Ca and Cv are calculated in accordance with code (UBC97SeismicCoeffFlag = 1), UBC97Z = 0.4, and the near source factor coefficients Na and Nv are calculated in accordance with code (UBC97NearSourceFlag = 1).
UBC97Dist: This is the distance to the seismic source in kilometers.
This item is applicable only when the seismic coefficients Ca and Cv are calculated in accordance with code (UBC97SeismicCoeffFlag = 1), UBC97Z = 0.4, and the near source factor coefficients Na and Nv are calculated in accordance with code (UBC97NearSourceFlag = 1).
UBC97Na: The near source factor coefficient, Na.
This item is applicable only when the seismic coefficients Ca and Cv are user defined (UBC97SeismicCoeffFlag = 2) and the near source factor coefficients Na and Nv are user defined (UBC97NearSourceFlag = 2).
UBC97Nv: The near source factor coefficient, Nv.
This item is applicable only when the seismic coefficients Ca and Cv are user defined (UBC97SeismicCoeffFlag = 2) and the near source factor coefficients Na and Nv are user defined (UBC97NearSourceFlag = 2).
UBC97I: The importance factor.
UBC97R: The overstrength factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, UBC97SeismicCoeffFlag, UBC97SoilProfileType, UBC97Z, UBC97Ca, UBC97Cv, UBC97NearSourceFlag, UBC97SourceType, UBC97Dist, UBC97Na, UBC97Nv, UBC97I, UBC97R]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetUBC97(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUBC97" failed')
        
        return ret

    def SetUserCoefficient(self, Name = None, DirFlag = None, Eccen = None, UserZ = None, TopZ = None, BottomZ = None, c = None, k = None):
        """
This function assigns auto seismic loading parameters for User Coefficient type loading.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is either 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
c: The base shear coefficient.
k: The building height exponent.
        """

        all_args = [Name, DirFlag, Eccen, UserZ, TopZ, BottomZ, c, k]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetUserCoefficient(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUserCoefficient" failed')
        
        return ret

    def SetUserLoadValue(self, Name = None, Diaph = None, Fx = None, Fy = None, Mz = None, x = None, y = None):
        """
This function assigns loading to an auto seismic load that is a User Load type. The SetUserLoad function is used to specify that an auto seismic load is a User Load type
The function returns zero if the loading is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern that has been assigned a User Load auto seismic type.
Diaph: The name of an existing special rigid diaphragm constraint, that is, a diaphragm constraint with the following features:
1. The constraint type is CONSTRAINT_DIAPHRAGM = 2.
2. The constraint coordinate system is Global.
3. The constraint axis is Z.
Fx: The global X direction force assigned to the specified diaphragm. [F]
Fy: The global Y direction force assigned to the specified diaphragm. [F]
Mz: The moment about the global Z axis assigned to the specified diaphragm. [FL]
x: The global X-coordinate of the point where the seismic force is applied. [L]
This item is applicable only when the auto seismic load is specified to have a user specified application point (see the SetUserLoad function).
y: The global Y-coordinate of the point where the seismic force is applied. [L]
This item is applicable only when the auto seismic load is specified to have a user specified application point (see the SetUserLoad function).
        """

        all_args = [Name, Diaph, Fx, Fy, Mz, x, y]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetUserLoadValue(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUserLoadValue" failed')
        
        return ret

    def SetUserLoad(self, Name = None, MyType = None, Eccen = None):
        """
This function sets the auto seismic load type to User Load. User load values are assigned using the SetUserLoadValue function.
The function returns zero if the load type is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
MyType: This is either 1 or 2, indicating the application point type for the user load.
1 = User specified application point
2 = At center of mass with optional additional eccentricity
Eccen: The eccentricity ratio that applies to all diaphragms. This item is only applicable when MyType = 2.
        """

        all_args = [Name, MyType, Eccen]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetUserLoad(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUserLoad" failed')
        
        return ret

    def GetChinese2002(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, JGJ32002AlphaMax = None, JGJ32002SI = None, JGJ32002DampRatio = None, JGJ32002Tg = None, JGJ32002PTDF = None, EnhancementFactor = None):
        """
This function retrieves auto seismic loading parameters for the Chinese 2002 code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a Chinese 2002 auto seismic load assignment.
DirFlag: This is 1, 2 or 3, indicating the seismic load direction.
1 = Global X
2 = Global Y
3 = Global Z
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is either 2 or 3, indicating the time period option.
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
JGJ32002AlphaMax: The maximum influence factor.
JGJ32002SI: This is 1, 2, 3, 4, 5 or 6, indicating the seismic intensity.
1 = 6(0.05g)
2 = 7(0.10g)
3 = 7(0.15g)
4 = 8(0.20g)
5 = 8(0.30g)
6 = 9(0.40g)
JGJ32002DampRatio: The damping ratio.
JGJ32002Tg: The characteristic ground period. [s]
JGJ32002PTDF: The period time discount factor.
EnhancementFactor: The enhancement factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, UserT, UserZ, TopZ, BottomZ, JGJ32002AlphaMax, JGJ32002SI, JGJ32002DampRatio, JGJ32002Tg, JGJ32002PTDF, EnhancementFactor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetChinese2002(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetChinese2002" failed')
        
        return ret

    def GetEurocode82004(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, EURO2004GroundType = None, EURO2004SpectrumType = None, EURO2004ag = None, EURO2004Beta = None, EURO2004q = None, EURO2004Lambda = None):
        """
This function retrieves auto seismic loading parameters for the Eurocode 8 2004 code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a Eurocode 8 2004 auto seismic load assignment.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified Ct factor. This item applies when the PeriodFlag item is 1.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
EURO2004GroundType: This is 1, 2, 3, 4 or 5, indicating the ground type.
1 = A
2 = B
3 = C
4 = D
5 = E
EURO2004SpectrumType: This is 1 or 2, indicating the spectrum type.
1 = Type 1
2 = Type 2
EURO2004ag: The design ground acceleration in g, ag.
EURO2004Beta: The lower bound factor, Beta.
EURO2004q: The behavior factor, q.
EURO2004Lambda: The correction factor, Lambda.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, EURO2004GroundType, EURO2004SpectrumType, EURO2004ag, EURO2004Beta, EURO2004q, EURO2004Lambda]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetEurocode82004(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEurocode82004" failed')
        
        return ret

    def GetNZS11702004(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, NZS2004SiteClass = None, NZS2004Z = None, NZS2004R = None, NZS2004DIST = None, NZS2004Sp = None, NZS2004Mu = None):
        """
This function retrieves auto seismic loading parameters for the NZS 1170 2004 code.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with a NZS 1170 2004 auto seismic load assignment.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
NZS2004SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
NZS2004Z: The hazard factor, Z.
NZS2004R: The return period factor, R.
NZS2004DIST: Distance to the fault in km, used to calculate the near fault factor..
NZS2004Sp: The structural performance factor, Sp.
NZS2004Mu: The structural ductility factor, u.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, UserT, UserZ, TopZ, BottomZ, NZS2004SiteClass, NZS2004Z, NZS2004R, NZS2004DIST, NZS2004Sp, NZS2004Mu]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetNZS11702004(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNZS11702004" failed')
        
        return ret

    def GetNZS11702004_1(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, NZS2004SiteClass = None, NZS2004Z = None, NZS2004R = None, NZS2004DIST = None, NZS2004Sp = None, NZS2004Mu = None, NZS2004ConsiderTSite = None, NZS2004TSite = None):
        """
This function retrieves auto seismic loading parameters 
 for the NZS 1170 2004 code.
The function returns zero if the parameters are successfully 
 retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern with 
 a NZS 1170 2004 auto seismic load assignment.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when 
 the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of 
 the seismic load are user specified. It is False if the elevations are 
 determined by the program.
TopZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the highest level where auto seismic 
 loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the lowest level where auto seismic loads 
 are applied. [L]
NZS2004SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
NZS2004Z: The hazard factor, Z.
NZS2004R: The return period factor, R.
NZS2004DIST: Distance to the fault in km, used to calculate the near 
 fault factor..
NZS2004Sp: The structural performance factor, Sp.
NZS2004Mu: The structural ductility factor, u.
NZS2004ConsiderTSite: Indicates whether to consider the site period for the 
 spectral shape factor.
NZS2004TSite: The low amplitude site period.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, UserT, UserZ, TopZ, BottomZ, NZS2004SiteClass, NZS2004Z, NZS2004R, NZS2004DIST, NZS2004Sp, NZS2004Mu, NZS2004ConsiderTSite, NZS2004TSite]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.GetNZS11702004_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNZS11702004_1" failed')
        
        return ret

    def SetChinese2002(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, JGJ32002AlphaMax = None, JGJ32002SI = None, JGJ32002DampRatio = None, JGJ32002Tg = None, JGJ32002PTDF = None, EnhancementFactor = None):
        """
This function assigns auto seismic loading parameters for the Chinese 2002 code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is 1, 2 or 3, indicating the seismic load direction.
1 = Global X
2 = Global Y
3 = Global Z
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is either 2 or 3, indicating the time period option.
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
JGJ32002AlphaMax: The maximum influence factor.
JGJ32002SI: This is 1, 2, 3, 4, 5 or 6, indicating the seismic intensity.
1 = 6(0.05g)
2 = 7(0.10g)
3 = 7(0.15g)
4 = 8(0.20g)
5 = 8(0.30g)
6 = 9(0.40g)
JGJ32002DampRatio: The damping ratio.
JGJ32002Tg: The characteristic ground period. [s]
JGJ32002PTDF: The period time discount factor.
EnhancementFactor: The enhancement factor.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, UserT, UserZ, TopZ, BottomZ, JGJ32002AlphaMax, JGJ32002SI, JGJ32002DampRatio, JGJ32002Tg, JGJ32002PTDF, EnhancementFactor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetChinese2002(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetChinese2002" failed')
        
        return ret

    def SetEurocode82004(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, CT = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, EURO2004GroundType = None, EURO2004SpectrumType = None, EURO2004ag = None, EURO2004Beta = None, EURO2004q = None, EURO2004Lambda = None):
        """
This function assigns auto seismic loading parameters for the Eurocode 8 2004 code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
CT: The code-specified Ct factor. This item applies when the PeriodFlag item is 1.
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
EURO2004GroundType: This is 1, 2, 3, 4 or 5, indicating the ground type.
1 = A
2 = B
3 = C
4 = D
5 = E
EURO2004SpectrumType: This is 1 or 2, indicating the spectrum type.
1 = Type 1
2 = Type 2
EURO2004ag: The design ground acceleration in g, ag.
EURO2004Beta: The lower bound factor, Beta.
EURO2004q: The behavior factor, q.
EURO2004Lambda: The correction factor, Lambda.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, CT, UserT, UserZ, TopZ, BottomZ, EURO2004GroundType, EURO2004SpectrumType, EURO2004ag, EURO2004Beta, EURO2004q, EURO2004Lambda]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetEurocode82004(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEurocode82004" failed')
        
        return ret

    def SetNZS11702004(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, NZS2004SiteClass = None, NZS2004Z = None, NZS2004R = None, NZS2004DIST = None, NZS2004Sp = None, NZS2004Mu = None):
        """
This function assigns auto seismic loading parameters for the NZS 1170.5 2004 code.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of the seismic load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto seismic loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto seismic loads are applied. [L]
NZS2004SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
NZS2004Z: The hazard factor, Z.
NZS2004R: The return period factor, R.
NZS2004DIST: Distance to the fault in km, used to calculate the near fault factor.
NZS2004Sp: The structural performance factor, Sp.
NZS2004Mu: The structural ductility factor, u.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, UserT, UserZ, TopZ, BottomZ, NZS2004SiteClass, NZS2004Z, NZS2004R, NZS2004DIST, NZS2004Sp, NZS2004Mu]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetNZS11702004(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNZS11702004" failed')
        
        return ret

    def SetNZS11702004_1(self, Name = None, DirFlag = None, Eccen = None, PeriodFlag = None, UserT = None, UserZ = None, TopZ = None, BottomZ = None, NZS2004SiteClass = None, NZS2004Z = None, NZS2004R = None, NZS2004DIST = None, NZS2004Sp = None, NZS2004Mu = None, NZS2004ConsiderTSite = None, NZS2004TSite = None):
        """
This function assigns auto seismic loading parameters 
 for the NZS 1170.5 2004 code.
The function returns zero if the parameters are successfully 
 assigned; otherwise it returns a nonzero value.

Name: The name of an existing Quake-type load pattern.
DirFlag: This is 1 or 2, indicating the seismic load direction.
1 = Global X
2 = Global Y
Eccen: The eccentricity ratio that applies to all diaphragms.
PeriodFlag: This is 1, 2 or 3, indicating the time period option.
1 = Approximate
2 = Program calculated
3 = User defined
UserT: The user specified time period. This item applies when 
 the PeriodFlag item is 3. [s]
UserZ: This item is True if the top and bottom elevations of 
 the seismic load are user specified. It is False if the elevations are 
 determined by the program.
TopZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the highest level where auto seismic 
 loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the lowest level where auto seismic loads 
 are applied. [L]
NZS2004SiteClass: This is 1, 2, 3, 4 or 5, indicating the site class.
1 = A
2 = B
3 = C
4 = D
5 = E
NZS2004Z: The hazard factor, Z.
NZS2004R: The return period factor, R.
NZS2004DIST: Distance to the fault in km, used to calculate the near 
 fault factor.
NZS2004Sp: The structural performance factor, Sp.
NZS2004Mu: The structural ductility factor, u.
NZS2004ConsiderTSite: Indicates whether to consider the site period for the 
 spectral shape factor.
NZS2004TSite: The low amplitude site period.
        """

        all_args = [Name, DirFlag, Eccen, PeriodFlag, UserT, UserZ, TopZ, BottomZ, NZS2004SiteClass, NZS2004Z, NZS2004R, NZS2004DIST, NZS2004Sp, NZS2004Mu, NZS2004ConsiderTSite, NZS2004TSite]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoSeismic.SetNZS11702004_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNZS11702004_1" failed')
        
        return ret

class AutoWindBridge:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetAASHTO2018(self, Name = None, LimitState = None, Superstructure = None, Substructure = None, Vertical = None, GroundElevation = None, SuperZProgCalc = None, SuperstructureZ = None, SubZProgCalc = None, WindSpeed = None, ExposureCategory = None, G = None, CdSuper = None, CdSub = None):
        """
This function retrieves bridge auto wind loading parameters for AASHTO 2018.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
LimitState: The limit state associated with the wind load.
1 = Strength III
2 = Strength V
3 = Service I
4 = Service IV

Superstructure: This item is True if wind on the superstructure should be considered, otherwise it is false.
Substructure: This item is True if wind on the substructure should be considered, otherwise it is false.
Vertical: This item is True if vertical wind should be considered, otherwise it is false
GroundElevation: The ground elevation used for determining heights used for wind pressure values. [L]
SuperZProgCalc: This item is True if the superstructure height, Z, should be program calculated, otherwise it is false.
SuperstructureZ: The substructure height Z. This item applies only when SubProgCalc = False. [L]
SubZProgCalc: This item is True if the substructure height, Z, should be program calculated, otherwise it is false.
WindSpeed: The wind speed in mph.
ExposureCategory: The wind exposure category.
1 = B
2 = C
3 = D

G: The gust effect factor, G.
CdSuper: The drag coefficient for the superstructure.
CdSub: The drag coefficient for the substructure.
        """

        all_args = [Name, LimitState, Superstructure, Substructure, Vertical, GroundElevation, SuperZProgCalc, SuperstructureZ, SubZProgCalc, WindSpeed, ExposureCategory, G, CdSuper, CdSub]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.GetAASHTO2018(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAASHTO2018" failed')
        
        return ret

    def GetAngles(self, Name = None, SymmetricTran = None, SymmetricLong = None, UserDefined = None, NumberAngles = None, Angles = None, TranCoeff = None, LongCoeff = None):
        """
This function retrieves the bridge wind angle data for a specified load pattern.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing bridge wind load pattern.
SymmetricTran: This is True if the angles are symmetric about the transverse axis, otherwise False.
SymmetricLong: This is True if the angles are symmetric about the longitudinal axis, otherwise False. 
UserDefined: This is True if the angles are user defined, otherwise False.
NumberAngles: The number of angles specified for the load pattern. This is only used if UserDefined = True.
Angles: This is an array containing the wind angles. All angles are returned, including those generated due to the symmetry options.
TranCoeff: This is an array containing the transverse coefficients corresponding with the angles. This is only used if UserDefined = True.
LongCoeff: This is an array containing the longitudinal coefficients corresponding with the angles. This is only used if UserDefined = True.
        """

        all_args = [Name, SymmetricTran, SymmetricLong, UserDefined, NumberAngles, Angles, TranCoeff, LongCoeff]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.GetAngles(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAngles" failed')
        
        return ret

    def GetAutoLiveLoad(self, Name = None, RefLoadPat = None, Height = None):
        """
This function retrieves auto wind on live load parameters.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing bridge wind - live load type pattern.
RefLoadPat: The name of an existing bridge wind load pattern that is referenced from this wind on live load pattern.
Height: The height above the roadway surface at which the wind on live load should be applied. [L]
        """

        all_args = [Name, RefLoadPat, Height]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.GetAutoLiveLoad(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAutoLiveLoad" failed')
        
        return ret

    def GetCSAS614(self, Name = None, Superstructure = None, Substructure = None, Vertical = None, GroundElevation = None, SuperZProgCalc = None, SuperstructureZ = None, q = None, Cg = None, CeProgCalc = None, Ce = None, ChStructure = None, ChLiveLoad = None, Cv = None):
        """
This function retrieves bridge auto wind loading parameters for CSA S6-14.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
Superstructure: This item is True if wind on the superstructure should be considered, otherwise it is false.
Substructure: This item is True if wind on the substructure should be considered, otherwise it is false.
Vertical: This item is True if vertical wind should be considered, otherwise it is false
GroundElevation: The ground elevation used for determining heights used for wind pressure values. [L]
SuperZProgCalc: This item is True if the superstructure height, Z, should be program calculated, otherwise it is false.
SuperstructureZ: The superstructure height Z. This item applies only when SuperProgCalc = False. [L]
q: The reference wind pressure, q. [F/L2]
Cg: The gust effect factor.
CeProgCalc: This item is True if the wind exposure factor, Ce, should be program calculated, otherwise it is false.
Ce: The wind exposure factor. This item applies only when CeProgCalc = False.
ChStructure: The Ch factor for wind acting on the structure.
ChLiveLoad: The Ch factor for wind acting on the live load.
Cv: The Cv factor for vertical wind.
        """

        all_args = [Name, Superstructure, Substructure, Vertical, GroundElevation, SuperZProgCalc, SuperstructureZ, q, Cg, CeProgCalc, Ce, ChStructure, ChLiveLoad, Cv]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.GetCSAS614(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCSAS614" failed')
        
        return ret

    def GetEurocode12005(self, Name = None, Superstructure = None, Substructure = None, Vertical = None, GroundElevation = None, SuperZProgCalc = None, SuperstructureZ = None, SubZProgCalc = None, WindSpeed = None, Terrain = None, Orography = None, k1 = None, Rho = None, Cfx = None, CfzUp = None):
        """
This function retrieves bridge auto wind loading parameters for Eurocode 1-2005.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
Superstructure: This item is True if wind on the superstructure should be considered, otherwise it is false.
Substructure: This item is True if wind on the substructure should be considered, otherwise it is false.
Vertical: This item is True if vertical wind should be considered, otherwise it is false
GroundElevation: The ground elevation used for determining heights used for wind pressure values. [L]
SuperZProgCalc: This item is True if the superstructure height, Z, should be program calculated, otherwise it is false.
SuperstructureZ: The substructure height Z. This item applies only when SubProgCalc = False. [L]
SubZProgCalc: This item is True if the substructure height, Z, should be program calculated, otherwise it is false.
WindSpeed: The basic wind speed, vb, in meters per second.
Terrain: The terrain category.
0 = 0
1 = I
2 = II
3 = III
4 = IV

Orography: The orography factor, Co.
k1: The turbulence factor, k1.
Rho: The air density in kg/m3, Rho.
Cfx: The force coefficient, Cf, in the horizontal direction.
CfzUp: The force coefficient, Cf, in the vertical up direction.
        """

        all_args = [Name, Superstructure, Substructure, Vertical, GroundElevation, SuperZProgCalc, SuperstructureZ, SubZProgCalc, WindSpeed, Terrain, Orography, k1, Rho, Cfx, CfzUp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.GetEurocode12005(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEurocode12005" failed')
        
        return ret

    def SetAASHTO2018(self, Name = None, LimitState = None, Superstructure = None, Substructure = None, Vertical = None, GroundElevation = None, SuperZProgCalc = None, SuperstructureZ = None, SubZProgCalc = None, WindSpeed = None, ExposureCategory = None, G = None, CdSuper = None, CdSub = None):
        """
This function sets bridge auto wind loading parameters for AASHTO 2018.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
LimitState: The limit state associated with the wind load.
1 = Strength III
2 = Strength V
3 = Service I
4 = Service IV

Superstructure: This item is True if wind on the superstructure should be considered, otherwise it is false.
Substructure: This item is True if wind on the substructure should be considered, otherwise it is false.
Vertical: This item is True if vertical wind should be considered, otherwise it is false
GroundElevation: The ground elevation used for determining heights used for wind pressure values. [L]
SuperZProgCalc: This item is True if the superstructure height, Z, should be program calculated, otherwise it is false.
SuperstructureZ: The substructure height Z. This item applies only when SubProgCalc = False. [L]
SubZProgCalc: This item is True if the substructure height, Z, should be program calculated, otherwise it is false.
WindSpeed: The wind speed in mph.
ExposureCategory: The wind exposure category.
1 = B
2 = C
3 = D
G: The gust effect factor, G.
CdSuper: The drag coefficient for the superstructure.
CdSub: The drag coefficient for the substructure.
        """

        all_args = [Name, LimitState, Superstructure, Substructure, Vertical, GroundElevation, SuperZProgCalc, SuperstructureZ, SubZProgCalc, WindSpeed, ExposureCategory, G, CdSuper, CdSub]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.SetAASHTO2018(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAASHTO2018" failed')
        
        return ret

    def SetAngles(self, Name = None, SymmetricTran = None, SymmetricLong = None, UserDefined = None, NumberAngles = None, Angles = None, TranCoeff = None, LongCoeff = None):
        """
This function sets the bridge wind angle data for a specified load pattern.
The function returns zero if the data is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing bridge wind load pattern.
SymmetricTran: This is True if the angles are symmetric about the transverse axis, otherwise False.
SymmetricLong: This is True if the angles are symmetric about the longitudinal axis, otherwise False. 
UserDefined: This is True if the angles are user defined, otherwise False.
NumberAngles: The number of angles specified for the load pattern. This is only used if UserDefined = True.
Angles: This is an array containing the wind angles. If duplicates are included, only the first one will be used. If SymmetricTran = True and/or SymmetricLong = True, only angles between 0 and 90 degrees will be used. Additional angles will be generated via the symmetry conditions. This is only used if UserDefined = True.
TranCoeff: This is an array containing the transverse coefficients corresponding with the angles. This is only used if UserDefined = True.
LongCoeff: This is an array containing the longitudinal coefficients corresponding with the angles. This is only used if UserDefined = True.
        """

        all_args = [Name, SymmetricTran, SymmetricLong, UserDefined, NumberAngles, Angles, TranCoeff, LongCoeff]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.SetAngles(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAngles" failed')
        
        return ret

    def SetAutoLiveLoad(self, Name = None, RefLoadPat = None, Height = None):
        """
This function applies auto wind on live load parameters.
The function returns zero if the parameters are successfully applied; otherwise it returns a nonzero value.

Name: The name of an existing bridge wind - live load type pattern.
RefLoadPat: The name of an existing bridge wind load pattern that is referenced from this wind on live load pattern.
Height: The height above the roadway surface at which the wind on live load should be applied. [L]
        """

        all_args = [Name, RefLoadPat, Height]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.SetAutoLiveLoad(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAutoLiveLoad" failed')
        
        return ret

    def SetCSAS614(self, Name = None, Superstructure = None, Substructure = None, Vertical = None, GroundElevation = None, SuperZProgCalc = None, SuperstructureZ = None, q = None, Cg = None, CeProgCalc = None, Ce = None, ChStructure = None, ChLiveLoad = None, Cv = None):
        """
This function sets bridge auto wind loading parameters for CSA S6-14.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
Superstructure: This item is True if wind on the superstructure should be considered, otherwise it is false.
Substructure: This item is True if wind on the substructure should be considered, otherwise it is false.
Vertical: This item is True if vertical wind should be considered, otherwise it is false
GroundElevation: The ground elevation used for determining heights used for wind pressure values. [L]
SuperZProgCalc: This item is True if the superstructure height, Z, should be program calculated, otherwise it is false.
SuperstructureZ: The superstructure height Z. This item applies only when SuperProgCalc = False. [L]
q: The reference wind pressure, q. [F/L2]
Cg: The gust effect factor.
CeProgCalc: This item is True if the wind exposure factor, Ce, should be program calculated, otherwise it is false.
Ce: The wind exposure factor. This item applies only when CeProgCalc = False.
ChStructure: The Ch factor for wind acting on the structure.
ChLiveLoad: The Ch factor for wind acting on the live load.
Cv: The Cv factor for vertical wind.
        """

        all_args = [Name, Superstructure, Substructure, Vertical, GroundElevation, SuperZProgCalc, SuperstructureZ, q, Cg, CeProgCalc, Ce, ChStructure, ChLiveLoad, Cv]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.SetCSAS614(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCSAS614" failed')
        
        return ret

    def SetEurocode12005(self, Name = None, Superstructure = None, Substructure = None, Vertical = None, GroundElevation = None, SuperZProgCalc = None, SuperstructureZ = None, SubZProgCalc = None, WindSpeed = None, Terrain = None, Orography = None, k1 = None, Rho = None, Cfx = None, CfzUp = None):
        """
This function sets bridge auto wind loading parameters for Eurocode 1-2005.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
Superstructure: This item is True if wind on the superstructure should be considered, otherwise it is false.
Substructure: This item is True if wind on the substructure should be considered, otherwise it is false.
Vertical: This item is True if vertical wind should be considered, otherwise it is false
GroundElevation: The ground elevation used for determining heights used for wind pressure values. [L]
SuperZProgCalc: This item is True if the superstructure height, Z, should be program calculated, otherwise it is false.
SuperstructureZ: The substructure height Z. This item applies only when SubProgCalc = False. [L]
SubZProgCalc: This item is True if the substructure height, Z, should be program calculated, otherwise it is false.
WindSpeed: The basic wind speed, vb, in meters per second.
Terrain: The terrain category.
0 = 0
1 = I
2 = II
3 = III
4 = IV

Orography: The orography factor, Co.
k1: The turbulence factor, k1.
Rho: The air density in kg/m3, Rho.
Cfx: The force coefficient, Cf, in the horizontal direction.
CfzUp: The force coefficient, Cf, in the vertical up direction.
        """

        all_args = [Name, Superstructure, Substructure, Vertical, GroundElevation, SuperZProgCalc, SuperstructureZ, SubZProgCalc, WindSpeed, Terrain, Orography, k1, Rho, Cfx, CfzUp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.SetEurocode12005(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEurocode12005" failed')
        
        return ret

    def SetNoneLiveLoad(self, Name = None):
        """
This function sets the auto wind – live load type for the specified load pattern to None.
The function returns zero if the loading type is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing bridge wind - live load type pattern.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.SetNoneLiveLoad(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNoneLiveLoad" failed')
        
        return ret

    def GetIRC62017(self, Name = None, Superstructure = None, Substructure = None, Vertical = None, GroundElevation = None, SuperZProgCalc = None, SuperstructureZ = None, SubZProgCalc = None, SubstructureZ = None, vb = None, Terrain = None, G = None, CDSuper = None, CDSub = None, CL = None):
        """
This function retrieves bridge auto wind loading parameters 
 for IRC:6-2017.
The function returns zero if the parameters are successfully 
 assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
Superstructure: This item is True if wind on the superstructure should 
 be considered, otherwise it is false.
Substructure: This item is True if wind on the substructure should 
 be considered, otherwise it is false.
Vertical: This item is True if vertical wind should be considered, 
 otherwise it is false
GroundElevation: The ground elevation used for determining heights used 
 for wind pressure values. [L]
SuperZProgCalc: This item is True if the superstructure height, Z, should 
 be program calculated, otherwise it is false.
SuperstructureZ: The superstructure height Z. This item applies only 
 when SuperProgCalc = False. [L]
SubZProgCalc: This item is True if the substructure height, Z, should 
 be program calculated, otherwise it is false.
SubstructureZ: The substructure height Z. This item applies only when 
 SubProgCalc = False. [L]
vb: The basic wind speed. [m/s]
Terrain: The terrain type.
0 
 = Plain
1 
 = Obstructions

G: The gust factor, G.
CDSuper: The drag coefficient for the superstructure, CD.
CDSub: The drag coefficient for the substructure, CD.
CL: The lift coefficient, CL, for vertical wind.
        """

        all_args = [Name, Superstructure, Substructure, Vertical, GroundElevation, SuperZProgCalc, SuperstructureZ, SubZProgCalc, SubstructureZ, vb, Terrain, G, CDSuper, CDSub, CL]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.GetIRC62017(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetIRC62017" failed')
        
        return ret

    def SetIRC62017(self, Name = None, Superstructure = None, Substructure = None, Vertical = None, GroundElevation = None, SuperZProgCalc = None, SuperstructureZ = None, SubZProgCalc = None, SubstructureZ = None, vb = None, Terrain = None, G = None, CDSuper = None, CDSub = None, CL = None):
        """
This function sets bridge auto wind loading parameters 
 for IRC:6-2017.
The function returns zero if the parameters are successfully 
 assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
Superstructure: This item is True if wind on the superstructure should 
 be considered, otherwise it is false.

Substructure: This item is True if wind on the substructure should 
 be considered, otherwise it is false.
Vertical: This item is True if vertical wind should be considered, 
 otherwise it is false
GroundElevation: The ground elevation used for determining heights used 
 for wind pressure values. [L]
SuperZProgCalc: This item is True if the superstructure height, Z, should 
 be program calculated, otherwise it is false.
SuperstructureZ: The superstructure height Z. This item applies only 
 when SuperProgCalc = False. [L]
SubZProgCalc: This item is True if the substructure height, Z, should 
 be program calculated, otherwise it is false.
SubstructureZ: The substructure height Z. This item applies only when 
 SubProgCalc = False. [L]
vb: The basic wind speed. [m/s]
Terrain: The terrain type.
0 
 = Plain
1 
 = Obstructions

G: The gust factor, G.
CDSuper: The drag coefficient for the superstructure, CD.
CDSub: The drag coefficient for the substructure, CD.
CL: The lift coefficient, CL, for vertical wind.
        """

        all_args = [Name, Superstructure, Substructure, Vertical, GroundElevation, SuperZProgCalc, SuperstructureZ, SubZProgCalc, SubstructureZ, vb, Terrain, G, CDSuper, CDSub, CL]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWindBridge.SetIRC62017(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetIRC62017" failed')
        
        return ret

class AutoWind:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetAPI4F2008_1(self, Name = None, ExposureFrom = None, DirAngle = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, SSLFactor = None, ShieldingFactor = None):
        """
This function retrieves auto wind loading parameters for API 4F 2008.
The function returns zero if the parameters are successfully assigned; otherwise, it returns a nonzero value.

Name: The name of an existing Wind-type load case with an API 4F 2008 auto wind assignment.
ExposureFrom: This is 2, 3, or 4, indicating the source of the wind exposure.
2 = From area objects
3 = From frame objects (open structure)
4 = From area objects and frame objects (open structure)
DirAngle: The direction angle for the wind load.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified.
It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The design reference wind velocity, Vref, in knots.
SSLFactor: The structural safety level multiplier.
ShieldingFactor: The shielding factor.
        """

        all_args = [Name, ExposureFrom, DirAngle, UserZ, TopZ, BottomZ, WindSpeed, SSLFactor, ShieldingFactor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetAPI4F2008_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAPI4F2008_1" failed')
        
        return ret

    def GetAPI4F2013(self, Name = None, ExposureFrom = None, DirAngle = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, SSLFactor = None, ShieldingFactor = None):
        """
This function retrieves auto wind loading parameters for API 4F 2013.
The function returns zero if the parameters are successfully assigned; otherwise, it returns a nonzero value.

Name: The name of an existing Wind-type load case with an API 4F 2013 auto wind assignment.
ExposureFrom: This is 2, 3, or 4, indicating the source of the wind exposure.
2 = From area objects
3 = From frame objects (open structure)
4 = From area objects and frame objects (open structure)
DirAngle: The direction angle for the wind load.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified.
It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The design reference wind velocity, Vref, in knots.
SSLFactor: The structural safety level multiplier.
ShieldingFactor: The shielding factor.
        """

        all_args = [Name, ExposureFrom, DirAngle, UserZ, TopZ, BottomZ, WindSpeed, SSLFactor, ShieldingFactor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetAPI4F2013(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAPI4F2013" failed')
        
        return ret

    def GetASCE702(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, ASCECase = None, ASCEe1 = None, ASCEe2 = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, Kzt = None, GustFactor = None, Kd = None, SolidGrossRatio = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for ASCE 7-02.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an ASCE7-02 auto wind assignment.
ExposureFrom: This is 1, 2, 3 or 4, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
3 = From frame objects (open structure)
4 = From area objects and frame objects (open structure)
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
ASCECase: This is 1, 2, 3, 4 or 5, indicating the desired case from ASCE7-02 Figure 6-9. 1, 2, 3 and 4 refer to cases 1 through 4 in the figure. 5 means to create all cases. This item applies only when ExposureFrom = 1.
ASCEe1: This is the value e1 in ASCE7-02 Figure 6-9. This item applies only when ExposureFrom = 1.
ASCEe2: This is the value e2 in ASCE7-02 Figure 6-9. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2, 3 or 4, indicating the exposure category.
1 = A
2 = B
3 = C
4 = D
ImportanceFactor: The importance factor.
Kzt: The topographical factor.
GustFactor: The gust factor.
Kd: The directionality factor.
SolidGrossRatio: The solid area divided by gross area ratio for open frame structure loading. This item applies only when the loading is from open structure wind loading (ExposureFrom = 3 or ExposureFrom = 4).
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, ASCECase, ASCEe1, ASCEe2, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, Kzt, GustFactor, Kd, SolidGrossRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetASCE702(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetASCE702" failed')
        
        return ret

    def GetASCE705(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, ASCECase = None, ASCEe1 = None, ASCEe2 = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, Kzt = None, GustFactor = None, Kd = None, SolidGrossRatio = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for ASCE 7-05.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an ASCE7-05 auto wind assignment.
ExposureFrom: This is 1, 2, 3 or 4, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
3 = From frame objects (open structure)
4 = From area objects and frame objects (open structure)
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
ASCECase: This is 1, 2, 3, 4 or 5, indicating the desired case from ASCE7-05 Figure 6-9. 1, 2, 3 and 4 refer to cases 1 through 4 in the figure. 5 means to create all cases. This item applies only when ExposureFrom = 1.
ASCEe1: This is the value e1 in ASCE7-05 Figure 6-9. This item applies only when ExposureFrom = 1.
ASCEe2: This is the value e2 in ASCE7-05 Figure 6-9. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2 or 3, indicating the exposure category.
1 = B
2 = C
3 = D
ImportanceFactor: The importance factor.
Kzt: The topographical factor.
GustFactor: The gust factor.
Kd: The directionality factor.
SolidGrossRatio: The solid area divided by the gross area ratio for open frame structure loading. This item applies only when the loading is from open structure wind loading (ExposureFrom = 3 or ExposureFrom = 4).
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, ASCECase, ASCEe1, ASCEe2, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, Kzt, GustFactor, Kd, SolidGrossRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetASCE705(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetASCE705" failed')
        
        return ret

    def GetASCE710(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, ASCECase = None, ASCEe1 = None, ASCEe2 = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, Kzt = None, GustFactor = None, Kd = None, SolidGrossRatio = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters 
 for ASCE 7-10.
The function returns zero if the parameters are successfully 
 assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with 
 an ASCE7-10 auto wind assignment.
ExposureFrom: This is 1, 2, 3 or 4, indicating the source of the wind 
 exposure.
1 = From extents of rigid 
 diaphragms
2 = From area objects
3 = From frame objects 
 (open structure)
4 = From area objects and 
 frame objects (open structure)
DirAngle: The direction angle for the wind load. This item applies 
 only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only 
 when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only 
 when ExposureFrom = 1.
ASCECase: This is 1, 2, 3, 4 or 5, indicating the desired case 
 from ASCE7-10 Figure 27.4-8. 1, 2, 3 and 4 refer to cases 1 through 4 
 in the figure. 5 means to create all cases. This item applies only when 
 ExposureFrom = 1.
ASCEe1: This is the value e1 in ASCE7-10 Figure 27.4-8. This 
 item applies only when ExposureFrom = 1.
ASCEe2: This is the value e2 in ASCE7-10 Figure 27.4-8. This 
 item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of 
 the wind load are user specified. It is False if the elevations are determined 
 by the program.
TopZ: This item is the global Z-coordinate at the highest 
 level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level 
 where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2 or 3, indicating the exposure category.
1 = B
2 = C
3 = D
ImportanceFactor: The importance factor.
Kzt: The topographical factor.
GustFactor: The gust factor.
Kd: The directionality factor.
SolidGrossRatio: The solid area divided by the gross area ratio for open 
 frame structure loading. This item applies only when the loading is from 
 open structure wind loading (ExposureFrom = 3 or ExposureFrom = 4).
UserExposure: If this item is True, the wind exposure widths are provided 
 by the user. If it is False, the wind exposure widths are calculated by 
 the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, ASCECase, ASCEe1, ASCEe2, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, Kzt, GustFactor, Kd, SolidGrossRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetASCE710(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetASCE710" failed')
        
        return ret

    def GetASCE716(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, ASCECase = None, ASCEe1 = None, ASCEe2 = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, Kzt = None, GustFactor = None, Kd = None, SolidGrossRatio = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters 
 for ASCE 7-16.
The function returns zero if the parameters are successfully 
 assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with 
 an ASCE7-16 auto wind assignment.
ExposureFrom: This is 1, 2, 3 or 4, indicating the source of the wind 
 exposure.
1 = From extents of rigid 
 diaphragms
2 = From area objects
3 = From frame objects 
 (open structure)
4 = From area objects and 
 frame objects (open structure)
DirAngle: The direction angle for the wind load. This item applies 
 only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only 
 when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only 
 when ExposureFrom = 1.
ASCECase: This is 1, 2, 3, 4 or 5, indicating the desired case 
 from ASCE7-16 Figure 27.3-8. 1, 2, 3 and 4 refer to cases 1 through 4 
 in the figure. 5 means to create all cases. This item applies only when 
 ExposureFrom = 1.
ASCEe1: This is the value e1 in ASCE7-16 Figure 27.3-8. This 
 item applies only when ExposureFrom = 1.
ASCEe2: This is the value e2 in ASCE7-16 Figure 27.3-8. This 
 item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of 
 the wind load are user specified. It is False if the elevations are determined 
 by the program.
TopZ: This item is the global Z-coordinate at the highest 
 level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level 
 where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2 or 3, indicating the exposure category.
1 = B
2 = C
3 = D
Kzt: The topographical factor.
GustFactor: The gust factor.
Kd: The directionality factor.
SolidGrossRatio: The solid area divided by the gross area ratio for open 
 frame structure loading. This item applies only when the loading is from 
 open structure wind loading (ExposureFrom = 3 or ExposureFrom = 4).
UserExposure: If this item is True, the wind exposure widths are provided 
 by the user. If it is False, the wind exposure widths are calculated by 
 the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, ASCECase, ASCEe1, ASCEe2, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, Kzt, GustFactor, Kd, SolidGrossRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetASCE716(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetASCE716" failed')
        
        return ret

    def GetASCE788(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, GustFactor = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for ASCE 7-88.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an ASCE7-88 auto wind assignment.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2, 3 or 4, indicating the exposure category.
1 = A
2 = B
3 = C
4 = D
ImportanceFactor: The importance factor.
GustFactor: The gust factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, GustFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetASCE788(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetASCE788" failed')
        
        return ret

    def GetASCE795(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, Kzt = None, GustFactor = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for ASCE 7-95.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an ASCE7-95 auto wind assignment.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2, 3 or 4, indicating the exposure category.
1 = A
2 = B
3 = C
4 = D
ImportanceFactor: The importance factor.
Kzt: The topographical factor.
GustFactor: The gust factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, Kzt, GustFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetASCE795(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetASCE795" failed')
        
        return ret

    def GetASNZS117022002(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, Ka = None, Kc = None, Kl = None, Kp = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, Cat = None, CycloneRegion = None, Md = None, Ms = None, Mt = None, Cdyn = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for AS/NZS 1170.2:2002.
The function returns zero if the parameters are successfully assigned; otherwise, it returns a nonzero value.

Name: The name of an existing Wind-type load case with an AS/NZS 1170.2:2002 auto wind assignment.
ExposureFrom: This is 1, or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
Ka: The area reduction factor, Ka.
Kc: The combination factor, Kc.
Kl: The local pressure factor, Kl.
Kp: The porous cladding factor, Kp.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The regional wind speed, Vr, in m/s.
Cat: This is 1, 2, 3 or 4, indicating the terrain category.
CycloneRegion: This is True or False, indicating if the structure is in a cyclone region.
Md: The directional multiplier, Md.
Ms: The shielding multiplier, Ms.
Mt: The topographic multiplier, Mt.
Cdyn: The dynamic response factor, Cdyn.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, Ka, Kc, Kl, Kp, UserZ, TopZ, BottomZ, WindSpeed, Cat, CycloneRegion, Md, Ms, Mt, Cdyn, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetASNZS117022002(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetASNZS117022002" failed')
        
        return ret

    def GetBOCA96(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, UserGust = None, GustFactor = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for BOCA 96.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an BOCA 96 auto wind assignment.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2, 3 or 4, indicating the exposure category.
1 = A
2 = B
3 = C
4 = D
ImportanceFactor: The importance factor.
UserGust: If this item is True, the gust factor is user defined. If it is False, the gust factor is determined from the code specified values.
GustFactor: The user defined gust factor. This item applies only when UserGust is True.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, UserGust, GustFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetBOCA96(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetBOCA96" failed')
        
        return ret

    def GetBS639995(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, Ve = None, Ca = None, Cr = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for BS6399-95.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an BS6399-95 auto wind assignment.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The front coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The rear coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
Ve: The effective wind speed in meters per second.
Ca: The size effect factor.
Cr: The dynamic augmentation factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, Ve, Ca, Cr, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetBS639995(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetBS639995" failed')
        
        return ret

    def GetChinese2010(self, Name = None, ExposureFrom = None, DirAngle = None, BuildingWidth = None, Us = None, UniformTaper = None, BHoverB0 = None, UserZ = None, TopZ = None, BottomZ = None, wzero = None, Rt = None, PhiZOpt = None, T1Opt = None, UserT = None, DampRatio = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for Chinese 2010.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an Chinese 2010 auto wind assignment.
ExposureFrom: This is 1 or 2 indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
BuildingWidth: The building width. [L]
Us: The shape coefficient. This item applies only when ExposureFrom = 1.
UniformTaper: This item is True if a correction is to be applied to the wind load for a uniform taper.
BHoverB0: The taper ratio, Bh/B0. This item applies only when UniformTaper = True.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
wzero: The basic wind pressure in kN/m2.
Rt: This is 1, 2, 3 or 4, indicating the ground roughness.
1 = A
2 = B
3 = C
4 = D
PhiZOpt: This is 0 or 1, indicating the Phi Z source.
0 = Modal analysis
1 = Z/H ratio
T1Opt: This is 0 or 1, indicating the T1 source.
0 = Modal analysis
1 = User defined
UserT: This item only applies when the T1 source is user defined (T1Opt = 1). It is the user defined T1 period. [s]
DampRatio: The damping ratio.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, BuildingWidth, Us, UniformTaper, BHoverB0, UserZ, TopZ, BottomZ, wzero, Rt, PhiZOpt, T1Opt, UserT, DampRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetChinese2010(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetChinese2010" failed')
        
        return ret

    def GetEurocode12005_1(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, Terrain = None, Orography = None, k1 = None, CsCd = None, Rho = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for Eurocode 1 2005.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with a Eurocode 1 2005 auto wind assignment.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The basic wind speed, vb, in meters per second.
Terrain: This is 0, 1, 2, 3 or 4, indicating the terrain category.
0 = 0
1 = I
2 = II
3 = III
4 = IV
Orography: The orography factor, Co.
k1: The turbulence factor, k1.
CsCd: The structural factor, CsCd.
Rho: The air density in kg/m3, Rho.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, Terrain, Orography, k1, CsCd, Rho, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetEurocode12005_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEurocode12005_1" failed')
        
        return ret

    def GetExposure_1(self, Name = None, Num = None, Diaph = None, x = None, y = None, MyWidth = None, MyDepth = None, Height = None):
        """
This function retrieves exposure parameters for auto wind loads determined from extents of rigid diaphragms. This function does not apply for User-type auto wind loads.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern that has an auto wind load assigned.
Num: The number of diaphragms at which exposure data is reported.
Diaph: This is an array that includes the names of the diaphragms that have eccentricity overrides.
x: This is an array that includes the global X-coordinate of the point where the wind force load is applied to the diaphragm. [L]
y: This is an array that includes the global Y-coordinate of the point where the wind force load is applied to the diaphragm. [L]
MyWidth: This is an array that includes the exposure width for the wind load applied to the specified diaphragm. [L]
MyDepth: This is an array that includes the exposure depth for the wind load applied to the specified diaphragm. [L]
Height: This is an array that includes the exposure height for the wind load applied to the specified diaphragm. [L]
        """

        all_args = [Name, Num, Diaph, x, y, MyWidth, MyDepth, Height]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetExposure_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetExposure_1" failed')
        
        return ret

    def GetIS8751987(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, Terrain = None, Class = None, K1 = None, K3 = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for Indian IS875-1987.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an Indian IS875-1987 auto wind assignment.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in meters per second.
Terrain: This is 1, 2, 3 or 4, indicating the terrain category.
Class: This is 1, 2 or 3, indicating the terrain category.
1 = A
2 = B
3 = C
K1: The risk coefficient (k1 factor).
K3: The topography factor (k3 factor).
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, Terrain, Class, K1, K3, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetIS8751987(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetIS8751987" failed')
        
        return ret

    def GetIS8752015(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, TerrainCategory = None, ImportanceFactor = None, k1 = None, k3 = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters 
 for Indian IS875-2015.
The function returns zero if the parameters are successfully 
 assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with 
 an Indian IS 875:2015 auto wind assignment.
ExposureFrom: This is either 1 or 2, indicating the source of the 
 wind exposure.
1 = From extents of rigid 
 diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies 
 only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only 
 when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only 
 when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of 
 the wind load are user specified. It is False if the elevations are determined 
 by the program.
TopZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the highest level where auto wind loads 
 are applied. [L]
BottomZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the lowest level where auto wind loads 
 are applied. [L]
WindSpeed: The wind speed in meters per second.
TerrainCategory: This is 1, 2, 3 or 4, indicating the terrain category.
ImportanceFactor: This is 1, 2 or 3, depending on the importance factor.
1 = 1.00
2 = 1.15
3 = 1.30
k1: The risk coefficient (k1 factor).
k3: The topography factor (k3 factor).
UserExposure: If this item is True, the wind exposure widths are provided 
 by the user. If it is False, the wind exposure widths are calculated by 
 the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, TerrainCategory, ImportanceFactor, k1, k3, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetIS8752015(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetIS8752015" failed')
        
        return ret

    def GetMexican(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, UserExposure = None):
        """
This function retrieves the Mexican auto wind loading parameters.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an Indian IS875-1987 auto wind assignment.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in meters per second.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetMexican(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMexican" failed')
        
        return ret

    def GetNBCC2005(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, q = None, GustFactor = None, ImportanceFactor = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for NBCC 2005.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an NBCC 2005 auto wind assignment.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
q: The velocity pressure in kPa.
GustFactor: The gust effect factor.
ImportanceFactor: The importance factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, q, GustFactor, ImportanceFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetNBCC2005(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNBCC2005" failed')
        
        return ret

    def GetNBCC2010_1(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, q = None, GustFactor = None, ImportanceFactor = None, TerrainType = None, CeWindward = None, CeLeeward = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for NBCC 2010.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an NBCC 2010 auto wind assignment.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
q: The velocity pressure in kPa.
GustFactor: The gust effect factor.
ImportanceFactor: The importance factor.
TerrainType: This is 1, 2, or 3, indicating the terrain type.
1 = Open
2 = Rough
3 = User
CeWindward: The windward exposure factor, Ce. This item applies only when TerrainType = 3.
CeLeeward: The windward exposure factor, Ce. This item applies only when TerrainType = 3.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, q, GustFactor, ImportanceFactor, TerrainType, CeWindward, CeLeeward, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetNBCC2010_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNBCC2010_1" failed')
        
        return ret

    def GetNBCC2015(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, NBCCCase = None, e1 = None, e2 = None, UserZ = None, TopZ = None, BottomZ = None, q = None, GustFactor = None, TopographicFactor = None, ImportanceFactor = None, TerrainType = None, CeWindward = None, CeLeeward = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for NBCC 2015.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an NBCC 2015 auto wind assignment..
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
NBCCCase: This is 1, 2, 3, 4, or 5, indicating the desired case from NBCC 2105 Figure A-4.1.7.9(1). 1,2,3, and 4 refer to cases 1 through 4 in the figure, while 5 means all cases. This item applies only when ExposureFrom = 1.
e1: This is the value e1 in the NBCC 2015 Figure A-4.1.7.9(1). This item applies only when ExposureFrom = 1.
e2: This is the value e2 in the NBCC 2015 Figure A-4.1.7.9(1). This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
q: The velocity pressure in kPa.
GustFactor: The gust effect factor, Cg.
TopographicFactor: The importance factor, Ct.
ImportanceFactor: The importance Factor, Iw.
TerrainType: This is 1, 2, or 3, indicating the terrain type.
1 = Open
2 = Rough
3 = User
CeWindward: The windward exposure factor, Ce. This item applies only when TerrainType = 3.
CeLeeward: The windward exposure factor, Ce. This item applies only when TerrainType = 3.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, NBCCCase, e1, e2, UserZ, TopZ, BottomZ, q, GustFactor, TopographicFactor, ImportanceFactor, TerrainType, CeWindward, CeLeeward, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetNBCC2015(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNBCC2015" failed')
        
        return ret

    def GetNBCC95(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, q = None, GustFactor = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for NBCC 95.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an NBCC 95 auto wind assignment.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
q: The velocity pressure in kPa.
GustFactor: The gust effect factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, q, GustFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetNBCC95(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNBCC95" failed')
        
        return ret

    def GetNTC2008(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, Vb = None, ExposureCategory = None, ct = None, cd = None, cp = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for NTC 2008.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an NTC 2008 auto wind assignment.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
Vb: The wind velocity in m/s.
ExposureCategory: This is 1, 2, 3, 4, or 5, indicating the exposure category.
1 = I
2 = II
3 = III
4 = IV
5 = V
ct: The topography factor, ct.
cd: The dynamic coefficient, cd.
cp: The shape factor, cp.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, Vb, ExposureCategory, ct, cd, cp, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetNTC2008(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNTC2008" failed')
        
        return ret

    def GetNTC2018(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, Vb = None, ExposureCategory = None, ct = None, cd = None, cp = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for NTC 2018.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an NTC 2018 auto wind assignment.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
Vb: The wind velocity in m/s.
ExposureCategory: This is 1, 2, 3, 4, or 5, indicating the exposure category.
1 = I
2 = II
3 = III
4 = IV
5 = V
ct: The topography factor, ct.
cd: The dynamic coefficient, cd.
cp: The shape factor, cp.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, Vb, ExposureCategory, ct, cd, cp, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetNTC2018(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNTC2018" failed')
        
        return ret

    def GetSP20133302016(self, Name = None, LoadingType = None, ExposureFrom = None, DirAngle = None, Cp = None, UserZ = None, TopZ = None, BottomZ = None, StructureType = None, LogDecrement = None, BuildingWidth = None, BuildingDepth = None, Zeq = None, WindDistrict = None, WindPressure = None, TerrainType = None, LimitFreq = None, ModalCase = None, FirstValMode = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for SP 20.13330.2016.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with a SP 20.13330.2016 auto wind assignment.
LoadingType: This indicates whether the loads should be calculated as static or dynamic.
1 = Static
2 = Dynamic
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure. This item applies only when LoadingType = 1. 
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item does not apply when ExposureFrom = 2.
Cp: The wind coefficient, Cp. This item applies only when LoadingType = 1 and ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
StructureType: This indicates the structure type for calculating the wind pressure.
1 = Building
2 = Other
LogDecrement: This specifies a value for the logarithmic decrement. This item applies only when LoadingType = 2.
1 = 0.15
2 = 0.30
BuildingWidth: This is the building width, normal to the wind direction. [L]
BuildingDepth: This is the building depth, in the direction of the wind. This item applies only when LoadingType = 2. [L]
Zeq: This is the equivalent height, Zeq, of the structure. This item applies only when LoadingType = 2. [L]
WindDistrict: This is the wind district to consider.
0 = Ia
1 = I
2 = II
3 = III
4 = IV
5 = V
6 = VI
7 = VII
8 = User Defined

WindPressure: This is the wind pressure. This item applies only when WindDistrict = 8. [F/L2]
TerrainType: This is the terrain type being considered.
1 = A
2 = B
3 = C

LimitFreq: The limit frequency. This item applies only when LoadingType = 2 and WindDistrict = 8.
ModalCase: The name of an existing modal load case to be used in determining dynamic wind loads. This item applies only when LoadingType = 2.
FirstValMode: The first valuable mode number from the specified modal case. This item applies only when LoadingType = 2.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms. This item applies only when LoadingType = 1.
        """

        all_args = [Name, LoadingType, ExposureFrom, DirAngle, Cp, UserZ, TopZ, BottomZ, StructureType, LogDecrement, BuildingWidth, BuildingDepth, Zeq, WindDistrict, WindPressure, TerrainType, LimitFreq, ModalCase, FirstValMode, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetSP20133302016(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSP20133302016" failed')
        
        return ret

    def GetUBC94(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, GustFactor = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for 1994 UBC.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an UBC94 auto wind assignment.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2 or 3, indicating the exposure category.
1 = B
2 = C
3 = D
ImportanceFactor: The importance factor.
GustFactor: The gust factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, GustFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetUBC94(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUBC94" failed')
        
        return ret

    def GetUBC97(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, GustFactor = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for 1997 UBC.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an UBC97 auto wind assignment.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2 or 3, indicating the exposure category.
1 = B
2 = C
3 = D
ImportanceFactor: The importance factor.
GustFactor: The gust factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, GustFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetUBC97(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUBC97" failed')
        
        return ret

    def GetUserLoad(self, Name = None, Num = None, Diaph = None, Fx = None, Fy = None, Mz = None, x = None, y = None):
        """
This function retrieves auto wind loading parameters for User-type wind loading.
The function returns zero if the parameters are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern that has a User-type auto wind load assigned.
Num: The number of diaphragms at which user wind loads are reported.
Diaph: This is an array that includes the names of the diaphragms that have user wind loads.
Fx: This is an array that includes the global X direction force assigned to the specified diaphragm. [F]
Fy: This is an array that includes the global Y direction force assigned to the specified diaphragm. [F]
Mz: This is an array that includes the moment about the global Z axis assigned to the specified diaphragm. [FL]
x: This is an array that includes the global X-coordinate of the point where the wind force load is applied to the diaphragm. [L]
y: This is an array that includes the global Y-coordinate of the point where the wind force load is applied to the diaphragm. [L]
        """

        all_args = [Name, Num, Diaph, Fx, Fy, Mz, x, y]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetUserLoad(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetUserLoad" failed')
        
        return ret

    def SetAPI4F2008_1(self, Name = None, ExposureFrom = None, DirAngle = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, SSLFactor = None, ShieldingFactor = None):
        """
This function assigns auto wind loading parameters for API 4F 2008.
The function returns zero if the parameters are successfully assigned; otherwise, it returns a nonzero value.

Name: The name of an existing Wind-type load case.
ExposureFrom: This is 2, 3, or 4, indicating the source of the wind exposure.
2 = From area objects
3 = From frame objects (open structure)
4 = From area objects and frame objects (open structure)
DirAngle: The direction angle for the wind load.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The design reference wind velocity, Vref, in knots.
SSLFactor: The structural safety level multiplier.
ShieldingFactor: The shielding factor.
        """

        all_args = [Name, ExposureFrom, DirAngle, UserZ, TopZ, BottomZ, WindSpeed, SSLFactor, ShieldingFactor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetAPI4F2008_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAPI4F2008_1" failed')
        
        return ret

    def SetAPI4F2013(self, Name = None, ExposureFrom = None, DirAngle = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, SSLFactor = None, ShieldingFactor = None):
        """
This function assigns auto wind loading parameters for API 4F 2013.
The function returns zero if the parameters are successfully assigned; otherwise, it returns a nonzero value.

Name: The name of an existing Wind-type load case.
ExposureFrom: This is 2, 3, or 4, indicating the source of the wind exposure.
2 = From area objects
3 = From frame objects (open structure)
4 = From area objects and frame objects (open structure)
DirAngle: The direction angle for the wind load.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The design reference wind velocity, Vref, in knots.
SSLFactor: The structural safety level multiplier.
ShieldingFactor: The shielding factor.
        """

        all_args = [Name, ExposureFrom, DirAngle, UserZ, TopZ, BottomZ, WindSpeed, SSLFactor, ShieldingFactor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetAPI4F2013(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAPI4F2013" failed')
        
        return ret

    def SetASCE702(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, ASCECase = None, ASCEe1 = None, ASCEe2 = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, Kzt = None, GustFactor = None, Kd = None, SolidGrossRatio = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for ASCE 7-02.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1, 2, 3 or 4, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
3 = From frame objects (open structure)
4 = From area objects and frame objects (open structure)
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
ASCECase: This is either 1, 2, 3, 4 or 5, indicating the desired case from ASCE7-02 Figure 6-9. 1, 2, 3 and 4 refer to cases 1 through 4 in the figure. 5 means to create all cases. This item applies only when ExposureFrom = 1.
ASCEe1: This is the value e1 in ASCE7-02 Figure 6-9. This item applies only when ExposureFrom = 1.
ASCEe2: This is the value e2 in ASCE7-02 Figure 6-9. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies pnly when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2, 3 or 4, indicating the exposure category.
1 = A
2 = B
3 = C
4 = D
ImportanceFactor: The importance factor.
Kzt: The topographical factor.
GustFactor: The gust factor.
Kd: The directionality factor.
SolidGrossRatio: The solid area divided by gross area ratio for open frame structure loading. This item applies only when the loading is from open structure wind loading (ExposureFrom = 3 or ExposureFrom = 4).
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, ASCECase, ASCEe1, ASCEe2, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, Kzt, GustFactor, Kd, SolidGrossRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetASCE702(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetASCE702" failed')
        
        return ret

    def SetASCE705(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, ASCECase = None, ASCEe1 = None, ASCEe2 = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, Kzt = None, GustFactor = None, Kd = None, SolidGrossRatio = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for ASCE 7-05.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1, 2, 3 or 4, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
3 = From frame objects (open structure)
4 = From area objects and frame objects (open structure)
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
ASCECase: This is 1, 2, 3, 4 or 5, indicating the desired case from ASCE7-05 Figure 6-9. 1, 2, 3 and 4 refer to cases 1 through 4 in the figure. 5 means to create all cases. This item applies only when ExposureFrom = 1.
ASCEe1: This is the value e1 in ASCE7-05 Figure 6-9. This item applies only when ExposureFrom = 1.
ASCEe2: This is the value e2 in ASCE7-05 Figure 6-9. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2 or 3, indicating the exposure category.
1 = B
2 = C
3 = D
ImportanceFactor: The importance factor.
Kzt: The topographical factor.
GustFactor: The gust factor.
Kd: The directionality factor.
SolidGrossRatio: The solid area divided by gross area ratio for open frame structure loading. This item applies only when the loading is from open structure wind loading (ExposureFrom = 3 or ExposureFrom = 4).
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, ASCECase, ASCEe1, ASCEe2, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, Kzt, GustFactor, Kd, SolidGrossRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetASCE705(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetASCE705" failed')
        
        return ret

    def SetASCE710(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, ASCECase = None, ASCEe1 = None, ASCEe2 = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, Kzt = None, GustFactor = None, Kd = None, SolidGrossRatio = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for 
 ASCE 7-10.
The function returns zero if the parameters are successfully 
 assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1, 2, 3 or 4, indicating the source of the wind 
 exposure.
1 = From extents of rigid 
 diaphragms
2 = From area objects
3 = From frame objects 
 (open structure)
4 = From area objects and 
 frame objects (open structure)
DirAngle: The direction angle for the wind load. This item applies 
 only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only 
 when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only 
 when ExposureFrom = 1.
ASCECase: This is 1, 2, 3, 4 or 5, indicating the desired case 
 from ASCE7-10 Figure 27.4-8. 1, 2, 3 and 4 refer to cases 1 through 4 
 in the figure. 5 means to create all cases. This item applies only when 
 ExposureFrom = 1.
ASCEe1: This is the value e1 in ASCE7-10 Figure 27.4-8. This 
 item applies only when ExposureFrom = 1.
ASCEe2: This is the value e2 in ASCE7-10 Figure 27.4-8. This 
 item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of 
 the wind load are user specified. It is False if the elevations are determined 
 by the program.
TopZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the highest level where auto wind loads 
 are applied. [L]
BottomZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the lowest level where auto wind loads 
 are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2 or 3, indicating the exposure category.
1 = B
2 = C
3 = D
ImportanceFactor: The importance factor.
Kzt: The topographical factor.
GustFactor: The gust factor.
Kd: The directionality factor.
SolidGrossRatio: The solid area divided by gross area ratio for open 
 frame structure loading. This item applies only when the loading is from 
 open structure wind loading (ExposureFrom = 3 or ExposureFrom = 4).
UserExposure: If this item is True, the wind exposure widths are provided 
 by the user. If it is False, the wind exposure widths are calculated by 
 the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, ASCECase, ASCEe1, ASCEe2, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, Kzt, GustFactor, Kd, SolidGrossRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetASCE710(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetASCE710" failed')
        
        return ret

    def SetASCE716(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, ASCECase = None, ASCEe1 = None, ASCEe2 = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, Kzt = None, GustFactor = None, Kd = None, SolidGrossRatio = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for 
 ASCE 7-16.
The function returns zero if the parameters are successfully 
 assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1, 2, 3 or 4, indicating the source of the wind 
 exposure.
1 = From extents of rigid 
 diaphragms
2 = From area objects
3 = From frame objects 
 (open structure)
4 = From area objects and 
 frame objects (open structure)
DirAngle: The direction angle for the wind load. This item applies 
 only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only 
 when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only 
 when ExposureFrom = 1.
ASCECase: This is 1, 2, 3, 4 or 5, indicating the desired case 
 from ASCE7-16 Figure 27.3-8 . 1, 2, 3 and 4 refer to cases 1 through 4 
 in the figure. 5 means to create all cases. This item applies only when 
 ExposureFrom = 1.
ASCEe1: This is the value e1 in ASCE7-16 Figure 27.3-8. This 
 item applies only when ExposureFrom = 1.
ASCEe2: This is the value e2 in ASCE7-16 Figure 27.3-8. This 
 item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of 
 the wind load are user specified. It is False if the elevations are determined 
 by the program.
TopZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the highest level where auto wind loads 
 are applied. [L]
BottomZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the lowest level where auto wind loads 
 are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2 or 3, indicating the exposure category.
1 = B
2 = C
3 = D
Kzt: The topographical factor.
GustFactor: The gust factor.
Kd: The directionality factor.
SolidGrossRatio: The solid area divided by gross area ratio for open 
 frame structure loading. This item applies only when the loading is from 
 open structure wind loading (ExposureFrom = 3 or ExposureFrom = 4).
UserExposure: If this item is True, the wind exposure widths are provided 
 by the user. If it is False, the wind exposure widths are calculated by 
 the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, ASCECase, ASCEe1, ASCEe2, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, Kzt, GustFactor, Kd, SolidGrossRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetASCE716(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetASCE716" failed')
        
        return ret

    def SetASCE788(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, GustFactor = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for ASCE 7-88.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2, 3 or 4, indicating the exposure category.
1 = A
2 = B
3 = C
4 = D
ImportanceFactor: The importance factor.
GustFactor: The gust factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, GustFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetASCE788(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetASCE788" failed')
        
        return ret

    def SetASCE795(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, Kzt = None, GustFactor = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for ASCE 7-95.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2, 3 or 4, indicating the exposure category.
1 = A
2 = B
3 = C
4 = D
ImportanceFactor: The importance factor.
Kzt: The topographical factor.
GustFactor: The gust factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, Kzt, GustFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetASCE795(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetASCE795" failed')
        
        return ret

    def SetASNZS117022002(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, Ka = None, Kc = None, Kl = None, Kp = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, Cat = None, CycloneRegion = None, Md = None, Ms = None, Mt = None, Cdyn = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for AS/NZS 1170.2:2002.
The function returns zero if the parameters are successfully assigned; otherwise, it returns a nonzero value.

Name: The name of an existing Wind-type load case.
ExposureFrom: This is 1, or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
Ka: The area reduction factor, Ka.
Kc: The combination factor, Kc.
Kl: The local pressure factor, Kl.
Kp: The porous cladding factor, Kp.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The regional wind speed, Vr, in m/s.
Cat: This is 1, 2, 3 or 4, indicating the terrain category.
CycloneRegion: This is True or False, indicating if the structure is in a cyclone region.
Md: The directional multiplier, Md.
Ms: The shielding multiplier, Ms.
Mt: The topographic multiplier, Mt.
Cdyn: The dynamic response factor, Cdyn.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, Ka, Kc, Kl, Kp, UserZ, TopZ, BottomZ, WindSpeed, Cat, CycloneRegion, Md, Ms, Mt, Cdyn, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetASNZS117022002(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetASNZS117022002" failed')
        
        return ret

    def SetBOCA96(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, GustFactor = None, UserGust = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for BOCA 96.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2, 3 or 4, indicating the exposure category.
1 = A
2 = B
3 = C
4 = D
ImportanceFactor: The importance factor.
GustFactor: The user defined gust factor. This item applies only when UserGust is True.
UserGust: If this item is True, the gust factor is user defined. If it is False, the gust factor is determined from the code specified values.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, GustFactor, UserGust, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetBOCA96(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetBOCA96" failed')
        
        return ret

    def SetBS639995(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, Ve = None, Ca = None, Cr = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for BS6399-95.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The front coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The rear coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
Ve: The effective wind speed in meters per second.
Ca: The size effect factor.
Cr: The dynamic augmentation factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, Ve, Ca, Cr, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetBS639995(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetBS639995" failed')
        
        return ret

    def SetChinese2010(self, Name = None, ExposureFrom = None, DirAngle = None, BuildingWidth = None, Us = None, UniformTaper = None, BHoverB0 = None, UserZ = None, TopZ = None, BottomZ = None, wzero = None, Rt = None, PhiZOpt = None, T1Opt = None, UserT = None, DampRatio = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for Chinese 2010.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item only applies when ExposureFrom = 1.
BuildingWidth: The building width. [L]
Us: The shape coefficient. This item applies only when ExposureFrom = 1.
UniformTaper: This item is True if a correction is to be applied to the wind load for a uniform taper.
BHoverB0: The taper ratio, Bh/B0. This item applies only when UniformTaper = True.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
wzero: The basic wind pressure in kN/m2.
Rt: This is 1, 2, 3 or 4, indicating the ground roughness.
1 = A
2 = B
3 = C
4 = D
PhiZOpt: This is 0 or 1, indicating the Phi Z source.
0 = Modal analysis
1 = Z/H ratio
T1Opt: This is 0 or 1, indicating the T1 source.
0 = Modal analysis
1 = User defined
UserT: This item applies only when the T1 source is user defined (T1Opt = 1). It is the user defined T1 period. [s]
DampRatio: The damping ratio.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, BuildingWidth, Us, UniformTaper, BHoverB0, UserZ, TopZ, BottomZ, wzero, Rt, PhiZOpt, T1Opt, UserT, DampRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetChinese2010(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetChinese2010" failed')
        
        return ret

    def SetEurocode12005_1(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, Terrain = None, Orography = None, k1 = None, CsCd = None, Rho = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for Eurocode 1 2005.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The basic wind speed, vb, in meters per second.
Terrain: This is 0, 1, 2, 3 or 4, indicating the terrain category.
0 = 0
1 = I
2 = II
3 = III
4 = IV
Orography: The orography factor, Co.
k1: The turbulence factor, k1.
CsCd: The structural factor, CsCd.
Rho: The air density in kg/m3, Rho.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, Terrain, Orography, k1, CsCd, Rho, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetEurocode12005_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEurocode12005_1" failed')
        
        return ret

    def SetExposure_1(self, Name = None, Diaph = None, x = None, y = None, Width = None, Depth = None, Height = None):
        """
This function assigns exposure parameters for auto wind loads determined from extents of rigid diaphragms. This function does not apply for User-type auto wind loads.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value. The function returns an error if the auto wind load is not specified to have user exposure parameters.

Name: The name of an existing Wind-type load pattern that has an auto wind load assigned.
Diaph: The name of an existing special rigid diaphragm constraint, that is, a diaphragm constraint with the following features:
1. The constraint type is CONSTRAINT_DIAPHRAGM = 2.
2. The constraint coordinate system is Global.
3. The constraint axis is Z.
x: The global X-coordinate of the point where the wind force is applied. [L]
y: The global Y-coordinate of the point where the wind force is applied. [L]
Width: The exposure width for the wind load applied to the specified diaphragm. [L]
Depth: The exposure depth for the wind load applied to the specified diaphragm. [L]
Height: The exposure height for the wind load applied to the specified diaphragm. [L]
        """

        all_args = [Name, Diaph, x, y, Width, Depth, Height]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetExposure_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetExposure_1" failed')
        
        return ret

    def SetIS8751987(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, Terrain = None, Class = None, K1 = None, K3 = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for Indian IS875-1987.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in meters per second.
Terrain: This is 1, 2, 3 or 4, indicating the terrain category.
Class: This is 1, 2 or 3, indicating the terrain category.
1 = A
2 = B
3 = C
K1: The risk coefficient (k1 factor).
K3: The topography factor (k3 factor).
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, Terrain, Class, K1, K3, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetIS8751987(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetIS8751987" failed')
        
        return ret

    def SetIS8752015(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, TerrainCategory = None, ImportanceFactor = None, k1 = None, k3 = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for 
 Indian IS875:2015.
The function returns zero if the parameters are successfully 
 assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with 
 an Indian IS 875:2015 auto wind assignment.
ExposureFrom: This is either 1 or 2, indicating the source of the 
 wind exposure.
1 = From extents of rigid 
 diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies 
 only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only 
 when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only 
 when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of 
 the wind load are user specified. It is False if the elevations are determined 
 by the program.
TopZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the highest level where auto wind loads 
 are applied. [L]
BottomZ: This item applies only when the UserZ item is True. 
 It is the global Z-coordinate at the lowest level where auto wind loads 
 are applied. [L]
WindSpeed: The wind speed in meters per second.
TerrainCategory: This is 1, 2, 3 or 4, indicating the terrain category.
ImportanceFactor: This is 1, 2 or 3, depending on the importance factor.
1 = 1.00
2 = 1.15
3 = 1.30
k1: The risk coefficient (k1 factor).
k3: The topography factor (k3 factor).
UserExposure: If this item is True, the wind exposure widths are provided 
 by the user. If it is False, the wind exposure widths are calculated by 
 the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, TerrainCategory, ImportanceFactor, k1, k3, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetIS8752015(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetIS8752015" failed')
        
        return ret

    def SetMexican(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, UserExposure = None):
        """
This function assigns the Mexican auto wind loading parameters.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in meters per second.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetMexican(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMexican" failed')
        
        return ret

    def SetNBCC2005(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, q = None, GustFactor = None, ImportanceFactor = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for NBCC 2005.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
q: The velocity pressure in kPa.
GustFactor: The gust effect factor.
ImportanceFactor: The importance factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, q, GustFactor, ImportanceFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetNBCC2005(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNBCC2005" failed')
        
        return ret

    def SetNBCC2010_1(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, q = None, GustFactor = None, ImportanceFactor = None, TerrainType = None, CeWindward = None, CeLeeward = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for NBCC 2010.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
q: The velocity pressure in kPa.
GustFactor: The gust effect factor.
ImportanceFactor: The importance factor.
TerrainType: This is 1, 2, or 3, indicating the terrain type.
1 = Open
2 = Rough
3 = User
CeWindward: The windward exposure factor, Ce. This item applies only when TerrainType = 3.
CeLeeward: The windward exposure factor, Ce. This item applies only when TerrainType = 3.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, q, GustFactor, ImportanceFactor, TerrainType, CeWindward, CeLeeward, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetNBCC2010_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNBCC2010_1" failed')
        
        return ret

    def SetNBCC2015(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, NBCCCase = None, e1 = None, e2 = None, UserZ = None, TopZ = None, BottomZ = None, q = None, GustFactor = None, ImportanceFactor = None, TerrainType = None, CeWindward = None, CeLeeward = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for NBCC 2015.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
NBCCCase: This is 1, 2, 3, 4, or 5, indicating the desired case from NBCC 2105 Figure A-4.1.7.9(1). 1,2,3, and 4 refer to cases 1 through 4 in the figure, while 5 means all cases. This item applies only when ExposureFrom = 1.
e1: This is the value e1 in the NBCC 2015 Figure A-4.1.7.9(1). This item applies only when ExposureFrom = 1.
e2: This is the value e2 in the NBCC 2015 Figure A-4.1.7.9(1). This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
q: The velocity pressure in kPa.
GustFactor: The gust effect factor, Cg.
ImportanceFactor: The importance Factor, Iw.
TerrainType: This is 1, 2, or 3, indicating the terrain type.
1 = Open
2 = Rough
3 = User
CeWindward: The windward exposure factor, Ce. This item applies only when TerrainType = 3.
CeLeeward: The windward exposure factor, Ce. This item applies only when TerrainType = 3.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, NBCCCase, e1, e2, UserZ, TopZ, BottomZ, q, GustFactor, ImportanceFactor, TerrainType, CeWindward, CeLeeward, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetNBCC2015(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNBCC2015" failed')
        
        return ret

    def SetNBCC95(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, q = None, GustFactor = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for NBCC 95.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
q: The velocity pressure in kPa.
GustFactor: The gust effect factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, q, GustFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetNBCC95(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNBCC95" failed')
        
        return ret

    def SetNone(self, Name = None):
        """
This function set the auto wind loading type for the specified load pattern to None.
The function returns zero if the loading type is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetNone(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNone" failed')
        
        return ret

    def SetNTC2008(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, Vb = None, ExposureCategory = None, ct = None, cd = None, cp = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for NTC 2008.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
Vb: The wind velocity in m/s.
ExposureCategory: This is 1, 2, 3, 4, or 5, indicating the exposure category.
1 = I
2 = II
3 = III
4 = IV
5 = V
ct: The topography factor, ct.
cd: The dynamic coefficient, cd.
cp: The shape factor, cp.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, Vb, ExposureCategory, ct, cd, cp, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetNTC2008(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNTC2008" failed')
        
        return ret

    def SetNTC2018(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, Vb = None, ExposureCategory = None, ct = None, cd = None, cp = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for NTC 2018.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
Vb: The wind velocity in m/s.
ExposureCategory: This is 1, 2, 3, 4, or 5, indicating the exposure category.
1 = I
2 = II
3 = III
4 = IV
5 = V
ct: The topography factor, ct.
cd: The dynamic coefficient, cd.
cp: The shape factor, cp.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, Vb, ExposureCategory, ct, cd, cp, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetNTC2018(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNTC2018" failed')
        
        return ret

    def SetSP20133302016(self, Name = None, LoadingType = None, ExposureFrom = None, DirAngle = None, Cp = None, UserZ = None, TopZ = None, BottomZ = None, StructureType = None, LogDecrement = None, BuildingWidth = None, BuildingDepth = None, Zeq = None, WindDistrict = None, WindPressure = None, TerrainType = None, LimitFreq = None, ModalCase = None, FirstValMode = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for SP 20.13330.2016.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with a SP 20.13330.2016 auto wind assignment.
LoadingType: This indicates whether the loads should be calculated as static or dynamic.
1 = Static
2 = Dynamic
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure. This item applies only when LoadingType = 1. 
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item does not apply when ExposureFrom = 2.
Cp: The wind coefficient, Cp. This item applies only when LoadingType = 1 and ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
StructureType: This indicates the structure type for calculating the wind pressure.
1 = Building
2 = Other
LogDecrement: This specifies a value for the logarithmic decrement. This item applies only when LoadingType = 2.
1 = 0.15
2 = 0.30
BuildingWidth: This is the building width, normal to the wind direction. [L]
BuildingDepth: This is the building depth, in the direction of the wind. This item applies only when LoadingType = 2. [L]
Zeq: This is the equivalent height, Zeq, of the structure. This item applies only when LoadingType = 2. [L]
WindDistrict: This is the wind district to consider.
0 = Ia
1 = I
2 = II
3 = III
4 = IV
5 = V
6 = VI
7 = VII
8 = User Defined

WindPressure: This is the wind pressure. This item applies only when WindDistrict = 8. [F/L2]
TerrainType: This is the terrain type being considered.
1 = A
2 = B
3 = C

LimitFreq: The limit frequency. This item applies only when LoadingType = 2 and WindDistrict = 8.
ModalCase: The name of an existing modal load case to be used in determining dynamic wind loads. This item applies only when LoadingType = 2.
FirstValMode: The first valuable mode number from the specified modal case. This item applies only when LoadingType = 2.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms. This item applies only when LoadingType = 1.
        """

        all_args = [Name, LoadingType, ExposureFrom, DirAngle, Cp, UserZ, TopZ, BottomZ, StructureType, LogDecrement, BuildingWidth, BuildingDepth, Zeq, WindDistrict, WindPressure, TerrainType, LimitFreq, ModalCase, FirstValMode, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetSP20133302016(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSP20133302016" failed')
        
        return ret

    def SetUBC94(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for 1994 UBC.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cq. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cq. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2 or 3, indicating the exposure category.
1 = B
2 = C
3 = D
ImportanceFactor: The importance factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetUBC94(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUBC94" failed')
        
        return ret

    def SetUBC97(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, ExposureType = None, ImportanceFactor = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for 1997 UBC.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cq. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cq. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The wind speed in miles per hour.
ExposureType: This is 1, 2 or 3, indicating the exposure category.
1 = B
2 = C
3 = D
ImportanceFactor: The importance factor.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, ExposureType, ImportanceFactor, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetUBC97(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUBC97" failed')
        
        return ret

    def SetUserLoad(self, Name = None, Diaph = None, Fx = None, Fy = None, Mz = None, x = None, y = None):
        """
This function assigns auto wind loading parameters for User-type wind loads.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern that has an auto wind load assigned.
Diaph: The name of an existing special rigid diaphragm constraint, that is, a diaphragm constraint with the following features:
1. The constraint type is CONSTRAINT_DIAPHRAGM = 2.
2. The constraint coordinate system is Global.
3. The constraint axis is Z.
Fx: The global X direction force assigned to the specified diaphragm. [F]
Fy: The global Y direction force assigned to the specified diaphragm. [F]
Mz: The moment about the global Z axis assigned to the specified diaphragm. [FL]
x: The global X-coordinate of the point where the wind force is applied. [L]
y: The global Y-coordinate of the point where the wind force is applied. [L]
        """

        all_args = [Name, Diaph, Fx, Fy, Mz, x, y]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetUserLoad(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetUserLoad" failed')
        
        return ret

    def GetAPI4F2008(self, Name = None, ExposureFrom = None, DirAngle = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, SSLFactor = None):
        """
This function retrieves auto wind loading parameters for API 4F 2008.
The function returns zero if the parameters are successfully assigned; otherwise, it returns a nonzero value.

Name: The name of an existing Wind-type load case with an API 4F 2008 auto wind assignment.
ExposureFrom: This is 2, 3 or 4, indicating the source of the wind exposure.
2 = From area objects
3 = From frame objects (open structure)
4 = From area objects and frame objects (open structure)
DirAngle: The direction angle for the wind load.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The design reference wind velocity, Vref, in knots.
SSLFactor: The structural safety level multiplier.
        """

        all_args = [Name, ExposureFrom, DirAngle, UserZ, TopZ, BottomZ, WindSpeed, SSLFactor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetAPI4F2008(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAPI4F2008" failed')
        
        return ret

    def GetChinese2002_1(self, Name = None, ExposureFrom = None, DirAngle = None, BuildingWidth = None, Us = None, UniformTaper = None, BHoverB0 = None, UserZ = None, TopZ = None, BottomZ = None, wzero = None, Rt = None, PhiZOpt = None, T1Opt = None, UserT = None, DampRatio = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for Chinese 2002.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an Chinese 2002 auto wind assignment.
ExposureFrom: This is 1 or 2 indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
BuildingWidth: The building width. [L]
Us: The shape coefficient. This item applies only when ExposureFrom = 1.
UniformTaper: This item is True if a correction is to be applied to the wind load for a uniform taper.
BHoverB0: The taper ratio, Bh/B0. This item applies only when UniformTaper = True.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
wzero: The basic wind pressure in kN/m2.
Rt: This is 1, 2, 3 or 4, indicating the ground roughness.
1 = A
2 = B
3 = C
4 = D
PhiZOpt: This is 0 or 1, indicating the Phi Z source.
0 = Modal analysis
1 = Z/H ratio
T1Opt: This is 0 or 1, indicating the T1 source.
0 = Modal analysis
1 = User defined
UserT: This item only applies when the T1 source is user defined (T1Opt = 1). It is the user defined T1 period. [s]
DampRatio: The damping ratio.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, BuildingWidth, Us, UniformTaper, BHoverB0, UserZ, TopZ, BottomZ, wzero, Rt, PhiZOpt, T1Opt, UserT, DampRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetChinese2002_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetChinese2002_1" failed')
        
        return ret

    def GetChinese2002(self, Name = None, ExposureFrom = None, DirAngle = None, BuildingWidth = None, Us = None, UserZ = None, TopZ = None, BottomZ = None, wzero = None, Rt = None, PhiZOpt = None, T1Opt = None, UserT = None, DampRatio = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for Chinese 2002.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with an Chinese 2002 auto wind assignment.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
BuildingWidth: The building width. [L]
Us: The shape coefficient. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
wzero: The basic wind pressure in kN/m2.
Rt: This is 1, 2, 3 or 4, indicating the ground roughness.
1 = A
2 = B
3 = C
4 = D
PhiZOpt: This is either 0 or 1, indicating the Phi Z source.
0 = Modal analysis
1 = Z/H ratio
T1Opt: This is either 0 or 1, indicating the T1 source.
0 = Modal analysis
1 = User defined
UserT: This item applies only when the T1 source is user defined (T1Opt = 1). It is the user defined T1 period. [s]
DampRatio: The damping ratio.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, BuildingWidth, Us, UserZ, TopZ, BottomZ, wzero, Rt, PhiZOpt, T1Opt, UserT, DampRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetChinese2002(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetChinese2002" failed')
        
        return ret

    def GetEurocode12005(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, Terrain = None, Orography = None, k1 = None, CsCd = None, UserExposure = None):
        """
This function retrieves auto wind loading parameters for Eurocode 1 2005.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern with a Eurocode 1 2005 auto wind assignment.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The basic wind speed, vb, in meters per second.
Terrain: This is 0, 1, 2, 3 or 4, indicating the terrain category.
0 = 0
1 = I
2 = II
3 = III
4 = IV
Orography: The orography factor, Co.
k1: The turbulence factor, k1.
CsCd: The structural factor, CsCd.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, Terrain, Orography, k1, CsCd, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetEurocode12005(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEurocode12005" failed')
        
        return ret

    def GetExposure(self, Name = None, Num = None, Diaph = None, x = None, y = None, MyWidth = None, Height = None):
        """
This function retrieves exposure parameters for auto wind loads determined from extents of rigid diaphragms. This function does not apply for User-type auto wind loads.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern that has an auto wind load assigned.
Num: The number of diaphragms at which exposure data is reported.
Diaph: This is an array that includes the names of the diaphragms that have eccentricity overrides.
x: This is an array that includes the global X-coordinate of the point where the wind force load is applied to the diaphragm. [L]
y: This is an array that includes the global Y-coordinate of the point where the wind force load is applied to the diaphragm. [L]
MyWidth: This is an array that includes the exposure width for the wind load applied to the specified diaphragm. [L]
Height: This is an array that includes the exposure height for the wind load applied to the specified diaphragm. [L]
        """

        all_args = [Name, Num, Diaph, x, y, MyWidth, Height]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.GetExposure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetExposure" failed')
        
        return ret

    def SetAPI4F2008(self, Name = None, ExposureFrom = None, DirAngle = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, SSLFactor = None):
        """
This function assigns auto wind loading parameters for API 4F 2008.
The function returns zero if the parameters are successfully assigned; otherwise, it returns a nonzero value.

Name: The name of an existing Wind-type load case.
ExposureFrom: This is 2, 3 or 4, indicating the source of the wind exposure.
2 = From area objects
3 = From frame objects (open structure)
4 = From area objects and frame objects (open structure)
DirAngle: The direction angle for the wind load.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The design reference wind velocity, Vref, in knots.
SSLFactor: The structural safety level multiplier.
        """

        all_args = [Name, ExposureFrom, DirAngle, UserZ, TopZ, BottomZ, WindSpeed, SSLFactor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetAPI4F2008(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAPI4F2008" failed')
        
        return ret

    def SetChinese2002_1(self, Name = None, ExposureFrom = None, DirAngle = None, BuildingWidth = None, Us = None, UniformTaper = None, BHoverB0 = None, UserZ = None, TopZ = None, BottomZ = None, wzero = None, Rt = None, PhiZOpt = None, T1Opt = None, UserT = None, DampRatio = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for Chinese 2002.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item only applies when ExposureFrom = 1.
BuildingWidth: The building width. [L]
Us: The shape coefficient. This item applies only when ExposureFrom = 1.
UniformTaper: This item is True if a correction is to be applied to the wind load for a uniform taper.
BHoverB0: The taper ratio, Bh/B0. This item applies only when UniformTaper = True.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
wzero: The basic wind pressure in kN/m2.
Rt: This is 1, 2, 3 or 4, indicating the ground roughness.
1 = A
2 = B
3 = C
4 = D
PhiZOpt: This is 0 or 1, indicating the Phi Z source.
0 = Modal analysis
1 = Z/H ratio
T1Opt: This is 0 or 1, indicating the T1 source.
0 = Modal analysis
1 = User defined
UserT: This item applies only when the T1 source is user defined (T1Opt = 1). It is the user defined T1 period. [s]
DampRatio: The damping ratio.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, BuildingWidth, Us, UniformTaper, BHoverB0, UserZ, TopZ, BottomZ, wzero, Rt, PhiZOpt, T1Opt, UserT, DampRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetChinese2002_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetChinese2002_1" failed')
        
        return ret

    def SetChinese2002(self, Name = None, ExposureFrom = None, DirAngle = None, BuildingWidth = None, Us = None, UserZ = None, TopZ = None, BottomZ = None, wzero = None, Rt = None, PhiZOpt = None, T1Opt = None, UserT = None, DampRatio = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for Chinese 2002.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is either 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
BuildingWidth: The building width. [L]
Us: The shape coefficient. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
wzero: The basic wind pressure in kN/m2.
Rt: This is 1, 2, 3 or 4, indicating the ground roughness.
1 = A
2 = B
3 = C
4 = D
PhiZOpt: This is either 0 or 1, indicating the Phi Z source.
0 = Modal analysis
1 = Z/H ratio
T1Opt: This is either 0 or 1, indicating the T1 source.
0 = Modal analysis
1 = User defined
UserT: This item applies only when the T1 source is user defined (T1Opt = 1). It is the user defined T1 period. [s]
DampRatio: The damping ratio.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, BuildingWidth, Us, UserZ, TopZ, BottomZ, wzero, Rt, PhiZOpt, T1Opt, UserT, DampRatio, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetChinese2002(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetChinese2002" failed')
        
        return ret

    def SetEurocode12005(self, Name = None, ExposureFrom = None, DirAngle = None, Cpw = None, Cpl = None, UserZ = None, TopZ = None, BottomZ = None, WindSpeed = None, Terrain = None, Orography = None, k1 = None, CsCd = None, UserExposure = None):
        """
This function assigns auto wind loading parameters for Eurocode 1 2005.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing Wind-type load pattern.
ExposureFrom: This is 1 or 2, indicating the source of the wind exposure.
1 = From extents of rigid diaphragms
2 = From area objects
DirAngle: The direction angle for the wind load. This item applies only when ExposureFrom = 1.
Cpw: The windward coefficient, Cp. This item applies only when ExposureFrom = 1.
Cpl: The leeward coefficient, Cp. This item applies only when ExposureFrom = 1.
UserZ: This item is True if the top and bottom elevations of the wind load are user specified. It is False if the elevations are determined by the program.
TopZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the highest level where auto wind loads are applied. [L]
BottomZ: This item applies only when the UserZ item is True. It is the global Z-coordinate at the lowest level where auto wind loads are applied. [L]
WindSpeed: The basic wind speed, vb, in meters per second.
Terrain: This is 0, 1, 2, 3 or 4, indicating the terrain category.
0 = 0
1 = I
2 = II
3 = III
4 = IV
Orography: The orography factor, Co.
k1: The turbulence factor, k1.
CsCd: The structural factor, CsCd.
UserExposure: If this item is True, the wind exposure widths are provided by the user. If it is False, the wind exposure widths are calculated by the program from the extents of the diaphragms.
        """

        all_args = [Name, ExposureFrom, DirAngle, Cpw, Cpl, UserZ, TopZ, BottomZ, WindSpeed, Terrain, Orography, k1, CsCd, UserExposure]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetEurocode12005(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEurocode12005" failed')
        
        return ret

    def SetExposure(self, Name = None, Diaph = None, x = None, y = None, Width = None, Height = None):
        """
This function assigns exposure parameters for auto wind loads determined from extents of rigid diaphragms. This function does not apply for User-type auto wind loads.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value. The function returns an error if the auto wind load is not specified to have user exposure parameters.

Name: The name of an existing Wind-type load pattern that has an auto wind load assigned.
Diaph: The name of an existing special rigid diaphragm constraint, that is, a diaphragm constraint with the following features:
1. The constraint type is CONSTRAINT_DIAPHRAGM = 2.
2. The constraint coordinate system is Global.
3. The constraint axis is Z.
x: The global X-coordinate of the point where the wind force is applied. [L]
y: The global Y-coordinate of the point where the wind force is applied. [L]
Width: The exposure width for the wind load applied to the specified diaphragm. [L]
Height: The exposure height for the wind load applied to the specified diaphragm. [L]
        """

        all_args = [Name, Diaph, x, y, Width, Height]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LoadPatterns.AutoWind.SetExposure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetExposure" failed')
        
        return ret

class SourceMass:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing mass source.
The function returns zero if the mass source is successfully changed, otherwise it returns a nonzero value. If the new name already exists, a nonzero value is returned and the mass source name is not changed.

Name: The name of an existing mass source.
NewName: The new name for the mass source.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SourceMass.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns the number of defined mass sources.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SourceMass.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
This function deletes an existing mass source.
The function returns zero if the mass source is successfully deleted; otherwise it returns a nonzero value. If the mass source to be deleted is the default mass source, a nonzero value is returned and th mass source is not deleted.

Name: The name of the mass source to be deleted.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SourceMass.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetDefault(self, Name = None):
        """
This function retrieves the default mass source.
The function returns zero if the default mass source is successfully retrieved, otherwise it returns nonzero.

Name: The name of the default mass source.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SourceMass.GetDefault(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDefault" failed')
        
        return ret

    def GetMassSource(self, Name = None, MassFromElements = None, MassFromMasses = None, MassFromLoads = None, IsDefault = None, NumberLoads = None, LoadPat = None, SF = None):
        """
This function gets the mass source data for an existing mass source.
The function returns zero if the mass source data is successfully retrieved, otherwise it returns a nonzero value.

Name: The mass source name.
MassFromElements: If this item is True then element self mass is included in the mass.
MassFromMasses: If this item is True then assigned masses are included in the mass.
MassFromLoads: If this item is True then specified load patterns are included in the mass.
IsDefault: If this item is True then the mass source is the default mass source.
NumberLoads: The number of load patterns specified for the mass source.This item is only applicable when the MassFromLoads item is True.
LoadPat: This is an array of load pattern names specified for the mass source.
SF: This is an array of load pattern multipliers specified for the mass source.
        """

        all_args = [Name, MassFromElements, MassFromMasses, MassFromLoads, IsDefault, NumberLoads, LoadPat, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SourceMass.GetMassSource(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMassSource" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined mass sources.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of mass source names retrieved by the program.
MyName: This is a one-dimensional array of mass source names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String
The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SourceMass.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def SetDefault(self, Name = None):
        """
This function sets the default mass source.
The function returns zero if the mass source is successfully flagged as default, otherwise it returns nonzero.  Only one mass source can be the default mass source so when this assignment is set all other mass sources are automatically set to have their IsDefault flag False.

Name: The name of the mass source to be flagged as the default mass source.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SourceMass.SetDefault(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDefault" failed')
        
        return ret

    def SetMassSource(self, Name = None, MassFromElements = None, MassFromMasses = None, MassFromLoads = None, IsDefault = None, NumberLoads = None, LoadPat = None, SF = None):
        """
This function adds a new mass source to the model or reinitializes an existing mass source.
The function returns zero if the mass source is successfully added or initialized, otherwise it returns a nonzero value.

Name: The mass source name. If a mass source with this name already exists then the mass source is reinitialized with the new data.All previous data assigned to the mass source is lost. If a mass source with this name does not exist then a new mass source is added.
MassFromElements: If this item is True then element self mass is included in the mass.
MassFromMasses: If this item is True then assigned masses are included in the mass.
MassFromLoads: If this item is True then specified load patterns are included in the mass.
IsDefault: If this item is True then the mass source is the default mass source.Only one mass source can be the default mass source so when this assignment is True all other mass sources are automatically set to have the IsDefault flag False.
NumberLoads: The number of load patterns specified for the mass source.This item is only applicable when the MassFromLoads item is True.
LoadPat: This is an array of load pattern names specified for the mass source.
SF: This is an array of load pattern multipliers specified for the mass source.
        """

        all_args = [Name, MassFromElements, MassFromMasses, MassFromLoads, IsDefault, NumberLoads, LoadPat, SF]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SourceMass.SetMassSource(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMassSource" failed')
        
        return ret

class NamedAssign:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.ModifierArea = ModifierArea(strict, api)
        self.ModifierCable = ModifierCable(strict, api)
        self.ModifierFrame = ModifierFrame(strict, api)
        self.ReleaseFrame = ReleaseFrame(strict, api)

class ModifierArea:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing area stiffness modifier.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined area stiffness modifier.
NewName: The new name for the area stiffness modifier.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierArea.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of defined area stiffness modifiers in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierArea.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified area stiffness modifier.
The function returns zero if the modifier is successfully deleted; otherwise it returns a nonzero value. It returns an error if the specified modifier can not be deleted; for example, if it is currently used by a staged construction load case.

Name: The name of an existing area stiffness modifier.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierArea.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetModifiers(self, Name = None, Value = None):
        """
This function retrieves the modifier assignments for an area stiffness modifier. The default value for all modifier values is one.
The function returns zero if the modifier assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area stiffness modifier.
Value: This is an array of ten unitless modifiers.
Value(0) = Membrane f11 modifier
Value(1) = Membrane f22 modifier
Value(2) = Membrane f12 modifier
Value(3) = Bending m11 modifier
Value(4) = Bending m22 modifier
Value(5) = Bending m12 modifier
Value(6) = Shear v13 modifier
Value(7) = Shear v23 modifier
Value(8) = Mass modifier
Value(9) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierArea.GetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModifiers" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined area stiffness modifiers.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero values.

NumberNames: The number of area stiffness modifier names retrieved by the program.
MyName: This is a one-dimensional array of area stiffness modifier names. The MyName array is created as a dynamic, zero-based array by the API user:
Dim MyName() as String
The array is dimensioned to (NumberNames - 1) inside the SAP2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierArea.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def SetModifiers(self, Name = None, Value = None):
        """
This function defines a named area stiffness modifier. The default value for all modifier values is one.
The function returns zero if the modifier is successfully defined; otherwise it returns a nonzero value.

Name: The name of a new or existing area stiffness modifier.
Value: This is an array of ten unitless modifiers.
Value(0) = Membrane f11 modifier
Value(1) = Membrane f22 modifier
Value(2) = Membrane f12 modifier
Value(3) = Bending m11 modifier
Value(4) = Bending m22 modifier
Value(5) = Bending m12 modifier
Value(6) = Shear v13 modifier
Value(7) = Shear v23 modifier
Value(8) = Mass modifier
Value(9) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierArea.SetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModifiers" failed')
        
        return ret

class ModifierCable:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing cable property modifier.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined cable property modifier.
NewName: The new name for the cable property modifier.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierCable.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of defined cable property modifiers in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierCable.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified cable property modifier.
The function returns zero if the modifier is successfully deleted; otherwise it returns a nonzero value. It returns an error if the specified modifier can not be deleted, for example, if it is currently used by a staged construction load case.

Name: The name of an existing cable property modifier.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierCable.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetModifiers(self, Name = None, Value = None):
        """
This function retrieves the modifier assignments for a cable property modifier. The default value for all modifier values is one.
The function returns zero if the modifier assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing cable property modifier.
Value: This is an array of three unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Mass modifier
Value(2) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierCable.GetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModifiers" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined cable property modifiers.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of cable property modifier names retrieved by the program.
MyName: This is a one-dimensional array of cable property modifier names. The MyName array is created as a dynamic, zero-based array by the API user:
Dim MyName() as String
The array is dimensioned to (NumberNames - 1) inside the SAP2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierCable.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def SetModifiers(self, Name = None, Value = None):
        """
This function defines a named cable property modifier. The default value for all modifier values is one.
The function returns zero if the modifier is successfully defined; otherwise it returns a nonzero value.

Name: The name of a new or existing cable property modifier.
Value: This is an array of three unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Mass modifier
Value(2) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierCable.SetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModifiers" failed')
        
        return ret

class ModifierFrame:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing frame property modifier.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined frame property modifier.
NewName: The new name for the frame property modifier.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierFrame.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of defined frame property modifiers in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierFrame.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified frame property modifier.
The function returns zero if the modifier is successfully deleted; otherwise it returns a nonzero value. It returns an error if the specified modifier can not be deleted; for example, if it is currently used by a staged construction load case.

Name: The name of an existing frame property modifier.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierFrame.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetModifiers(self, Name = None, Value = None):
        """
This function retrieves the modifier assignments for a frame property modifier. The default value for all modifier values is one.
The function returns zero if the modifier assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame property modifier.
Value: This is an array of eight unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Shear area in local 2 direction modifier
Value(2) = Shear area in local 3 direction modifier
Value(3) = Torsional constant modifier
Value(4) = Moment of inertia about local 2 axis modifier
Value(5) = Moment of inertia about local 3 axis modifier
Value(6) = Mass modifier
Value(7) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierFrame.GetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModifiers" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined frame property modifiers.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of frame property modifier names retrieved by the program.
MyName: This is a one-dimensional array of frame property modifier names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String
The array is dimensioned to (NumberNames - 1) inside the SAP2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierFrame.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def SetModifiers(self, Name = None, Value = None):
        """
This function defines a named frame property modifier. The default value for all modifier values is one.
The function returns zero if the modifier is successfully defined; otherwise it returns a nonzero value.

Name: The name of a new or existing frame property modifier.
Value: This is an array of eight unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Shear area in local 2 direction modifier
Value(2) = Shear area in local 3 direction modifier
Value(3) = Torsional constant modifier
Value(4) = Moment of inertia about local 2 axis modifier
Value(5) = Moment of inertia about local 3 axis modifier
Value(6) = Mass modifier
Value(7) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ModifierFrame.SetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModifiers" failed')
        
        return ret

class ReleaseFrame:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing frame end release.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined frame end release.
NewName: The new name for the frame end release.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ReleaseFrame.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of defined frame end releases in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ReleaseFrame.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified frame end release.
The function returns zero if the end release is successfully deleted; otherwise it returns a nonzero value. It returns an error if the specified end release can not be deleted; for example, if it is currently used by a staged construction load case.

Name: The name of an existing frame end release.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ReleaseFrame.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined frame end releases.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero values.

NumberNames: The number of frame end release names retrieved by the program.
MyName: This is a one-dimensional array of frame end release names. The MyName array is created as a dynamic, zero-based array by the API user:
Dim MyName() as String
The array is dimensioned to (NumberNames - 1) inside the SAP2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ReleaseFrame.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetReleases(self, Name = None, ii = None, jj = None, StartValue = None, EndValue = None):
        """
This function retrieves the release assignments for a frame end release.
The function returns zero if the release assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame end release.
ii: These are arrays of six booleans indicating the I-End and J-End releases.
ii(0) and jj(0) = U1 release
ii(1) and jj(1) = U2 release
ii(2) and jj(2) = U3 release
ii(3) and jj(3) = R1 release
ii(4) and jj(4) = R2 release
ii(5) and jj(5) = R3 release

jj: These are arrays of six booleans indicating the I-End and J-End releases.
ii(0) and jj(0) = U1 release
ii(1) and jj(1) = U2 release
ii(2) and jj(2) = U3 release
ii(3) and jj(3) = R1 release
ii(4) and jj(4) = R2 release
ii(5) and jj(5) = R3 release

StartValue: These are arrays of six values indicating the I-End and J-End partial fixity springs.
StartValue(0) and EndValue(0) = U1 partial fixity [F/L]
StartValue(1) and EndValue(1) = U2 partial fixity [F/L]
StartValue(2) and EndValue(2) = U3 partial fixity [F/L]
StartValue(3) and EndValue(3) = R1 partial fixity [FL/rad]
StartValue(4) and EndValue(4) = R2 partial fixity [FL/rad]
StartValue(5) and EndValue(5) = R3 partial fixity [FL/rad]
EndValue: These are arrays of six values indicating the I-End and J-End partial fixity springs.
StartValue(0) and EndValue(0) = U1 partial fixity [F/L]
StartValue(1) and EndValue(1) = U2 partial fixity [F/L]
StartValue(2) and EndValue(2) = U3 partial fixity [F/L]
StartValue(3) and EndValue(3) = R1 partial fixity [FL/rad]
StartValue(4) and EndValue(4) = R2 partial fixity [FL/rad]
StartValue(5) and EndValue(5) = R3 partial fixity [FL/rad]
        """

        all_args = [Name, ii, jj, StartValue, EndValue]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ReleaseFrame.GetReleases(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetReleases" failed')
        
        return ret

    def SetReleases(self, Name = None, ii = None, jj = None, StartValue = None, EndValue = None):
        """
This function defines a named frame end release.
The function returns zero if the release is successfully defined; otherwise it returns a nonzero value.

Name: The name of a new or existing frame end release.
ii: These are arrays of six booleans indicating the I-End and J-End releases.
ii(0) and jj(0) = U1 release
ii(1) and jj(1) = U2 release
ii(2) and jj(2) = U3 release
ii(3) and jj(3) = R1 release
ii(4) and jj(4) = R2 release
ii(5) and jj(5) = R3 release

jj: These are arrays of six booleans indicating the I-End and J-End releases.
ii(0) and jj(0) = U1 release
ii(1) and jj(1) = U2 release
ii(2) and jj(2) = U3 release
ii(3) and jj(3) = R1 release
ii(4) and jj(4) = R2 release
ii(5) and jj(5) = R3 release

StartValue: These are arrays of six values indicating the I-End and J-End partial fixity springs.
StartValue(0) and EndValue(0) = U1 partial fixity [F/L]
StartValue(1) and EndValue(1) = U2 partial fixity [F/L]
StartValue(2) and EndValue(2) = U3 partial fixity [F/L]
StartValue(3) and EndValue(3) = R1 partial fixity [FL/rad]
StartValue(4) and EndValue(4) = R2 partial fixity [FL/rad]
StartValue(5) and EndValue(5) = R3 partial fixity [FL/rad]
EndValue: These are arrays of six values indicating the I-End and J-End partial fixity springs.
StartValue(0) and EndValue(0) = U1 partial fixity [F/L]
StartValue(1) and EndValue(1) = U2 partial fixity [F/L]
StartValue(2) and EndValue(2) = U3 partial fixity [F/L]
StartValue(3) and EndValue(3) = R1 partial fixity [FL/rad]
StartValue(4) and EndValue(4) = R2 partial fixity [FL/rad]
StartValue(5) and EndValue(5) = R3 partial fixity [FL/rad]
        """

        all_args = [Name, ii, jj, StartValue, EndValue]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedAssign.ReleaseFrame.SetReleases(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetReleases" failed')
        
        return ret

class NamedSets:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetJointRespSpec(self, Name = None, LoadCase = None, NumberJoints = None, JointNames = None, CoordSys = None, Direction = None, Abscissa = None, Ordinate = None, DefaultFreq = None, StructuralFreq = None, NumberUserFreq = None, UserFreqValues = None, NumberDampValues = None, DampingValues = None, AbscissaPlotType = None, SpectrumWidening = None, OrdinatePlotType = None, OrdinateScaleFactor = None):
        """
This function gets a joint response spectrum named set definition.  
The function returns zero if the named set is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing joint response spectrum named set..
LoadCase: The name of a time history load case for which results will be extracted.
NumberJoints: The number of joints for which to generate response spectra. 
JointNames: This is an array of joint names for which to generate response spectra.
CoordSys: The name of a coordinate system in which the direction for results is defined. This can be Global, Local, or any other user-defined coordinate system.
Direction: This specifies the direction, in the specified coordinate system, in which the results are to be retrieved. Valid values for the direction are:
1 = Local 1, Global X, or user-defined coordinate system X
2 = Local 2, Global Y, or user-defined coordinate system Y
3 = Local 3, Global Z, or user-defined coordinate system Z
Abscissa: This is one of the following, specifying the abscissa data type.
1 = Frequency
2 = Period
Ordinate: This is one of the following, specifying the ordinate data type.
1 = Spectral displacement
2 = Spectral velocity
3 = Pseudo-spectral velocity
4 = Spectral acceleration
5 = Pseudo-spectral acceleration
DefaultFreq: If this item is True, the default frequencies are used for output.
StructuralFreq: If this item is True, the structural frequencies are used for output.
NumberUserFreq: The number of user-defined frequencies, which may be 0.
UserFreqValues: This is an array that includes the user-defined frequencies. Values are returnedusing indices 0 to NumberUserFreq-1 if NumberUserFreq > 0. [1/s]
NumberDampValues: The number of critical damping ratio values.
DampingValues: This is an array that includes the critical damping ratios to be used for extracting results. Values are supplied using indices 0 to NumberDampValues-1.
AbscissaPlotType: This is one of the following, specifying the abscissa axis scale type.
1 = Arithmetic
2 = Log
SpectrumWidening: This specifies the percentage by which to widen the peaks of the spectrum.
OrdinatePlotType: This is one of the following, specifying the ordinate axis scale type.
1 = Arithmetic
2 = Log
OrdinateScaleFactor: This is the scale factor used to linearly scale the response spectrum ordinate values.
        """

        all_args = [Name, LoadCase, NumberJoints, JointNames, CoordSys, Direction, Abscissa, Ordinate, DefaultFreq, StructuralFreq, NumberUserFreq, UserFreqValues, NumberDampValues, DampingValues, AbscissaPlotType, SpectrumWidening, OrdinatePlotType, OrdinateScaleFactor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedSets.GetJointRespSpec(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetJointRespSpec" failed')
        
        return ret

    def SetJointRespSpec(self, Name = None, LoadCase = None, NumberJoints = None, JointNames = None, CoordSys = None, Direction = None, Abscissa = None, Ordinate = None, DefaultFreq = None, StructuralFreq = None, NumberUserFreq = None, UserFreqValues = None, NumberDampValues = None, DampingValues = None, AbscissaPlotType = None, SpectrumWidening = None, OrdinatePlotType = None, OrdinateScaleFactor = None):
        """
This function defines a joint response spectrum named set.  
The function returns zero if the named set is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a new or existing joint response spectrum named set. If the named set already exists, it will be modified, otherwise a new named set will be created.
LoadCase: The name of a time history load case for which results will be extracted.
NumberJoints: The number of joints for which to generate response spectra. 
JointNames: This is an array of joint names for which to generate response spectra.
CoordSys: The name of a coordinate system in which the direction for results is defined. This can be Global, Local, or any other user-defined coordinate system.
Direction: This is a value specifying the direction, in the specified coordinate system, in which the results are to be retrieved. Valid values for the direction are:
1 = Local 1, Global X, or user-defined coordinate system X
2 = Local 2, Global Y, or user-defined coordinate system Y
3 = Local 3, Global Z, or user-defined coordinate system Z
Abscissa: This is one of the following, specifying the abscissa data type.
1 = Frequency
2 = Period
Ordinate: This is one of the following, specifying the ordinate data type.
1 = Spectral displacement
2 = Spectral velocity
3 = Pseudo-spectral velocity
4 = Spectral acceleration
5 = Pseudo-spectral acceleration
DefaultFreq: If this item is True, the default frequencies are used for output.
StructuralFreq: If this item is True, the structural frequencies are used for output.
NumberUserFreq: The number of user-defined frequencies, which may be 0.
UserFreqValues: This is an array that includes the user-defined frequencies. Values are returnedusing indices 0 to NumberUserFreq-1 if NumberUserFreq > 0. [1/s]
NumberDampValues: The number of critical damping ratio values, which must be at least 1..
DampingValues: This is an array that includes the critical damping ratios to be used for extracting results. Values are supplied using indices 0 to NumberDampValues-1.
AbscissaPlotType: This is one of the following, specifying the abscissa axis scale type.
1 = Arithmetic
2 = Log
SpectrumWidening: This specifies the percentage by which to widen the peaks of the spectrum.
OrdinatePlotType: This is one of the following, specifying the ordinate axis scale type.
1 = Arithmetic
2 = Log
OrdinateScaleFactor: This is the scale factor used to linearly scale the response spectrum ordinate values.
        """

        all_args = [Name, LoadCase, NumberJoints, JointNames, CoordSys, Direction, Abscissa, Ordinate, DefaultFreq, StructuralFreq, NumberUserFreq, UserFreqValues, NumberDampValues, DampingValues, AbscissaPlotType, SpectrumWidening, OrdinatePlotType, OrdinateScaleFactor]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.NamedSets.SetJointRespSpec(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetJointRespSpec" failed')
        
        return ret

class PropArea:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing area property.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined area property.
NewName: The new name for the area property.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self, PropType = None):
        """
This function returns the total number of defined area properties in the model. If desired, counts can be returned for all area properties of a specified type in the model.

PropType: This optional value is 0, 1, 2 or 3, indicating the type of area properties included in the count.
0 = All
1 = Shell
2 = Plane
3 = Asolid
        """

        all_args = [PropType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified area property.
The function returns zero if the area property is successfully deleted; otherwise it returns a nonzero value. It returns an error if the specified area property can not be deleted, for example, if it is being used by an area object.

Name: The name of an existing area property.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetAsolid(self, Name = None, MatProp = None, MatAng = None, Arc = None, Incompatible = None, CSys = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves area property data for an asolid-type area section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing asolid-type area property.
MatProp: The name of the material property for the area property.
MatAng: The material angle. [deg]
Arc: The arc angle through which the area object is passed to define the asolid element. [deg]
A value of zero means 1 radian (approximately 57.3 degrees).
Incompatible: If this item is True, incompatible bending modes are included in the stiffness formulation. In general, incompatible modes significantly improve the bending behavior of the object.
CSys: The area object is rotated about the Z-axis in this coordinate system to define the asolid element.
Color: The display color assigned to the property.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, MatProp, MatAng, Arc, Incompatible, CSys, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.GetAsolid(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAsolid" failed')
        
        return ret

    def GetModifiers(self, Name = None, Value = None):
        """
This function retrieves the modifier assignments for an area property. The default value for all modifiers is one.
The function returns zero if the modifier assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area property.
Value: This is an array of 10 unitless modifiers.
Value(0) = Membrane f11 modifier
Value(1) = Membrane f22 modifier
Value(2) = Membrane f12 modifier
Value(3) = Bending m11 modifier
Value(4) = Bending m22 modifier
Value(5) = Bending m12 modifier
Value(6) = Shear v13 modifier
Value(7) = Shear v23 modifier
Value(8) = Mass modifier
Value(9) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.GetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModifiers" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None, PropType = None):
        """
This function retrieves the names of all defined area properties of the specified type.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of area property names retrieved by the program.
MyName: This is a one-dimensional array of area property names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String
The array is dimensioned to (NumberNames - 1) inside the SAP2000 program, filled with the names, and returned to the API user.
PropType: This optional value is 0, 1, 2 or 3, indicating the type of area properties included in the name list.
0 = All
1 = Shell
2 = Plane
3 = Asolid
        """

        all_args = [NumberNames, MyName, PropType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetPlane(self, Name = None, MyType = None, MatProp = None, MatAng = None, Thickness = None, Incompatible = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves area property data for a plane-type area section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing plane-type area property.
MyType: This is either 1 or 2, indicating the plane type.
1 = Plane-stress
2 = Plane-strain
MatProp: The name of the material property for the area property.
MatAng: The material angle. [deg]
Thickness: The plane thickness. [L]
Incompatible: If this item is True, incompatible bending modes are included in the stiffness formulation. In general, incompatible modes significantly improve the bending behavior of the object.
Color: The display color assigned to the property.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, MyType, MatProp, MatAng, Thickness, Incompatible, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.GetPlane(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPlane" failed')
        
        return ret

    def GetShellDesign(self, Name = None, MatProp = None, SteelLayoutOption = None, DesignCoverTopDir1 = None, DesignCoverTopDir2 = None, DesignCoverBotDir1 = None, DesignCoverBotDir2 = None):
        """
This function retrieves area property design parameters for a shell-type area section.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing shell-type area property.
MatProp: The name of the material property for the area property.
SteelLayoutOption: This is 0, 1 or 2 indicating, the rebar layout option.
0 = Default
1 = One layer
2 = Two layers
DesignCoverTopDir1: The cover to the centroid of the top reinforcing steel running in the local 1 and 2 axes directions of the area object, respectively. [L]
This item applies only when SteelLayoutOption = 1 or 2.
DesignCoverTopDir2: The cover to the centroid of the top reinforcing steel running in the local 1 and 2 axes directions of the area object, respectively. [L]
This item applies only when SteelLayoutOption = 1 or 2.
DesignCoverBotDir1: The cover to the centroid of the bottom reinforcing steel running in the local 1 and 2 axes directions of the area object, respectively. [L]
This item applies only when SteelLayoutOption = 2.
DesignCoverBotDir2: The cover to the centroid of the bottom reinforcing steel running in the local 1 and 2 axes directions of the area object, respectively. [L]
This item applies only when SteelLayoutOption = 2.
        """

        all_args = [Name, MatProp, SteelLayoutOption, DesignCoverTopDir1, DesignCoverTopDir2, DesignCoverBotDir1, DesignCoverBotDir2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.GetShellDesign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetShellDesign" failed')
        
        return ret

    def GetShellLayer_1(self, Name = None, NumberLayers = None, LayerName = None, Dist = None, Thickness = None, Type = None, NumIntegrationPts = None, MatProp = None, MatAng = None, S11Type = None, S22Type = None, S12Type = None):
        """
This function retrieves area property layer parameters for a shell-type area section.
The function returns zero if the parameters are successfully retrieved, otherwise it returns a nonzero value.
The function returns an error if the specified area property is not a shell-type property specified to be a layered shell.

Name: The name of an existing shell-type area property that is specified to be a layered shell property.
NumberLayers: The number of layers in the area property.
LayerName: This is an array that includes the name of each layer.
Dist: This is an array that includes the distance from the area reference surface (area object joint location plus offsets) to the mid-height of the layer. [L]
Thickness: This is an array that includes the thickness of each layer. [L]
Type: This is an array that includes 1, 2 or 3, indicating the layer type.
1 = Shell
2 = Membrane
3 = Plate

NumIntegrationPts: The number of integration points in the thickness direction for the layer. The locations are determined by the program using standard Guass-quadrature rules.
MatProp: This is an array that includes the name of the material property for the layer.
MatAng: This is an array that includes the material angle for the layer. [deg]
S11Type: These are arrays that include 0, 1 or 2, indicating the material component behavior.
0 = Inactive
1 = Linear
2 = Nonlinear
S22Type: These are arrays that include 0, 1 or 2, indicating the material component behavior.
0 = Inactive
1 = Linear
2 = Nonlinear
S12Type: These are arrays that include 0, 1 or 2, indicating the material component behavior.
0 = Inactive
1 = Linear
2 = Nonlinear
        """

        all_args = [Name, NumberLayers, LayerName, Dist, Thickness, Type, NumIntegrationPts, MatProp, MatAng, S11Type, S22Type, S12Type]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.GetShellLayer_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetShellLayer_1" failed')
        
        return ret

    def GetShellLayer_2(self, Name = None, NumberLayers = None, LayerName = None, Dist = None, Thickness = None, Type = None, NumIntegrationPts = None, MatProp = None, MatAng = None, MatBehavior = None, S11Type = None, S22Type = None, S12Type = None):
        """
This function retrieves area property layer parameters 
 for a shell-type area section.
The function returns zero if the parameters are successfully 
 retrieved, otherwise it returns a nonzero value.
The function returns an error if the specified area 
 property is not a shell-type property specified to be a layered shell.

Name: The name of an existing shell-type area property that 
 is specified to be a layered shell property.
NumberLayers: The number of layers in the area property.
LayerName: This is an array that includes the name of each layer.
Dist: This is an array that includes the distance from the 
 area reference surface (area object joint location plus offsets) to the 
 mid-height of the layer. [L]
Thickness: This is an array that includes the thickness of each 
 layer. [L]
Type: This is an array that includes 1, 2 or 3, indicating 
 the layer type.
1 = Shell
2 = Membrane
3 = Plate

NumIntegrationPts: The number of integration points in the thickness direction 
 for the layer. The locations are determined by the program using standard 
 Guass-quadrature rules.
MatProp: This is an array that includes the name of the material 
 property for the layer.
MatAng: This is an array that includes the material angle for 
 the layer. [deg]
MatBehavior: This is an array that includes 0 or 1,indicating the 
 material behavior for the layer.
0 = Directional
1 = Coupled

S11Type: These are arrays that include 0, 1 or 2, indicating 
 the material component behavior.
0 = Inactive
1 = Linear
2 = Nonlinear
S22Type: These are arrays that include 0, 1 or 2, indicating 
 the material component behavior.
0 = Inactive
1 = Linear
2 = Nonlinear
S12Type: These are arrays that include 0, 1 or 2, indicating 
 the material component behavior.
0 = Inactive
1 = Linear
2 = Nonlinear
        """

        all_args = [Name, NumberLayers, LayerName, Dist, Thickness, Type, NumIntegrationPts, MatProp, MatAng, MatBehavior, S11Type, S22Type, S12Type]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.GetShellLayer_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetShellLayer_2" failed')
        
        return ret

    def GetTypeOAPI(self, Name = None, PropType = None):
        """
This function retrieves the property type for the specified area property.
The function returns zero if the type is successfully retrieved; otherwise it returns nonzero.

Name: The name of an existing area property.
PropType: This is 1, 2 or 3, indicating the type of area property.
1 = Shell
2 = Plane
3 = Asolid
        """

        all_args = [Name, PropType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.GetTypeOAPI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTypeOAPI" failed')
        
        return ret

    def SetAsolid(self, Name = None, MatProp = None, MatAng = None, Arc = None, Incompatible = None, CSys = None, Color = None, Notes = None, GUID = None):
        """
This function initializes an asolid-type area property. If this function is called for an existing area property, all items for the property are reset to their default value.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new area property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the area property.
MatAng: The material angle. [deg]
Arc: The arc angle through which the area object is passed to define the asolid element. [deg]
A value of zero means 1 radian (approximately 57.3 degrees).
Incompatible: If this item is True, incompatible bending modes are included in the stiffness formulation. In general, incompatible modes significantly improve the bending behavior of the object.
CSys: The area object is rotated about the Z-axis in this coordinate system to define the asolid element.
Color: The display color assigned to the property. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, MatProp, MatAng, Arc, Incompatible, CSys, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.SetAsolid(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAsolid" failed')
        
        return ret

    def SetModifiers(self, Name = None, Value = None):
        """
This function assigns property modifiers to an area property. The default value for all modifiers is one.
The function returns zero if the modifiers are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area property.
Value: This is an array of 10 unitless modifiers.
Value(0) = Membrane f11 modifier
Value(1) = Membrane f22 modifier
Value(2) = Membrane f12 modifier
Value(3) = Bending m11 modifier
Value(4) = Bending m22 modifier
Value(5) = Bending m12 modifier
Value(6) = Shear v13 modifier
Value(7) = Shear v23 modifier
Value(8) = Mass modifier
Value(9) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.SetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModifiers" failed')
        
        return ret

    def SetPlane(self, Name = None, MyType = None, MatProp = None, MatAng = None, Thickness = None, Incompatible = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a plane-type area property. If this function is called for an existing area property, all items for the property are reset to their default value.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new area property. If this is an existing property, that property is modified; otherwise, a new property is added.
MyType: This is either 1 or 2, indicating the plane type.
1 = Plane-stress
2 = Plane-strain
MatProp: The name of the material property for the area property.
MatAng: The material angle. [deg]
Thickness: The plane thickness. [L]
Incompatible: If this item is True, incompatible bending modes are included in the stiffness formulation. In general, incompatible modes significantly improve the bending behavior of the object.
Color: The display color assigned to the property. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, MyType, MatProp, MatAng, Thickness, Incompatible, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.SetPlane(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPlane" failed')
        
        return ret

    def SetShellDesign(self, Name = None, MatProp = None, SteelLayoutOption = None, DesignCoverTopDir1 = None, DesignCoverTopDir2 = None, DesignCoverBotDir1 = None, DesignCoverBotDir2 = None):
        """
This function assigns the design parameters for shell-type area properties.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing shell-type area property.
MatProp: The name of the material property for the area property.
SteelLayoutOption: This is 0, 1 or 2, indicating the rebar layout option.
0 = Default
1 = One layer
2 = Two layers
DesignCoverTopDir1: The cover to the centroid of the top reinforcing steel running in the local 1 and 2 axes directions of the area object, respectively. [L]
This item applies only when SteelLayoutOption = 1 or 2.
DesignCoverTopDir2: The cover to the centroid of the top reinforcing steel running in the local 1 and 2 axes directions of the area object, respectively. [L]
This item applies only when SteelLayoutOption = 1 or 2.
DesignCoverBotDir1: The cover to the centroid of the bottom reinforcing steel running in the local 1 and 2 axes directions of the area object, respectively. [L]
This item applies only when SteelLayoutOption = 2.
DesignCoverBotDir2: The cover to the centroid of the bottom reinforcing steel running in the local 1 and 2 axes directions of the area object, respectively. [L]
This item applies only when SteelLayoutOption = 2.
        """

        all_args = [Name, MatProp, SteelLayoutOption, DesignCoverTopDir1, DesignCoverTopDir2, DesignCoverBotDir1, DesignCoverBotDir2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.SetShellDesign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetShellDesign" failed')
        
        return ret

    def SetShellLayer_1(self, Name = None, NumberLayers = None, LayerName = None, Dist = None, Thickness = None, Type = None, NumIntegrationPts = None, MatProp = None, MatAng = None, S11Type = None, S22Type = None, S12Type = None):
        """
This function assigns the layer parameters for shell-type area properties.
The function returns zero if the parameters are successfully assigned; otherwise, it returns a nonzero value.
The function returns an error if the specified area property is not a shell-type property specified to be a layered shell.

Name: The name of an existing shell-type area property that is specified to be a layered shell property.
NumberLayers: The number of layers in the area property.
LayerName: This is an array that includes the name of each layer.
Dist: This is an array that includes the distance from the area reference surface (area object joint location plus offsets) to the mid-height of the layer. [L]
Thickness: This is an array that includes the thickness of each layer. [L]
Type: This is an array that includes 1, 2 or 3, indicating the layer type.
1 = Shell
2 = Membrane
3 = Plate

NumIntegrationPts: The number of integration points in the thickness direction for the layer. The locations are determined by the program using standard Guass-quadrature rules.
MatProp: This is an array that includes the name of the material property for the layer.
MatAng: This is an array that includes the material angle for the layer. [deg]
S11Type: These are arrays that include 0, 1 or 2, indicating the material component behavior.
0 = Inactive
1 = Linear
2 = Nonlinear
S22Type: These are arrays that include 0, 1 or 2, indicating the material component behavior.
0 = Inactive
1 = Linear
2 = Nonlinear
S12Type: These are arrays that include 0, 1 or 2, indicating the material component behavior.
0 = Inactive
1 = Linear
2 = Nonlinear
        """

        all_args = [Name, NumberLayers, LayerName, Dist, Thickness, Type, NumIntegrationPts, MatProp, MatAng, S11Type, S22Type, S12Type]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.SetShellLayer_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetShellLayer_1" failed')
        
        return ret

    def SetShellLayer_2(self, Name = None, NumberLayers = None, LayerName = None, Dist = None, Thickness = None, Type = None, NumIntegrationPts = None, MatProp = None, MatAng = None, MatBehavior = None, S11Type = None, S22Type = None, S12Type = None):
        """
This function assigns the layer parameters for shell-type 
 area properties.
The function returns zero if the parameters are successfully 
 assigned; otherwise, it returns a nonzero value.
The function returns an error if the specified area 
 property is not a shell-type property specified to be a layered shell.

Name: The name of an existing shell-type area property that 
 is specified to be a layered shell property.
NumberLayers: The number of layers in the area property.
LayerName: This is an array that includes the name of each layer.
Dist: This is an array that includes the distance from the 
 area reference surface (area object joint location plus offsets) to the 
 mid-height of the layer. [L]
Thickness: This is an array that includes the thickness of each 
 layer. [L]
Type: This is an array that includes 1, 2 or 3, indicating 
 the layer type.
1 = Shell
2 = Membrane
3 = Plate

NumIntegrationPts: The number of integration points in the thickness direction 
 for the layer. The locations are determined by the program using standard 
 Guass-quadrature rules.
MatProp: This is an array that includes the name of the material 
 property for the layer.
MatAng: This is an array that includes the material angle for 
 the layer. [deg]
MatBehavior: This is an array that includes 0 or 1,indicating the 
 material behavior for the layer.
0 = Directional
1 = Coupled

S11Type: These are arrays that include 0, 1 or 2, indicating 
 the material component behavior.
0 = Inactive
1 = Linear
2 = Nonlinear
S22Type: These are arrays that include 0, 1 or 2, indicating 
 the material component behavior.
0 = Inactive
1 = Linear
2 = Nonlinear
S12Type: These are arrays that include 0, 1 or 2, indicating 
 the material component behavior.
0 = Inactive
1 = Linear
2 = Nonlinear
        """

        all_args = [Name, NumberLayers, LayerName, Dist, Thickness, Type, NumIntegrationPts, MatProp, MatAng, MatBehavior, S11Type, S22Type, S12Type]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.SetShellLayer_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetShellLayer_2" failed')
        
        return ret

    def SetShell_1(self, Name = None, ShellType = None, IncludeDrillingDOF = None, MatProp = None, MatAng = None, Thickness = None, Bending = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a shell-type area property. If this function is called for an existing area property, all items for the property are reset to their default value.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new area property. If this is an existing property, that property is modified; otherwise, a new property is added.
ShellType: This is 1, 2, 3, 4, 5 or 6, indicating the shell type.
1 = Shell - thin
2 = Shell - thick
3 = Plate - thin
4 = Plate - thick
5 = Membrane
6 = Shell layered/nonlinear
IncludeDrillingDOF: This item is True if drilling degrees of freedom are included in the element formulation in the analysis model. This item does not apply when ShellType = 3, 4 or 6.
MatProp: The name of the material property for the area property. This item does not apply when ShellType = 6.
MatAng: The material angle. [deg]
This item does not apply when ShellType = 6.
Thickness: The membrane thickness. [L]
This item does not apply when ShellType = 6.
Bending: The bending thickness. [L]
This item does not apply when ShellType = 6.
Color: The display color assigned to the property. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, then the program assigns a GUID to the property.
        """

        all_args = [Name, ShellType, IncludeDrillingDOF, MatProp, MatAng, Thickness, Bending, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.SetShell_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetShell_1" failed')
        
        return ret

    def GetNotionalSize(self, Name = None, stype = None, Value = None):
        """
This function retrieves the method to determine the notional size of an area section for the creep and shrinkage calculations. This function is currently worked for shell type area section.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing shell-type area section property.
stype: The type to define the notional size of a section. It can be:
"Auto" = Program will determine the notional size based on the average thickness of an area element.
"User" = The notional size is based on the user-defined value.
"None" = Notional size will not be considered. In other words, the time-dependent effect of this section will not be considered.
Value: For stype is "Auto", the Value represents for the scale factor to the program-determined notional size; for stype is “User”, the Value represents for the user-defined notional size [L]; for stype is “None”, the Value will not be used and can be set to 1.
        """

        all_args = [Name, stype, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.GetNotionalSize(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNotionalSize" failed')
        
        return ret

    def SetNotionalSize(self, Name = None, stype = None, Value = None):
        """
This function assigns the method to determine the notional size of an area section for the creep and shrinkage calculations. This function is currently worked for shell type area section.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing shell-type area section property.
stype: The type to define the notional size of a section. It can be:
"Auto" = Program will determine the notional size based on the average thickness of an area element.
"User" = The notional size is based on the user-defined value.
"None" = Notional size will not be considered. In other words, the time-dependent effect of this section will not be considered.
Value: For stype is "Auto", the Value represents for the scale factor to the program-determined notional size; for stype is “User”, the Value represents for the user-defined notional size [L]; for stype is “None”, the Value will not be used and can be set to 1.
        """

        all_args = [Name, stype, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.SetNotionalSize(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNotionalSize" failed')
        
        return ret

    def GetShellLayer(self, Name = None, NumberLayers = None, LayerName = None, Dist = None, Thickness = None, MatProp = None, NonLinear = None, MatAng = None, NumIntegrationPts = None):
        """
This function retrieves area property layer parameters for a shell-type area section.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.
The function returns an error if the specified area property is not a shell-type property specified to be a layered shell.

Name: The name of an existing shell-type area property that is specified to be a layered shell property.
NumberLayers: The number of layers in the area property.
LayerName: This is an array that includes the name of each layer.
Dist: This is an array that includes the distance from the area reference surface (area object joint location plus offsets) to the midheight of the layer. [L]
Thickness: This is an array that includes the thickness of each layer. [L]
MatProp: This is an array that includes the name of the material property for the layer.
NonLinear: This is an array that includes a boolean (True or False) value. If this item is True, and if the material property assigned to the layer is nonlinear, the layer will behave nonlinearly in a nonlinear load case. If this item is False, the layer will never behave nonlinearly.
MatAng: This is an array that includes the material angle for the layer. [deg]
NumIntegrationPts: The number of integration points in the thickness direction for the layer. The locations are determined by the program using standard Guass-quadrature rules.
        """

        all_args = [Name, NumberLayers, LayerName, Dist, Thickness, MatProp, NonLinear, MatAng, NumIntegrationPts]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.GetShellLayer(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetShellLayer" failed')
        
        return ret

    def SetShell(self, Name = None, ShellType = None, MatProp = None, MatAng = None, Thickness = None, Bending = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a shell-type area property. If this function is called for an existing area property, all items for the property are reset to their default value.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new area property. If this is an existing property, that property is modified; otherwise, a new property is added.
ShellType: This is 1, 2, 3, 4, 5 or 6, indicating the shell type.
1 = Shell - thin
2 = Shell - thick
3 = Plate - thin
4 = Plate - thick
5 = Membrane
6 = Shell layered/nonlinear
MatProp: The name of the material property for the area property. This item does not apply when ShellType = 6.
MatAng: The material angle. [deg]
This item does not apply when ShellType = 6.
Thickness: The membrane thickness. [L]
This item does not apply when ShellType = 6.
Bending: The bending thickness. [L]
This item does not apply when ShellType = 6.
Color: The display color assigned to the property. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, ShellType, MatProp, MatAng, Thickness, Bending, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.SetShell(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetShell" failed')
        
        return ret

    def SetShellLayer(self, Name = None, NumberLayers = None, LayerName = None, Dist = None, Thickness = None, MatProp = None, NonLinear = None, MatAng = None, NumIntegrationPts = None):
        """
This function assigns the layer parameters for shell-type area properties.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.
The function returns an error if the specified area property is not a shell-type property specified to be a layered shell.

Name: The name of an existing shell-type area property that is specified to be a layered shell property.
NumberLayers: The number of layers in the area property.
LayerName: This is an array that includes the name of each layer.
Dist: This is an array that includes the distance from the area reference surface (area object joint location plus offsets) to the midheight of the layer. [L]
Thickness: This is an array that includes the thickness of each layer. [L]
MatProp: This is an array that includes the name of the material property for the layer.
NonLinear: This is an array that includes a boolean (True or False) value. If this item is True, and if the material property assigned to the layer is nonlinear, the layer will behave nonlinearly in a nonlinear load case. If this item is False, the layer will never behave nonlinearly.
MatAng: This is an array that includes the material angle for the layer. [deg]
NumIntegrationPts: The number of integration points in the thickness direction for the layer. The locations are determined by the program using standard Guass-quadrature rules.
        """

        all_args = [Name, NumberLayers, LayerName, Dist, Thickness, MatProp, NonLinear, MatAng, NumIntegrationPts]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropArea.SetShellLayer(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetShellLayer" failed')
        
        return ret

class PropCable:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing cable property.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined cable property.
NewName: The new name for the cable property.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropCable.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of defined cable properties in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropCable.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified cable property.
The function returns zero if the property is successfully deleted; otherwise it returns a nonzero value. It returns an error if the specified property can not be deleted, for example, if it is assigned to an existing object.

Name: The name of an existing cable property.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropCable.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetModifiers(self, Name = None, Value = None):
        """
This function retrieves the modifier assignments for a cable property. The default value for all modifiers is one.
The function returns zero if the modifier assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing cable property.
Value: This is an array of three unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Mass modifier
Value(2) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropCable.GetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModifiers" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined cable properties in the model.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of cable property names retrieved by the program.
MyName: This is a one-dimensional array of cable property names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String
The array is dimensioned to (NumberNames - 1) inside the SAP2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropCable.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetProp(self, Name = None, MatProp = None, Area = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves cable property definition data.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing cable property.
MatProp: The name of the material property assigned to the cable property.
Area: The cross-sectional area of the cable. [L2]
Color: The display color assigned to the property.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, MatProp, Area, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropCable.GetProp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProp" failed')
        
        return ret

    def SetModifiers(self, Name = None, Value = None):
        """
This function assigns property modifiers to a cable property. The default value for all modifiers is one.
The function returns zero if the modifiers are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing cable property.
Value: This is an array of 3 unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Mass modifier
Value(2) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropCable.SetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModifiers" failed')
        
        return ret

    def SetProp(self, Name = None, MatProp = None, Area = None, Color = None, Notes = None, GUID = None):
        """
This function defines a cable property.
The function returns zero if the property is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new cable property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property assigned to the cable property.
Area: The cross-sectional area of the cable. [L2]
Color: The display color assigned to the property. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, MatProp, Area, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropCable.SetProp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetProp" failed')
        
        return ret

class PropFrame:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.SDShape = SDShape(strict, api)

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing frame section property.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined frame section property.
NewName: The new name for the frame section property.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self, PropType = None):
        """
This function returns the total number of defined frame section properties in the model. If desired, counts can be returned for all frame section properties of a specified type in the model.

PropType: This optional value is one of the following items in the eFramePropType enumeration.
SECTION_I = 1
SECTION_CHANNEL = 2
SECTION_T = 3
SECTION_ANGLE = 4
SECTION_DBLANGLE = 5
SECTION_BOX = 6
SECTION_PIPE = 7
SECTION_RECTANGULAR = 8
SECTION_CIRCLE = 9
SECTION_GENERAL = 10
SECTION_DBCHANNEL = 11
SECTION_AUTO = 12
SECTION_SD = 13
SECTION_VARIABLE = 14
SECTION_JOIST = 15
SECTION_BRIDGE = 16
SECTION_COLD_C = 17
SECTION_COLD_2C = 18
SECTION_COLD_Z = 19
SECTION_COLD_L = 20
SECTION_COLD_2L = 21
SECTION_COLD_HAT = 22
SECTION_BUILTUP_I_COVERPLATE = 23
SECTION_PCC_GIRDER_I = 24
SECTION_PCC_GIRDER_U = 25
SECTION_BUILTUP_I_HYBRID = 26
SECTION_BUILTUP_U_HYBRID = 27

If no value is input for PropType, a count is returned for all frame section properties in the model regardless of type.
        """

        all_args = [PropType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified frame section property.
The function returns zero if the frame section property is successfully deleted; otherwise it returns a nonzero value. It returns an error if the specified frame section property can not be deleted; for example, if it is being used by a frame object.

Name: The name of an existing frame section property.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetAngle(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for an angle-type frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
FileName: If the section property was imported from a property file; this is the name of that file. If the section property was not imported; this item is blank.
MatProp: The name of the material property for the section.
t3: The vertical leg depth. [L]
t2: The horizontal leg width. [L]
tf: The horizontal leg thickness. [L]
tw: The vertical leg thickness. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, tf, tw, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetAngle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAngle" failed')
        
        return ret

    def GetAutoSelectAluminum(self, Name = None, NumberItems = None, SectName = None, AutoStartSection = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a aluminum auto select lists.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing auto select section list-type frame section property.
NumberItems: The number of frame section properties included in the auto select list.
SectName: This is an array of the names of the frame section properties included in the auto select list.
AutoStartSection: This is Median or the name of a frame section property in the SectName array. It is the starting section for the auto select list.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, NumberItems, SectName, AutoStartSection, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetAutoSelectAluminum(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAutoSelectAluminum" failed')
        
        return ret

    def GetAutoSelectColdFormed(self, Name = None, NumberItems = None, SectName = None, AutoStartSection = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a cold formed auto select lists.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing auto select section list-type frame section property.
NumberItems: The number of frame section properties included in the auto select list.
SectName: This is an array of the names of the frame section properties included in the auto select list.
AutoStartSection: This is Median or the name of a frame section property in the SectName array. It is the starting section for the auto select list.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, NumberItems, SectName, AutoStartSection, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetAutoSelectColdFormed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAutoSelectColdFormed" failed')
        
        return ret

    def GetAutoSelectSteel(self, Name = None, NumberItems = None, SectName = None, AutoStartSection = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a steel auto select lists.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing auto select section list–type frame section property.
NumberItems: The number of frame section properties included in the auto select list.
SectName: This is an array of the names of the frame section properties included in the auto select list.
AutoStartSection: This is either Median or the name of a frame section property in the SectName array. It is the starting section for the auto select list.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, NumberItems, SectName, AutoStartSection, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetAutoSelectSteel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAutoSelectSteel" failed')
        
        return ret

    def GetChannel(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a channel-type frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The flange width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, tf, tw, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetChannel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetChannel" failed')
        
        return ret

    def GetCircle(self, Name = None, FileName = None, MatProp = None, t3 = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a circular frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing circular frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The section diameter. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetCircle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCircle" failed')
        
        return ret

    def GetColdBox(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, Thickness = None, Radius = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data 
 for a cold formed box frame section.
The function returns zero if the section property data 
 is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing cold formed box frame section 
 property.
FileName: If the section property was imported from a property 
 file, this is the name of that file. If the section property was not imported, 
 this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section top flange width. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned 
 to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, Thickness, Radius, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetColdBox(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetColdBox" failed')
        
        return ret

    def GetColdC(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, Thickness = None, Radius = None, LipDepth = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a cold formed C-type frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing cold formed C-type frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section width. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
LipDepth: The lip depth, if any. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, Thickness, Radius, LipDepth, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetColdC(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetColdC" failed')
        
        return ret

    def GetColdHat(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, Thickness = None, Radius = None, LipDepth = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a cold formed hat-type frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing cold formed hat-type frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section width. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
LipDepth: The lip depth, if any. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, Thickness, Radius, LipDepth, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetColdHat(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetColdHat" failed')
        
        return ret

    def GetColdI(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, t2b = None, Thickness = None, Radius = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data 
 for a cold formed I-shape frame section.
The function returns zero if the section property data 
 is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing cold formed I-shape frame section 
 property.
FileName: If the section property was imported from a property 
 file, this is the name of that file. If the section property was not imported, 
 this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section top flange width. [L]
t2b: The section bottom flange width. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned 
 to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, t2b, Thickness, Radius, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetColdI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetColdI" failed')
        
        return ret

    def GetColdL(self, Name = None, FileName = None, MatProp = None, t3 = None, Thickness = None, Radius = None, LipDepth = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data 
 for a cold formed Angle frame section.
The function returns zero if the section property data 
 is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing cold formed Angle frame section 
 property.
FileName: If the section property was imported from a property 
 file, this is the name of that file. If the section property was not imported, 
 this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
LipDepth: The lip depth, if any. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned 
 to the section.
        """

        all_args = [Name, FileName, MatProp, t3, Thickness, Radius, LipDepth, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetColdL(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetColdL" failed')
        
        return ret

    def GetColdPipe(self, Name = None, FileName = None, MatProp = None, t3 = None, Thickness = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data 
 for a cold formed pipe frame section.
The function returns zero if the section property data 
 is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing cold formed pipe frame section 
 property.
FileName: If the section property was imported from a property 
 file, this is the name of that file. If the section property was not imported, 
 this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
Thickness: The section thickness. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned 
 to the section.
        """

        all_args = [Name, FileName, MatProp, t3, Thickness, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetColdPipe(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetColdPipe" failed')
        
        return ret

    def GetColdT(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, Thickness = None, Radius = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data 
 for a cold formed Tee frame section.
The function returns zero if the section property data 
 is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing cold formed Tee frame section 
 property.
FileName: If the section property was imported from a property 
 file, this is the name of that file. If the section property was not imported, 
 this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section top flange width. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned 
 to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, Thickness, Radius, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetColdT(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetColdT" failed')
        
        return ret

    def GetColdZ(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, Thickness = None, Radius = None, LipDepth = None, LipAngle = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a cold formed Z-type frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing cold formed Z-type frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section width. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
LipDepth: The lip depth, if any. [L]
LipAngle: The lip angle measured from horizontal (0 <= LipAngle <= 90). [deg]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, Thickness, Radius, LipDepth, LipAngle, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetColdZ(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetColdZ" failed')
        
        return ret

    def GetCoverPlatedI(self, Name = None, SectName = None, FyTopFlange = None, FyWeb = None, FyBotFlange = None, tc = None, bc = None, MatPropTop = None, tcb = None, bcb = None, MatPropBot = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a tube-type frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
SectName: The name of an existing I-type frame section property that is used for the I-section portion of the coverplated I section.
FyTopFlange: The yield strength of the top flange of the I-section. [F/L2]
If this item is 0, the yield strength of the I-section specified by the SectName item is used.
FyWeb: The yield strength of the web of the I-section. [F/L2]
If this item is 0, the yield strength of the I-section specified by the SectName item is used.
FyBotFlange: The yield strength of the bottom flange of the I-section. [F/L2]
If this item is 0, the yield strength of the I-section specified by the SectName item is used.
tc: The thickness of the top cover plate. [L]
If the tc or the bc item is less than or equal to 0, no top cover plate exists.
bc: The width of the top cover plate. [L]
If the tc or the bc item is less than or equal to 0, no top cover plate exists.
MatPropTop: The name of the material property for the top cover plate.
This item applies only if both the tc and the bc items are greater than 0.
tcb: The thickness of the bottom cover plate. [L]
If the tcb or the bcb item is less than or equal to 0, no bottom cover plate exists.
bcb: The width of the bottom cover plate. [L]
If the tcb or the bcb item is less than or equal to 0, no bottom cover plate exists.
MatPropBot: The name of the material property for the bottom cover plate.
This item applies only if both the tcb and the bcb items are greater than 0.
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, SectName, FyTopFlange, FyWeb, FyBotFlange, tc, bc, MatPropTop, tcb, bcb, MatPropBot, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetCoverPlatedI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCoverPlatedI" failed')
        
        return ret

    def GetDblAngle(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, dis = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a double angle-type frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The vertical leg depth. [L]
t2: The total width of the section, that is, the sum of the widths of each horizontal leg plus the back-to-back distance. [L]
tf: The horizontal leg thickness. [L]
tw: The vertical leg thickness. [L]
dis: The back-to-back distance between the angles. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, tf, tw, dis, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetDblAngle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDblAngle" failed')
        
        return ret

    def GetDblChannel(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, dis = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a double channel-type frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The total width of the section, that is, the sum of the widths of each flange plus the back-to-back distance. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
dis: The back-to-back distance between the channels. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, tf, tw, dis, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetDblChannel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDblChannel" failed')
        
        return ret

    def GetGeneral(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, Area = None, As2 = None, As3 = None, Torsion = None, I22 = None, I33 = None, S22 = None, S33 = None, Z22 = None, Z33 = None, R22 = None, R33 = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a general frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section width. [L]
Area: The cross-sectional area. [L2]
As2: The shear area for forces in the section local 2-axis direction. [L2]
As3: The shear area for forces in the section local 3-axis direction. [L2]
Torsion: The torsional constant. [L4]
I22: The moment of inertia for bending about the local 2 axis. [L4]
I33: The moment of inertia for bending about the local 3 axis. [L4]
S22: The section modulus for bending about the local 2 axis. [L3]
S33: The section modulus for bending about the local 3 axis. [L3]
Z22: The plastic modulus for bending about the local 2 axis. [L3]
Z33: The plastic modulus for bending about the local 3 axis. [L3]
R22: The radius of gyration about the local 2 axis. [L]
R33: The radius of gyration about the local 3 axis. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, Area, As2, As3, Torsion, I22, I33, S22, S33, Z22, Z33, R22, R33, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetGeneral(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGeneral" failed')
        
        return ret

    def GetHybridISection(self, Name = None, MatPropTopFlange = None, MatPropWeb = None, MatPropBotFlange = None, t3 = None, t2 = None, TF = None, TW = None, t2b = None, tfb = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a steel hybrid I frame section.
The function returns zero if the section property data is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
MatPropTopFlange: The name of the material property for the top flange.
MatPropWeb: The name of the material property for the web.
MatPropBotFlange: The name of the material property for the bottom flange.
t3: The height of the section. [L]
t2: The width of the top flange. [L]
TF: The thickness of the top flange. [L]
TW: The thickness of the web. [L]
t2b: The width of the bottom flange. [L]
tfb: The thickness of the bottom flange. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, MatPropTopFlange, MatPropWeb, MatPropBotFlange, t3, t2, TF, TW, t2b, tfb, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetHybridISection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetHybridISection" failed')
        
        return ret

    def GetHybridUSection(self):
        """
This function retrieves frame section property data for a steel hybrid U frame section.
The function returns zero if the section property data is successfully retrieved, otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetHybridUSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetHybridUSection" failed')
        
        return ret

    def GetISection(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, t2b = None, tfb = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for an I-type frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing I-type frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The top flange width. [L]
tf: The top flange thickness. [L]
tw: The web thickness. [L]
t2b: The bottom flange width. [L]
tfb: The bottom flange thickness. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, tf, tw, t2b, tfb, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetISection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetISection" failed')
        
        return ret

    def GetModifiers(self, Name = None, Value = None):
        """
This function retrieves the modifier assignments for a frame section property. The default value for all modifiers is one.
The function returns zero if the modifier assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
Value: This is an array of eight unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Shear area in local 2 direction modifier
Value(2) = Shear area in local 3 direction modifier
Value(3) = Torsional constant modifier
Value(4) = Moment of inertia about local 2 axis modifier
Value(5) = Moment of inertia about local 3 axis modifier
Value(6) = Mass modifier
Value(7) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModifiers" failed')
        
        return ret

    def GetNameInPropFile(self, Name = None, NameInFile = None, FileName = None, MatProp = None, PropType = None):
        """
This function retrieves the names of the section property file from which an imported frame section originated, and it also retrieves the section name used in the property file.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.
If the specified frame section property was not imported, blank strings are returned for NameInFile and FileName.

Name: The name of an existing frame section property.
NameInFile: The name of the specified frame section property in the frame section property file.
FileName: The name of the frame section property file from which the specified frame section property was obtained.
MatProp: The name of the material property for the section.
PropType: This is one of the following items in the eFramePropType enumeration.
SECTION_I = 1
SECTION_CHANNEL = 2
SECTION_T = 3
SECTION_ANGLE = 4
SECTION_DBLANGLE = 5
SECTION_BOX = 6
SECTION_PIPE = 7
SECTION_RECTANGULAR = 8
SECTION_CIRCLE = 9
SECTION_GENERAL = 10
SECTION_DBCHANNEL = 11
SECTION_AUTO = 12
SECTION_SD = 13
SECTION_VARIABLE = 14
SECTION_JOIST = 15
SECTION_BRIDGE = 16
SECTION_COLD_C = 17
SECTION_COLD_2C = 18
SECTION_COLD_Z = 19
SECTION_COLD_L = 20
SECTION_COLD_2L = 21
SECTION_COLD_HAT = 22
SECTION_BUILTUP_I_COVERPLATE = 23
SECTION_PCC_GIRDER_I = 24
SECTION_PCC_GIRDER_U = 25
        """

        all_args = [Name, NameInFile, FileName, MatProp, PropType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetNameInPropFile(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameInPropFile" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None, PropType = None):
        """
This function retrieves the names of all defined frame section properties of the specified type.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of frame section property names retrieved by the program.
MyName: This is a one-dimensional array of frame section property names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String
The array is dimensioned to (NumberNames - 1) inside the SAP2000 program, filled with the names, and returned to the API user.
PropType: This optional value is one of the following items in the eFramePropType enumeration.
SECTION_I = 1
SECTION_CHANNEL = 2
SECTION_T = 3
SECTION_ANGLE = 4
SECTION_DBLANGLE = 5
SECTION_BOX = 6
SECTION_PIPE = 7
SECTION_RECTANGULAR = 8
SECTION_CIRCLE = 9
SECTION_GENERAL = 10
SECTION_DBCHANNEL = 11
SECTION_AUTO = 12
SECTION_SD = 13
SECTION_VARIABLE = 14
SECTION_JOIST = 15
SECTION_BRIDGE = 16
SECTION_COLD_C = 17
SECTION_COLD_2C = 18
SECTION_COLD_Z = 19
SECTION_COLD_L = 20
SECTION_COLD_2L = 21
SECTION_COLD_HAT = 22
SECTION_BUILTUP_I_COVERPLATE = 23
SECTION_PCC_GIRDER_I = 24
SECTION_PCC_GIRDER_U = 25
SECTION_BUILTUP_I_HYBRID = 26
SECTION_BUILTUP_U_HYBRID = 27

If no value is input for PropType, names are returned for all frame section properties in the model regardless of type.
        """

        all_args = [NumberNames, MyName, PropType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetNonPrismatic(self, NumberItems = None, StartSec = None, EndSec = None, MyLength = None, MyType = None, EI33 = None, EI22 = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for nonprismatic (variable) sections.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of segments assigned to the nonprismatic section.
StartSec: This is an array of the names of the frame section properties at the start of each segment.
EndSec: This is an array of the names of the frame section properties at the end of each segment.
MyLength: This is an array that includes the length of each segment. The length may be variable or absolute as indicated by the MyType item. [L] when length is absolute
MyType: This is an array of either 1 or 2, indicating the length type for each segment.
1 = Variable (relative length)
2 = Absolute
EI33: This is an array of either 1, 2 or 3, indicating the variation type for EI33 and EI22 in each segment.
1 = Linear
2 = Parabolic
3 = Cubic
EI22: This is an array of either 1, 2 or 3, indicating the variation type for EI33 and EI22 in each segment.
1 = Linear
2 = Parabolic
3 = Cubic
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [NumberItems, StartSec, EndSec, MyLength, MyType, EI33, EI22, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetNonPrismatic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNonPrismatic" failed')
        
        return ret

    def GetPipe(self, Name = None, FileName = None, MatProp = None, t3 = None, tw = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a pipe-type frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The outside diameter. [L]
tw: The wall thickness. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, tw, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetPipe(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPipe" failed')
        
        return ret

    def GetPrecastI_1(self, Name = None, FileName = None, MatProp = None, b = None, d = None, t = None, c = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a precast concrete I girder frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing precast concrete I girder frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
b: This is an array, dimensioned to 3, containing the horizontal section dimensions. [L]
b(0) = B1 (> 0)
b(1) = B2 (> 0)
b(2) = B3 (>= 0)
b(3) = B4 (>= 0)
Section dimensions B1 through B4 are defined on the precast concrete I girder definition form.
d: This is an array, dimensioned to 5, containing the vertical section dimensions. [L]
d(0) = D1 (> 0)
d(1) = D2 (> 0)
d(2) = D3 (>= 0)
d(3) = D4 (>= 0)
d(4) = D5 (> 0)
d(5) = D6 (>= 0)
d(6) = D7 (>=0)
Section dimensions D1 through D7 are defined on the precast concrete I girder definition form.
t: This is an array, dimensioned to 1, containing the web thickness dimensions. [L]
T(0) = T1 (> 0)
T(1) = T2 (> 0)
Section dimensions T1 and T2 are defined on the precast I girder definition form.
c: The bottom flange chamfer dimension, denoted as C1 on the precast concrete I girder definition form.
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, b, d, t, c, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetPrecastI_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPrecastI_1" failed')
        
        return ret

    def GetPrecastU(self, Name = None, FileName = None, MatProp = None, b = None, d = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a precast concrete U girder frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing precast concrete U girder frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
b: This is an array, dimensioned to 5, containing the horizontal section dimensions. [L]
b(0) = B1 (> 0)
b(1) = B2 (> 0)
b(2) = B3 (> 0)
b(3) = B4 (>= 0)
b(4) = B5 (>= 0)
b(5) = B6 (>= 0)
Section dimensions B1 through B6 are defined on the precast concrete U girder definition form.
d: This is an array, dimensioned to 6, containing the vertical section dimensions. [L]
d(0) = D1 (> 0)
d(1) = D2 (> 0)
d(2) = D3 (>= 0)
d(3) = D4 (>= 0)
d(4) = D5 (>= 0)
d(5) = D6 (>= 0)
d(6) = D7 (>= 0)
Section dimensions D1 through D7 are defined on the precast concrete U girder definition form.
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, b, d, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetPrecastU(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPrecastU" failed')
        
        return ret

    def GetPropFileNameList(self, FileName = None, NumberNames = None, MyName = None, MyType = None, PropType = None):
        """
This function retrieves the names of all defined frame section properties of a specified type in a specified frame section property file.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

FileName: The name of the frame section property file from which to get the name list.
In most cases, inputting only the name of the property file (e.g. Sections8.pro) is required, and the program will be able to find it. In some cases, inputting the full path to the property file may be necessary.
NumberNames: The number of frame section property names retrieved by the program.
MyName: This is an array the includes the property names obtained from the frame section property file.
MyType: This is an array the includes the property type for each property obtained from the frame section property file. See the PropType item below for a list of the possible property types.
PropType: This optional value is one of the following items in the eFramePropType enumeration.
SECTION_I = 1
SECTION_CHANNEL = 2
SECTION_T = 3
SECTION_ANGLE = 4
SECTION_DBLANGLE = 5
SECTION_BOX = 6
SECTION_PIPE = 7
SECTION_RECTANGULAR = 8
SECTION_CIRCLE = 9
SECTION_GENERAL = 10
SECTION_DBCHANNEL = 11
SECTION_AUTO = 12
SECTION_SD = 13
SECTION_VARIABLE = 14
SECTION_JOIST = 15
SECTION_BRIDGE = 16
SECTION_COLD_C = 17
SECTION_COLD_2C = 18
SECTION_COLD_Z = 19
SECTION_COLD_L = 20
SECTION_COLD_2L = 21
SECTION_COLD_HAT = 22
SECTION_BUILTUP_I_COVERPLATE = 23
SECTION_PCC_GIRDER_I = 24
SECTION_PCC_GIRDER_U = 25
SECTION_BUILTUP_I_HYBRID = 26
SECTION_BUILTUP_U_HYBRID = 27

If no value is input for PropType, names are returned for all frame section properties in the specified file regardless of type.
        """

        all_args = [FileName, NumberNames, MyName, MyType, PropType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetPropFileNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPropFileNameList" failed')
        
        return ret

    def GetRebarBeam(self, Name = None, MatPropLong = None, MatPropConfine = None, CoverTop = None, CoverBot = None, TopLeftArea = None, TopRightArea = None, BotLeftArea = None, BotRightArea = None):
        """
This function retrieves beam rebar data for frame sections.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.
This function applies only to the following section types. Calling this function for any other type of frame section property returns an error.
SECTION_T = 3
SECTION_ANGLE = 4
SECTION_RECTANGULAR = 8
SECTION_CIRCLE = 9
The material assigned to the specified frame section property must be concrete or this function returns an error.

Name: The name of an existing frame section property.
MatPropLong: The name of the rebar material property for the longitudinal rebar.
MatPropConfine: The name of the rebar material property for the confinement rebar.
CoverTop: The distance from the top of the beam to the centroid of the top longitudinal reinforcement. [L]
CoverBot: The distance from the bottom of the beam to the centroid of the bottom longitudinal reinforcement. [L]
TopLeftArea: The total area of longitudinal reinforcement at the top left end of the beam. [L2]
TopRightArea: The total area of longitudinal reinforcement at the top right end of the beam. [L2]
BotLeftArea: The total area of longitudinal reinforcement at the bottom left end of the beam. [L2]
BotRightArea: The total area of longitudinal reinforcement at the bottom right end of the beam. [L2]
        """

        all_args = [Name, MatPropLong, MatPropConfine, CoverTop, CoverBot, TopLeftArea, TopRightArea, BotLeftArea, BotRightArea]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetRebarBeam(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetRebarBeam" failed')
        
        return ret

    def GetRebarColumn(self, Name = None, MatPropLong = None, MatPropConfine = None, Pattern = None, ConfineType = None, Cover = None, NumberCBars = None, NumberR3Bars = None, NumberR2Bars = None, RebarSize = None, TieSize = None, TieSpacingLongit = None, Number2DirTieBars = None, Number3DirTieBars = None, ToBeDesigned = None):
        """
This function retrieves column rebar data for frame sections.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.
This function applies only to the following section types. Calling this function for any other type of frame section property returns an error.
SECTION_RECTANGULAR = 8
SECTION_CIRCLE = 9
The material assigned to the specified frame section property must be concrete or else this function returns an error.

Name: The name of an existing frame section property.
MatPropLong: The name of the rebar material property for the longitudinal rebar.
MatPropConfine: The name of the rebar material property for the confinement rebar.
Pattern: This is either 1 or 2, indicating the rebar configuration.
1 = Rectangular
2 = Circular
For circular frame section properties, this item must be 2; otherwise an error is returned.
ConfineType: This is either 1 or 2, indicating the confinement bar type.
1 = Ties
2 = Spiral
This item applies only when Pattern = 2. If Pattern = 1, the confinement bar type is assumed to be ties.
Cover: The clear cover for the confinement steel (ties). In the special case of circular reinforcement in a rectangular column, this is the minimum clear cover. [L]
NumberCBars: This item applies to a circular rebar configuration, Pattern = 2. It is the total number of longitudinal reinforcing bars in the column.
NumberR3Bars: This item applies to a rectangular rebar configuration, Pattern = 1. It is the number of longitudinal bars (including the corner bar) on each face of the column that is parallel to the local 3-axis of the column.
NumberR2Bars: This item applies to a rectangular rebar configuration, Pattern = 1. It is the number of longitudinal bars (including the corner bar) on each face of the column that is parallel to the local 2-axis of the column.
RebarSize: The rebar name for the longitudinal rebar in the column.
TieSize: The rebar name for the confinement rebar in the column.
TieSpacingLongit: The longitudinal spacing of the confinement bars (ties). [L]
Number2DirTieBars: This item applies to a rectangular reinforcing configuration, Pattern = 1. It is the number of confinement bars (tie legs) extending in the local 2-axis direction of the column.
Number3DirTieBars: This item applies to a rectangular reinforcing configuration, Pattern = 1. It is the number of confinement bars (tie legs) extending in the local 3-axis direction of the column.
ToBeDesigned: If this item is True, the column longitudinal rebar is to be designed; otherwise it is to be checked.
        """

        all_args = [Name, MatPropLong, MatPropConfine, Pattern, ConfineType, Cover, NumberCBars, NumberR3Bars, NumberR2Bars, RebarSize, TieSize, TieSpacingLongit, Number2DirTieBars, Number3DirTieBars, ToBeDesigned]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetRebarColumn(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetRebarColumn" failed')
        
        return ret

    def GetRectangle(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a rectangular frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing rectangular frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section width. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetRectangle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetRectangle" failed')
        
        return ret

    def GetSDSection(self, Name = None, MatProp = None, NumberItems = None, ShapeName = None, MyType = None, DesignType = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves section property data for a section designer section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing section designer property.
MatProp: The name of the base material property for the section.
NumberItems: The number of shapes defined in the section designer section.
ShapeName: This is an array that includes the name of each shape in the section designer section.
MyType: This is an array that includes the type of each shape in the section designer section.
1 = I-section
2 = Channel
3 = Tee
4 = Angle
5 = Double Angle
6 = Box
7 = Pipe
8 = Plate

101 = Solid Rectangle
102 = Solid Circle
103 = Solid Segment
104 = Solid Sector

201 = Polygon

301 = Reinforcing Single
302 = Reinforcing Line
303 = Reinforcing Rectangle
304 = Reinforcing Circle

401 = Reference Line
402 = Reference Circle

501 = Caltrans Square
502 = Caltrans Circle
503 = Caltrans Hexagon
504 = Caltrans Octagon
DesignType: This is 0, 1, 2 or 3, indicating the design option for the section.
0 = No design
1 = Design as general steel section
2 = Design as a concrete column; check the reinforcing
3 = Design as a concrete column; design the reinforcing
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, MatProp, NumberItems, ShapeName, MyType, DesignType, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetSDSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSDSection" failed')
        
        return ret

    def GetSectProps(self, Name = None, Area = None, As2 = None, As3 = None, Torsion = None, I22 = None, I33 = None, S22 = None, S33 = None, Z22 = None, Z33 = None, R22 = None, R33 = None):
        """
This function retrieves properties for frame section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
Area: The cross-sectional area. [L2]
As2: The shear area for forces in the section local 2-axis direction. [L2]
As3: The shear area for forces in the section local 3-axis direction. [L2]
Torsion: The torsional constant. [L4]
I22: The moment of inertia for bending about the local 2 axis. [L4]
I33: The moment of inertia for bending about the local 3 axis. [L4]
S22: The section modulus for bending about the local 2 axis. [L3]
S33: The section modulus for bending about the local 3 axis. [L3]
Z22: The plastic modulus for bending about the local 2 axis. [L3]
Z33: The plastic modulus for bending about the local 3 axis. [L3]
R22: The radius of gyration about the local 2 axis. [L]
R33: The radius of gyration about the local 3 axis. [L]
        """

        all_args = [Name, Area, As2, As3, Torsion, I22, I33, S22, S33, Z22, Z33, R22, R33]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetSectProps(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSectProps" failed')
        
        return ret

    def GetTee(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a tee-type frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The flange width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, tf, tw, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetTee(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTee" failed')
        
        return ret

    def GetTube(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a tube-type frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, tf, tw, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetTube(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTube" failed')
        
        return ret

    def GetTypeRebar(self, Name = None, PropType = None):
        """
This function retrieves the rebar design type for the specified frame section property.
The function returns zero if the type is successfully retrieved; otherwise it returns nonzero.
This function applies only to the following section property types. Calling this function for any other type of frame section property returns an error.
SECTION_T = 3
SECTION_ANGLE = 4
SECTION_RECTANGULAR = 8
SECTION_CIRCLE = 9
A nonzero rebar type is returned only if the frame section property has a concrete material.

Name: The name of an existing frame section property.
PropType: This is 0, 1 or 2, indicating the rebar design type.
0 = None
1 = Column
2 = Beam
        """

        all_args = [Name, PropType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetTypeRebar(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTypeRebar" failed')
        
        return ret

    def GetTypeOAPI(self, Name = None, PropType = None):
        """
This function retrieves the property type for the specified 
 frame section property.
The function returns zero if the type is successfully 
 retrieved; otherwise it returns nonzero.

Name: The name of an existing frame section property.
PropType: This is one of the following items in the eFramePropType 
 enumeration.
I = 1
Channel = 2
T = 3
Angle = 4
DblAngle = 5
Box = 6
Pipe = 7
Rectangular = 8
Circle = 9
General = 10
DbChannel = 11
Auto = 12
SD = 13
Variable = 14
Joist = 15
Bridge = 16
Cold_C = 17
Cold_2C = 18
Cold_Z = 19
Cold_L = 20
Cold_2L = 21
Cold_HAT = 22
BuiltupICoverplate = 23
PCCGIRDERI = 24
PCCGIRDERU = 25
BuiltupIHybrid = 26
BuiltupUHybrid = 27
PCCGirderSuperT = 41
Cold_Box = 42
Cold_I = 43
Cold_Pipe = 44
Cold_T = 45
Trapezoidal = 46
        """

        all_args = [Name, PropType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetTypeOAPI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTypeOAPI" failed')
        
        return ret

    def ImportProp(self, Name = None, MatProp = None, FileName = None, PropName = None, Color = None, Notes = None, GUID = None):
        """
This function imports a frame section property from a property file.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.
If the property file is not found, or the specified property name is not found in the property file, the section is set to be a general section with default properties.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added. This name does not need to be the same as the PropName item.
MatProp: The name of the material property for the section.
FileName: The name of the frame section property file from which to get the frame section property specified by the PropName item.
In most cases you can input just the name of the property file (e.g. Sections8.pro) and the program will be able to find it. In some cases you may have to input the full path to the property file.
PropName: The name of the frame section property, inside the property file specified by the FileName item, that is to be imported.
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, FileName, PropName, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.ImportProp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ImportProp" failed')
        
        return ret

    def SetAngle(self, Name = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, Color = None, Notes = None):
        """
This function initializes an angle-type frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The vertical leg depth. [L]
t2: The horizontal leg width. [L]
tf: The horizontal leg thickness. [L]
tw: The vertical leg thickness. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID
The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, then the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, tf, tw, Color, Notes]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetAngle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAngle" failed')
        
        return ret

    def SetAutoSelectAluminum(self, Name = None, NumberItems = None, SectName = None, AutoStartSection = None, Notes = None, GUID = None):
        """
This function assigns frame section properties to an auto select list. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the auto select list is successfully filled; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
NumberItems: The number of frame section properties included in the auto select list.
SectName: This is an array of the names of the frame section properties included in the auto select list.
Auto select lists and nonprismatic (variable) sections are not allowed in this array.
AutoStartSection: This is Median or the name of a frame section property in the SectName array. It is the starting section for the auto select list.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, NumberItems, SectName, AutoStartSection, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetAutoSelectAluminum(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAutoSelectAluminum" failed')
        
        return ret

    def SetAutoSelectColdFormed(self, Name = None, NumberItems = None, SectName = None, AutoStartSection = None, Notes = None, GUID = None):
        """
This function assigns frame section properties to an auto select list. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the auto select list is successfully filled; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
NumberItems: The number of frame section properties included in the auto select list.
SectName: This is an array of the names of the frame section properties included in the auto select list.
Auto select lists and nonprismatic (variable) sections are not allowed in this array.
AutoStartSection: This is Median or the name of a frame section property in the SectName array. It is the starting section for the auto select list.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, NumberItems, SectName, AutoStartSection, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetAutoSelectColdFormed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAutoSelectColdFormed" failed')
        
        return ret

    def SetAutoSelectSteel(self, Name = None, NumberItems = None, SectName = None, AutoStartSection = None, Notes = None, GUID = None):
        """
This function assigns frame section properties to an auto select list. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the auto select list is successfully filled; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
NumberItems: The number of frame section properties included in the auto select list.
SectName: This is an array of the names of the frame section properties included in the auto select list.
Auto select lists and nonprismatic (variable) sections are not allowed in this array.
AutoStartSection: This is either Median or the name of a frame section property in the SectName array. It is the starting section for the auto select list.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, NumberItems, SectName, AutoStartSection, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetAutoSelectSteel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAutoSelectSteel" failed')
        
        return ret

    def SetChannel(self, Name = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a channel-type frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The flange width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, tf, tw, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetChannel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetChannel" failed')
        
        return ret

    def SetCircle(self, Name = None, MatProp = None, t3 = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a solid circular frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The section diameter. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetCircle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCircle" failed')
        
        return ret

    def SetColdBox(self, Name = None, MatProp = None, t3 = None, t2 = None, Thickness = None, Radius = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a cold formed box frame section 
 property. If this function is called for an existing frame section property, 
 all items for the section are reset to their default value.
The function returns zero if the section property is 
 successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. 
 If this is an existing property, that property is modified; otherwise, 
 a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section top flange width. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
Color: The display color assigned to the section. If Color 
 is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned 
 to the section. If this item is input as Default, the program assigns 
 a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, Thickness, Radius, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetColdBox(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetColdBox" failed')
        
        return ret

    def SetColdC(self, Name = None, MatProp = None, t3 = None, t2 = None, Thickness = None, Radius = None, LipDepth = None, Color = None, Notes = None, GUID = None):
        """
This function initializes an cold formed C-type frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section width. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
LipDepth: The lip depth, if any. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, Thickness, Radius, LipDepth, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetColdC(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetColdC" failed')
        
        return ret

    def SetColdHat(self, Name = None, MatProp = None, t3 = None, t2 = None, Thickness = None, Radius = None, LipDepth = None, Color = None, Notes = None, GUID = None):
        """
This function initializes an cold formed hat-type frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section width. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
LipDepth: The lip depth, if any. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, then the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, Thickness, Radius, LipDepth, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetColdHat(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetColdHat" failed')
        
        return ret

    def SetColdI(self, Name = None, MatProp = None, t3 = None, t2 = None, t2b = None, Thickness = None, Radius = None, Color = None, Notes = None, GUID = None):
        """
This function initializes an cold formed I-shape frame 
 section property. If this function is called for an existing frame section 
 property, all items for the section are reset to their default value.
The function returns zero if the section property is 
 successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. 
 If this is an existing property, that property is modified; otherwise, 
 a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section top flange width. [L]
t2b: The section bottom flange width. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
Color: The display color assigned to the section. If Color 
 is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned 
 to the section. If this item is input as Default, the program assigns 
 a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, t2b, Thickness, Radius, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetColdI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetColdI" failed')
        
        return ret

    def SetColdL(self, Name = None, MatProp = None, t3 = None, Thickness = None, Radius = None, LipDepth = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a cold formed Angle frame 
 section property. If this function is called for an existing frame section 
 property, all items for the section are reset to their default value.
The function returns zero if the section property is 
 successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. 
 If this is an existing property, that property is modified; otherwise, 
 a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
LipDepth: The lip depth, if any. [L]
Color: The display color assigned to the section. If Color 
 is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned 
 to the section. If this item is input as Default, the program assigns 
 a GUID to the section.
        """

        all_args = [Name, MatProp, t3, Thickness, Radius, LipDepth, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetColdL(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetColdL" failed')
        
        return ret

    def SetColdPipe(self, Name = None, MatProp = None, t3 = None, Thickness = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a cold formed pipe frame section 
 property. If this function is called for an existing frame section property, 
 all items for the section are reset to their default value.
The function returns zero if the section property is 
 successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. 
 If this is an existing property, that property is modified; otherwise, 
 a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
Thickness: The section thickness. [L]
Color: The display color assigned to the section. If Color 
 is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned 
 to the section. If this item is input as Default, the program assigns 
 a GUID to the section.
        """

        all_args = [Name, MatProp, t3, Thickness, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetColdPipe(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetColdPipe" failed')
        
        return ret

    def SetColdT(self, Name = None, MatProp = None, t3 = None, t2 = None, Thickness = None, Radius = None, Color = None, Notes = None, GUID = None):
        """
This function initializes an cold formed Tee frame section 
 property. If this function is called for an existing frame section property, 
 all items for the section are reset to their default value.
The function returns zero if the section property is 
 successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. 
 If this is an existing property, that property is modified; otherwise, 
 a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section top flange width. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
Color: The display color assigned to the section. If Color 
 is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned 
 to the section. If this item is input as Default, the program assigns 
 a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, Thickness, Radius, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetColdT(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetColdT" failed')
        
        return ret

    def SetColdZ(self, Name = None, MatProp = None, t3 = None, t2 = None, Thickness = None, Radius = None, LipDepth = None, LipAngle = None, Color = None, Notes = None, GUID = None):
        """
This function initializes an cold formed Z-type frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property then that property is modified, otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section width. [L]
Thickness: The section thickness. [L]
Radius: The corner radius, if any. [L]
LipDepth: The lip depth, if any. [L]
LipAngle: The lip angle measured from horizontal (0 <= LipAngle <= 90). [deg]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, Thickness, Radius, LipDepth, LipAngle, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetColdZ(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetColdZ" failed')
        
        return ret

    def SetCoverPlatedI(self, Name = None, SectName = None, FyTopFlange = None, FyWeb = None, FyBotFlange = None, tc = None, bc = None, MatPropTop = None, tcb = None, bcb = None, MatPropBot = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a cover plated I-type frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
SectName: The name of an existing I-type frame section property that is used for the I-section portion of the coverplated I section.
FyTopFlange: The yield strength of the top flange of the I-section. [F/L2]
If this item is 0, the yield strength of the I-section specified by the SectName item is used.
FyWeb: The yield strength of the web of the I-section. [F/L2]
If this item is 0, the yield strength of the I-section specified by the SectName item is used.
FyBotFlange: The yield strength of the bottom flange of the I-section. [F/L2]
If this item is 0, the yield strength of the I-section specified by the SectName item is used.
tc: The thickness of the top cover plate. [L]
If the tc or the bc item is less than or equal to 0, no top cover plate exists.
bc: The width of the top cover plate. [L]
If the tc or the bc item is less than or equal to 0, no top cover plate exists.
MatPropTop: The name of the material property for the top cover plate.
This item applies only if both the tc and the bc items are greater than 0.
tcb: The thickness of the bottom cover plate. [L]
If the tcb or the bcb item is less than or equal to 0, no bottom cover plate exists.
bcb: The width of the bottom cover plate. [L]
If the tcb or the bcb item is less than or equal to 0, no bottom cover plate exists.
MatPropBot: The name of the material property for the bottom cover plate.
This item applies only if both the tcb and the bcb items are greater than 0.
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, SectName, FyTopFlange, FyWeb, FyBotFlange, tc, bc, MatPropTop, tcb, bcb, MatPropBot, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetCoverPlatedI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCoverPlatedI" failed')
        
        return ret

    def SetDblAngle(self, Name = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, dis = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a double angle-type frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The vertical leg depth. [L]
t2: The total width of the section, that is, the sum of the widths of each horizontal leg plus the back-to-back distance. [L]
tf: The horizontal leg thickness. [L]
tw: The vertical leg thickness. [L]
dis: The back-to-back distance between the angles. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, tf, tw, dis, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetDblAngle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDblAngle" failed')
        
        return ret

    def SetDblChannel(self, Name = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, dis = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a double channel-type frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The total width of the section, that is, the sum of the widths of each flange plus the back-to-back distance. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
dis: The back-to-back distance between the channels. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, tf, tw, dis, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetDblChannel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDblChannel" failed')
        
        return ret

    def SetGeneral(self, Name = None, MatProp = None, t3 = None, t2 = None, Area = None, As2 = None, As3 = None, Torsion = None, I22 = None, I33 = None, S22 = None, S33 = None, Z22 = None, Z33 = None, R22 = None, R33 = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a general frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section width. [L]
Area: The cross-sectional area. [L2]
As2: The shear area for forces in the section local 2-axis direction. [L2]
As3: The shear area for forces in the section local 3-axis direction. [L2]
Torsion: The torsional constant. [L4]
I22: The moment of inertia for bending about the local 2 axis. [L4]
I33: The moment of inertia for bending about the local 3 axis. [L4]
S22: The section modulus for bending about the local 2 axis. [L3]
S33: The section modulus for bending about the local 3 axis. [L3]
Z22: The plastic modulus for bending about the local 2 axis. [L3]
Z33: The plastic modulus for bending about the local 3 axis. [L3]
R22: The radius of gyration about the local 2 axis. [L]
R33: The radius of gyration about the local 3 axis. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, Area, As2, As3, Torsion, I22, I33, S22, S33, Z22, Z33, R22, R33, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetGeneral(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGeneral" failed')
        
        return ret

    def SetHybridISection(self, Name = None, MatPropTopFlange = None, MatPropWeb = None, MatPropBotFlange = None, t3 = None, t2 = None, TF = None, TW = None, t2b = None, tfb = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a steel hybrid I frame section property. If this function is called for an existing frame section property then all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized, otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property then that property is modified, otherwise, a new property is added.
MatPropTopFlange: The name of the material property for the top flange.
MatPropWeb: The name of the material property for the web.
MatPropBotFlange: The name of the material property for the bottom flange.
t3: The height of the section. [L]
t2: The width of the top flange. [L]
TF: The thickness of the top flange. [L]
TW: The thickness of the web. [L]
t2b: The width of the bottom flange. [L]
tfb: The thickness of the bottom flange. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, then the program assigns a GUID to the section.
        """

        all_args = [Name, MatPropTopFlange, MatPropWeb, MatPropBotFlange, t3, t2, TF, TW, t2b, tfb, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetHybridISection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetHybridISection" failed')
        
        return ret

    def SetHybridUSection(self):
        """
This function initializes a steel hybrid U frame section property. If this function is called for an existing frame section property then all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized, otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetHybridUSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetHybridUSection" failed')
        
        return ret

    def SetISection(self, Name = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, t2b = None, tfb = None, Color = None, Notes = None, GUID = None):
        """
This function initializes an I-type frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The top flange width. [L]
tf: The top flange thickness. [L]
tw: The web thickness. [L]
t2b: The bottom flange width. [L]
tfb: The bottom flange thickness. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, tf, tw, t2b, tfb, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetISection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetISection" failed')
        
        return ret

    def SetModifiers(self, Name = None, Value = None):
        """
This function assigns property modifiers to a frame section property. The default value for all modifiers is one.
The function returns zero if the modifiers are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
Value: This is an array of eight unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Shear area in local 2 direction modifier
Value(2) = Shear area in local 3 direction modifier
Value(3) = Torsional constant modifier
Value(4) = Moment of inertia about local 2 axis modifier
Value(5) = Moment of inertia about local 3 axis modifier
Value(6) = Mass modifier
Value(7) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModifiers" failed')
        
        return ret

    def SetNonPrismatic(self, Name = None, NumberItems = None, StartSec = None, EndSec = None, MyLength = None, MyType = None, EI33 = None, EI22 = None, Color = None, Notes = None, GUID = None):
        """
This function assigns data to a nonprismatic frame section property.
The function returns zero if the data is successfully filled; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
NumberItems: The number of segments assigned to the nonprismatic section.
StartSec: This is an array of the names of the frame section properties at the start of each segment.
Auto select lists and nonprismatic sections are not allowed in this array.
EndSec: This is an array of the names of the frame section properties at the end of each segment.
Auto select lists and nonprismatic sections are not allowed in this array.
MyLength: This is an array that includes the length of each segment. The length may be variable or absolute as indicated by the MyType item. [L] when length is absolute
MyType: This is an array of either 1 or 2, indicating the length type for each segment.
1 = Variable (relative length)
2 = Absolute
EI33: This is an array of 1, 2 or 3, indicating the variation type for EI33 and EI22 in each segment.
1 = Linear
2 = Parabolic
3 = Cubic
EI22: This is an array of 1, 2 or 3, indicating the variation type for EI33 and EI22 in each segment.
1 = Linear
2 = Parabolic
3 = Cubic
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, NumberItems, StartSec, EndSec, MyLength, MyType, EI33, EI22, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetNonPrismatic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNonPrismatic" failed')
        
        return ret

    def SetPipe(self, Name = None, MatProp = None, t3 = None, tw = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a pipe-type frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The outside diameter. [L]
tw: The wall thickness. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, tw, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetPipe(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPipe" failed')
        
        return ret

    def SetPrecastI_1(self, Name = None, MatProp = None, b = None, d = None, t = None, c = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a precast concrete I girder frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
b: This is an array, dimensioned to 3, containing the horizontal section dimensions. [L]
b(0) = B1 (> 0)
b(1) = B2 (> 0)
b(2) = B3 (>= 0)
b(3) = B4 (>= 0)
Section dimensions B1 through B4 are defined on the precast concrete I girder definition form.
d: This is an array, dimensioned to 5, containing the vertical section dimensions. [L]
d(0) = D1 (> 0)
d(1) = D2 (> 0)
d(2) = D3 (>= 0)
d(3) = D4 (>= 0)
d(4) = D5 (> 0)
d(5) = D6 (>= 0)
d(6) = D7 (>=0)
Section dimensions D1 through D7 are defined on the precast concrete I girder definition form.
t: This is an array, dimensioned to 1, containing the web thickness dimensions. [L]
T(0) = T1 (> 0)
T(1) = T2 (> 0)
Section dimensions T1 and T2 are defined on the precast I girder definition form.
c: The bottom flange chamfer dimension, denoted as C1 on the precast concrete I girder definition form.
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, b, d, t, c, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetPrecastI_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPrecastI_1" failed')
        
        return ret

    def SetPrecastU(self, Name = None, MatProp = None, b = None, d = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a precast concrete U girder frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
b: This is an array, dimensioned to 5, containing the horizontal section dimensions. [L]
b(0) = B1 (> 0)
b(1) = B2 (> 0)
b(2) = B3 (> 0)
b(3) = B4 (>= 0)
b(4) = B5 (>= 0)
b(5) = B6 (>= 0)
Section dimensions B1 through B6 are defined on the precast concrete U girder definition form.
d: This is an array, dimensioned to 6, containing the vertical section dimensions. [L]
d(0) = D1 (> 0)
d(1) = D2 (> 0)
d(2) = D3 (>= 0)
d(3) = D4 (>= 0)
d(4) = D5 (>= 0)
d(5) = D6 (>= 0)
d(6) = D7 (>= 0)
Section dimensions D1 through D7 are defined on the precast concrete U girder definition form.
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, b, d, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetPrecastU(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPrecastU" failed')
        
        return ret

    def SetRebarBeam(self, Name = None, MatPropLong = None, MatPropConfine = None, CoverTop = None, CoverBot = None, TopLeftArea = None, TopRightArea = None, BotLeftArea = None, BotRightArea = None):
        """
This function assigns beam rebar data to frame sections.
The function returns zero if the rebar data is successfully assigned; otherwise it returns a nonzero value.
This function applies only to the following section types. Calling this function for any other type of frame section property returns an error.
SECTION_T = 3
SECTION_ANGLE = 4
SECTION_RECTANGULAR = 8
SECTION_CIRCLE = 9
The material assigned to the specified frame section property must be concrete or this function returns an error.

Name: The name of an existing frame section property.
MatPropLong: The name of the rebar material property for the longitudinal rebar.
MatPropConfine: The name of the rebar material property for the confinement rebar.
CoverTop: The distance from the top of the beam to the centroid of the top longitudinal reinforcement. [L]
CoverBot: The distance from the bottom of the beam to the centroid of the bottom longitudinal reinforcement. [L]
TopLeftArea: The total area of longitudinal reinforcement at the top left end of the beam. [L2]
TopRightArea: The total area of longitudinal reinforcement at the top right end of the beam. [L2]
BotLeftArea: The total area of longitudinal reinforcement at the bottom left end of the beam. [L2]
BotRightArea: The total area of longitudinal reinforcement at the bottom right end of the beam. [L2]
        """

        all_args = [Name, MatPropLong, MatPropConfine, CoverTop, CoverBot, TopLeftArea, TopRightArea, BotLeftArea, BotRightArea]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetRebarBeam(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetRebarBeam" failed')
        
        return ret

    def SetRebarColumn(self, Name = None, MatPropLong = None, MatPropConfine = None, Pattern = None, ConfineType = None, Cover = None, NumberCBars = None, NumberR3Bars = None, NumberR2Bars = None, RebarSize = None, TieSize = None, TieSpacingLongit = None, Number2DirTieBars = None, Number3DirTieBars = None, ToBeDesigned = None):
        """
This function assigns column rebar data to frame sections.
The function returns zero if the rebar data is successfully assigned; otherwise it returns a nonzero value.
This function applies only to the following section types. Calling this function for any other type of frame section property returns an error.
SECTION_RECTANGULAR = 8
SECTION_CIRCLE = 9
The material assigned to the specified frame section property must be concrete or else this function returns an error.

Name: The name of an existing frame section property.
MatPropLong: The name of the rebar material property for the longitudinal rebar.
MatPropConfine: The name of the rebar material property for the confinement rebar.
Pattern: This is either 1 or 2, indicating the rebar configuration.
1 = Rectangular
2 = Circular
For circular frame section properties this item must be 2; otherwise an error is returned.
ConfineType: This is either 1 or 2, indicating the confinement bar type.
1 = Ties
2 = Spiral
This item applies only when Pattern = 2. If Pattern = 1, the confinement bar type is assumed to be ties.
Cover: The clear cover for the confinement steel (ties). In the special case of circular reinforcement in a rectangular column, this is the minimum clear cover. [L]
NumberCBars: This item applies to a circular rebar configuration, Pattern = 2. It is the total number of longitudinal reinforcing bars in the column.
NumberR3Bars: This item applies to a rectangular rebar configuration, Pattern = 1. It is the number of longitudinal bars (including the corner bar) on each face of the column that is parallel to the local 3-axis of the column.
NumberR2Bars: This item applies to a rectangular rebar configuration, Pattern = 1. It is the number of longitudinal bars (including the corner bar) on each face of the column that is parallel to the local 2-axis of the column.
RebarSize: The rebar name for the longitudinal rebar in the column.
TieSize: The rebar name for the confinement rebar in the column.
TieSpacingLongit: The longitudinal spacing of the confinement bars (ties). [L]
Number2DirTieBars: This item applies to a rectangular reinforcing configuration, Pattern = 1. It is the number of confinement bars (tie legs) running in the local 2-axis direction of the column.
Number3DirTieBars: This item applies to a rectangular reinforcing configuration, Pattern = 1. It is the number of confinement bars (tie legs) running in the local 3-axis direction of the column.
ToBeDesigned: If this item is True, the column longitudinal rebar is to be designed; otherwise it is to be checked.
        """

        all_args = [Name, MatPropLong, MatPropConfine, Pattern, ConfineType, Cover, NumberCBars, NumberR3Bars, NumberR2Bars, RebarSize, TieSize, TieSpacingLongit, Number2DirTieBars, Number3DirTieBars, ToBeDesigned]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetRebarColumn(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetRebarColumn" failed')
        
        return ret

    def SetRectangle(self, Name = None, MatProp = None, t3 = None, t2 = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a solid rectangular frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section width. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetRectangle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetRectangle" failed')
        
        return ret

    def SetSDSection(self, Name = None, MatProp = None, DesignType = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a section designer property.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the base material property for the section.
DesignType: This is 0, 1, 2 or 3, indicating the design option for the section.
0 = No design
1 = Design as general steel section
2 = Design as a concrete column; check the reinforcing
3 = Design as a concrete column; design the reinforcing

When DesignType = 1 is assigned, the material property specified by the MatProp item must be a steel material; otherwise the program sets DesignType = 0.
Similarly, when DesignType = 2 or DesignType = 3 is assigned, the material property specified by the MatProp item must be a concrete material; otherwise the program sets DesignType = 0.
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, DesignType, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetSDSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSDSection" failed')
        
        return ret

    def SetTee(self, Name = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a tee-type frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The flange width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, tf, tw, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetTee(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTee" failed')
        
        return ret

    def SetTube(self, Name = None, MatProp = None, t3 = None, t2 = None, tf = None, tw = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a tube-type frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, tf, tw, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetTube(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTube" failed')
        
        return ret

    def GetNotionalSize(self, Name = None, stype = None, Value = None):
        """
This function retrieves the method to determine the notional size of a frame section for the creep and shrinkage calculations. This function is currently worked for the steel/aluminum sections - I/Wide Flange, Channel, Tee, Angle, Double Angle, Double Channel, Pipe and Tube sections, and all the concrete sections - Rectangular, Circular, Pipe, Tube, Precast I.
The function returns zero if the parameters are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
stype: The type to define the notional size of a section. It can be:
"Auto" = Program will determine the notional size based on the average thickness of an area element.
"User" = The notional size is based on the user-defined value.
"None" = Notional size will not be considered. In other words, the time-dependent effect of this section will not be considered.
Value: For stype is "Auto", the Value represents for the scale factor to the program-determined notional size; for stype is “User”, the Value represents for the user-defined notional size [L]; for stype is “None”, the Value will not be used and can be set to 1.
        """

        all_args = [Name, stype, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetNotionalSize(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNotionalSize" failed')
        
        return ret

    def GetTrapezoidal(self, Name = None, FileName = None, MatProp = None, t3 = None, t2 = None, t2b = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a trapezoidal frame section.
The function returns zero if the section property is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing trapezoidal frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.

MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section top width. [L]
t2b: The section bottom width. [L]
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, t3, t2, t2b, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetTrapezoidal(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTrapezoidal" failed')
        
        return ret

    def SetNotionalSize(self, Name = None, stype = None, Value = None):
        """
This function assigns the method to determine the notional size of a frame section for the creep and shrinkage calculations. This function is currently worked for the steel/aluminum sections - I/Wide Flange, Channel, Tee, Angle, Double Angle, Double Channel, Pipe and Tube sections, and all the concrete sections - Rectangular, Circular, Pipe, Tube, Precast I.
The function returns zero if the parameters are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing frame section property.
stype: The type to define the notional size of a section. It can be:
"Auto" = Program will determine the notional size based on the average thickness of an area element.
"User" = The notional size is based on the user-defined value.
"None" = Notional size will not be considered. In other words, the time-dependent effect of this section will not be considered.
Value: For stype is "Auto", the Value represents for the scale factor to the program-determined notional size; for stype is “User”, the Value represents for the user-defined notional size [L]; for stype is “None”, the Value will not be used and can be set to 1.
        """

        all_args = [Name, stype, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetNotionalSize(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetNotionalSize" failed')
        
        return ret

    def SetTrapezoidal(self, Name = None, MatProp = None, t3 = None, t2 = None, t2b = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a solid trapezoidal frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
t3: The section depth. [L]
t2: The section top width. [L]
t2b: The section bottom width. [L]
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, t3, t2, t2b, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetTrapezoidal(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTrapezoidal" failed')
        
        return ret

    def GetPrecastI(self, Name = None, FileName = None, MatProp = None, b = None, d = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves frame section property data for a precast concrete I girder frame section.
The function returns zero if the section property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing precast concrete I girder frame section property.
FileName: If the section property was imported from a property file, this is the name of that file. If the section property was not imported, this item is blank.
MatProp: The name of the material property for the section.
b: This is an array, dimensioned to 3, containing the horizontal section dimensions. [L]
b(0) = B1 (> 0)
b(1) = B2 (> 0)
b(2) = B3 (> 0)
b(3) = B4 (>= 0)
Section dimensions B1 through B4 are defined on the precast concrete I girder definition form.
d: This is an array, dimensioned to 5, containing the vertical section dimensions. [L]
d(0) = D1 (> 0)
d(1) = D2 (> 0)
d(2) = D3 (>= 0)
d(3) = D4 (>= 0)
d(4) = D5 (>= 0)
d(5) = D6 (> 0)
Section dimensions D1 through D6 are defined on the precast concrete I girder definition form.
Color: The display color assigned to the section.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section.
        """

        all_args = [Name, FileName, MatProp, b, d, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.GetPrecastI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPrecastI" failed')
        
        return ret

    def SetPrecastI(self, Name = None, MatProp = None, b = None, d = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a precast concrete I girder frame section property. If this function is called for an existing frame section property, all items for the section are reset to their default value.
The function returns zero if the section property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new frame section property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property for the section.
b: This is an array, dimensioned to 3, containing the horizontal section dimensions. [L]
b(0) = B1 (> 0)
b(1) = B2 (> 0)
b(2) = B3 (> 0)
b(3) = B4 (>= 0)
Section dimensions B1 through B4 are defined on the precast concrete I girder definition form.
d: This is an array, dimensioned to 5, containing the vertical section dimensions. [L]
d(0) = D1 (> 0)
d(1) = D2 (> 0)
d(2) = D3 (>= 0)
d(3) = D4 (>= 0)
d(4) = D5 (>= 0)
d(5) = D6 (> 0)
Section dimensions D1 through D6 are defined on the precast concrete I girder definition form.
Color: The display color assigned to the section. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the section.
GUID: The GUID (global unique identifier), if any, assigned to the section. If this item is input as Default, the program assigns a GUID to the section.
        """

        all_args = [Name, MatProp, b, d, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SetPrecastI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPrecastI" failed')
        
        return ret

class SDShape:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def Delete(self, Name = None, ShapeName = None, All = None):
        """
This function deletes shapes from a section designer property.
The function returns zero if the shape is successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing shape in a section designer property. If the All item is True, this item may be specified as a blank string.
All: If this item is True, all shapes in the section designer property specified by the Name item are deleted.
        """

        all_args = [Name, ShapeName, All]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetAngle(self, Name = None, ShapeName = None, MatProp = None, PropName = None, Color = None, XCenter = None, YCenter = None, h = None, bf = None, tf = None, tw = None, Rotation = None):
        """
This function retrieves property data for an Angle shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing Angle shape in the specified frame section property.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined Angle property that has been imported from a section property file. If it is the name of a defined Angle property, the section dimensions are taken from that property.
Color: The fill color assigned to the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
h: The section depth. [L]
bf: The flange width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
        """

        all_args = [Name, ShapeName, MatProp, PropName, Color, XCenter, YCenter, h, bf, tf, tw, Rotation]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetAngle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAngle" failed')
        
        return ret

    def GetChannel(self, Name = None, ShapeName = None, MatProp = None, PropName = None, Color = None, XCenter = None, YCenter = None, h = None, bf = None, tf = None, tw = None, Rotation = None):
        """
This function retrieves property data for a Channel shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing Channel shape in the specified frame section property.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined Channel property that has been imported from a section property file. If it is the name of a defined Channel property, the section dimensions are taken from that property.
Color: The fill color assigned to the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
h: The section depth. [L]
bf: The flange width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
        """

        all_args = [Name, ShapeName, MatProp, PropName, Color, XCenter, YCenter, h, bf, tf, tw, Rotation]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetChannel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetChannel" failed')
        
        return ret

    def GetDblAngle(self, Name = None, ShapeName = None, MatProp = None, PropName = None, Color = None, XCenter = None, YCenter = None, h = None, w = None, tf = None, tw = None, dis = None, Rotation = None):
        """
This function retrieves property data for a Double Angle shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing Double Angle shape in the specified frame section property.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined Double Angle property that has been imported from a section property file. If it is the name of a defined Double Angle property, then the section dimensions are taken from that property.
Color: The fill color assigned to the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
h: The section depth. [L]
w: The flange width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
dis: Separation between the two flanges that are parallel. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
        """

        all_args = [Name, ShapeName, MatProp, PropName, Color, XCenter, YCenter, h, w, tf, tw, dis, Rotation]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetDblAngle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDblAngle" failed')
        
        return ret

    def GetISection(self, Name = None, ShapeName = None, MatProp = None, PropName = None, Color = None, XCenter = None, YCenter = None, h = None, bf = None, tf = None, tw = None, bfb = None, tfb = None, Rotation = None):
        """
This function retrieves property data for an I-section shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing I-section shape in the specified frame section property.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined I-section property that has been imported from a section property file. If it is the name of a defined I-section property, the section dimensions are taken from that property.
Color: The fill color assigned to the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
h: The section depth. [L]
bf: The top flange width. [L]
tf: The top flange thickness. [L]
tw: The web thickness. [L]
bfb: The bottom flange width. [L]
tfb: The bottom flange thickness. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
        """

        all_args = [Name, ShapeName, MatProp, PropName, Color, XCenter, YCenter, h, bf, tf, tw, bfb, tfb, Rotation]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetISection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetISection" failed')
        
        return ret

    def GetPipe(self, Name = None, ShapeName = None, MatProp = None, PropName = None, Color = None, XCenter = None, YCenter = None, diameter = None, thickness = None):
        """
This function retrieves property data for a Pipe shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing Pipe shape in the specified frame section property.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined Pipe property that has been imported from a section property file. If it is the name of a defined Pipe property, the section dimensions are taken from that property.
Color: The fill color assigned to the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
diameter: The outer diameter of the Pipe. [L]
thickness: The wall thickness of the Pipe. [L]
        """

        all_args = [Name, ShapeName, MatProp, PropName, Color, XCenter, YCenter, diameter, thickness]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetPipe(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPipe" failed')
        
        return ret

    def GetPlate(self, Name = None, ShapeName = None, MatProp = None, Color = None, XCenter = None, YCenter = None, thickness = None, w = None, Rotation = None):
        """
This function retrieves property data for an Plate shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing Plate shape in the specified frame section property.
MatProp: The name of the material property for the shape.
Color: The fill color assigned to the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
thickness: The thickness of the plate. [L]
w: The width of the Plate. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
        """

        all_args = [Name, ShapeName, MatProp, Color, XCenter, YCenter, thickness, w, Rotation]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetPlate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPlate" failed')
        
        return ret

    def GetPolygon(self, Name = None, ShapeName = None, MatProp = None, SSOverwrite = None, NumberPoints = None, X = None, Y = None, Radius = None, Color = None, Reinf = None, MatRebar = None):
        """
This function retrieves property data for a polygon shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing polygon shape in the specified frame section property.
MatProp: The name of the material property for the shape.
SSOverwrite: This is a blank string, Default, or the name of a defined stress-strain curve.
If this item is a blank string or Default, the shape stress-strain curve is based on the assigned material property.
NumberPoints: The number of point coordinates used to define the polygon.
X: This is an array that contains the X-coordinates of the polygon points. [L]
Y: This is an array that contains the Y-coordinates of the polygon points. [L]
Radius: This is an array that contains the radius to be applied at each of the polygon points. [L]
Color: The fill color assigned to the shape.
Reinf: This item is True when there is edge and corner reinforcing steel associated with the shape. The MatProp item must refer to a concrete material for this item to be True.
MatRebar: The material property for the edge and corner reinforcing steel associated with the shape. This item applies only when the MatProp item is a concrete material and the Reinf item is True.
        """

        all_args = [Name, ShapeName, MatProp, SSOverwrite, NumberPoints, X, Y, Radius, Color, Reinf, MatRebar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetPolygon(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPolygon" failed')
        
        return ret

    def GetRefCircle(self, Name = None, ShapeName = None, XCenter = None, YCenter = None, Diameter = None):
        """
This function retrieves property data for a reference circle shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Diameter: The diameter of the circular shape. [L]
        """

        all_args = [Name, ShapeName, XCenter, YCenter, Diameter]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetRefCircle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetRefCircle" failed')
        
        return ret

    def GetRefLine(self, Name = None, ShapeName = None, X1 = None, Y1 = None, X2 = None, Y2 = None):
        """
This function retrieves property data for a reference line shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of a reference line shape in the section designer section.
X1: The section designer X coordinate of the first drawn end point of the line pattern reinforcing. [L]
Y1: The section designer Y coordinate of the first drawn end point of the line pattern reinforcing. [L]
X2: The section designer X coordinate of the second drawn end point of the line pattern reinforcing. [L]
Y2: The section designer Y coordinate of the second drawn end point of the line pattern reinforcing. [L]
        """

        all_args = [Name, ShapeName, X1, Y1, X2, Y2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetRefLine(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetRefLine" failed')
        
        return ret

    def GetReinfCircle(self, Name = None, ShapeName = None, XCenter = None, YCenter = None, Diameter = None, NumberBars = None, Rotation = None, Barsize = None, MatRebar = None):
        """
This function retrieves property data for a circular reinforcing shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of a circular reinforcing shape in the section designer section.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Diameter: The diameter of the circular shape. [L]
NumberBars: The number of equally spaced bars for the circular reinforcing.
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Barsize: It is the size of the reinforcing bar.
MatRebar: The material property for the reinforcing steel.
        """

        all_args = [Name, ShapeName, XCenter, YCenter, Diameter, NumberBars, Rotation, Barsize, MatRebar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetReinfCircle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetReinfCircle" failed')
        
        return ret

    def GetReinfCorner(self, Name = None, ShapeName = None, NumberItems = None, PointNum = None, RebarSize = None):
        """
This function retrieves corner point reinforcing data for solid rectangle, circle and polygon shapes in a section designer property.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing solid rectangle shape in the specified frame section property.
NumberItems: The number of edges in the shape.
PointNum: This is an array that includes the corner point number in the shape.
RebarSize: This is an array that includes None or the name of a defined rebar, indicating the rebar assignment to the considered corner point.
        """

        all_args = [Name, ShapeName, NumberItems, PointNum, RebarSize]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetReinfCorner(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetReinfCorner" failed')
        
        return ret

    def GetReinfEdge(self, Name = None, ShapeName = None, NumberItems = None, EdgeNum = None, RebarSize = None, Spacing = None, Cover = None):
        """
This function retrieves edge reinforcing data for solid rectangle, circle, polygon, and rectangular reinforcing shapes in a section designer property.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing solid rectangle shape in the specified frame section property.
NumberItems: The number of edges in the shape.
EdgeNum: This is an array that includes the edge number in the shape.
RebarSize: This is an array that includes None or the name of a defined rebar, indicating the rebar assignment to the considered edge.
Spacing: This is an array that includes the rebar maximum center-to-center along the considered edge. [L]
Cover: This is an array that includes the rebar clear cover along the considered edge. [L]
        """

        all_args = [Name, ShapeName, NumberItems, EdgeNum, RebarSize, Spacing, Cover]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetReinfEdge(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetReinfEdge" failed')
        
        return ret

    def GetReinfLine(self, Name = None, ShapeName = None, X1 = None, Y1 = None, X2 = None, Y2 = None, Spacing = None, BarSize = None, EndBars = None, MatRebar = None):
        """
This function retrieves property data for a line reinforcing shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of a line reinforcing shape in the section designer section.
X1: The section designer X coordinate of the first drawn end point of the line reinforcing. [L]
Y1: The section designer Y coordinate of the first drawn end point of the line reinforcing. [L]
X2: The section designer X coordinate of the second drawn end point of the line reinforcing. [L]
Y2: The section designer Y coordinate of the second drawn end point of the line reinforcing. [L]
Spacing: The center-to-center spacing of the bars in the line pattern shape. [L]
BarSize: The size of the reinforcing bars used in the line reinforcing shape.
EndBars: This item is True when there are bars at the end points of the line reinforcing.
MatRebar: The material property for the reinforcing steel.
        """

        all_args = [Name, ShapeName, X1, Y1, X2, Y2, Spacing, BarSize, EndBars, MatRebar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetReinfLine(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetReinfLine" failed')
        
        return ret

    def GetReinfRectangular(self, Name = None, ShapeName = None, XCenter = None, YCenter = None, h = None, w = None, Rotation = None, MatRebar = None):
        """
This function retrieves property data for a rectangular reinforcing shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of a rectangular reinforcing shape in the section designer section.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
h: The section depth. [L]
w: The top flange width. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
MatRebar: The material property for the reinforcing steel.
        """

        all_args = [Name, ShapeName, XCenter, YCenter, h, w, Rotation, MatRebar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetReinfRectangular(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetReinfRectangular" failed')
        
        return ret

    def GetReinfSingle(self, Name = None, ShapeName = None, XCenter = None, YCenter = None, Barsize = None, MatRebar = None):
        """
This function retrieves property data for a single bar reinforcing shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of a single bar reinforcing shape in the section designer section.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Barsize: The size of the reinforcing bar.
MatRebar: The material property for the reinforcing steel.
        """

        all_args = [Name, ShapeName, XCenter, YCenter, Barsize, MatRebar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetReinfSingle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetReinfSingle" failed')
        
        return ret

    def GetSolidCircle(self):
        """
This function retrieves property data for a solid circle shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetSolidCircle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSolidCircle" failed')
        
        return ret

    def GetSolidRect(self, Name = None, ShapeName = None, MatProp = None, SSOverwrite = None, Color = None, XCenter = None, YCenter = None, h = None, w = None, Rotation = None, Reinf = None, MatRebar = None):
        """
This function retrieves property data for a solid rectangular shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing solid rectangle shape in the specified frame section property.
MatProp: The name of the material property for the shape.
SSOverwrite: This is a blank string, Default, or the name of a defined stress-strain curve.
If this item is a blank string or Default, the shape stress-strain curve is based on the assigned material property.
Color: The fill color assigned to the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
h: The section depth. [L]
w: The section width. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Reinf: This item is True when there is edge and corner reinforcing steel associated with the shape. The MatProp item must refer to a concrete material for this item to be True.
MatRebar: The material property for the edge and corner reinforcing steel associated with the shape. This item applies only when the MatProp item is a concrete material and the Reinf item is True.
        """

        all_args = [Name, ShapeName, MatProp, SSOverwrite, Color, XCenter, YCenter, h, w, Rotation, Reinf, MatRebar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetSolidRect(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSolidRect" failed')
        
        return ret

    def GetSolidSector(self, Name = None, ShapeName = None, MatProp = None, Color = None, XCenter = None, YCenter = None, Angle = None, Rotation = None, Radius = None):
        """
This function retrieves property data for a solid sector shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing solid sector shape in the specified frame section property.
MatProp: The name of the material property for the shape.
Color: The fill color assigned to the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Angle: The angle between the two radii that define the circular sector. [deg]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Radius: The radius of the circle defining the Sector. [L]
        """

        all_args = [Name, ShapeName, MatProp, Color, XCenter, YCenter, Angle, Rotation, Radius]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetSolidSector(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSolidSector" failed')
        
        return ret

    def GetSolidSegment(self, Name = None, ShapeName = None, MatProp = None, Color = None, XCenter = None, YCenter = None, Angle = None, Rotation = None, Radius = None):
        """
This function retrieves property data for a solid segment shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing solid segment shape in the specified frame section property.
MatProp: The name of the material property for the shape.
Color: The fill color assigned to the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Angle: The angle between lines drawn from the center of the circle to the end points of the chord tat defines the segment. [deg]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Radius: The radius of the circle defining the segment.
        """

        all_args = [Name, ShapeName, MatProp, Color, XCenter, YCenter, Angle, Rotation, Radius]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetSolidSegment(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSolidSegment" failed')
        
        return ret

    def GetTee(self, Name = None, ShapeName = None, MatProp = None, PropName = None, Color = None, XCenter = None, YCenter = None, h = None, bf = None, tf = None, tw = None, Rotation = None):
        """
This function retrieves property data for a Tee shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing Tee shape in the specified frame section property.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined Tee property that has been imported from a section property file. If it is the name of a defined Tee property, the section dimensions are taken from that property.
Color: The fill color assigned to the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
h: The section depth. [L]
bf: The section width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
        """

        all_args = [Name, ShapeName, MatProp, PropName, Color, XCenter, YCenter, h, bf, tf, tw, Rotation]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetTee(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTee" failed')
        
        return ret

    def GetTube(self, Name = None, ShapeName = None, MatProp = None, PropName = None, Color = None, XCenter = None, YCenter = None, h = None, w = None, tf = None, tw = None, Rotation = None):
        """
This function retrieves property data for a Tube shape in a section designer section.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing Tube shape in the specified frame section property.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined Tube property that has been imported from a section property file. If it is the name of a defined Tube property, the section dimensions are taken from that property.
Color: The fill color assigned to the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
h: The section height. [L]
w: The section width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
        """

        all_args = [Name, ShapeName, MatProp, PropName, Color, XCenter, YCenter, h, w, tf, tw, Rotation]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.GetTube(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTube" failed')
        
        return ret

    def SetAngle(self, Name = None, ShapeName = None, MatProp = None, PropName = None, XCenter = None, YCenter = None, Rotation = None, Color = None, h = None, bf = None, tf = None, tw = None):
        """
This function adds a new Angle shape or modifies an existing shape to be an Angle shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined Angle property that has been imported from a section property file.
If this item is a blank string, the section dimensions are taken from the values input in this function.
If this item is the name of a defined Angle property that has been imported from a section property file, the section dimensions are taken from the specified Angle property.
If this item is not blank, and the specified property name is not an Angle that was imported from a section property file, an error is returned.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Color: The fill color assigned to the shape. If Color is specified as -1, the program will automatically assign the default fill color.
h: The section depth. [L]
bf: The flange width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
        """

        all_args = [Name, ShapeName, MatProp, PropName, XCenter, YCenter, Rotation, Color, h, bf, tf, tw]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetAngle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAngle" failed')
        
        return ret

    def SetChannel(self, Name = None, ShapeName = None, MatProp = None, PropName = None, XCenter = None, YCenter = None, Rotation = None, Color = None, h = None, bf = None, tf = None, tw = None):
        """
This function adds a new Channel shape or modifies an existing shape to be a Channel shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined Channel property that has been imported from a section property file.
If this item is a blank string, the section dimensions are taken from the values input in this function.
If this item is the name of a defined Channel property that has been imported from a section property file, the section dimensions are taken from the specified Channel property.
If this item is not blank, and the specified property name is not an Channel that was imported from a section property file, an error is returned.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Color: The fill color assigned to the shape. If Color is specified as -1, the program will automatically assign the default fill color.
h: The section depth. [L]
bf: The flange width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
        """

        all_args = [Name, ShapeName, MatProp, PropName, XCenter, YCenter, Rotation, Color, h, bf, tf, tw]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetChannel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetChannel" failed')
        
        return ret

    def SetDblAngle(self, Name = None, ShapeName = None, MatProp = None, PropName = None, XCenter = None, YCenter = None, Rotation = None, Color = None, h = None, w = None, tf = None, tw = None, dis = None):
        """
This function adds a new Double Angle shape or modifies an existing shape to be an Double Angle shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined DblAngle property that has been imported from a section property file.
If this item is a blank string, the section dimensions are taken from the values input in this function.
If this item is the name of a defined DblAngle property that has been imported from a section property file, the section dimensions are taken from the specified DblAngle property.
If this item is not blank and the specified property name is not an DblAngle that was imported from a section property file, an error is returned.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Color: The fill color assigned to the shape. If Color is specified as -1, the program will automatically assign the default fill color.
h: The section depth. [L]
w: The flange width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
dis: Separation between the two flanges that are parallel. [L]
        """

        all_args = [Name, ShapeName, MatProp, PropName, XCenter, YCenter, Rotation, Color, h, w, tf, tw, dis]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetDblAngle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDblAngle" failed')
        
        return ret

    def SetISection(self, Name = None, ShapeName = None, MatProp = None, PropName = None, XCenter = None, YCenter = None, Rotation = None, Color = None, h = None, bf = None, tf = None, tw = None, bfb = None, tfb = None):
        """
This function adds a new I-section shape or modifies an existing shape to be an I-section shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined I-section property that has been imported from a section property file.
If this item is a blank string, the section dimensions are taken from the values input in this function.
If this item is the name of a defined I-section property that has been imported from a section property file, the section dimensions are taken from the specified I-section property.
If this item is not blank, and the specified property name is not an I-section that was imported from a section property file, an error is returned.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Color: The fill color assigned to the shape. If Color is specified as -1, the program will automatically assign the default fill color.
h: The section depth. [L]
bf: The top flange width. [L]
tf: The top flange thickness. [L]
tw: The web thickness. [L]
bfb: The bottom flange width. [L]
tfb: The bottom flange thickness. [L]
        """

        all_args = [Name, ShapeName, MatProp, PropName, XCenter, YCenter, Rotation, Color, h, bf, tf, tw, bfb, tfb]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetISection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetISection" failed')
        
        return ret

    def SetPipe(self, Name = None, ShapeName = None, MatProp = None, PropName = None, XCenter = None, YCenter = None, Color = None, diameter = None, thickness = None):
        """
This function adds a new Pipe shape or modifies an existing shape to be a Pipe shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined Pipe property that has been imported from a section property file.
If this item is a blank string, the section dimensions are taken from the values input in this function.
If this item is the name of a defined Pipe property that has been imported from a section property file, the section dimensions are taken from the specified Pipe property.
If this item is not blank and the specified property name is not a Pipe that was imported from a section property file, an error is returned.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Color: The fill color assigned to the shape. If Color is specified as -1, the program will automatically assign the default fill color.
diameter: The outer diameter of the Pipe. [L]
thickness: The wall thickness of the Pipe. [L]
        """

        all_args = [Name, ShapeName, MatProp, PropName, XCenter, YCenter, Color, diameter, thickness]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetPipe(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPipe" failed')
        
        return ret

    def SetPlate(self, Name = None, ShapeName = None, MatProp = None, XCenter = None, YCenter = None, Rotation = None, Color = None, thickness = None, w = None):
        """
This function adds a new Plate shape or modifies an existing shape to be a Plate shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape,n that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
MatProp: The name of the material property for the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Color: The fill color assigned to the shape. If Color is specified as -1, the program will automatically assign the default fill color.
thickness: The thickness of the plate. [L]
w: The width of the Plate. [L]
        """

        all_args = [Name, ShapeName, MatProp, XCenter, YCenter, Rotation, Color, thickness, w]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetPlate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPlate" failed')
        
        return ret

    def SetPolygon(self, Name = None, ShapeName = None, MatProp = None, SSOverwrite = None, NumberPoints = None, X = None, Y = None, Radius = None, Color = None, Reinf = None, MatRebar = None):
        """
This function adds a new polygon shape or modifies an existing shape to be a polygon shape in a section designer property.
The polygon points must be defined in order around the polygon, otherwise the shape will be created incorrectly or the creation of the shape will fail.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero val .

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
MatProp: The name of the material property for the shape.
SSOverwrite: This is a blank string, Default, or the name of a defined stress-strain curve.
If this item is a blank string or Default, the shape stress-strain curve is based on the assigned material property.
NumberPoints: The number of point coordinates used to define the polygon.
X: This is an array that contains the X-coordinates of the polygon points. [L]
Y: This is an array that contains the Y-coordinates of the polygon points. [L]
Radius: This is an array that contains the radius to be applied at each of the polygon points. [L]
Color: The fill color assigned to the shape. If Color is specified as -1, the program will automatically assign the default fill color.
Reinf: This item is True when there is edge and corner reinforcing steel associated with the shape.
If the MatProp item is not a concrete material, this item is always assumed to be False.
MatRebar: The material property for the edge and corner reinforcing steel associated with the shape. This item applies only when the MatProp item is a concrete material and the Reinf item is True.
        """

        all_args = [Name, ShapeName, MatProp, SSOverwrite, NumberPoints, X, Y, Radius, Color, Reinf, MatRebar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetPolygon(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPolygon" failed')
        
        return ret

    def SetRefCircle(self, Name = None, ShapeName = None, XCenter = None, YCenter = None, Diameter = None):
        """
This function adds a new reference circle shape or modifies an existing shape to be a reference circle shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Diameter: The diameter of the circular shape. [L]
        """

        all_args = [Name, ShapeName, XCenter, YCenter, Diameter]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetRefCircle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetRefCircle" failed')
        
        return ret

    def SetRefLine(self, Name = None, ShapeName = None, X1 = None, Y1 = None, X2 = None, Y2 = None):
        """
This function adds a new reference line shape or modifies an existing shape to be a reference line shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
X1: The section designer X coordinate of the first drawn end point of the line pattern reinforcing. [L]
Y1: The section designer Y coordinate of the first drawn end point of the line pattern reinforcing. [L]
X2: The section designer X coordinate of the second drawn end point of the line pattern reinforcing. [L]
Y2: The section designer Y coordinate of the second drawn end point of the line pattern reinforcing. [L]
        """

        all_args = [Name, ShapeName, X1, Y1, X2, Y2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetRefLine(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetRefLine" failed')
        
        return ret

    def SetReinfCircle(self, Name = None, ShapeName = None, XCenter = None, YCenter = None, Diameter = None, NumberBars = None, Rotation = None, Barsize = None, MatRebar = None):
        """
This function adds a new circular reinforcing shape or modifies an existing shape to be an circular reinforcing shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Diameter: The diameter of the circular shape. [L]
NumberBars: The number of equally spaced bars for the circular reinforcing.
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Barsize: It is the size of the reinforcing bar.
MatRebar: The material property for the reinforcing steel.
        """

        all_args = [Name, ShapeName, XCenter, YCenter, Diameter, NumberBars, Rotation, Barsize, MatRebar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetReinfCircle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetReinfCircle" failed')
        
        return ret

    def SetReinfCorner(self, Name = None, ShapeName = None, PointNum = None, RebarSize = None, All = None):
        """
This function specifies corner reinforcing in solid rectangle, circle and polygon shapes in a section designer property.
The function returns zero if the reinforcing is successfully specified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing solid rectangle, circle or polygon shape in the specified section.
PointNum: An corner point number in the shape. This item is ignored if the All item is True.
RebarSize: This is None or the name of a defined rebar, indicating the rebar assignment to the specified corner.
All: If this item is True, the specified rebar data applies to all corners in the shape.
        """

        all_args = [Name, ShapeName, PointNum, RebarSize, All]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetReinfCorner(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetReinfCorner" failed')
        
        return ret

    def SetReinfEdge(self, Name = None, ShapeName = None, EdgeNum = None, RebarSize = None, Spacing = None, Cover = None, All = None):
        """
This function specifies edge reinforcing in solid rectangle, circle, polygon and rectangular reinforcing shapes in a section designer property.
The function returns zero if the reinforcing is successfully specified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing solid rectangle, circle or polygon shape in the specified section.
EdgeNum: An edge number in the shape. This item is ignored if the All item is True.
RebarSize: This is None or the name of a defined rebar, indicating the rebar assignment to the specified edge.
Spacing: This is the rebar maximum center-to-center along the specified edge. [L]
Cover: This is the rebar clear cover along the specified edge. [L]
All: If this item is True, the specified rebar data applies to all edges in the shape.
        """

        all_args = [Name, ShapeName, EdgeNum, RebarSize, Spacing, Cover, All]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetReinfEdge(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetReinfEdge" failed')
        
        return ret

    def SetReinfLine(self, Name = None, ShapeName = None, X1 = None, Y1 = None, X2 = None, Y2 = None, Spacing = None, BarSize = None, EndBars = None, MatRebar = None):
        """
This function adds a new line reinforcing shape or modifies an existing shape to be a line reinforcing shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
X1: The section designer X coordinate of the first drawn end point of the line reinforcing. [L]
Y1: The section designer Y coordinate of the first drawn end point of the line reinforcing. [L]
X2: The section designer X coordinate of the second drawn end point of the line reinforcing. [L]
Y2: The section designer Y coordinate of the second drawn end point of the line reinforcing. [L]
Spacing: The center-to-center spacing of the bars in the line pattern shape. [L]
BarSize: The size of the reinforcing bars used in the line reinforcing shape.
EndBars: This item is True when there are bars at the end points of the line reinforcing.
MatRebar: The material property for the reinforcing steel.
        """

        all_args = [Name, ShapeName, X1, Y1, X2, Y2, Spacing, BarSize, EndBars, MatRebar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetReinfLine(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetReinfLine" failed')
        
        return ret

    def SetReinfRectangular(self, Name = None, ShapeName = None, XCenter = None, YCenter = None, Rotation = None, h = None, w = None, MatRebar = None):
        """
This function adds a new rectangular reinforcing shape or modifies an existing shape to be a rectangular reinforcing shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
h: The section depth. [L]
w: The top flange width. [L]
MatRebar: The material property for the reinforcing steel.
        """

        all_args = [Name, ShapeName, XCenter, YCenter, Rotation, h, w, MatRebar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetReinfRectangular(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetReinfRectangular" failed')
        
        return ret

    def SetReinfSingle(self, Name = None, ShapeName = None, XCenter = None, YCenter = None, Barsize = None, MatRebar = None):
        """
This function adds a new single bar reinforcing shape or modifies an existing shape to be a single bar reinforcing shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Barsize: It is the size of the reinforcing bar.
MatRebar: The material property for the reinforcing steel.
        """

        all_args = [Name, ShapeName, XCenter, YCenter, Barsize, MatRebar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetReinfSingle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetReinfSingle" failed')
        
        return ret

    def SetSolidCircle(self):
        """
This function adds a new solid circle shape or modifies an existing shape to be a solid circle shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetSolidCircle(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSolidCircle" failed')
        
        return ret

    def SetSolidRect(self, Name = None, ShapeName = None, MatProp = None, SSOverwrite = None, XCenter = None, YCenter = None, Rotation = None, Color = None, h = None, w = None, Reinf = None, MatRebar = None):
        """
This function adds a new solid rectangle shape or modifies an existing shape to be an solid rectangle shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
MatProp: The name of the material property for the shape.
SSOverwrite: This is a blank string, Default, or the name of a defined stress-strain curve.
If this item is a blank string or Default, the shape stress-strain curve is based on the assigned material property.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Color: The fill color assigned to the shape. If Color is specified as -1, the program will automatically assign the default fill color.
h: The section depth. [L]
w: The section width. [L]
Reinf: This item is True when there is edge and corner reinforcing steel associated with the shape.
If the MatProp item is not a concrete material, this item is always assumed to be False.
MatRebar: The material property for the edge and corner reinforcing steel associated with the shape. This item applies only when the MatProp item is a concrete material and the Reinf item is True.
        """

        all_args = [Name, ShapeName, MatProp, SSOverwrite, XCenter, YCenter, Rotation, Color, h, w, Reinf, MatRebar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetSolidRect(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSolidRect" failed')
        
        return ret

    def SetSolidSector(self, Name = None, ShapeName = None, MatProp = None, XCenter = None, YCenter = None, Angle = None, Rotation = None, Radius = None, Color = None):
        """
This function adds a new solid sector shape or modifies an existing shape to be a solid sector shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
MatProp: The name of the material property for the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Angle: The angle between the two radii that define the circular sector. [deg]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Radius: The radius of the circle defining the Sector. [L]
Color: The fill color assigned to the shape. If Color is specified as -1, the program will automatically assign the default fill color.
        """

        all_args = [Name, ShapeName, MatProp, XCenter, YCenter, Angle, Rotation, Radius, Color]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetSolidSector(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSolidSector" failed')
        
        return ret

    def SetSolidSegment(self, Name = None, ShapeName = None, MatProp = None, XCenter = None, YCenter = None, Angle = None, Rotation = None, Radius = None, Color = None):
        """
This function adds a new solid segment shape or modifies an existing shape to be a solid segment shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
MatProp: The name of the material property for the shape.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Angle: The angle between lines drawn from the center of the circle to the end points of the chord tat defines the segment. [deg]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Radius: The radius of the circle defining the segment.
Color: The fill color assigned to the shape. If Color is specified as -1, the program will automatically assign the default fill color.
        """

        all_args = [Name, ShapeName, MatProp, XCenter, YCenter, Angle, Rotation, Radius, Color]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetSolidSegment(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSolidSegment" failed')
        
        return ret

    def SetTee(self, Name = None, ShapeName = None, MatProp = None, PropName = None, XCenter = None, YCenter = None, Rotation = None, Color = None, h = None, bf = None, tf = None, tw = None):
        """
This function adds a new Tee shape or modifies an existing shape to be a Tee shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined Tee property that has been imported from a section property file.
If this item is a blank string, the section dimensions are taken from the values input in this function.
If this item is the name of a defined Tee property that has been imported from a section property file, the section dimensions are taken from the specified Tee property.
If this item is not blank, and the specified property name is not a Tee that was imported from a section property file, an error is returned.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Color: The fill color assigned to the shape. If Color is specified as -1, the program will automatically assign the default fill color.
h: The section depth. [L]
bf: The section width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
        """

        all_args = [Name, ShapeName, MatProp, PropName, XCenter, YCenter, Rotation, Color, h, bf, tf, tw]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetTee(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTee" failed')
        
        return ret

    def SetTube(self, Name = None, ShapeName = None, MatProp = None, PropName = None, XCenter = None, YCenter = None, Rotation = None, Color = None, h = None, w = None, tf = None, tw = None):
        """
This function adds a new Tube shape or modifies an existing shape to be a Tube shape in a section designer property.
The function returns zero if the shape is successfully added or modified; otherwise it returns a nonzero value.

Name: The name of an existing frame section property that is a section designer section.
ShapeName: The name of an existing or new shape in a section designer property. If this is an existing shape, that shape is modified; otherwise, a new shape is added.
This item may be input as a blank string, in which case the program will assign a shape name to the shape and return that name in the ShapeName variable.
MatProp: The name of the material property for the shape.
PropName: This is a blank string or the name of a defined Tube property that has been imported from a section property file.
If this item is a blank string, the section dimensions are taken from the values input in this function.
If this item is the name of a defined Tube property that has been imported from a section property file, the section dimensions are taken from the specified Tube property.
If this item is not blank and the specified property name is not an Tube that was imported from a section property file, an error is returned.
XCenter: The X-coordinate of the center of the shape in the section designer coordinate system. [L]
YCenter: The Y-coordinate of the center of the shape in the section designer coordinate system. [L]
Rotation: The counter clockwise rotation of the shape from its default orientation. [deg]
Color: The fill color assigned to the shape. If Color is specified as -1, the program will automatically assign the default fill color.
h: The section height. [L]
w: The section width. [L]
tf: The flange thickness. [L]
tw: The web thickness. [L]
        """

        all_args = [Name, ShapeName, MatProp, PropName, XCenter, YCenter, Rotation, Color, h, w, tf, tw]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropFrame.SDShape.SetTube(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTube" failed')
        
        return ret

class PropLink:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing link property.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined link property.
NewName: The new name for the link property.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self, PropType = None):
        """
This function returns the total number of defined link 
 properties in the model. If desired, counts can be returned for all link 
 properties of a specified type in the model.

PropType: This optional value is one of the following items in 
 the eLinkPropType enumeration.
NLPROP_LINEAR = 1
NLPROP_DAMPER = 2
NLPROP_GAP = 3
NLPROP_HOOK = 4
NLPROP_PLASTIC_WEN = 5
NLPROP_ISOLATOR1 = 6(Rubber 
 isolator)
NLPROP_ISOLATOR2 = 7(Friction 
 isolator)
NLPROP_MULTILINEAR_ELASTIC 
 = 8
NLPROP_MULTILINEAR_PLASTIC 
 = 9
NLPROP_ISOLATOR3 = 10(T/C 
 Friction isolator)

If no value is input for PropType, a count is returned 
 for all link properties in the model regardless of type.
        """

        all_args = [PropType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified link property.
The function returns zero if the link property is successfully deleted; otherwise it returns a nonzero value. It returns an error if the specified link property can not be deleted, for example, if it is being used by an existing link object.

Name: The name of an existing link property.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetDamper(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, c = None, cexp = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function retrieves link property data for an exponential damper-type link property.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing exponential damper-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties

The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]

The term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
c: This is an array of nonlinear damping coefficient terms for the link property. The nonlinear damping coefficient applies for nonlinear analyses.
c(0) = U1 [F/(L^cexp)]
c(1) = U2 [F/(L^cexp)]
c(2) = U3 [F/(L^cexp)]
c(3) = R1 [FL]
c(4) = R2 [FL]
c(5) = R3 [FL]

The term c(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
cexp: This is an array of the nonlinear damping exponent terms. The nonlinear damping exponent applies for nonlinear analyses. It is applied to the velocity across the damper in the equation of motion.
cexp(0) = U1
cexp(1) = U2
cexp(2) = U3
cexp(3) = R1
cexp(4) = R2
cexp(5) = R3

The term cexp(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, c, cexp, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetDamper(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDamper" failed')
        
        return ret

    def GetDamperBilinear(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, c = None, cy = None, ForceLimit = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """


Name: The name of an existing bilinear damper-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained.)
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity
The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties
The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]
The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]
The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]
The term k(n) only applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
c: This is an array of nonlinear initial damping coefficient terms for the link property. The nonlinear initial damping coefficient applies for nonlinear analyses.
c(0) = U1 [F/L]
c(1) = U2 [F/L]
c(2) = U3 [F/L]
c(3) = R1 [FL]
c(4) = R2 [FL]
c(5) = R3 [FL]
The term c(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
cy: This is an array of nonlinear yielded damping coefficient terms for the link property. The nonlinear yielded damping coefficient applies for nonlinear analyses.
cy(0) = U1 [F/L]
cy(1) = U2 [F/L]
cy(2) = U3 [F/L]
cy(3) = R1 [FL]
cy(4) = R2 [FL]
cy(5) = R3 [FL]
The term cy(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
ForceLimit: This is an array of nonlinear linear force limit terms for the link property. The linear force limit applies for nonlinear analyses.
ForceLimit(0) = U1 [F]
ForceLimit(1) = U2 [F]
ForceLimit(2) = U3 [F]
ForceLimit(3) = R1 [FL]
ForceLimit(4) = R2 [FL]
ForceLimit(5) = R3 [FL]
The term ForceLimit(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, c, cy, ForceLimit, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetDamperBilinear(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDamperBilinear" failed')
        
        return ret

    def GetDamperLinearExponential(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, c = None, cexp = None, ForceLimit = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """


Name: The name of an existing linear exponential damper-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained.)
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity
The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties
The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]
The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]
The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]
The term k(n) only applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
c: This is an array of nonlinear damping coefficient terms for the link property. The nonlinear damping coefficient applies for nonlinear analyses.
c(0) = U1 [F/(L^cexp)]
c(1) = U2 [F/(L^cexp)]
c(2) = U3 [F/(L^cexp)]
c(3) = R1 [FL]
c(4) = R2 [FL]
c(5) = R3 [FL]
The term c(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
cexp: This is an array of the nonlinear damping exponent terms. The nonlinear damping exponent applies for nonlinear analyses. It is applied to the velocity across the damper in the equation of motion.
cexp(0) = U1
cexp(1) = U2
cexp(2) = U3
cexp(3) = R1
cexp(4) = R2
cexp(5) = R3
The term cexp(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
ForceLimit: This is an array of nonlinear linear force limit terms for the link property. The linear force limit applies for nonlinear analyses.
ForceLimit(0) = U1 [F]
ForceLimit(1) = U2 [F]
ForceLimit(2) = U3 [F]
ForceLimit(3) = R1 [FL]
ForceLimit(4) = R2 [FL]
ForceLimit(5) = R3 [FL]
The term ForceLimit(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, c, cexp, ForceLimit, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetDamperLinearExponential(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDamperLinearExponential" failed')
        
        return ret

    def GetDamperFrictionSpring(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, k1 = None, k2 = None, u0 = None, us = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """


Name: The name of an existing friction spring damper-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained.)
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity
The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties
The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]
The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]
The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial (nonslipping) stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]
The term k(n) only applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
k1: This is an array of slipping stiffness when loading terms for the link property. The slipping stiffness when loading applies for nonlinear analyses.
k1(0) = U1 [F/L]
k1(1) = U2 [F/L]
k1(2) = U3 [F/L]
k1(3) = R1 [FL]
k1(4) = R2 [FL]
k1(5) = R3 [FL]
The term k1(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
k2: This is an array of slipping stiffness when unloading terms for the link property. The slipping stiffness when unloading applies for nonlinear analyses.
k2(0) = U1 [F/L]
k2(1) = U2 [F/L]
k2(2) = U3 [F/L]
k2(3) = R1 [FL]
k2(4) = R2 [FL]
k2(5) = R3 [FL]
The term k2(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
u0: This is an array of precompression displacement terms for the link property. The nonlinear precompression displacement applies for nonlinear analyses.
u0(0) = U1 [L]
u0(1) = U2 [L]
u0(2) = U3 [L]
u0(3) = R1
u0(4) = R2
u0(5) = R3
The term u0(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
us: This is an array of stop displacement terms for the link property. The nonlinear stop displacement applies for nonlinear analyses.
us(0) = U1 [L]
us(1) = U2 [L]
us(2) = U3 [L]
us(3) = R1
us(4) = R2
us(5) = R3
The term us(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, k1, k2, u0, us, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetDamperFrictionSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDamperFrictionSpring" failed')
        
        return ret

    def GetFrictionIsolator(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, Slow = None, Fast = None, Rate = None, Radius = None, Damping = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function retrieves link property data for a friction isolator-type link property.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing friction isolator-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1, Not Used
NonLinear(4) = R2, Not Used
NonLinear(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U1, U2 and U3. For those degrees of freedom, the term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1, Not Used
k(4) = R2, Not Used
k(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U1, U2 and U3. For those degrees of freedom, the term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Slow: This is an array of the friction coefficient at zero velocity terms for the link property. This coefficient applies for nonlinear analyses.
Slow(0) = U1, Not Used
Slow(1) = U2
Slow(2) = U3
Slow(3) = R1, Not Used
Slow(4) = R2, Not Used
Slow(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Slow(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Fast: This is an array of the friction coefficient at fast velocity terms for the link property. This coefficient applies for nonlinear analyses.
Fast(0) = U1, Not Used
Fast(1) = U2
Fast(2) = U3
Fast(3) = R1, Not Used
Fast(4) = R2, Not Used
Fast(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Fast(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Rate: This is an array of the inverse of the characteristic sliding velocity terms for the link property. This item applies for nonlinear analyses.
Rate(0) = U1, Not Used
Rate(1) = U2 [s/L]
Rate(2) = U3 [s/L]
Rate(3) = R1, Not Used
Rate(4) = R2, Not Used
Rate(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Rate(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Radius: This is an array of the radius of the sliding contact surface terms for the link property. Inputting 0 means there is an infinite radius, that is, the slider is flat. This item applies for nonlinear analyses.
Radius(0) = U1, Not Used
Radius(1) = U2 [L]
Radius(2) = U3 [L]
Radius(3) = R1, Not Used
Radius(4) = R2, Not Used
Radius(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Radius(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Damping: This is the nonlinear damping coefficient used for the axial translational degree of freedom, U1. This item applies for nonlinear analyses. [F/L]
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, Slow, Fast, Rate, Radius, Damping, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetFrictionIsolator(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetFrictionIsolator" failed')
        
        return ret

    def GetGap(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, dis = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function retrieves link property data for a gap-type link property.
The function returns zero if the property data is retrieved successfully; otherwise it returns a nonzero value.

Name: The name of an existing gap-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties

The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]

The term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dis: This is an array of initial gap opening terms for the link property. The initial gap opening applies for nonlinear analyses.
dis(0) = U1 [L]
dis(1) = U2 [L]
dis(2) = U3 [L]
dis(3) = R1 [rad]
dis(4) = R2 [rad]
dis(5) = R3 [rad]

The term dis(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, dis, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetGap(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGap" failed')
        
        return ret

    def GetHook(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, dis = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function retrieves link property data for a hook-type link property.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing hook-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties

The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]

The term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dis: This is an array of initial hook opening terms for the link property. The initial hook opening applies for nonlinear analyses.
c(0) = U1 [L]
c(1) = U2 [L]
c(2) = U3 [L]
c(3) = R1 [rad]
c(4) = R2 [rad]
c(5) = R3 [rad]

The term dis(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, dis, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetHook(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetHook" failed')
        
        return ret

    def GetLinear(self, Name = None, DOF = None, Fixed = None, Ke = None, Ce = None, dj2 = None, dj3 = None, KeCoupled = None, CeCoupled = None, Notes = None, GUID = None):
        """
This function retrieves link property data for a linear-type link property.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing linear-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity if DOF(0) = True
Fixed(1) = U2 fixity if DOF(1) = True
Fixed(2) = U3 fixity if DOF(2) = True
Fixed(3) = R1 fixity if DOF(3) = True
Fixed(4) = R2 fixity if DOF(4) = True
Fixed(5) = R3 fixity if DOF(5) = True
Ke: This is an array of stiffness terms for the link property. There are 6 terms in the array if the stiffness is uncoupled and 21 if it is coupled. The KeCoupled item indicates if the stiffness is coupled.
If the stiffness is uncoupled:
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

If the stiffness is coupled:
Ke(0) = U1U1 [F/L]
Ke(1) = U1U2 [F/L]
Ke(2) = U2U2 [F/L]
Ke(3) = U1U3 [F/L]
Ke(4) = U2U3 [F/L]
Ke(5) = U3U3 [F/L]
Ke(6) = U1R1 [F]
Ke(7) = U2R1 [F]
Ke(8) = U3R1 [F]
Ke(9) = R1R1 [FL]
Ke(10) = U1R2 [F]
Ke(11) = U2R2 [F]
Ke(12) = U3R2 [F]
Ke(13) = R1R2 [FL]
Ke(14) = R2R2 [FL]
Ke(15) = U1R3 [F]
Ke(16) = U2R3 [F]
Ke(17) = U3R3 [F]
Ke(18) = R1R3 [FL]
Ke(19) = R2R3 [FL]
Ke(20) = R3R3 [FL]
Ce: This is an array of damping terms for the link property. There are 6 terms in the array if the damping is uncoupled and 21 if it is coupled. The CeCoupled item indicates if the damping is coupled.
If the damping is uncoupled:
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

If the damping is coupled:
Ce(0) = U1U1 [F/L]
Ce(1) = U1U2 [F/L]
Ce(2) = U2U2 [F/L]
Ce(3) = U1U3 [F/L]
Ce(4) = U2U3 [F/L]
Ce(5) = U3U3 [F/L]
Ce(6) = U1R1 [F]
Ce(7) = U2R1 [F]
Ce(8) = U3R1 [F]
Ce(9) = R1R1 [FL]
Ce(10) = U1R2 [F]
Ce(11) = U2R2 [F]
Ce(12) = U3R2 [F]
Ce(13) = R1R2 [FL]
Ce(14) = R2R2 [FL]
Ce(15) = U1R3 [F]
Ce(16) = U2R3 [F]
Ce(17) = U3R3 [F]
Ce(18) = R1R3 [FL]
Ce(19) = R2R3 [FL]
Ce(20) = R3R3 [FL]
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
KeCoupled: This item is True if the link stiffness, Ke, is coupled. There are 21 terms in the Ke array if Ke is coupled; otherwise there are 6 terms.
CeCoupled: This item is True if the link damping, Ce, is coupled. There are 21 terms in the Ce array if Ce is coupled; otherwise there are 6 terms.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, DOF, Fixed, Ke, Ce, dj2, dj3, KeCoupled, CeCoupled, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetLinear(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLinear" failed')
        
        return ret

    def GetMultiLinearElastic(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function retrieves link property data for a multilinear elastic-type link property.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing multilinear elastic-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties

The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies pnly when DOF(n) = True and Fixed(n) = False.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetMultiLinearElastic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMultiLinearElastic" failed')
        
        return ret

    def GetMultiLinearPlastic(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function retrieves link property data for a multilinear plastic-type link property.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing multilinear plastic-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties

The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetMultiLinearPlastic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMultiLinearPlastic" failed')
        
        return ret

    def GetMultiLinearPoints(self, Name = None, DOF = None, NumberPoints = None, F = None, D = None, MyType = None, a1 = None, a2 = None, b1 = None, b2 = None, eta = None):
        """
This function retrieves the force-deformation data for a specified degree of freedom in multilinear elastic and multilinear plastic link properties.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.
To successfully retrieve this data from the indicated link property, the following conditions must be met:
1.    The link property must be multilinear elastic or multilinear plastic.
2.    The specified DOF must be active.
3.    The specified DOF must not be fixed.
4.    The specified DOF must be nonlinear.

Name: The name of an existing multilinear elastic or multilinear plastic link property.
DOF: This is 1, 2, 3, 4, 5 or 6, indicating the degree of freedom to which the multilinear points apply.
1 = U1
2 = U2
3 = U3
4 = R1
5 = R2
6 = R3
NumberPoints: The number of foce-defomation points for the specified degree of freedom.
F: This is an array, dimensioned to NumberPoints - 1, that includes the force at each point. When DOF is U1, U2 or U3, this is a force. When DOF is R1, R2 or R3, this is a moment. [F] if DOF <= 3, and [FL} if DOF > 3
D: This is an array, dimensioned to NumberPoints - 1, that includes the displacement at each point. When DOF is U1, U2 or U3, this is a translation. When DOF is R1, R2 or R3, this is a rotation. [L] if DOF <= 3, and [rad] if DOF > 3
MyType: This item applies only to multilinear plastic link properties. It is 1, 2 or 3, indicating the hysteresis type.
1 = Kinematic
2 = Takeda
3 = Pivot
a1: This item only applies to multilinear plastic link properties that have a pivot hysteresis type (MyType = 3). It is the Alpha1 hysteresis parameter.
a2: This item applies only to multilinear plastic link properties that have a pivot hysteresis type (MyType = 3). It is the Alpha2 hysteresis parameter.
b1: This item applies only to multilinear plastic link properties that have a pivot hysteresis type (MyType = 3). It is the Beta1 hysteresis parameter.
b2: This item applies only to multilinear plastic link properties that have a pivot hysteresis type (MyType = 3). It is the Beta2 hysteresis parameter.
eta: This item applies only to multilinear plastic link properties that have a pivot hysteresis type (MyType = 3). It is the Eta hysteresis parameter.
        """

        all_args = [Name, DOF, NumberPoints, F, D, MyType, a1, a2, b1, b2, eta]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetMultiLinearPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMultiLinearPoints" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None, PropType = None):
        """
This function retrieves the names of all defined link properties of the specified type.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of link property names retrieved by the program.
MyName: This is a one-dimensional array of link property names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String
The array is dimensioned to (NumberNames - 1) inside the SAP2000 program, filled with the names, and returned to the API user.
PropType: This optional value is one of the following items in the eLinkPropType enumeration.
NLPROP_LINEAR = 1
NLPROP_DAMPER = 2
NLPROP_GAP = 3
NLPROP_HOOK = 4
NLPROP_PLASTIC_WEN = 5
NLPROP_ISOLATOR1 = 6(Rubber isolator)
NLPROP_ISOLATOR2 = 7(Friction isolator)
NLPROP_MULTILINEAR_ELASTIC = 8
NLPROP_MULTILINEAR_PLASTIC = 9
NLPROP_ISOLATOR3 = 10(T/C Friction isolator)

If no value is input for PropType, names are returned for all link properties in the model regardless of type.
        """

        all_args = [NumberNames, MyName, PropType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetPDelta(self, Name = None, Value = None):
        """
This function retrieves P-delta parameters for a link 
 property.
The function returns zero if the data is successfully 
 retrieved; otherwise it returns a nonzero value.

Name: The name of an existing link property.
Value: This is an array of P-delta parameters.
Value(0) = M2 P-delta 
 to I-end of link as moment, M2I
Value(1) = M2 P-delta 
 to J-end of link as moment, M2J
Value(2) = M3 P-delta 
 to I-end of link as moment, M3I
Value(3) = M3 P-delta 
 to J-end of link as moment, M3J
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetPDelta(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPDelta" failed')
        
        return ret

    def GetPlasticWen(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, Yield = None, Ratio = None, exp = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function retrieves link property data for a plastic Wen-type link property.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing plastic Wen-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties

The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]

The term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Yield: This is an array of yield force terms for the link property. The yield force applies for nonlinear analyses.
Yield(0) = U1 [F]
Yield(1) = U2 [F]
Yield(2) = U3 [F]
Yield(3) = R1 [FL]
Yield(4) = R2 [FL]
Yield(5) = R3 [FL]

The term Yield(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Ratio: This is an array of post-yield stiffness ratio terms for the link property. The post-yield stiffness ratio applies for nonlinear analyses. It is the post-yield stiffness divided by the initial stiffness.
Ratio(0) = U1
Ratio(1) = U2
Ratio(2) = U3
Ratio(3) = R1
Ratio(4) = R2
Ratio(5) = R3

The term Ratio(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
exp: This is an array of yield exponent terms for the link property. The yield exponent applies for nonlinear analyses. The yielding exponent that controls the sharpness of the transition from the initial stiffness to the yielded stiffness.
exp(0) = U1
exp(1) = U2
exp(2) = U3
exp(3) = R1
exp(4) = R2
exp(5) = R3

The term exp(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, Yield, Ratio, exp, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetPlasticWen(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPlasticWen" failed')
        
        return ret

    def GetRubberIsolator(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, Yield = None, Ratio = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function retrieves link property data for a rubber isolator-type link property.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing rubber isolator-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1, Not Used
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1, Not Used
NonLinear(4) = R2, Not Used
NonLinear(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1, Not Used
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1, Not Used
k(4) = R2, Not Used
k(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Yield: This is an array of yield force terms for the link property. The yield force applies for nonlinear analyses.
Yield(0) = U1, Not Used
Yield(1) = U2 [F]
Yield(2) = U3 [F]
Yield(3) = R1, Not Used
Yield(4) = R2, Not Used
Yield(5) = R3, Not Used

The term Yield(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Ratio: This is an array of post-yield stiffness ratio terms for the link property. The post-yield stiffness ratio applies for nonlinear analyses. It is the post-yield stiffness divided by the initial stiffness.
Ratio(0) = U1, Not Used
Ratio(1) = U2
Ratio(2) = U3
Ratio(3) = R1, Not Used
Ratio(4) = R2, Not Used
Ratio(5) = R3, Not Used

The term Ratio(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies pnly when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, Yield, Ratio, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetRubberIsolator(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetRubberIsolator" failed')
        
        return ret

    def GetSpringData(self, Name = None, DefinedForThisLength = None, DefinedForThisArea = None):
        """
This function retrieves length and area values for a link property that are used if the link property is specified in line and area spring assignments.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing link property.
DefinedForThisLength: The link property is defined for this length in a line (frame) spring. [L]
DefinedForThisArea: The link property is defined for this area in an area spring. [L2]
        """

        all_args = [Name, DefinedForThisLength, DefinedForThisArea]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetSpringData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSpringData" failed')
        
        return ret

    def GetTCFrictionIsolator(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, Slow = None, Fast = None, Rate = None, Radius = None, SlowT = None, FastT = None, RateT = None, kt = None, dis = None, dist = None, Damping = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function retrieves link property data for a T/C friction isolator-type link property.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing T/C friction isolator-type link property.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies pnly when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1, Not Used
NonLinear(4) = R2, Not Used
NonLinear(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U1, U2 and U3. For those degrees of freedom, the term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1, Not Used
k(4) = R2, Not Used
k(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U1, U2 and U3. For those degrees of freedom, the term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Slow: This is an array of the friction coefficient at zero velocity terms when U1 is in compression for the link property. This coefficient applies for nonlinear analyses.
Slow(0) = U1, Not Used
Slow(1) = U2
Slow(2) = U3
Slow(3) = R1, Not Used
Slow(4) = R2, Not Used
Slow(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Slow(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Fast: This is an array of the friction coefficient at fast velocity terms when U1 is in compression for the link property. This coefficient applies for nonlinear analyses.
Fast(0) = U1, Not Used
Fast(1) = U2
Fast(2) = U3
Fast(3) = R1, Not Used
Fast(4) = R2, Not Used
Fast(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Fast(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Rate: This is an array of the inverse of the characteristic sliding velocity terms when U1 is in compression for the link property. This item applies for nonlinear analyses.
Rate(0) = U1, Not Used
Rate(1) = U2 [s/L]
Rate(2) = U3 [s/L]
Rate(3) = R1, Not Used
Rate(4) = R2, Not Used
Rate(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Rate(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Radius: This is an array of the radius of the sliding contact surface terms for the link property. Inputting 0 means there is an infinite radius, that is, the slider is flat. This item applies for nonlinear analyses.
Radius(0) = U1, Not Used
Radius(1) = U2 [L]
Radius(2) = U3 [L]
Radius(3) = R1, Not Used
Radius(4) = R2, Not Used
Radius(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Radius(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
SlowT: This is an array of the friction coefficient at zero velocity terms when U1 is in tension for the link property. This coefficient applies for nonlinear analyses.
SlowT(0) = U1, Not Used
SlowT(1) = U2
SlowT(2) = U3
SlowT(3) = R1, Not Used
SlowT(4) = R2, Not Used
SlowT(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term SlowT(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
FastT: This is an array of the friction coefficient at fast velocity terms when U1 is in tension for the link property. This coefficient applies for nonlinear analyses.
FastT(0) = U1, Not Used
FastT(1) = U2
FastT(2) = U3
FastT(3) = R1, Not Used
FastT(4) = R2, Not Used
FastT(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term FastT(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
RateT: This is an array of the inverse of the characteristic sliding velocity terms when U1 is in tension for the link property. This item applies for nonlinear analyses.
RateT(0) = U1, Not Used
RateT(1) = U2 [s/L]
RateT(2) = U3 [s/L]
RateT(3) = R1, Not Used
RateT(4) = R2, Not Used
RateT(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term RateT(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
kt: The axial translational tension stiffness for the U1 degree of freedom. This item applies for nonlinear analyses. [F/L]
dis: The U1 degree of freedom gap opening for compression. This item applies for nonlinear analyses. [L]
dist: The U1 degree of freedom gap opening for tension. This item applies for nonlinear analyses. [L]
Damping: The nonlinear damping coefficient used for the axial translational degree of freedom, U1. This item applies for nonlinear analyses. [F/L]
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, Slow, Fast, Rate, Radius, SlowT, FastT, RateT, kt, dis, dist, Damping, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetTCFrictionIsolator(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTCFrictionIsolator" failed')
        
        return ret

    def GetTriplePendulumIsolator(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, K1 = None, Damping = None, K = None, Slow = None, Fast = None, Rate = None, Radius = None, StopDist = None, HeightOut = None, HeightIn = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function retrieves link property data for a Triple Pendulum Isolator type link property.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing Triple Pendulum Isolator type link property.
DOF: This is a Boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3

Fixed: This is a Boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) only applies when DOF(n) = True.
NonLinear: This is a Boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1, Not Used
NonLinear(4) = R2, Not Used
NonLinear(5) = R3, Not Used

Note that this item is applicable for degrees of freedom U1, U2 and U3 only. For those degrees of freedom, the term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses, and also for nonlinear analysis for those DOF for which NonLinear(n) = False.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
K1: This is the axial compression stiffness for the U1 degree of freedom. This item applies for nonlinear analyses. [F/L]
Damping: This is the nonlinear damping coefficient for the axial degree of freedom, U1, when it is in compression. This item applies for nonlinear analyses. [F/L]
K: This is an array, dimensioned to 3, of initial nonlinear stiffness (before sliding) for each sliding surface.
K(0) = for the outer top sliding surface [F/L]
K(1) = for the outer bottom sliding surface [F/L]
K(2) = for the inner top sliding surface [F/L]
K(3) = for the inner bottom sliding surface [F/L]

Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Slow: This is an array, dimensioned to 3, of the friction coefficient at zero velocity for each sliding surface when U1 is in compression.
Slow(0) = for the outer top sliding surface
Slow(1) = for the outer bottom sliding surface
Slow(2) = for the inner top sliding surface
Slow(3) = for the inner bottom sliding surface

Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term Slow(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Fast: This is an array, dimensioned to 3, of the friction coefficient at fast velocity for each sliding surface when U1 is in compression.
Fast(0) = for the outer top sliding surface
Fast(1) = for the outer bottom sliding surface
Fast(2) = for the inner top sliding surface
Fast(3) = for the inner bottom sliding surface

Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term Fast(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Rate: This is an array, dimensioned to 3, of the inverse of the characteristic sliding velocity for the Slow and Fast friction coefficients for each sliding surface. This item applies for nonlinear analyses.
Rate(0) = for the outer top sliding surface [s/L]
Rate(1) = for the outer bottom sliding surface [s/L]
Rate(2) = for the inner top sliding surface [s/L]
Rate(3) = for the inner bottom sliding surface [s/L]

Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term Rate(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Radius: This is an array, dimensioned to 3, of the radius for each sliding surface. Inputting 0 means there is an infinite radius, that is, the slider is flat. This item applies for nonlinear analyses.
Radius(0) = for the outer top sliding surface [L]
Radius(1) = for the outer bottom sliding surface [L]
Radius(2) = for the inner top sliding surface [L]
Radius(3) = for the inner bottom sliding surface [L]

Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term Radius(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
StopDist: This is an array, dimensioned to 3, of the amount of displacement allowed before hitting a stiff limit for each sliding surface. Inputting 0 means there is no stop. This item applies for nonlinear analyses.
StopDist(0) = for the outer top sliding surface [L]
StopDist(1) = for the outer bottom sliding surface [L]
StopDist(2) = for the inner top sliding surface [L]
StopDist(3) = for the inner bottom sliding surface [L]

Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term StopDist(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
HeightOut: This is the height (distance) between the outer sliding surfaces at zero displacement. [L]
Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
HeightIn: This is the height (distance) between the inner sliding surfaces. [L]
Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring, that is, the center of the isolator. This item applies only when DOF(2) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring, that is, the center of the isolator. This item applies only when DOF(3) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, K1, Damping, K, Slow, Fast, Rate, Radius, StopDist, HeightOut, HeightIn, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetTriplePendulumIsolator(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTriplePendulumIsolator" failed')
        
        return ret

    def GetTypeOAPI(self, Name = None, PropType = None):
        """
This function retrieves the property type for the specified link property.
The function returns zero if the type is successfully retrieved; otherwise it returns nonzero.

Name: The name of an existing link property.
PropType: This is one of the following items in the eLinkPropType enumeration.
NLPROP_LINEAR = 1
NLPROP_DAMPER = 2
NLPROP_GAP = 3
NLPROP_HOOK = 4
NLPROP_PLASTIC_WEN = 5
NLPROP_ISOLATOR1 = 6(Rubber isolator)
NLPROP_ISOLATOR2 = 7(Friction isolator)
NLPROP_MULTILINEAR_ELASTIC = 8
NLPROP_MULTILINEAR_PLASTIC = 9
NLPROP_ISOLATOR3 = 10(T/C Friction isolator)
        """

        all_args = [Name, PropType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetTypeOAPI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTypeOAPI" failed')
        
        return ret

    def GetWeightAndMass(self, Name = None, w = None, m = None, R1 = None, R2 = None, R3 = None):
        """
This function retrieves weight and mass data for a link property.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing link property.
w: The weight of the link. [F]
m: The translational mass of the link. [M]
R1: The rotational inertia of the link about its local 1 axis. [ML2]
R2: The rotational inertia of the link about its local 2 axis. [ML2]
R3: The rotational inertia of the link about its local 3 axis. [ML2]
        """

        all_args = [Name, w, m, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.GetWeightAndMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetWeightAndMass" failed')
        
        return ret

    def SetDamper(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, c = None, cexp = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function initializes an exponential damper-type link property. If this function is called for an existing link property, all items for the property are reset to their default values.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new link property. If this is an existing property, that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties

The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]

The term k(n) only applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
c: This is an array of nonlinear damping coefficient terms for the link property. The nonlinear damping coefficient applies for nonlinear analyses.
c(0) = U1 [F/(L^cexp)]
c(1) = U2 [F/(L^cexp)]
c(2) = U3 [F/(L^cexp)]
c(3) = R1 [FL]
c(4) = R2 [FL]
c(5) = R3 [FL]

The term c(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
cexp: This is an array of the nonlinear damping exponent terms. The nonlinear damping exponent applies for nonlinear analyses. It is applied to the velocity across the damper in the equation of motion.
cexp(0) = U1
cexp(1) = U2
cexp(2) = U3
cexp(3) = R1
cexp(4) = R2
cexp(5) = R3

The term cexp(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, c, cexp, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetDamper(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDamper" failed')
        
        return ret

    def SetDamperBilinear(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, c = None, cy = None, ForceLimit = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """


Name: The name of an existing or new link property. If this is an existing property, that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained.)
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity
The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties
The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]
The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]
The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]
The term k(n) only applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
c: This is an array of nonlinear initial damping coefficient terms for the link property. The nonlinear initial damping coefficient applies for nonlinear analyses.
c(0) = U1 [F/L]
c(1) = U2 [F/L]
c(2) = U3 [F/L]
c(3) = R1 [FL]
c(4) = R2 [FL]
c(5) = R3 [FL]
The term c(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
cy: This is an array of nonlinear yielded damping coefficient terms for the link property. The nonlinear yielded damping coefficient applies for nonlinear analyses.
cy(0) = U1 [F/L]
cy(1) = U2 [F/L]
cy(2) = U3 [F/L]
cy(3) = R1 [FL]
cy(4) = R2 [FL]
cy(5) = R3 [FL]
The term cy(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
ForceLimit: This is an array of nonlinear linear force limit terms for the link property. The linear force limit applies for nonlinear analyses.
ForceLimit(0) = U1 [F]
ForceLimit(1) = U2 [F]
ForceLimit(2) = U3 [F]
ForceLimit(3) = R1 [FL]
ForceLimit(4) = R2 [FL]
ForceLimit(5) = R3 [FL]
The term ForceLimit(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, c, cy, ForceLimit, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetDamperBilinear(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDamperBilinear" failed')
        
        return ret

    def SetDamperFrictionSpring(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, k1 = None, k2 = None, u0 = None, us = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """


Name: The name of an existing or new link property. If this is an existing property, that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained.)
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity
The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties
The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]
The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]
The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial (nonslipping) stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]
The term k(n) only applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
k1: This is an array of slipping stiffness when loading terms for the link property. The slipping stiffness when loading applies for nonlinear analyses.
k1(0) = U1 [F/L]
k1(1) = U2 [F/L]
k1(2) = U3 [F/L]
k1(3) = R1 [FL]
k1(4) = R2 [FL]
k1(5) = R3 [FL]
The term k1(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
k2: This is an array of slipping stiffness when unloading terms for the link property. The slipping stiffness when unloading applies for nonlinear analyses.
k2(0) = U1 [F/L]
k2(1) = U2 [F/L]
k2(2) = U3 [F/L]
k2(3) = R1 [FL]
k2(4) = R2 [FL]
k2(5) = R3 [FL]
The term k2(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
u0: This is an array of precompression displacement terms for the link property. The nonlinear precompression displacement applies for nonlinear analyses.
u0(0) = U1 [L]
u0(1) = U2 [L]
u0(2) = U3 [L]
u0(3) = R1
u0(4) = R2
u0(5) = R3
The term u0(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
us: This is an array of stop displacement terms for the link property. The nonlinear stop displacement applies for nonlinear analyses.
us(0) = U1 [L]
us(1) = U2 [L]
us(2) = U3 [L]
us(3) = R1
us(4) = R2
us(5) = R3
The term us(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, k1, k2, u0, us, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetDamperFrictionSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDamperFrictionSpring" failed')
        
        return ret

    def SetDamperLinearExponential(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, c = None, cexp = None, ForceLimit = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """


Name: The name of an existing or new link property. If this is an existing property, that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained.)
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity
The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties
The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]
The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]
The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]
The term k(n) only applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
c: This is an array of nonlinear damping coefficient terms for the link property. The nonlinear damping coefficient applies for nonlinear analyses.
c(0) = U1 [F/(L^cexp)]
c(1) = U2 [F/(L^cexp)]
c(2) = U3 [F/(L^cexp)]
c(3) = R1 [FL]
c(4) = R2 [FL]
c(5) = R3 [FL]
The term c(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
cexp: This is an array of the nonlinear damping exponent terms. The nonlinear damping exponent applies for nonlinear analyses. It is applied to the velocity across the damper in the equation of motion.
cexp(0) = U1
cexp(1) = U2
cexp(2) = U3
cexp(3) = R1
cexp(4) = R2
cexp(5) = R3
The term cexp(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
ForceLimit: This is an array of nonlinear linear force limit terms for the link property. The linear force limit applies for nonlinear analyses.
ForceLimit(0) = U1 [F]
ForceLimit(1) = U2 [F]
ForceLimit(2) = U3 [F]
ForceLimit(3) = R1 [FL]
ForceLimit(4) = R2 [FL]
ForceLimit(5) = R3 [FL]
The term ForceLimit(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, c, cexp, ForceLimit, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetDamperLinearExponential(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDamperLinearExponential" failed')
        
        return ret

    def SetFrictionIsolator(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, Slow = None, Fast = None, Rate = None, Radius = None, Damping = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function initializes a friction isolator-type link property. If this function is called for an existing link property, all items for the property are reset to their default value.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new link property. If this is an existing property, that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1, Not Used
NonLinear(4) = R2, Not Used
NonLinear(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U1, U2 and U3. For those degrees of freedom, the term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1, Not Used
k(4) = R2, Not Used
k(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U1, U2 and U3. For those degrees of freedom, the term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Slow: This is an array of the friction coefficient at zero velocity terms for the link property. This coefficient applies for nonlinear analyses.
Slow(0) = U1, Not Used
Slow(1) = U2
Slow(2) = U3
Slow(3) = R1, Not Used
Slow(4) = R2, Not Used
Slow(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Slow(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Fast: This is an array of the friction coefficient at fast velocity terms for the link property. This coefficient applies for nonlinear analyses.
Fast(0) = U1, Not Used
Fast(1) = U2
Fast(2) = U3
Fast(3) = R1, Not Used
Fast(4) = R2, Not Used
Fast(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Fast(n) applies pnly when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Rate: This is an array of the inverse of the characteristic sliding velocity terms for the link property. This item applies for nonlinear analyses.
Rate(0) = U1, Not Used
Rate(1) = U2 [s/L]
Rate(2) = U3 [s/L]
Rate(3) = R1, Not Used
Rate(4) = R2, Not Used
Rate(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Rate(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Radius: This is an array of the radius of the sliding contact surface terms for the link property. Inputting 0 means there is an infinite radius, that is, the slider is flat. This item applies for nonlinear analyses.
Radius(0) = U1, Not Used
Radius(1) = U2 [L]
Radius(2) = U3 [L]
Radius(3) = R1, Not Used
Radius(4) = R2, Not Used
Radius(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Radius(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Damping: This is the nonlinear damping coefficient used for the axial translational degree of freedom, U1. This item applies for nonlinear analyses. [F/L]
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, Slow, Fast, Rate, Radius, Damping, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetFrictionIsolator(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFrictionIsolator" failed')
        
        return ret

    def SetGap(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, dis = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function initializes a gap-type link property. If this function is called for an existing link property, all items for the property are reset to their default value.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new link property. If this is an existing property then that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties

The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]

The term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dis: This is an array of initial gap opening terms for the link property. The initial gap opening applies for nonlinear analyses.
dis(0) = U1 [L]
dis(1) = U2 [L]
dis(2) = U3 [L]
dis(3) = R1 [rad]
dis(4) = R2 [rad]
dis(5) = R3 [rad]

The term dis(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, dis, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetGap(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGap" failed')
        
        return ret

    def SetHook(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, dis = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function initializes a hook-type link property. If this function is called for an existing link property, all items for the property are reset to their default value.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new link property. If this is an existing property then that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties

The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]

The term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dis: This is an array of initial hook opening terms for the link property. The initial hook opening applies for nonlinear analyses.
c(0) = U1 [L]
c(1) = U2 [L]
c(2) = U3 [L]
c(3) = R1 [rad]
c(4) = R2 [rad]
c(5) = R3 [rad]

The term dis(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, dis, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetHook(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetHook" failed')
        
        return ret

    def SetLinear(self, Name = None, DOF = None, Fixed = None, Ke = None, Ce = None, dj2 = None, dj3 = None, KeCoupled = None, CeCoupled = None, Notes = None, GUID = None):
        """
This function initializes a linear-type link property. If this function is called for an existing link property, all items for the property are reset to their default value.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new link property. If this is an existing property, that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity if DOF(0) = True
Fixed(1) = U2 fixity if DOF(1) = True
Fixed(2) = U3 fixity if DOF(2) = True
Fixed(3) = R1 fixity if DOF(3) = True
Fixed(4) = R2 fixity if DOF(4) = True
Fixed(5) = R3 fixity if DOF(5) = True
Ke: This is an array of stiffness terms for the link property. There are 6 terms in the array if the stiffness is uncoupled and 21 if it is coupled. The KeCoupled item indicates if the stiffness is coupled.
If the stiffness is uncoupled:
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

If the stiffness is coupled:
Ke(0) = U1U1 [F/L]
Ke(1) = U1U2 [F/L]
Ke(2) = U2U2 [F/L]
Ke(3) = U1U3 [F/L]
Ke(4) = U2U3 [F/L]
Ke(5) = U3U3 [F/L]
Ke(6) = U1R1 [F]
Ke(7) = U2R1 [F]
Ke(8) = U3R1 [F]
Ke(9) = R1R1 [FL]
Ke(10) = U1R2 [F]
Ke(11) = U2R2 [F]
Ke(12) = U3R2 [F]
Ke(13) = R1R2 [FL]
Ke(14) = R2R2 [FL]
Ke(15) = U1R3 [F]
Ke(16) = U2R3 [F]
Ke(17) = U3R3 [F]
Ke(18) = R1R3 [FL]
Ke(19) = R2R3 [FL]
Ke(20) = R3R3 [FL]
Ce: This is an array of damping terms for the link property. There are 6 terms in the array if the damping is uncoupled and 21 if it is coupled. The CeCoupled item indicates if the damping is coupled.
If the damping is uncoupled:
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

If the damping is coupled:
Ce(0) = U1U1 [F/L]
Ce(1) = U1U2 [F/L]
Ce(2) = U2U2 [F/L]
Ce(3) = U1U3 [F/L]
Ce(4) = U2U3 [F/L]
Ce(5) = U3U3 [F/L]
Ce(6) = U1R1 [F]
Ce(7) = U2R1 [F]
Ce(8) = U3R1 [F]
Ce(9) = R1R1 [FL]
Ce(10) = U1R2 [F]
Ce(11) = U2R2 [F]
Ce(12) = U3R2 [F]
Ce(13) = R1R2 [FL]
Ce(14) = R2R2 [FL]
Ce(15) = U1R3 [F]
Ce(16) = U2R3 [F]
Ce(17) = U3R3 [F]
Ce(18) = R1R3 [FL]
Ce(19) = R2R3 [FL]
Ce(20) = R3R3 [FL]
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
KeCoupled: This item is True if the link stiffness, Ke, is coupled. There are 21 terms in the Ke array if Ke is coupled; otherwise there are 6 terms.
CeCoupled: This item is True if the link damping, Ce, is coupled. There are 21 terms in the Ce array if Ce is coupled; otherwise there are 6 terms.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, Ke, Ce, dj2, dj3, KeCoupled, CeCoupled, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetLinear(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLinear" failed')
        
        return ret

    def SetMultiLinearElastic(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function initializes a multilinear elastic-type link property. If this function is called for an existing link property, all items for the property are reset to their default value.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new link property. If this is an existing property then. that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties

The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetMultiLinearElastic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMultiLinearElastic" failed')
        
        return ret

    def SetMultiLinearPlastic(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function initializes a multilinear plastic-type link property. If this function is called for an existing link property, all items for the property are reset to their default values.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new link property. If this is an existing property, that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties

The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetMultiLinearPlastic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMultiLinearPlastic" failed')
        
        return ret

    def SetMultiLinearPoints(self, Name = None, DOF = None, NumberPoints = None, F = None, D = None, MyType = None, a1 = None, a2 = None, b1 = None, b2 = None, eta = None):
        """
This function sets the force-deformation data for a specified degree of freedom in multilinear elastic and multilinear plastic link properties.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.
To successfully apply this data to the indicated link property, the following conditions must be met:
1.    The link property must be multilinear elastic or multilinear plastic.
2.    The specified DOF must be active.
3.    The specified DOF must not be fixed.
4.    The specified DOF must be nonlinear.

Name: The name of an existing multilinear elastic or multilinear plastic link property.
DOF: This is 1, 2, 3, 4, 5 or 6, indicating the degree of freedom to which the multilinear points apply.
1 = U1
2 = U2
3 = U3
4 = R1
5 = R2
6 = R3
NumberPoints: The number of foce-defomation points for the specified degree of freedom.
F: This is an array, dimensioned to NumberPoints - 1, that includes the force at each point. When DOF is U1, U2 or U3, this is a force. When DOF is R1, R2 or R3. this is a moment. [F] if DOF <= 3, and [FL} if DOF > 3
D: This is an array, dimensioned to NumberPoints - 1, that includes the displacement at each point. When DOF is U1, U2 or U3, this is a translation. When DOF is R1, R2 or R3, this is a rotation. [L] if DOF <= 3, and [rad] if DOF > 3
MyType: This item applies only to multilinear plastic link properties. It is 1, 2 or 3, indicating the hysteresis type.
1 = Kinematic
2 = Takeda
3 = Pivot
a1: This item applies only to multilinear plastic link properties that have a pivot hysteresis type (MyType = 3). It is the Alpha1 hysteresis parameter.
a2: This item applies only to multilinear plastic link properties that have a pivot hysteresis type (MyType = 3). It is the Alpha2 hysteresis parameter.
b1: This item applies only to multilinear plastic link properties that have a pivot hysteresis type (MyType = 3). It is the Beta1 hysteresis parameter.
b2: This item applies only to multilinear plastic link properties that have a pivot hysteresis type (MyType = 3). It is the Beta2 hysteresis parameter.
eta: This item applies only to multilinear plastic link properties that have a pivot hysteresis type (MyType = 3). It is the Eta hysteresis parameter.
        """

        all_args = [Name, DOF, NumberPoints, F, D, MyType, a1, a2, b1, b2, eta]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetMultiLinearPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMultiLinearPoints" failed')
        
        return ret

    def SetPDelta(self, Name = None, Value = None):
        """
This function assigns P-delta parameters to a link property.
The function returns zero if the values are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing link property.
Value: This is an array of P-delta parameters.
Value(0) = M2 P-delta to I-end of link as moment, M2I
Value(1) = M2 P-delta to J-end of link as moment, M2J
Value(2) = M3 P-delta to I-end of link as moment, M3I
Value(3) = M3 P-delta to J-end of link as moment, M3J
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetPDelta(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPDelta" failed')
        
        return ret

    def SetPlasticWen(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, Yield = None, Ratio = None, exp = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function initializes a plastic Wen-type link property. If this function is called for an existing link property, all items for the property are reset to their default values.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new link property. If this is an existing property, that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1 has nonlinear properties
NonLinear(4) = R2 has nonlinear properties
NonLinear(5) = R3 has nonlinear properties

The term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1 [FL]
k(4) = R2 [FL]
k(5) = R3 [FL]

The term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Yield: This is an array of yield force terms for the link property. The yield force applies for nonlinear analyses.
Yield(0) = U1 [F]
Yield(1) = U2 [F]
Yield(2) = U3 [F]
Yield(3) = R1 [FL]
Yield(4) = R2 [FL]
Yield(5) = R3 [FL]

The term Yield(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Ratio: This is an array of post-yield stiffness ratio terms for the link property. The post-yield stiffness ratio applies for nonlinear analyses. It is the post-yield stiffness divided by the initial stiffness.
Ratio(0) = U1
Ratio(1) = U2
Ratio(2) = U3
Ratio(3) = R1
Ratio(4) = R2
Ratio(5) = R3

The term Ratio(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
exp: This is an array of yield exponent terms for the link property. The yield exponent applies for nonlinear analyses. The yielding exponent that controls the sharpness of the transition from the initial stiffness to the yielded stiffness.
exp(0) = U1
exp(1) = U2
exp(2) = U3
exp(3) = R1
exp(4) = R2
exp(5) = R3

The term exp(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, Yield, Ratio, exp, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetPlasticWen(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPlasticWen" failed')
        
        return ret

    def SetRubberIsolator(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, Yield = None, Ratio = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function initializes a rubber isolator-type link property. If this function is called for an existing link property, all items for the property are reset to their default value.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new link property. If this is an existing property, that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1, Not Used
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1, Not Used
NonLinear(4) = R2, Not Used
NonLinear(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1, Not Used
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1, Not Used
k(4) = R2, Not Used
k(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Yield: This is an array of yield force terms for the link property. The yield force applies for nonlinear analyses.
Yield(0) = U1, Not Used
Yield(1) = U2 [F]
Yield(2) = U3 [F]
Yield(3) = R1, Not Used
Yield(4) = R2, Not Used
Yield(5) = R3, Not Used

The term Yield(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Ratio: This is an array of post-yield stiffness ratio terms for the link property. The post-yield stiffness ratio applies for nonlinear analyses. It is the post-yield stiffness divided by the initial stiffness.
Ratio(0) = U1, Not Used
Ratio(1) = U2
Ratio(2) = U3
Ratio(3) = R1, Not Used
Ratio(4) = R2, Not Used
Ratio(5) = R3, Not Used

The term Ratio(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, Yield, Ratio, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetRubberIsolator(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetRubberIsolator" failed')
        
        return ret

    def SetSpringData(self, Name = None, DefinedForThisLength = None, DefinedForThisArea = None):
        """
This function assigns length and area values to a link property that are used if the link property is specified in line and area spring assignments.
The function returns zero if the values are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing link property.
DefinedForThisLength: The link property is defined for this length in a line (frame) spring. [L]
DefinedForThisArea: The link property is defined for this area in an area spring. [L2]
        """

        all_args = [Name, DefinedForThisLength, DefinedForThisArea]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetSpringData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSpringData" failed')
        
        return ret

    def SetTCFrictionIsolator(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, k = None, Slow = None, Fast = None, Rate = None, Radius = None, SlowT = None, FastT = None, RateT = None, kt = None, dis = None, dist = None, Damping = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function initializes a T/C friction isolator-type link property. If this function is called for an existing link property, all items for the property are reset to their default value.
The function returns zero if the property is successfully initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new link property. If this is an existing property, that property is modified; otherwise, a new property is added.
DOF: This is a boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
Fixed: This is a boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1, Not Used
NonLinear(4) = R2, Not Used
NonLinear(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U1, U2 and U3. For those degrees of freedom, the term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
k: This is an array of initial stiffness terms for the link property. The initial stiffness applies for nonlinear analyses.
k(0) = U1 [F/L]
k(1) = U2 [F/L]
k(2) = U3 [F/L]
k(3) = R1, Not Used
k(4) = R2, Not Used
k(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U1, U2 and U3. For those degrees of freedom, the term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Slow: This is an array of the friction coefficient at zero velocity terms when U1 is in compression for the link property. This coefficient applies for nonlinear analyses.
Slow(0) = U1, Not Used
Slow(1) = U2
Slow(2) = U3
Slow(3) = R1, Not Used
Slow(4) = R2, Not Used
Slow(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Slow(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Fast: This is an array of the friction coefficient at fast velocity terms when U1 is in compression for the link property. This coefficient applies for nonlinear analyses.
Fast(0) = U1, Not Used
Fast(1) = U2
Fast(2) = U3
Fast(3) = R1, Not Used
Fast(4) = R2, Not Used
Fast(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Fast(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Rate: This is an array of the inverse of the characteristic sliding velocity terms when U1 is in compression for the link property. This item applies for nonlinear analyses.
Rate(0) = U1, Not Used
Rate(1) = U2 [s/L]
Rate(2) = U3 [s/L]
Rate(3) = R1, Not Used
Rate(4) = R2, Not Used
Rate(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Rate(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Radius: This is an array of the radius of the sliding contact surface terms for the link property. Inputting 0 means there is an infinite radius, that is, the slider is flat. This item applies for nonlinear analyses.
Radius(0) = U1, Not Used
Radius(1) = U2 [L]
Radius(2) = U3 [L]
Radius(3) = R1, Not Used
Radius(4) = R2, Not Used
Radius(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term Radius(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
SlowT: This is an array of the friction coefficient at zero velocity terms when U1 is in tension for the link property. This coefficient applies for nonlinear analyses.
SlowT(0) = U1, Not Used
SlowT(1) = U2
SlowT(2) = U3
SlowT(3) = R1, Not Used
SlowT(4) = R2, Not Used
SlowT(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term SlowT(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
FastT: This is an array of the friction coefficient at fast velocity terms when U1 is in tension for the link property. This coefficient applies for nonlinear analyses.
FastT(0) = U1, Not Used
FastT(1) = U2
FastT(2) = U3
FastT(3) = R1, Not Used
FastT(4) = R2, Not Used
FastT(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term FastT(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
RateT: This is an array of the inverse of the characteristic sliding velocity terms when U1 is in tension for the link property. This item applies for nonlinear analyses.
RateT(0) = U1, Not Used
RateT(1) = U2 [s/L]
RateT(2) = U3 [s/L]
RateT(3) = R1, Not Used
RateT(4) = R2, Not Used
RateT(5) = R3, Not Used

Note that this item is applicable only for degrees of freedom U2 and U3. For those degrees of freedom, the term RateT(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
kt: The axial translational tension stiffness for the U1 degree of freedom. This item applies for nonlinear analyses. [F/L]
dis: The U1 degree of freedom gap opening for compression. This item applies for nonlinear analyses. [L]
dist: The U1 degree of freedom gap opening for tension. This item applies for nonlinear analyses. [L]
Damping: The nonlinear damping coefficient used for the axial translational degree of freedom, U1. This item applies for nonlinear analyses. [F/L]
dj2: The distance from the J-End of the link to the U2 shear spring. This item applies only when DOF(1) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring. This item applies only when DOF(2) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, k, Slow, Fast, Rate, Radius, SlowT, FastT, RateT, kt, dis, dist, Damping, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetTCFrictionIsolator(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTCFrictionIsolator" failed')
        
        return ret

    def SetTriplePendulumIsolator(self, Name = None, DOF = None, Fixed = None, NonLinear = None, Ke = None, Ce = None, K1 = None, Damping = None, K = None, Slow = None, Fast = None, Rate = None, Radius = None, StopDist = None, HeightOut = None, HeightIn = None, dj2 = None, dj3 = None, Notes = None, GUID = None):
        """
This function initializes a Triple Pendulum Isolator type link property. If this function is called for an existing link property, then all items for the property are reset to their default value.
The function returns zero if the property is successfully initialized, otherwise it returns a nonzero value.

Name: The name of an existing or new link property. If this is an existing property, that property is modified; otherwise, a new property is added.
DOF: This is a Boolean array, dimensioned to 5, indicating if properties exist for a specified degree of freedom.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3

Fixed: This is a Boolean array, dimensioned to 5, indicating if the specified degree of freedom is fixed (restrained).
Fixed(0) = U1 fixity
Fixed(1) = U2 fixity
Fixed(2) = U3 fixity
Fixed(3) = R1 fixity
Fixed(4) = R2 fixity
Fixed(5) = R3 fixity

The term Fixed(n) applies only when DOF(n) = True.
NonLinear: This is a Boolean array, dimensioned to 5, indicating if nonlinear properties exist for a specified degree of freedom.
NonLinear(0) = U1 has nonlinear properties
NonLinear(1) = U2 has nonlinear properties
NonLinear(2) = U3 has nonlinear properties
NonLinear(3) = R1, Not Used
NonLinear(4) = R2, Not Used
NonLinear(5) = R3, Not Used

Note that this item is applicable for degrees of freedom U1, U2 and U3 only. For those degrees of freedom, the term NonLinear(n) applies only when DOF(n) = True and Fixed(n) = False.
Ke: This is an array of effective stiffness terms for the link property. The effective stiffness applies for linear analyses, and also for nonlinear analysis for those DOF for which NonLinear(n) = False.
Ke(0) = U1 [F/L]
Ke(1) = U2 [F/L]
Ke(2) = U3 [F/L]
Ke(3) = R1 [FL]
Ke(4) = R2 [FL]
Ke(5) = R3 [FL]

The term Ke(n) applies only when DOF(n) = True and Fixed(n) = False.
Ce: This is an array of effective damping terms for the link property. The effective damping applies for linear analyses.
Ce(0) = U1 [F/L]
Ce(1) = U2 [F/L]
Ce(2) = U3 [F/L]
Ce(3) = R1 [FL]
Ce(4) = R2 [FL]
Ce(5) = R3 [FL]

The term Ce(n) applies only when DOF(n) = True and Fixed(n) = False.
K1: This is the axial compression stiffness for the U1 degree of freedom. This item applies for nonlinear analyses. [F/L]
Damping: This is the nonlinear damping coefficient for the axial degree of freedom, U1, when it is in compression. This item applies for nonlinear analyses. [F/L]
K: This is an array, dimensioned to 3, of initial nonlinear stiffness (before sliding) for each sliding surface.
K(0) = for the outer top sliding surface [F/L]
K(1) = for the outer bottom sliding surface [F/L]
K(2) = for the inner top sliding surface [F/L]
K(3) = for the inner bottom sliding surface [F/L]

Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term k(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Slow: This is an array, dimensioned to 3, of the friction coefficient at zero velocity for each sliding surface when U1 is in compression.
Slow(0) = for the outer top sliding surface
Slow(1) = for the outer bottom sliding surface
Slow(2) = for the inner top sliding surface
Slow(3) = for the inner bottom sliding surface

Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term Slow(n) only applies when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Fast: This is an array, dimensioned to 3, of the friction coefficient at fast velocity for each sliding surface when U1 is in compression.
Fast(0) = for the outer top sliding surface
Fast(1) = for the outer bottom sliding surface
Fast(2) = for the inner top sliding surface
Fast(3) = for the inner bottom sliding surface

Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term Fast(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Rate: This is an array, dimensioned to 3, of the inverse of the characteristic sliding velocity for the Slow and Fast friction coefficients for each sliding surface. This item applies for nonlinear analyses.
Rate(0) = for the outer top sliding surface [s/L]
Rate(1) = for the outer bottom sliding surface [s/L]
Rate(2) = for the inner top sliding surface [s/L]
Rate(3) = for the inner bottom sliding surface [s/L]

Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term Rate(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
Radius: This is an array, dimensioned to 3, of the radius for each sliding surface. Inputting 0 means there is an infinite radius, that is, the slider is flat. This item applies for nonlinear analyses.
Radius(0) = for the outer top sliding surface [L]
Radius(1) = for the outer bottom sliding surface [L]
Radius(2) = for the inner top sliding surface [L]
Radius(3) = for the inner bottom sliding surface [L]

Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term Radius(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
StopDist: This is an array, dimensioned to 3, of the amount of displacement allowed before hitting a stiff limit for each sliding surface. Inputting 0 means there is no stop. This item applies for nonlinear analyses.
StopDist(0) = for the outer top sliding surface [L]
StopDist(1) = for the outer bottom sliding surface [L]
StopDist(2) = for the inner top sliding surface [L]
StopDist(3) = for the inner bottom sliding surface [L]

Note that this item is applicable for degrees of freedom U2 and U3 only . For those degrees of freedom, the term StopDist(n) applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
HeightOut: This is the height (distance) between the outer sliding surfaces at zero displacement. [L]
Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
HeightIn: This is the height (distance) between the inner sliding surfaces. [L]
Note that this item is applicable for degrees of freedom U2 and U3 only. For those degrees of freedom, the term applies only when DOF(n) = True, Fixed(n) = False and NonLinear(n) = True.
dj2: The distance from the J-End of the link to the U2 shear spring, that is, the center of the isolator. This item applies only when DOF(2) = True. [L]
dj3: The distance from the J-End of the link to the U3 shear spring, that is, the center of the isolator. This item applies only when DOF(3) = True. [L]
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, then the program assigns a GUID to the property.
        """

        all_args = [Name, DOF, Fixed, NonLinear, Ke, Ce, K1, Damping, K, Slow, Fast, Rate, Radius, StopDist, HeightOut, HeightIn, dj2, dj3, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetTriplePendulumIsolator(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTriplePendulumIsolator" failed')
        
        return ret

    def SetWeightAndMass(self, Name = None, w = None, m = None, R1 = None, R2 = None, R3 = None):
        """
This function assigns weight and mass values to a link property.
The function returns zero if the values are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing link property.
w: The weight of the link. [F]
m: The translational mass of the link. [M]
R1: The rotational inertia of the link about its local 1 axis. [ML2]
R2: The rotational inertia of the link about its local 2 axis. [ML2]
R3: The rotational inertia of the link about its local 3 axis. [ML2]
        """

        all_args = [Name, w, m, R1, R2, R3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropLink.SetWeightAndMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetWeightAndMass" failed')
        
        return ret

class PropMaterial:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.TimeDep = TimeDep(strict, api)

    def GetConcreteCEBFIP90(self, Name = None, ConsiderConcreteAge = None, ConsiderConcreteCreep = None, ConsiderConcreteShrinkage = None, CEBFIPsCoefficient = None, RelativeHumidity = None, NotionalSize = None, ShrinkageCoefficient = None, ShrinkageStartAge = None, UseSeries = None, NumberSeriesTerms = None, Temp = None):
        """
This function retrieves the time dependent CEB FIP-90 material property data for concrete materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not concrete.

Name: The name of an existing concrete material property.
ConsiderConcreteAge: If this item is True, time dependence is considered for concrete compressive strength and stiffness (modulus of elasticity).
ConsiderConcreteCreep: If this item is True, time dependence is considered for concrete creep.
ConsiderConcreteShrinkage: If this item is True, time dependence is considered for concrete shrinkage.
CEBFIPsCoefficient: This is the cement type coefficient. This item applies only when ConsiderConcreteAge = True.
RelativeHumidity: This is relative humidity. This item applies only when ConsiderConcreteCreep = True or ConsiderConcreteShrinkage = True.
NotionalSize: This is notional size of the member. This item applies only when ConsiderConcreteCreep = True or ConsiderConcreteShrinkage = True.
As defined in Equation 2.1-69 of CEB_FIP Model Code 1990 the notional size is equal to two times the cross-sectional area of the member divided by the perimeter of the member in contact with the atmosphere.
ShrinkageCoefficient: This is the shrinkage coefficient as defined in Equation 2.1-76 of CEB_FIP Model Code 1990. This item applies only when ConsiderConcreteShrinkage = True.
ShrinkageStartAge: This is the shrinkage start age in days as used in Section 2.1.6.4.4 of CEB_FIP Model Code 1990. This item applies only when ConsiderConcreteShrinkage = True.
UseSeries: This is either 0 or 1, indicating the creep integration type.
0 = Full integration
1 = Dirichlet series

This item applies only when ConsiderConcreteCreep = True.
NumberSeriesTerms: This is the number of series terms used when integrating based on a Dirichlet series. This item applies only when ConsiderConcreteCreep = True and UseSeries = 1.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been previously defined for the material.
        """

        all_args = [Name, ConsiderConcreteAge, ConsiderConcreteCreep, ConsiderConcreteShrinkage, CEBFIPsCoefficient, RelativeHumidity, NotionalSize, ShrinkageCoefficient, ShrinkageStartAge, UseSeries, NumberSeriesTerms, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetConcreteCEBFIP90(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetConcreteCEBFIP90" failed')
        
        return ret

    def GetTendonCEBFIP90(self, Name = None, ConsiderSteelRelaxation = None, CEBFIPClass = None, UseSeries = None, NumberSeriesTerms = None, Temp = None):
        """
This function retrieves the time dependent CEB FIP-90 material property data for tendon materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not tendon.

Name: The name of an existing tendon material property.
ConsiderSteelRelaxation: If this item is True, time dependence is considered for tendon steel relaxation.
CEBFIPClass: This is either 1 or 2, indicating the CEB FIP-90 class. This item applies only when ConsiderSteelRelaxation = True.
UseSeries: This is either 0 or 1, indicating the steel relaxation integration type.
0 = Full integration
1 = Dirichlet series

This item applies only when ConsiderSteelRelaxation = True.
NumberSeriesTerms: This is the number of series terms used when integrating based on a Dirichlet series. This item applies only when ConsiderSteelRelaxation = True and UseSeries = 1.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been previously defined for the material.
        """

        all_args = [Name, ConsiderSteelRelaxation, CEBFIPClass, UseSeries, NumberSeriesTerms, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetTendonCEBFIP90(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTendonCEBFIP90" failed')
        
        return ret

    def AddMaterial(self, Name = None, MatType = None, Region = None, Standard = None, Grade = None, UserName = None):
        """
This function adds a new material property to the model 
 based on the Code-specified and other pre-defined material properties 
 defined in the installed file "CSiMaterialLibrary*.xml" located 
 in subfolder "Property Libraries" under the CSiBridge installation 
 folder.
The function returns zero if the material property is 
 successfully added, otherwise it returns a nonzero value.

Name: This item is returned by the program. It is the name 
 that the program ultimately assigns for the material property. If no UserName 
 is specified, the program assigns a default name to the material property. 
 If a UserName is specified and that name is not used for another material 
 property, the UserName is assigned to the material property.
MatType: This is one of the following items in the eMatType enumeration.
eMatType_Steel 
 = 1
eMatType_Concrete 
 = 2
eMatType_NoDesign 
 = 3
eMatType_Aluminum 
 = 4
eMatType_ColdFormed 
 = 5
eMatType_Rebar 
 = 6
eMatType_Tendon 
 = 7

Region: The region name of the material property that is user-predefined 
 in the file "CSiMaterialLibrary*.xml" located in subfolder "Property 
 Libraries" under the CSiBridge installation.
Standard: The Standard name of the material property with the 
 specified MatType within the specified region.
Grade: The Grade name of the material property with the specified 
 MatType within the specified region and Standard.
UserName: This is an optional user specified name for the material 
 property. If a UserName is specified and that name is already used for 
 another material property, the program ignores the UserName.
        """

        all_args = [Name, MatType, Region, Standard, Grade, UserName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.AddMaterial(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddMaterial" failed')
        
        return ret

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing material property.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined material property.
NewName: The new name for the material property.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self, MatType = None):
        """
This function returns the total number of defined material 
 properties in the model. If desired, counts can be returned for all material 
 properties of a specified type in the model.

MatType: This optional value is one of the following items in 
 the eMatType enumeration.
eMatType_Steel 
 = 1
eMatType_Concrete 
 = 2
eMatType_NoDesign 
 = 3
eMatType_Aluminum 
 = 4
eMatType_ColdFormed 
 = 5
eMatType_Rebar 
 = 6
eMatType_Tendon 
 = 7

If no value is input for MatType, a count is returned 
 for all material properties in the model regardless of type.
        """

        all_args = [MatType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified material property.
The function returns zero if the material property is successfully deleted; otherwise it returns a nonzero value. It returns an error if the specified material property can not be deleted, for example, if it is being used in a section property.

Name: The name of an existing material property.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetCoupledModelType(self, Name = None, MatCoupledType = None, Temp = None):
        """
This function retrieves 
 the nonlinear coupled modeling type for a specified material
The function returns 
 zero if the assignment data is successfully obtained; otherwise it returns 
 a nonzero value.

Name: The name of an existing material property.
MatCoupledType: This is one of the following items in the eMatCoupledType 
 enumeration.
None 
 = 1
VonMisesPlasticity 
 = 2
ModifiedDarwinPecknoldConcrete 
 = 3

Temp: This item applies only 
 if the specified material has properties that are temperature dependent. 
 That is, it applies only if properties are specified for the material 
 at more than one temperature.
This item is the temperature 
 at which the specified data is to be retrieved. The temperature must have 
 been defined previously for the material.
        """

        all_args = [Name, MatCoupledType, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetCoupledModelType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCoupledModelType" failed')
        
        return ret

    def GetDamping(self, Name = None, ModalRatio = None, ViscousMassCoeff = None, ViscousStiffCoeff = None, HystereticMassCoeff = None, HystereticStiffCoeff = None, Temp = None):
        """
This function retrieves the  additional material damping data for the material.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing material property.
ModalRatio: The modal damping ratio.
ViscousMassCoeff: The mass coefficient for viscous proportional damping.
ViscousStiffCoeff: The stiffness coefficient for viscous proportional damping.
HystereticMassCoeff: The mass coefficient for hysteretic proportional damping.
HystereticStiffCoeff: The stiffness coefficient for hysteretic proportional damping.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been previously defined for the material.
        """

        all_args = [Name, ModalRatio, ViscousMassCoeff, ViscousStiffCoeff, HystereticMassCoeff, HystereticStiffCoeff, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetDamping(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDamping" failed')
        
        return ret

    def GetMassSource(self, MyOption = None, NumberLoads = None, LoadPat = None, sf = None):
        """
This function retrieves the mass source for the model.
The function returns zero if the mass source is successfully retrieved; otherwise it returns a nonzero value.

MyOption: This is 1, 2 or 3, indicating the mass source option.
1 = From element self mass and additional masses
2 = From loads
3 = From element self mass and additional masses and loads
NumberLoads: The number of load patterns from which mass is obtained. This item applies only when MyOption is 2 or 3.
LoadPat: This is an array of the names of the load patterns from which mass is obtained. This item applies only when MyOption is 2 or 3.
sf: This is an array of load patterns multipliers used to calculate the mass. This item applies only when MyOption is 2 or 3.
        """

        all_args = [MyOption, NumberLoads, LoadPat, sf]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetMassSource(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMassSource" failed')
        
        return ret

    def GetMaterial(self, Name = None, MatType = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves some basic material property 
 data.
The function returns zero if the material is successfully 
 retrieved; otherwise it returns a nonzero value.

Name: The name of an existing material property.
MatType: This is one of the following items in the eMatType enumeration.
eMatType_Steel 
 = 1
eMatType_Concrete 
 = 2
eMatType_NoDesign 
 = 3
eMatType_Aluminum 
 = 4
eMatType_ColdFormed 
 = 5
eMatType_Rebar 
 = 6
eMatType_Tendon 
 = 7
Color: The display color assigned to the material.
Notes: The notes, if any, assigned to the material.
GUID: The GUID (global unique identifier), if any, assigned 
 to the material.
        """

        all_args = [Name, MatType, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetMaterial(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMaterial" failed')
        
        return ret

    def GetMPAnisotropic(self, Name = None, e = None, u = None, a = None, g = None, Temp = None):
        """
This function retrieves the mechanical properties for a material with an anisotropic directional symmetry type.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the symmetry type of the specified material is not anisotropic.

Name: The name of an existing material property.
e: This is an array that includes the modulus of elasticity.
e(0) = E1 [F/L2]
e(1) = E2 [F/L2]
e(2) = E3 [F/L2]
u: This is an array that includes poisson’s ratio.
u(0) = U12
u(1) = U13
u(2) = U23
u(3) = U14
u(4) = U24
u(5) = U34
u(6) = U15
u(7) = U25
u(8) = U35
u(9) = U45
u(10) = U16
u(11) = U26
u(12) = U36
u(13) = U46
u(14) = U56
a: This is an array that includes the thermal coefficient.
a(0) = A1 [1/T]
a(1) = A2 [1/T]
a(2) = A3 [1/T]
a(3) = A12 [1/T]
a(4) = A13 [1/T]
a(5) = A23 [1/T]
g: This is an array that includes the shear modulus.
g(0) = G12 [F/L2]
g(1) = G13 [F/L2]
g(2) = G23 [F/L2]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been previously defined for the material.
        """

        all_args = [Name, e, u, a, g, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetMPAnisotropic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMPAnisotropic" failed')
        
        return ret

    def GetMPIsotropic(self, Name = None, e = None, u = None, a = None, g = None, Temp = None):
        """
This function retrieves the mechanical properties for a material with an isotropic directional symmetry type.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the symmetry type of the specified material is not isotropic.

Name: The name of an existing material property.
e: The modulus of elasticity. [F/L2]
u: Poisson’s ratio.
a: The thermal coefficient. [1/T]
g: The shear modulus. For isotropic materials this value is program calculated from the modulus of elasticity and poisson’s ratio. [F/L2]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, e, u, a, g, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetMPIsotropic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMPIsotropic" failed')
        
        return ret

    def GetMPOrthotropic(self, Name = None, e = None, u = None, a = None, g = None, Temp = None):
        """
This function retrieves the mechanical properties for a material with an orthotropic directional symmetry type.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the symmetry type of the specified material is not orthotropic.

Name: The name of an existing material property.
e: This is an array that includes the modulus of elasticity.
e(0) = E1 [F/L2]
e(1) = E2 [F/L2]
e(2) = E3 [F/L2]
u: This is an array that includes poisson’s ratio.
u(0) = U12
u(1) = U13
u(2) = U23
a: This is an array that includes the thermal coefficient.
a(0) = A1 [1/T]
a(1) = A2 [1/T]
a(2) = A3 [1/T]
g: This is an array that includes the shear modulus.
g(0) = G12 [F/L2]
g(1) = G13 [F/L2]
g(2) = G23 [F/L2]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, e, u, a, g, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetMPOrthotropic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMPOrthotropic" failed')
        
        return ret

    def GetMPUniaxial(self, Name = None, e = None, a = None, Temp = None):
        """
This function retrieves the mechanical properties for a material with a uniaxial directional symmetry type.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the symmetry type of the specified material is not uniaxial.

Name: The name of an existing material property.
e: The modulus of elasticity. [F/L2]
a: The thermal coefficient. [1/T]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been previously defined for the material.
        """

        all_args = [Name, e, a, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetMPUniaxial(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMPUniaxial" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None, MatType = None):
        """
This function retrieves the names of all defined material 
 properties of the specified type.
The function returns zero if the names are successfully 
 retrieved; otherwise it returns nonzero.

NumberNames: The number of material property names retrieved by the 
 program.
MyName: This is a one-dimensional array of material property 
 names. The MyName array is created as a dynamic, zero-based, array by 
 the API user:
Dim MyName() 
 as String
The array is dimensioned to (NumberNames - 1) inside 
 the SAP2000 program, filled with the names, and returned to the API user.
MatType: This optional value is one of the following items in 
 the eMatType enumeration.
eMatType_Steel 
 = 1
eMatType_Concrete 
 = 2
eMatType_NoDesign 
 = 3
eMatType_Aluminum 
 = 4
eMatType_ColdFormed 
 = 5
eMatType_Rebar 
 = 6
eMatType_Tendon 
 = 7

If no value is input for MatType, names are returned 
 for all material properties in the model regardless of type.
        """

        all_args = [NumberNames, MyName, MatType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetOAluminum(self, Name = None, MyType = None, Alloy = None, Fcy = None, Fty = None, Ftu = None, Fsu = None, SSHysType = None, Temp = None):
        """
This function retrieves the other material property data for aluminum materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not aluminum.

Name: The name of an existing aluminum material property.
MyType: This is 1, 2 or 3, indicating the type of aluminum.
1 = Wrought
2 = Cast-Mold
3 = Cast-Sand
Alloy: The Alloy designation for the aluminum, for example, 2014-T6 for wrought or 356.0-T7 for cast (mold or sand) aluminum.
Fcy: The compressive yield strength of aluminum. [F/L2]
Fty: The tensile yield strength of aluminum. [F/L2]
Ftu: The tensile ultimate strength of aluminum. [F/L2]
Fsu: The shear ultimate strength of aluminum. [F/L2]
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, MyType, Alloy, Fcy, Fty, Ftu, Fsu, SSHysType, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetOAluminum(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOAluminum" failed')
        
        return ret

    def GetOColdFormed(self, Name = None, Fy = None, Fu = None, SSHysType = None, Temp = None):
        """
This function retrieves the other material property data for cold formed materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not cold formed.

Name: The name of an existing cold formed material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, SSHysType, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetOColdFormed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOColdFormed" failed')
        
        return ret

    def GetOConcrete_2(self, Name = None, fc = None, efc = None, IsLightweight = None, fcsfactor = None, SSType = None, SSHysType = None, StrainAtfc = None, StrainUltimate = None, FinalSlope = None, FrictionAngle = None, DilatationalAngle = None, Temp = None):
        """
This function retrieves the other material property data for concrete materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not concrete.

Name: The name of an existing concrete material property.
fc: The concrete compressive strength. [F/L2]
efc: The expected concrete compressive strength. [F/L2]
IsLightweight: If this item is True, the concrete is assumed to be lightweight concrete.
fcsfactor: The shear strength reduction factor for lightweight concrete.
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
2 = Parametric - Mander
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtfc: This item applies only to parametric stress-strain curves. It is the strain at the unconfined compressive strength.
StrainUltimate: This item applies only to parametric stress-strain curves. It is the ultimate unconfined strain capacity.
FinalSlope: This item applies only to parametric stress-strain curves. It is a multiplier on the material modulus of elasticity, E. This value multiplied times E gives the final slope on the compression side of the curve.
FrictionAngle: The Drucker-Prager friction angle, 0 <= FrictionAngle < 90. [deg]
DilatationalAngle: The Drucker-Prager dilatational angle, 0 <= DilatationalAngle < 90. [deg]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, fc, efc, IsLightweight, fcsfactor, SSType, SSHysType, StrainAtfc, StrainUltimate, FinalSlope, FrictionAngle, DilatationalAngle, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetOConcrete_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOConcrete_2" failed')
        
        return ret

    def GetONoDesign(self, Name = None, FrictionAngle = None, DilatationalAngle = None, Temp = None):
        """
This function retrieves the other material property data for no design type materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not concrete.

Name: The name of an existing concrete material property.
FrictionAngle: The Drucker-Prager friction angle, 0 <= FrictionAngle < 90. [deg]
DilatationalAngle: The Drucker-Prager dilatational angle, 0 <= DilatationalAngle < 90. [deg]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, FrictionAngle, DilatationalAngle, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetONoDesign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetONoDesign" failed')
        
        return ret

    def GetORebar_1(self, Name = None, Fy = None, Fu = None, eFy = None, eFu = None, SSType = None, SSHysType = None, StrainAtHardening = None, StrainUltimate = None, FinalSlope = None, UseCaltransSSDefaults = None, Temp = None):
        """
This function retrieves the other material property data for rebar materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not rebar.

Name: The name of an existing rebar material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
eFy: The expected yield stress. [F/L2]
eFu: The expected tensile stress. [F/L2]
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
2 = Parametric - Park
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtHardening: This item applies only when parametric stress-strain curves are used and when UseCaltransSSDefaults is False. It is the strain at the onset of strain hardening.
StrainUltimate: This item applies only when parametric stress-strain curves are used and when UseCaltransSSDefaults is False. It is the ultimate strain capacity. This item must be larger than the StrainAtHardening item.
FinalSlope: This item applies only to parametric stress-strain curves. It is a multiplier on the material modulus of elasticity, E. This value multiplied times E gives the final slope of the curve.
UseCaltransSSDefaults: If this item is True, the program uses Caltrans default controlling strain values, which are bar size dependent.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, eFy, eFu, SSType, SSHysType, StrainAtHardening, StrainUltimate, FinalSlope, UseCaltransSSDefaults, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetORebar_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetORebar_1" failed')
        
        return ret

    def GetOSteel_1(self, Name = None, Fy = None, Fu = None, eFy = None, eFu = None, SSType = None, SSHysType = None, StrainAtHardening = None, StrainAtMaxStress = None, StrainAtRupture = None, FinalSlope = None, Temp = None):
        """
This function retrieves the other material property data for steel materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not steel.

Name: The name of an existing steel material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
eFy: The expected yield stress. [F/L2]
eFu: The expected tensile stress. [F/L2]
SSType: This is 0 or 1. indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtHardening: This item applies only to parametric stress-strain curves. It is the strain at the onset of strain hardening.
StrainAtMaxStress: This item applies only to parametric stress-strain curves. It is the strain at maximum stress.
StrainAtRupture: This item applies only to parametric stress-strain curves. It is the strain at rupture.
FinalSlope: This item applies only to parametric stress-strain curves. It is a multiplier on the material modulus of elasticity, E. This value multiplied times E gives the final slope of the curve.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, eFy, eFu, SSType, SSHysType, StrainAtHardening, StrainAtMaxStress, StrainAtRupture, FinalSlope, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetOSteel_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOSteel_1" failed')
        
        return ret

    def GetOTendon_1(self, Name = None, Fy = None, Fu = None, SSType = None, SSHysType = None, FinalSlope = None, Temp = None):
        """
This function retrieves the other material property data for tendon materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not tendon.

Name: The name of an existing tendon material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric – 250 ksi strand
2 = Parametric – 270 ksi strand
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
FinalSlope: This item applies only to parametric stress-strain curves. It is a multiplier on the material modulus of elasticity, E. This value multiplied times E gives the final slope of the curve.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, SSType, SSHysType, FinalSlope, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetOTendon_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOTendon_1" failed')
        
        return ret

    def GetSSCurve(self, Name = None, NumberPoints = None, PointID = None, Strain = None, Stress = None, SectName = None, RebarArea = None, Temp = None):
        """
This function retrieves the material stress-strain curve.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing material property.
NumberPoints: The number of points in the stress-strain curve.
PointID: This is one of the following integers which sets the point ID. The point ID controls the color that will be displayed for hinges in a deformed shape plot.
-5 = -E
-4 = -D
-3 = -C
-2 = -B
0 = None
1 = A
2 = B
3 = C
4 = D
5 = E

Strain: This is an array that includes the strain at each point on the stress strain curve.
Stress: This is an array that includes the stress at each point on the stress strain curve. [F/L2]
SectName: This item applies only if the specified material is concrete with a Mander concrete type.
This is the frame section property for which the Mander stress-strain curve is retrieved.
The section must be round or rectangular.
RebarArea: This item applies only if the specified material is rebar, which does not have a user-defined stress-strain curve and is specified to use Caltrans default controlling strain values, which are bar size dependent.
This is the area of the rebar for which the stress-strain curve is retrieved.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, NumberPoints, PointID, Strain, Stress, SectName, RebarArea, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetSSCurve(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSSCurve" failed')
        
        return ret

    def GetTemp(self, Name = None, NumberItems = None, Temp = None):
        """
This function retrieves the temperatures at which properties are specified for a material.
The function returns zero if the temperatures are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a material property.
NumberItems: The number of different temperatures at which properties are specified for the material.
Temp: This is an array that includes the different temperatures at which properties are specified for the material.
        """

        all_args = [Name, NumberItems, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTemp" failed')
        
        return ret

    def GetTypeOAPI(self, Name = None, MatType = None, SymType = None):
        """
This function retrieves the material type for the specified 
 material.
The function returns zero if the type is successfully 
 retrieved; otherwise it returns nonzero.

Name: The name of an existing material property.
MatType: This is one of the following items in the eMatType enumeration.
eMatType_Steel 
 = 1
eMatType_Concrete 
 = 2
eMatType_NoDesign 
 = 3
eMatType_Aluminum 
 = 4
eMatType_ColdFormed 
 = 5
eMatType_Rebar 
 = 6
eMatType_Tendon 
 = 7

SymType: This is 0, 1, 2 or 3, indicating the material directional 
 symmetry type.
0 = Isotropic
1 = Orthotropic
2 = Anisotropic
3 = Uniaxial
        """

        all_args = [Name, MatType, SymType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetTypeOAPI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTypeOAPI" failed')
        
        return ret

    def GetVonMisesPlasticityParameters(self):
        """
This function gets the 
 Von Mises Plasticity coupled modeling parameters for a specified material
The function returns 
 zero if the assignment data is successfully obtained; otherwise it returns 
 a nonzero value. 
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetVonMisesPlasticityParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetVonMisesPlasticityParameters" failed')
        
        return ret

    def GetWeightAndMass(self, Name = None, w = None, m = None, Temp = None):
        """
This function retrieves the weight per unit volume and mass per unit volume of the material.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing material property.
w: The weight per unit volume for the material. [F/L3]
m: The mass per unit volume for the material. [M/L3]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, w, m, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetWeightAndMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetWeightAndMass" failed')
        
        return ret

    def SetCoupledModelType(self, Name = None, MatCoupledType = None, Temp = None):
        """
This function sets the 
 nonlinear coupled modeling type for a specified material
The function returns 
 zero if the assignment data is successfully assigned; otherwise it returns 
 a nonzero value.

Name: The name of an existing material property. 
MatCoupledType: This is one of the following items in the eMatCoupledType 
 enumeration.
None 
 = 1
VonMisesPlasticity 
 = 2
ModifiedDarwinPecknoldConcrete 
 = 3

Temp: This item applies only 
 if the specified material has properties that are temperature dependent. 
 That is, it applies only if properties are specified for the material 
 at more than one temperature.
This item is the temperature 
 at which the specified data is to be retrieved. The temperature must have 
 been defined previously for the material.
        """

        all_args = [Name, MatCoupledType, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetCoupledModelType(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCoupledModelType" failed')
        
        return ret

    def SetDamping(self, Name = None, ModalRatio = None, ViscousMassCoeff = None, ViscousStiffCoeff = None, HystereticMassCoeff = None, HystereticStiffCoeff = None, Temp = None):
        """
This function sets the additional material damping data for the material.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing material property.
ModalRatio: The modal damping ratio.
ViscousMassCoeff: The mass coefficient for viscous proportional damping.
ViscousStiffCoeff: The stiffness coefficient for viscous proportional damping.
HystereticMassCoeff: The mass coefficient for hysteretic proportional damping.
HystereticStiffCoeff: The stiffness coefficient for hysteretic proportional damping.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been previously defined for the material.
        """

        all_args = [Name, ModalRatio, ViscousMassCoeff, ViscousStiffCoeff, HystereticMassCoeff, HystereticStiffCoeff, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetDamping(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDamping" failed')
        
        return ret

    def SetMassSource(self, MyOption = None, NumberLoads = None, LoadPat = None, sf = None):
        """
This function sets the mass source for the model.
The function returns zero if the mass source is successfully set; otherwise it returns a nonzero value.
If either the MassFromElements or MassFromMasses parameter is specified as True, both values will be set to true in the model. Both of these items are currently controlled with a single option within the user interface.

MyOption: This is 1, 2 or 3, indicating the mass source option.
1 = From element self mass and additional masses
2 = From loads
3 = From element self mass and additional masses and loads
NumberLoads: The number of load patterns from which mass is obtained. This item applies only when MyOption is 2 or 3.
LoadPat: This is an array of the names of the load patterns from which mass is obtained. This item applies only when MyOption is 2 or 3.
sf: This is an array of load patterns multipliers used to calculate the mass. This item applies only when MyOption is 2 or 3.
        """

        all_args = [MyOption, NumberLoads, LoadPat, sf]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetMassSource(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMassSource" failed')
        
        return ret

    def SetMaterial(self, Name = None, MatType = None, Color = None, Notes = None, GUID = None):
        """
This function initializes a material property. If this 
 function is called for an existing material property, all items for the 
 material are reset to their default value.
The function returns zero if the material is successfully 
 initialized; otherwise it returns a nonzero value.

Name: The name of an existing or new material property. If 
 this is an existing property, that property is modified; otherwise, a 
 new property is added.
MatType: This is one of the following items in the eMatType enumeration.
eMatType_Steel 
 = 1
eMatType_Concrete 
 = 2
eMatType_NoDesign 
 = 3
eMatType_Aluminum 
 = 4
eMatType_ColdFormed 
 = 5
eMatType_Rebar 
 = 6
eMatType_Tendon 
 = 7

Color: The display color assigned to the material. If Color 
 is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the material.
GUID: The GUID (global unique identifier), if any, assigned 
 to the material. If this item is input as Default, the program assigns 
 a GUID to the material.
        """

        all_args = [Name, MatType, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetMaterial(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMaterial" failed')
        
        return ret

    def SetMPAnisotropic(self, Name = None, e = None, u = None, a = None, g = None, Temp = None):
        """
This function sets the material directional symmetry type to anisotropic, and assigns the anisotropic mechanical properties.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing material property.
e: This is an array that includes the modulus of elasticity.
e(0) = E1 [F/L2]
e(1) = E2 [F/L2]
e(2) = E3 [F/L2]
u: This is an array that includes poisson’s ratio.
u(0) = U12
u(1) = U13
u(2) = U23
u(3) = U14
u(4) = U24
u(5) = U34
u(6) = U15
u(7) = U25
u(8) = U35
u(9) = U45
u(10) = U16
u(11) = U26
u(12) = U36
u(13) = U46
u(14) = U56
a: This is an array that includes the thermal coefficient.
a(0) = A1 [1/T]
a(1) = A2 [1/T]
a(2) = A3 [1/T]
a(3) = A12 [1/T]
a(4) = A13 [1/T]
a(5) = A23 [1/T]
g: This is an array that includes the shear modulus.
g(0) = G12 [F/L2]
g(1) = G13 [F/L2]
g(2) = G23 [F/L2]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, e, u, a, g, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetMPAnisotropic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMPAnisotropic" failed')
        
        return ret

    def SetMPIsotropic(self, Name = None, e = None, u = None, a = None, Temp = None):
        """
This function sets the material directional symmetry type to isotropic, and assigns the isotropic mechanical properties.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing material property.
e: The modulus of elasticity. [F/L2]
u: Poisson’s ratio.
a: The thermal coefficient. [1/T]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, e, u, a, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetMPIsotropic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMPIsotropic" failed')
        
        return ret

    def SetMPOrthotropic(self, Name = None, e = None, u = None, a = None, g = None, Temp = None):
        """
This function sets the material directional symmetry type to orthotropic, and assigns the orthotropic mechanical properties.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing material property.
e: This is an array that includes the modulus of elasticity.
e(0) = E1 [F/L2]
e(1) = E2 [F/L2]
e(2) = E3 [F/L2]
u: This is an array that includes poisson’s ratio.
u(0) = U12
u(1) = U13
u(2) = U23
a: This is an array that includes the thermal coefficient.
a(0) = A1 [1/T]
a(1) = A2 [1/T]
a(2) = A3 [1/T]
g: This is an array that includes the shear modulus.
g(0) = G12 [F/L2]
g(1) = G13 [F/L2]
g(2) = G23 [F/L2]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, e, u, a, g, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetMPOrthotropic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMPOrthotropic" failed')
        
        return ret

    def SetMPUniaxial(self, Name = None, e = None, a = None, Temp = None):
        """
This function sets the material directional symmetry type to uniaxial, and assigns the uniaxial mechanical properties.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing material property.
e: The modulus of elasticity. [F/L2]
a: The thermal coefficient. [1/T]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, e, a, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetMPUniaxial(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMPUniaxial" failed')
        
        return ret

    def SetOAluminum(self, Name = None, MyType = None, Alloy = None, Fcy = None, Fty = None, Ftu = None, Fsu = None, SSHysType = None, Temp = None):
        """
This function sets the other material property data for aluminum materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing aluminum material property.
MyType: This is 1, 2 or 3, indicating the type of aluminum.
1 = Wrought
2 = Cast-Mold
3 = Cast-Sand
Alloy: The Alloy designation for the aluminum, for example, 2014-T6 for wrought or 356.0-T7 for cast (mold or sand) aluminum.
Fcy: The compressive yield strength of aluminum. [F/L2]
Fty: The tensile yield strength of aluminum. [F/L2]
Ftu: The tensile ultimate strength of aluminum. [F/L2]
Fsu: The shear ultimate strength of aluminum. [F/L2]
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, MyType, Alloy, Fcy, Fty, Ftu, Fsu, SSHysType, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetOAluminum(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOAluminum" failed')
        
        return ret

    def SetOColdFormed(self, Name = None, Fy = None, Fu = None, SSHysType = None, Temp = None):
        """
This function sets the other material property data for cold formed materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing cold formed material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, SSHysType, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetOColdFormed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOColdFormed" failed')
        
        return ret

    def SetOConcrete_2(self, Name = None, fc = None, efc = None, IsLightweight = None, fcsfactor = None, SSType = None, SSHysType = None, StrainAtfc = None, StrainUltimate = None, FinalSlope = None, FrictionAngle = None, DilatationalAngle = None, Temp = None):
        """
This function sets the other material property data for concrete materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing concrete material property.
fc: The concrete compressive strength. [F/L2]
efc: The expected concrete compressive strength. [F/L2]
IsLightweight: If this item is True, the concrete is assumed to be lightweight concrete.
fcsfactor: The shear strength reduction factor for lightweight concrete.
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
2 = Parametric - Mander
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtfc: This item applies only to parametric stress-strain curves. It is the strain at the unconfined compressive strength.
StrainUltimate: This item applies only to parametric stress-strain curves. It is the ultimate unconfined strain capacity. This item must be larger than the StrainAtfc item.
FinalSlope: This item applies only to parametric stress-strain curves. It is a multiplier on the material modulus of elasticity, E. This value multiplied times E gives the final slope on the compression side of the curve.
FrictionAngle: The Drucker-Prager friction angle, 0 <= FrictionAngle < 90. [deg]
DilatationalAngle: The Drucker-Prager dilatational angle, 0 <= DilatationalAngle < 90. [deg]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, fc, efc, IsLightweight, fcsfactor, SSType, SSHysType, StrainAtfc, StrainUltimate, FinalSlope, FrictionAngle, DilatationalAngle, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetOConcrete_2(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOConcrete_2" failed')
        
        return ret

    def SetONoDesign(self, Name = None, FrictionAngle = None, DilatationalAngle = None, Temp = None):
        """
This function sets the other material property data for no design type materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing concrete material property.
FrictionAngle: The Drucker-Prager friction angle, 0 <= FrictionAngle < 90. [deg]
DilatationalAngle: The Drucker-Prager dilatational angle, 0 <= DilatationalAngle < 90. [deg]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, FrictionAngle, DilatationalAngle, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetONoDesign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetONoDesign" failed')
        
        return ret

    def SetORebar_1(self, Name = None, Fy = None, Fu = None, eFy = None, eFu = None, SSType = None, SSHysType = None, StrainAtHardening = None, StrainUltimate = None, FinalSlope = None, UseCaltransSSDefaults = None, Temp = None):
        """
This function sets the other material property data for rebar materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing rebar material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
eFy: The expected yield stress. [F/L2]
eFu: The expected tensile stress. [F/L2]
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
2 = Parametric - Park
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtHardening: This item applies only when parametric stress-strain curves are used and when UseCaltransSSDefaults is False. It is the strain at the onset of strain hardening.
StrainUltimate: This item applies only when parametric stress-strain curves are used and when UseCaltransSSDefaults is False. It is the ultimate strain capacity. This item must be larger than the StrainAtHardening item.
FinalSlope: This item applies only to parametric stress-strain curves. It is a multiplier on the material modulus of elasticity, E. This value multiplied times E gives the final slope of the curve.
UseCaltransSSDefaults: If this item is True, the program uses Caltrans default controlling strain values, which are bar size dependent.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, eFy, eFu, SSType, SSHysType, StrainAtHardening, StrainUltimate, FinalSlope, UseCaltransSSDefaults, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetORebar_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetORebar_1" failed')
        
        return ret

    def SetOSteel_1(self, Name = None, Fy = None, Fu = None, eFy = None, eFu = None, SSType = None, SSHysType = None, StrainAtHardening = None, StrainAtMaxStress = None, StrainAtRupture = None, FinalSlope = None, Temp = None):
        """
This function sets the other material property data for steel materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing steel material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
eFy: The expected yield stress. [F/L2]
eFu: The expected tensile stress. [F/L2]
SSType: This is 0 or 1, indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtHardening: This item applies only to parametric stress-strain curves. It is the strain at the onset of strain hardening.
StrainAtMaxStress: This item applies only to parametric stress-strain curves. It is the strain at maximum stress. This item must be larger than the StrainAtHardening item.
StrainAtRupture: This item applies only to parametric stress-strain curves. It is the strain at rupture. This item must be larger than the StrainAtMaxStress item.
FinalSlope: This item applies only to parametric stress-strain curves. It is a multiplier on the material modulus of elasticity, E. This value multiplied times E gives the final slope of the curve.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, eFy, eFu, SSType, SSHysType, StrainAtHardening, StrainAtMaxStress, StrainAtRupture, FinalSlope, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetOSteel_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOSteel_1" failed')
        
        return ret

    def SetOTendon_1(self, Name = None, Fy = None, Fu = None, SSType = None, SSHysType = None, FinalSlope = None, Temp = None):
        """
This function sets the other material property data for tendon materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing tendon material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric – 250 ksi strand
2 = Parametric – 270 ksi strand
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
FinalSlope: This item applies only to parametric stress-strain curves. It is a multiplier on the material modulus of elasticity, E. This value multiplied times E gives the final slope of the curve.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, SSType, SSHysType, FinalSlope, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetOTendon_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOTendon_1" failed')
        
        return ret

    def SetSSCurve(self, Name = None, NumberPoints = None, PointID = None, Strain = None, Stress = None, Temp = None):
        """
This function sets the material stress-strain curve for materials that are specified to have user-defined stress-strain curves.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing material property.
NumberPoints: The number of points in the stress-strain curve. This item must be at least 3.
PointID: This is one of the following integers which sets the point ID. The point ID controls the color that will be displayed for hinges in a deformed shape plot.
-5 = -E
-4 = -D
-3 = -C
-2 = -B
0 = None
1 = A
2 = B
3 = C
4 = D
5 = E

The point IDs must be input in numerically increasing order, except that 0 (None) values are allowed anywhere. No duplicate values are allowed excepth for 0 (None).
Strain: This is an array that includes the strain at each point on the stress strain curve. The strains must increase monotonically.
Stress: This is an array that includes the stress at each point on the stress strain curve. [F/L2]
Points that have a negative strain must have a zero or negative stress. Similarly, points that have a positive strain must have a zero or positive stress.
There must be one point defined that has zero strain and zero stress.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, NumberPoints, PointID, Strain, Stress, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetSSCurve(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSSCurve" failed')
        
        return ret

    def SetTemp(self, Name = None, NumberItems = None, Temp = None):
        """
This function assigns the temperatures at which properties are specified for a material. This data is required only for materials whose properties are temperature dependent.
The function returns zero if the temperatures are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing material property.
NumberItems: The number of different temperatures at which properties are specified for the material.
Temp: This is an array that includes the different temperatures at which properties are specified for the material.
        """

        all_args = [Name, NumberItems, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTemp" failed')
        
        return ret

    def SetVonMisesPlasticityParameters(self):
        """
This function sets the 
 Von Mises Plasticity coupled modeling parameters for a specified material
The 
 function returns zero if the assignment data is successfully assigned; 
 otherwise it returns a nonzero value. 
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetVonMisesPlasticityParameters(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetVonMisesPlasticityParameters" failed')
        
        return ret

    def SetWeightAndMass(self, Name = None, MyOption = None, Value = None, Temp = None):
        """
This function assigns weight per unit volume or mass per unit volume to a material property.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing material property.
MyOption: This is either 1 or 2, indicating what is specified by the Value item.
1 = Weight per unit volume is specified
2 = Mass per unit volume is specified
If the weight is specified, the corresponding mass is program calculated based on the specified weight. Similarly, if the mass is specified, the corresponding weight is program calculated based on the specified mass.
Value: This is either the weight per unit volume or the mass per unit volume, depending on the value of the MyOption item. [F/L3] for MyOption = 1 (weight), and [M/L3] for MyOption = 2 (mass)
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been define previously for the material.
        """

        all_args = [Name, MyOption, Value, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetWeightAndMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetWeightAndMass" failed')
        
        return ret

    def AddQuick(self, Name = None, MatType = None, SteelType = None, ConcreteType = None, AluminumType = None, ColdFormedType = None, RebarType = None, TendonType = None, UserName = None):
        """
This function adds a new material property to the model using built-in default values.
The function returns zero if the property is successfully added; otherwise it returns nonzero.

Name: This item is returned by the program. It is the name that the program ultimately assigns for the material property. If no UserName is specified, the program assigns a default name to the material property. If a UserName is specified and that name is not used for another material property, the UserName is assigned to the material property.
MatType: This is one of the following items in the eMatType enumeration.
MATERIAL_STEEL = 1
MATERIAL_CONCRETE = 2
MATERIAL_NODESIGN = 3
MATERIAL_ALUMINUM = 4
MATERIAL_COLDFORMED = 5
MATERIAL_REBAR = 6
MATERIAL_TENDON = 7
SteelType: This is one of the following items in the eMatTypeSteel enumeration.
MATERIAL_STEEL_SUBTYPE_ASTM_A36 = 1
MATERIAL_STEEL_SUBTYPE_ASTM_A53GrB = 2
MATERIAL_STEEL_SUBTYPE_ASTM_A500GrB_Fy42 = 3
MATERIAL_STEEL_SUBTYPE_ASTM_A500GrB_Fy46 = 4
MATERIAL_STEEL_SUBTYPE_ASTM_A572Gr50 = 5
MATERIAL_STEEL_SUBTYPE_ASTM_A913Gr50 = 6
MATERIAL_STEEL_SUBTYPE_ASTM_A992_Fy50 = 7
MATERIAL_STEEL_SUBTYPE_CHINESE_Q235 = 8
MATERIAL_STEEL_SUBTYPE_CHINESE_Q345 = 9
MATERIAL_STEEL_SUBTYPE_INDIAN_Fe250 = 10
MATERIAL_STEEL_SUBTYPE_INDIAN_Fe345 = 11
MATERIAL_STEEL_SUBTYPE_EN100252_S235 = 12
MATERIAL_STEEL_SUBTYPE_EN100252_S275 = 13
MATERIAL_STEEL_SUBTYPE_EN100252_S355 = 14
MATERIAL_STEEL_SUBTYPE_EN100252_S450 = 15

This item is applicable only when MatType = MATERIAL_STEEL.
ConcreteType: This is one of the following items in the eMatTypeConcrete enumeration.
MATERIAL_CONCRETE_SUBTYPE_FC3000_NORMALWEIGHT = 1
MATERIAL_CONCRETE_SUBTYPE_FC4000_NORMALWEIGHT = 2
MATERIAL_CONCRETE_SUBTYPE_FC5000_NORMALWEIGHT = 3
MATERIAL_CONCRETE_SUBTYPE_FC6000_NORMALWEIGHT = 4
MATERIAL_CONCRETE_SUBTYPE_FC3000_LIGHTWEIGHT = 5
MATERIAL_CONCRETE_SUBTYPE_FC4000_LIGHTWEIGHT = 6
MATERIAL_CONCRETE_SUBTYPE_FC5000_LIGHTWEIGHT = 7
MATERIAL_CONCRETE_SUBTYPE_FC6000_LIGHTWEIGHT = 8
MATERIAL_CONCRETE_SUBTYPE_CHINESE_C20_NORMALWEIGHT = 9
MATERIAL_CONCRETE_SUBTYPE_CHINESE_C30_NORMALWEIGHT = 10
MATERIAL_CONCRETE_SUBTYPE_CHINESE_C40_NORMALWEIGHT = 11
MATERIAL_CONCRETE_SUBTYPE_INDIAN_M15_NORMALWEIGHT = 12
MATERIAL_CONCRETE_SUBTYPE_INDIAN_M20_NORMALWEIGHT = 13
MATERIAL_CONCRETE_SUBTYPE_INDIAN_M25_NORMALWEIGHT = 14
MATERIAL_CONCRETE_SUBTYPE_INDIAN_M30_NORMALWEIGHT = 15
MATERIAL_CONCRETE_SUBTYPE_INDIAN_M35_NORMALWEIGHT = 16
MATERIAL_CONCRETE_SUBTYPE_INDIAN_M40_NORMALWEIGHT = 17
MATERIAL_CONCRETE_SUBTYPE_INDIAN_M45_NORMALWEIGHT = 18
MATERIAL_CONCRETE_SUBTYPE_INDIAN_M50_NORMALWEIGHT = 19
MATERIAL_CONCRETE_SUBTYPE_INDIAN_M55_NORMALWEIGHT = 20
MATERIAL_CONCRETE_SUBTYPE_INDIAN_M60_NORMALWEIGHT = 21
MATERIAL_CONCRETE_SUBTYPE_EN_C12_NORMALWEIGHT = 22
MATERIAL_CONCRETE_SUBTYPE_EN_C16_NORMALWEIGHT = 23
MATERIAL_CONCRETE_SUBTYPE_EN_C20_NORMALWEIGHT = 24
MATERIAL_CONCRETE_SUBTYPE_EN_C25_NORMALWEIGHT = 25
MATERIAL_CONCRETE_SUBTYPE_EN_C30_NORMALWEIGHT = 26
MATERIAL_CONCRETE_SUBTYPE_EN_C35_NORMALWEIGHT = 27
MATERIAL_CONCRETE_SUBTYPE_EN_C40_NORMALWEIGHT = 28
MATERIAL_CONCRETE_SUBTYPE_EN_C45_NORMALWEIGHT = 29
MATERIAL_CONCRETE_SUBTYPE_EN_C50_NORMALWEIGHT = 30
MATERIAL_CONCRETE_SUBTYPE_EN_C55_NORMALWEIGHT = 31
MATERIAL_CONCRETE_SUBTYPE_EN_C60_NORMALWEIGHT = 32
MATERIAL_CONCRETE_SUBTYPE_EN_C70_NORMALWEIGHT = 33
MATERIAL_CONCRETE_SUBTYPE_EN_C80_NORMALWEIGHT = 34
MATERIAL_CONCRETE_SUBTYPE_EN_C90_NORMALWEIGHT = 35

This item is applicable only when MatType = MATERIAL_CONCRETE.
AluminumType: This is one of the following items in the eMatTypeAluminum enumeration.
MATERIAL_ALUMINUM_SUBTYPE_6061_T6 = 1
MATERIAL_ALUMINUM_SUBTYPE_6063_T6 = 2
MATERIAL_ALUMINUM_SUBTYPE_5052_H34 = 3

This item is applicable only when MatType = MATERIAL_ALUMINUM.
ColdFormedType: This is one of the following items in the eMatTypeColdFormed enumeration.
MATERIAL_COLDFORMED_SUBTYPE_ASTM_A653SQGr33 = 1
MATERIAL_COLDFORMED_SUBTYPE_ASTM_A653SQGr50 = 2

This item is applicable only when MatType = MATERIAL_COLDFORMED.
RebarType: This is one of the following items in the eMatTypeRebar enumeration.
MATERIAL_REBAR_SUBTYPE_ASTM_A615Gr40 = 1
MATERIAL_REBAR_SUBTYPE_ASTM_A615Gr60 = 2
MATERIAL_REBAR_SUBTYPE_ASTM_A615Gr75 = 3
MATERIAL_REBAR_SUBTYPE_ASTM_A706 = 4
MATERIAL_REBAR_SUBTYPE_CHINESE_HPB235 = 5
MATERIAL_REBAR_SUBTYPE_CHINESE_HRB335 = 6
MATERIAL_REBAR_SUBTYPE_CHINESE_HRB400 = 7
MATERIAL_REBAR_SUBTYPE_INDIAN_Mild250 = 8
MATERIAL_REBAR_SUBTYPE_INDIAN_HYSD415 = 9
MATERIAL_REBAR_SUBTYPE_INDIAN_HYSD500 = 10
MATERIAL_REBAR_SUBTYPE_INDIAN_HYSD550 = 11

This item is applicable only when MatType = MATERIAL_REBAR.
TendonType: This is one of the following items in the eMatTypeTendon enumeration.
MATERIAL_TENDON_SUBTYPE_ASTM_A416Gr250 = 1
MATERIAL_TENDON_SUBTYPE_ASTM_A416Gr270 = 2

This item is applicable only when MatType = MATERIAL_TENDON.
UserName: This is an optional user specified name for the material property. If a UserName is specified and that name is already used for another material property, the program ignores the UserName.
        """

        all_args = [Name, MatType, SteelType, ConcreteType, AluminumType, ColdFormedType, RebarType, TendonType, UserName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.AddQuick(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddQuick" failed')
        
        return ret

    def GetOConcrete(self, Name = None, fc = None, IsLightweight = None, fcsfactor = None, eFu = None, SSType = None, SSHysType = None, StrainAtfc = None, StrainUltimate = None, FrictionAngle = None, DilatationalAngle = None, Temp = None):
        """
This function retrieves the other material property data for concrete materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not concrete.

Name: The name of an existing concrete material property.
fc: The concrete compressive strength. [F/L2]
IsLightweight: If this item is True, the concrete is assumed to be lightweight concrete.
fcsfactor: The shear strength reduction factor for lightweight concrete.
eFu: The expected tensile stress. [F/L2]
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
2 = Parametric - Mander
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtfc: This item applies only to parametric stress-strain curves. It is the strain at the unconfined compressive strength.
StrainUltimate: This item applies only to parametric stress-strain curves. It is the ultimate unconfined strain capacity.
FrictionAngle: The Drucker-Prager friction angle, 0 <= FrictionAngle < 90. [deg]
DilatationalAngle: The Drucker-Prager dilatational angle, 0 <= DilatationalAngle < 90. [deg]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, fc, IsLightweight, fcsfactor, eFu, SSType, SSHysType, StrainAtfc, StrainUltimate, FrictionAngle, DilatationalAngle, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetOConcrete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOConcrete" failed')
        
        return ret

    def GetOConcrete_1(self, Name = None, fc = None, IsLightweight = None, fcsfactor = None, SSType = None, SSHysType = None, StrainAtfc = None, StrainUltimate = None, FinalSlope = None, FrictionAngle = None, DilatationalAngle = None, Temp = None):
        """
This function retrieves the other material property data for concrete materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not concrete.

Name: The name of an existing concrete material property.
fc: The concrete compressive strength. [F/L2]
IsLightweight: If this item is True, the concrete is assumed to be lightweight concrete.
fcsfactor: The shear strength reduction factor for lightweight concrete.
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
2 = Parametric - Mander
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtfc: This item applies only to parametric stress-strain curves. It is the strain at the unconfined compressive strength.
StrainUltimate: This item applies only to parametric stress-strain curves. It is the ultimate unconfined strain capacity.
FinalSlope: This item applies only to parametric stress-strain curves. It is a multiplier on the material modulus of elasticity, E. This value multiplied times E gives the final slope on the compression side of the curve.
FrictionAngle: The Drucker-Prager friction angle, 0 <= FrictionAngle < 90. [deg]
DilatationalAngle: The Drucker-Prager dilatational angle, 0 <= DilatationalAngle < 90. [deg]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, fc, IsLightweight, fcsfactor, SSType, SSHysType, StrainAtfc, StrainUltimate, FinalSlope, FrictionAngle, DilatationalAngle, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetOConcrete_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOConcrete_1" failed')
        
        return ret

    def GetORebar(self, Name = None, Fy = None, Fu = None, eFy = None, eFu = None, SSType = None, SSHysType = None, StrainAtHardening = None, StrainUltimate = None, UseCaltransSSDefaults = None, Temp = None):
        """
This function retrieves the other material property data for rebar materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not rebar.

Name: The name of an existing rebar material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
eFy: The expected yield stress. [F/L2]
eFu: The expected tensile stress. [F/L2]
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
2 = Parametric - Park
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtHardening: This item applies only when parametric stress-strain curves are used and when UseCaltransSSDefaults is False. It is the strain at the onset of strain hardening.
StrainUltimate: This item applies only when parametric stress-strain curves are used and when UseCaltransSSDefaults is False. It is the ultimate strain capacity. This item must be larger than the StrainAtHardening item.
UseCaltransSSDefaults: If this item is True, the program uses Caltrans default controlling strain values, which are bar size dependent.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, eFy, eFu, SSType, SSHysType, StrainAtHardening, StrainUltimate, UseCaltransSSDefaults, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetORebar(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetORebar" failed')
        
        return ret

    def GetOSteel(self, Name = None, Fy = None, Fu = None, eFy = None, eFu = None, SSType = None, SSHysType = None, StrainAtHardening = None, StrainAtMaxStress = None, StrainAtRupture = None, Temp = None):
        """
This function retrieves the other material property data for steel materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not steel.

Name: The name of an existing steel material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
eFy: The expected yield stress. [F/L2]
eFu: The expected tensile stress. [F/L2]
SSType: This is 0 or 1. indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtHardening: This item applies only to parametric stress-strain curves. It is the strain at the onset of strain hardening.
StrainAtMaxStress: This item applies only to parametric stress-strain curves. It is the strain at maximum stress.
StrainAtRupture: This item applies only to parametric stress-strain curves. It is the strain at rupture.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, eFy, eFu, SSType, SSHysType, StrainAtHardening, StrainAtMaxStress, StrainAtRupture, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetOSteel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOSteel" failed')
        
        return ret

    def GetOTendon(self, Name = None, Fy = None, Fu = None, SSType = None, SSHysType = None, Temp = None):
        """
This function retrieves the other material property data for tendon materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not tendon.

Name: The name of an existing tendon material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric – 250 ksi strand
2 = Parametric – 270 ksi strand
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, SSType, SSHysType, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.GetOTendon(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOTendon" failed')
        
        return ret

    def SetOConcrete(self, Name = None, fc = None, IsLightweight = None, fcsfactor = None, eFu = None, SSType = None, SSHysType = None, StrainAtfc = None, StrainUltimate = None, FrictionAngle = None, DilatationalAngle = None, Temp = None):
        """
This function sets the other material property data for concrete materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing concrete material property.
fc: The concrete compressive strength. [F/L2]
IsLightweight: If this item is True, the concrete is assumed to be lightweight concrete.
fcsfactor: The shear strength reduction factor for lightweight concrete.
eFu: The expected tensile stress. [F/L2]
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
2 = Parametric - Mander
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtfc: This item applies only to parametric stress-strain curves. It is the strain at the unconfined compressive strength.
StrainUltimate: This item applies only to parametric stress-strain curves. It is the ultimate unconfined strain capacity. This item must be larger than the StrainAtfc item.
FrictionAngle: The Drucker-Prager friction angle, 0 <= FrictionAngle < 90. [deg]
DilatationalAngle: The Drucker-Prager dilatational angle, 0 <= DilatationalAngle < 90. [deg]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, fc, IsLightweight, fcsfactor, eFu, SSType, SSHysType, StrainAtfc, StrainUltimate, FrictionAngle, DilatationalAngle, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetOConcrete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOConcrete" failed')
        
        return ret

    def SetOConcrete_1(self, Name = None, fc = None, IsLightweight = None, fcsfactor = None, SSType = None, SSHysType = None, StrainAtfc = None, StrainUltimate = None, FinalSlope = None, FrictionAngle = None, DilatationalAngle = None, Temp = None):
        """
This function sets the other material property data for concrete materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing concrete material property.
fc: The concrete compressive strength. [F/L2]
IsLightweight: If this item is True, the concrete is assumed to be lightweight concrete.
fcsfactor: The shear strength reduction factor for lightweight concrete.
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
2 = Parametric - Mander
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtfc: This item applies only to parametric stress-strain curves. It is the strain at the unconfined compressive strength.
StrainUltimate: This item applies only to parametric stress-strain curves. It is the ultimate unconfined strain capacity. This item must be larger than the StrainAtfc item.
FinalSlope: This item applies only to parametric stress-strain curves. It is a multiplier on the material modulus of elasticity, E. This value multiplied times E gives the final slope on the compression side of the curve.
FrictionAngle: The Drucker-Prager friction angle, 0 <= FrictionAngle < 90. [deg]
DilatationalAngle: The Drucker-Prager dilatational angle, 0 <= DilatationalAngle < 90. [deg]
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, fc, IsLightweight, fcsfactor, SSType, SSHysType, StrainAtfc, StrainUltimate, FinalSlope, FrictionAngle, DilatationalAngle, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetOConcrete_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOConcrete_1" failed')
        
        return ret

    def SetORebar(self, Name = None, Fy = None, Fu = None, eFy = None, eFu = None, SSType = None, SSHysType = None, StrainAtHardening = None, StrainUltimate = None, UseCaltransSSDefaults = None, Temp = None):
        """
This function sets the other material property data for rebar materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing rebar material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
eFy: The expected yield stress. [F/L2]
eFu: The expected tensile stress. [F/L2]
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
2 = Parametric - Park
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtHardening: This item applies only when parametric stress-strain curves are used and when UseCaltransSSDefaults is False. It is the strain at the onset of strain hardening.
StrainUltimate: This item applies only when parametric stress-strain curves are used and when UseCaltransSSDefaults is False. It is the ultimate strain capacity. This item must be larger than the StrainAtHardening item.
UseCaltransSSDefaults: If this item is True, the program uses Caltrans default controlling strain values, which are bar size dependent.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, eFy, eFu, SSType, SSHysType, StrainAtHardening, StrainUltimate, UseCaltransSSDefaults, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetORebar(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetORebar" failed')
        
        return ret

    def SetOSteel(self, Name = None, Fy = None, Fu = None, eFy = None, eFu = None, SSType = None, SSHysType = None, StrainAtHardening = None, StrainAtMaxStress = None, StrainAtRupture = None, Temp = None):
        """
This function sets the other material property data for steel materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing steel material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
eFy: The expected yield stress. [F/L2]
eFu: The expected tensile stress. [F/L2]
SSType: This is 0 or 1, indicating the stress-strain curve type.
0 = User defined
1 = Parametric - Simple
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
StrainAtHardening: This item applies only to parametric stress-strain curves. It is the strain at the onset of strain hardening.
StrainAtMaxStress: This item applies only to parametric stress-strain curves. It is the strain at maximum stress. This item must be larger than the StrainAtHardening item.
StrainAtRupture: This item applies only to parametric stress-strain curves. It is the strain at rupture. This item must be larger than the StrainAtMaxStress item.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, eFy, eFu, SSType, SSHysType, StrainAtHardening, StrainAtMaxStress, StrainAtRupture, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetOSteel(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOSteel" failed')
        
        return ret

    def SetOTendon(self, Name = None, Fy = None, Fu = None, SSType = None, SSHysType = None, Temp = None):
        """
This function sets the other material property data for tendon materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing tendon material property.
Fy: The minimum yield stress. [F/L2]
Fu: The minimum tensile stress. [F/L2]
SSType: This is 0, 1 or 2, indicating the stress-strain curve type.
0 = User defined
1 = Parametric – 250 ksi strand
2 = Parametric – 270 ksi strand
SSHysType: This is 0, 1 or 2, indicating the stress-strain hysteresis type.
0 = Elastic
1 = Kinematic
2 = Takeda
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been defined previously for the material.
        """

        all_args = [Name, Fy, Fu, SSType, SSHysType, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.SetOTendon(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOTendon" failed')
        
        return ret

class TimeDep:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetConcreteScaleFactors(self, Name = None, ScaleFactorAge = None, ScaleFactorCreep = None, ScaleFactorShrinkage = None, Temp = None):
        """
This function retrieves the scale factors for the time-dependent material property data for concrete materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not concrete.

Name: The name of an existing concrete material property.
ScaleFactorAge: This value multiplies the stiffness (modulus of elasticity) computed with age for the material during a time-dependent analysis. It has no effect for load cases that do not consider time-dependent effects, or for materials that do not consider time-dependent age effects. The default value is unity, and the specified value must be positive.
ScaleFactorCreep: This value multiplies the creep coefficient, and hence the creep strain, computed for the material during a time-dependent analysis. It has no effect for load cases that do not consider time-dependent effects, or for materials that do not consider creep effects. The default value is unity, and the specified value must be positive.
ScaleFactorShrinkage: This value multiplies the shrinkage strain computed for the material during a time-dependent analysis. It has no effect for load cases that do not consider time-dependent effects, or for materials that do not consider shrinkage effects. The default value is unity, and the specified value must be positive.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been previously defined for the material.
        """

        all_args = [Name, ScaleFactorAge, ScaleFactorCreep, ScaleFactorShrinkage, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.TimeDep.GetConcreteScaleFactors(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetConcreteScaleFactors" failed')
        
        return ret

    def GetTendonScaleFactors(self, Name = None, ScaleFactorRelaxation = None, Temp = None):
        """
This function retrieves the scale factors for the time-dependent material property data for tendon materials.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value. The function returns an error if the specified material is not tendon.

Name: The name of an existing tendon material property.
ScaleFactorRelaxation: This value multiplies the relaxation coefficient, and hence the relaxation strain, computed for the material during a time-dependent analysis. It has no effect for load cases that do not consider time-dependent effects, or for materials that do not consider relaxation effects. The default value is unity, and the specified value must be positive.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been previously defined for the material.
        """

        all_args = [Name, ScaleFactorRelaxation, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.TimeDep.GetTendonScaleFactors(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTendonScaleFactors" failed')
        
        return ret

    def SetConcreteCEBFIP90(self, Name = None, ConsiderConcreteAge = None, ConsiderConcreteCreep = None, ConsiderConcreteShrinkage = None, CEBFIPsCoefficient = None, RelativeHumidity = None, NotionalSize = None, ShrinkageCoefficient = None, ShrinkageStartAge = None, UseSeries = None, NumberSeriesTerms = None, Temp = None):
        """
This function sets the time dependent CEB FIP-90 material property data for concrete materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing concrete material property.
ConsiderConcreteAge: If this item is True, time dependence is considered for concrete compressive strength and stiffness (modulus of elasticity).
ConsiderConcreteCreep: If this item is True, time dependence is considered for concrete creep.
ConsiderConcreteShrinkage: If this item is True, time dependence is considered for concrete shrinkage.
CEBFIPsCoefficient: This is the cement type coefficient. This item applies only when ConsiderConcreteAge = True.
RelativeHumidity: This is relative humidity. This item applies only when ConsiderConcreteCreep = True or ConsiderConcreteShrinkage = True.
NotionalSize: This is notional size of the member. This item applies only when ConsiderConcreteCreep = True or ConsiderConcreteShrinkage = True.
As defined in Equation 2.1-69 of CEB_FIP Model Code 1990 the notional size is equal to two times the cross-sectional area of the member divided by the perimeter of the member in contact with the atmosphere.
ShrinkageCoefficient: This is the shrinkage coefficient as defined in Equation 2.1-76 of CEB_FIP Model Code 1990. This item applies only when ConsiderConcreteShrinkage = True.
ShrinkageStartAge: This is the shrinkage start age in days as used in Section 2.1.6.4.4 of CEB_FIP Model Code 1990. This item applies only when ConsiderConcreteShrinkage = True.
UseSeries: This is either 0 or 1, indicating the creep integration type.
0 = Full integration
1 = Dirichlet series

This item applies only when ConsiderConcreteCreep = True.
NumberSeriesTerms: This is the number of series terms used when integrating based on a Dirichlet series. This item applies only when ConsiderConcreteCreep = True and UseSeries = 1.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been previously defined for the material.
        """

        all_args = [Name, ConsiderConcreteAge, ConsiderConcreteCreep, ConsiderConcreteShrinkage, CEBFIPsCoefficient, RelativeHumidity, NotionalSize, ShrinkageCoefficient, ShrinkageStartAge, UseSeries, NumberSeriesTerms, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.TimeDep.SetConcreteCEBFIP90(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetConcreteCEBFIP90" failed')
        
        return ret

    def SetConcreteScaleFactors(self, Name = None, ScaleFactorAge = None, ScaleFactorCreep = None, ScaleFactorShrinkage = None, Temp = None):
        """
This function sets scale factors for the time-dependent material property data for concrete materials. If this function is not called, default values of unity are assumed for all scale factors.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing concrete material property.
ScaleFactorAge: This value multiplies the stiffness (modulus of elasticity) computed with age for the material during a time-dependent analysis. It has no effect for load cases that do not consider time-dependent effects, or for materials that do not consider time-dependent age effects. The default value is unity, and the specified value must be positive.
ScaleFactorCreep: This value multiplies the creep coefficient, and hence the creep strain, computed for the material during a time-dependent analysis. It has no effect for load cases that do not consider time-dependent effects, or for materials that do not consider creep effects. The default value is unity, and the specified value must be positive.
ScaleFactorShrinkage: This value multiplies the shrinkage strain computed for the material during a time-dependent analysis. It has no effect for load cases that do not consider time-dependent effects, or for materials that do not consider shrinkage effects. The default value is unity, and the specified value must be positive.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been previously defined for the material.
        """

        all_args = [Name, ScaleFactorAge, ScaleFactorCreep, ScaleFactorShrinkage, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.TimeDep.SetConcreteScaleFactors(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetConcreteScaleFactors" failed')
        
        return ret

    def SetTendonCEBFIP90(self, Name = None, ConsiderSteelRelaxation = None, CEBFIPClass = None, UseSeries = None, NumberSeriesTerms = None, Temp = None):
        """
This function sets the time dependent CEB FIP-90 material property data for tendon materials.
The function returns zero if the data is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing tendon material property.
ConsiderSteelRelaxation: If this item is True, time dependence is considered for tendon steel relaxation.
CEBFIPClass: This is either 1 or 2, indicating the CEB FIP-90 class. This item applies only when ConsiderSteelRelaxation = True.
UseSeries: This is either 0 or 1, indicating the steel relaxation integration type.
0 = Full integration
1 = Dirichlet series

This item applies only when ConsiderSteelRelaxation = True.
NumberSeriesTerms: This is the number of series terms used when integrating based on a Dirichlet series. This item applies only when ConsiderSteelRelaxation = True and UseSeries = 1.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data applies. The temperature must have been previously defined for the material.
        """

        all_args = [Name, ConsiderSteelRelaxation, CEBFIPClass, UseSeries, NumberSeriesTerms, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.TimeDep.SetTendonCEBFIP90(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTendonCEBFIP90" failed')
        
        return ret

    def SetTendonScaleFactors(self, Name = None, ScaleFactorRelaxation = None, Temp = None):
        """
This function sets scale factors for the time-dependent material property data for tendon materials. If this function is not called, default values of unity are assumed for all scale factors.
The function returns zero if the data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing tendon material property.
ScaleFactorRelaxation: This value multiplies the relaxation coefficient, and hence the relaxation strain, computed for the material during a time-dependent analysis. It has no effect for load cases that do not consider time-dependent effects, or for materials that do not consider relaxation effects. The default value is unity, and the specified value must be positive.
Temp: This item applies only if the specified material has properties that are temperature dependent. That is, it applies only if properties are specified for the material at more than one temperature.
This item is the temperature at which the specified data is to be retrieved. The temperature must have been previously defined for the material.
        """

        all_args = [Name, ScaleFactorRelaxation, Temp]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropMaterial.TimeDep.SetTendonScaleFactors(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTendonScaleFactors" failed')
        
        return ret

class PropRebar:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing rebar 
 property.
The function returns zero if the new name is successfully 
 applied; otherwise it returns a nonzero value.

Name: The existing name of a defined rebar property.
NewName: The new name for the rebar property.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropRebar.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of defined rebar 
 properties in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropRebar.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified rebar property.
The function returns zero if the property is successfully 
 deleted; otherwise it returns a nonzero value. It returns an error if 
 the specified property can not be deleted, for example, if it is assigned 
 to an existing object.

Name: The name of an existing rebar property.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropRebar.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined rebar 
 properties in the model.
The function returns zero if the names are successfully 
 retrieved; otherwise it returns nonzero.

NumberNames: The number of rebar property names retrieved by the 
 program.
MyName: This is a one-dimensional array of rebar property names. 
 The MyName array is created as a dynamic, zero-based, array by the API 
 user:
Dim MyName() 
 as String
The array is dimensioned to (NumberNames - 1) inside 
 the SAP2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropRebar.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetProp(self, Name = None, Area = None, Diameter = None):
        """
This function retrieves rebar property definition data.
The function returns zero if the property data is successfully 
 retrieved; otherwise it returns a nonzero value.

Name: The name of an existing rebar property.
Area: The cross-sectional area of the rebar. [L2]
Diameter: The diameter of the rebar. [L]
        """

        all_args = [Name, Area, Diameter]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropRebar.GetProp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProp" failed')
        
        return ret

    def SetProp(self, Name = None, Area = None, Diameter = None):
        """
This function defines a rebar property.
The function returns zero if the property is successfully 
 defined; otherwise it returns a nonzero value.

Name: The name of an existing or new rebar property. If this 
 is an existing property, that property is modified; otherwise, a new property 
 is added.
Area: The cross-sectional area of the rebar. [L2]
Diameter: The diameter of the rebar. [L]
        """

        all_args = [Name, Area, Diameter]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropRebar.SetProp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetProp" failed')
        
        return ret

class PropSolid:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing solid property.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined solid property.
NewName: The new name for the solid property.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropSolid.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of defined solid properties in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropSolid.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified solid property.
The function returns zero if the property is successfully deleted; otherwise it returns a nonzero value. It returns an error if the specified property can not be deleted, for example, if it is assigned to an existing object.

Name: The name of an existing solid property.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropSolid.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined solid properties in the model.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of solid property names retrieved by the program.
MyName: This is a one-dimensional array of solid property names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String
The array is dimensioned to (NumberNames - 1) inside the SAP2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropSolid.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetProp(self, Name = None, MatProp = None, a = None, b = None, c = None, Incompatible = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves solid property definition data.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid property.
MatProp: The name of the material property assigned to the solid property.
a: The material angle A. [deg]
b: The material angle B. [deg]
c: The material angle C. [deg]
Incompatible: If this item is True, incompatible bending modes are included in the stiffness formulation. In general, incompatible modes significantly improve the bending behavior of the object.
Color: The display color assigned to the property.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, MatProp, a, b, c, Incompatible, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropSolid.GetProp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProp" failed')
        
        return ret

    def SetProp(self, Name = None, MatProp = None, a = None, b = None, c = None, Incompatible = None, Color = None, Notes = None, GUID = None):
        """
This function defines a solid property.
The function returns zero if the property is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new solid property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property assigned to the solid property.
a: The material angle A. [deg]
b: The material angle B. [deg]
c: The material angle C. [deg]
Incompatible: If this item is True, incompatible bending modes are included in the stiffness formulation. In general, incompatible modes significantly improve the bending behavior of the object.
Color: The display color assigned to the property. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, MatProp, a, b, c, Incompatible, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropSolid.SetProp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetProp" failed')
        
        return ret

class PropTendon:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeName(self, Name = None, NewName = None):
        """
This function changes the name of an existing tendon property.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined tendon property.
NewName: The new name for the tendon property.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropTendon.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of defined tendon properties in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropTendon.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def Delete(self, Name = None):
        """
The function deletes a specified tendon property.
The function returns zero if the property is successfully deleted; otherwise it returns a nonzero value. It returns an error if the specified property can not be deleted, for example, if it is assigned to an existing object.

Name: The name of an existing tendon property.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropTendon.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined tendon properties in the model.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of tendon property names retrieved by the program.
MyName: This is a one-dimensional array of tendon property names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String
The array is dimensioned to (NumberNames - 1) inside the SAP2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropTendon.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetProp(self, Name = None, MatProp = None, ModelingOption = None, Area = None, Color = None, Notes = None, GUID = None):
        """
This function retrieves tendon property definition data.
The function returns zero if the property data is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing tendon property.
MatProp: The name of the material property assigned to the tendon property.
ModelingOption: This is either 1 or 2, indicating the tendon modeling option.
1 = Model tendon as loads
2 = Model tendon as elements
Area: The cross-sectional area of the tendon. [L2]
Color: The display color assigned to the property.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property.
        """

        all_args = [Name, MatProp, ModelingOption, Area, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropTendon.GetProp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProp" failed')
        
        return ret

    def SetProp(self, Name = None, MatProp = None, ModelingOption = None, Area = None, Color = None, Notes = None, GUID = None):
        """
This function defines a tendon property.
The function returns zero if the property is successfully defined; otherwise it returns a nonzero value.

Name: The name of an existing or new tendon property. If this is an existing property, that property is modified; otherwise, a new property is added.
MatProp: The name of the material property assigned to the tendon property.
ModelingOption: This is either 1 or 2, indicating the tendon modeling option.
1 = Model tendon as loads
2 = Model tendon as elements
Area: The cross-sectional area of the tendon. [L2]
Color: The display color assigned to the property. If Color is specified as -1, the program will automatically assign a color.
Notes: The notes, if any, assigned to the property.
GUID: The GUID (global unique identifier), if any, assigned to the property. If this item is input as Default, the program assigns a GUID to the property.
        """

        all_args = [Name, MatProp, ModelingOption, Area, Color, Notes, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PropTendon.SetProp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetProp" failed')
        
        return ret

class SectCut:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def AddQuad(self, Name = None, GroupName = None, X = None, Y = None, Z = None):
        """
This function adds a new quadrilateral to a section cut defined by quadrilaterals.
The function returns zero if the quadrilateral is successfully, otherwise it returns a nonzero value.

Name: The name of an existing section cut.
GroupName: 
X: This is an array of four X coordinates, one for each of the four points defining the quadrilateral.
Y: This is an array of four Y coordinates, one for each of the four points defining the quadrilateral.
Z: This is an array of four Z coordinates, one for each of the four points defining the quadrilateral.
        """

        all_args = [Name, GroupName, X, Y, Z]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.AddQuad(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddQuad" failed')
        
        return ret

    def GetCutInfo(self):
        """
This function gets basic information about an existing section cut.
The function returns zero if the section cut information is successfully obtained, otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.GetCutInfo(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCutInfo" failed')
        
        return ret

    def GetLocalAxesAnalysis(self, Name = None, Z = None, Y = None, X = None, IsAdvanced = None):
        """
This function gets the local axes angles for an existing section cut whose result type is Analysis.
The function returns zero if the angles are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing section cut.
Z: The Rotation about the Z axis.
Y: The rotation about the Y' axis where Y' is the orientation of the Y axis after rotation about the Z axis.
X: The rotation about the X'' axis where X'' is the orientation of the X axis after rotation about the Z axis and about the Y' axis.
IsAdvanced: Indicates if advanced local axes are specified.
        """

        all_args = [Name, Z, Y, X, IsAdvanced]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.GetLocalAxesAnalysis(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxesAnalysis" failed')
        
        return ret

    def GetLocalAxesAngleDesign(self, Name = None, Angle = None):
        """
This function gets the local axes angle for section cuts whose result type is Design (Wall, Spandrel or Slab).
The function returns zero if the angle is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing section cut.
Angle: For design local axes orientation type wall this is the angle from the global X to the local 2 axis.For orientation types spandrel and slab it is the angle from the global X to the local 1 axis.
        """

        all_args = [Name, Angle]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.GetLocalAxesAngleDesign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxesAngleDesign" failed')
        
        return ret

    def GetLocalAxesAdvancedAnalysis(self):
        """
This function gets the advanced local axes data for an existing section cut whose result type is Analysis.
The function returns zero if the data is successfully retrieved, otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.GetLocalAxesAdvancedAnalysis(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxesAdvancedAnalysis" failed')
        
        return ret

    def GetQuad(self):
        """
This function returns the coordinates of a quadrilateral cutting plane in a section cut defined by quadrilaterals.
The function returns zero if the coordinates are successfully returned, otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.GetQuad(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetQuad" failed')
        
        return ret

    def GetResultLocation(self, Name = None, IsDefault = None, X = None, Y = None, Z = None):
        """
This function gets the results location for an existing section cut.
The function returns zero if the result location is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing section cut.
IsDefault: Indicates if the section cut results are reported at the default location.If so, the X, Y and Z items are ignored.
X: The X coordinate of the section cut result location when it is not default
Y: The Y coordinate of the section cut result location when it is not default
Z: The Z coordinate of the section cut result location when it is not default
        """

        all_args = [Name, IsDefault, X, Y, Z]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.GetResultLocation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetResultLocation" failed')
        
        return ret

    def GetResultsSide(self, Name = None, Side = None):
        """
This function gets the side of the elements from which results are obtained.
The function returns zero if the side is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing section cut.
Side: This item is either 1 or 2 and indicates the side of the elements from which section cut results are obtained.
For section cuts defined from quadrilaterals with an Analysis result type:
1 = Positive 3-axis side of quadrilateral
2 = Negative 3-axis side of quadrilateral

For section cuts with a Design Wall result type:
1 = Top
2 = Bottom

For section cuts with a Design Spandrel or Design Slab result type:
1 = Right
2 = Left
        """

        all_args = [Name, Side]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.GetResultsSide(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetResultsSide" failed')
        
        return ret

    def SetByGroup(self, Name = None, GroupName = None, MyType = None):
        """
This function adds a new section cut defined by a group to the model or reinitializes an existing section cut to be defined by a group.
The function returns zero if the section cut is successfully added or initialized, otherwise it returns a nonzero value.

Name: The section cut name. If a section cut with this name already exists then the section cut is reinitialized with the new data.All previous data assigned to the section cut is lost. If a section cut with this name does not exist then a new section cut is added.
GroupName: The name of the group on which the section cut is based.
MyType: This is either 1, 2, 3 or 4 indicating the result type of the section cut.
1 = Analysis
2 = Design Wall
3 = Design Spandrel
4 = Design Slab
        """

        all_args = [Name, GroupName, MyType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.SetByGroup(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetByGroup" failed')
        
        return ret

    def SetByQuad(self, Name = None, GroupName = None, MyType = None, X = None, Y = None, Z = None):
        """
This function adds a new section cut defined by a quadrilateral to the model or reinitializes an existing section cut to be defined by a quadrilateral.
The function returns zero if the section cut is successfully added or initialized, otherwise it returns a nonzero value.

Name: The section cut name. If a section cut with this name already exists then the section cut is reinitialized with the new data.All previous data assigned to the section cut is lost. If a section cut with this name does not exist then a new section cut is added.
GroupName: The name of the group associated with the section cut.
MyType: This is either 1, 2, 3 or 4 indicating the result type of the section cut.
1 = Analysis
2 = Design Wall
3 = Design Spandrel
4 = Design Slab
X: This is an array of four X coordinates, one for each of the four points defining the quadrilateral.
Y: This is an array of four Y coordinates, one for each of the four points defining the quadrilateral.
Z: This is an array of four Z coordinates, one for each of the four points defining the quadrilateral.
        """

        all_args = [Name, GroupName, MyType, X, Y, Z]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.SetByQuad(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetByQuad" failed')
        
        return ret

    def SetLocalAxesAnalysis(self, Name = None, Z = None, Y = None, X = None):
        """
This function sets the local axes angles for an existing section cut whose result type is Analysis.
The function returns zero if the angles are successfully set, otherwise it returns a nonzero value.

Name: The name of an existing section cut.
Z: The Rotation about the Z axis.
Y: The rotation about the Y' axis where Y' is the orientation of the Y axis after rotation about the Z axis.
X: The rotation about the X'' axis where X'' is the orientation of the X axis after rotation about the Z axis and about the Y' axis.
        """

        all_args = [Name, Z, Y, X]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.SetLocalAxesAnalysis(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxesAnalysis" failed')
        
        return ret

    def SetLocalAxesAdvancedAnalysis(self, Name = None, Active = None, AxVectOpt = None, PlVectOpt = None, AxCSys = None, PlCSys = None, AxDir = None, PlDir = None, AxPt = None, PlPt = None, AxVect = None, PlVect = None, Plane2 = None):
        """
This function sets the advanced local axes data for an existing section cut whose result type is Analysis.
The function returns zero if the data is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing section cut.
Active: This is True if advanced local axes exist.
AxVectOpt: This is 1, 2 or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector

PlVectOpt: This is 1, 2 or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector

AxCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
PlCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
AxDir: This is an array dimensioned to 1 (2 integers), indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB

PlDir: This is an array dimensioned to 1 (2 integers), indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB

AxPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
PlPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
AxVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
PlVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
Plane2: This is 12, 13, 21, 23, 31 or 32, indicating that the local plane determined by the plane reference vector is the 1-2, 1-3, 2-1, 2-3, 3-1, 0r 3-2 plane. This item applies only when the Active item is True.
        """

        all_args = [Name, Active, AxVectOpt, PlVectOpt, AxCSys, PlCSys, AxDir, PlDir, AxPt, PlPt, AxVect, PlVect, Plane2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.SetLocalAxesAdvancedAnalysis(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxesAdvancedAnalysis" failed')
        
        return ret

    def SetLocalAxesAngleDesign(self, Name = None, Angle = None):
        """
This function sets the local axes angle for section cuts whose result type is Design (Wall, Spandrel or Slab).
The function returns zero if the angle is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing section cut.
Angle: For design local axes orientation type wall this is the angle from the global X to the local 2 axis.For orientation types spandrel and slab it is the angle from the global X to the local 1 axis.
        """

        all_args = [Name, Angle]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.SetLocalAxesAngleDesign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxesAngleDesign" failed')
        
        return ret

    def SetResultLocation(self, Name = None, IsDefault = None, X = None, Y = None, Z = None):
        """
This function sets the results location for an existing section cut.
The function returns zero if the result location is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing section cut.
IsDefault: Indicates if the section cut results are reported at the default location.If so, the X, Y and Z items are ignored.
X: The X coordinate of the section cut result location when it is not default
Y: The Y coordinate of the section cut result location when it is not default
Z: The Z coordinate of the section cut result location when it is not default
        """

        all_args = [Name, IsDefault, X, Y, Z]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.SetResultLocation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetResultLocation" failed')
        
        return ret

    def SetResultsSide(self, Name = None, Side = None):
        """
This function sets the side of the elements from which results are obtained.
The function returns zero if the side is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing section cut.
Side: This item is either 1 or 2 and indicates the side of the elements from which section cut results are obtained.
For section cuts defined from quadrilaterals with an Analysis result type:
1 = Positive 3-axis side of quadrilateral
2 = Negative 3-axis side of quadrilateral

For section cuts with a Design Wall result type:
1 = Top
2 = Bottom

For section cuts with a Design Spandrel or Design Slab result type:
1 = Right
2 = Left
        """

        all_args = [Name, Side]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SectCut.SetResultsSide(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetResultsSide" failed')
        
        return ret

class DesignAluminum:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.AA_2015 = AA_2015(strict, api)
        self.AA_2020 = AA_2020(strict, api)
        self.AA_ASD_2000 = AA_ASD_2000(strict, api)
        self.AA_LRFD_2000 = AA_LRFD_2000(strict, api)
        self.Eurocode_9_2007 = Eurocode_9_2007(strict, api)

    def DeleteResults(self):
        """
This function deletes all aluminum frame design results.
The function returns zero if the results are successfully deleted; otherwise it returns a nonzero value.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.DeleteResults(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteResults" failed')
        
        return ret

    def GetCode(self, CodeName = None):
        """
This function retrieves the aluminum design code.
The function returns zero if the code is successfully retrieved; otherwise it returns a nonzero value.

CodeName: This is one of the following aluminum design code names.
AA-ASD 2000
AA-LRFD 2000
        """

        all_args = [CodeName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.GetCode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCode" failed')
        
        return ret

    def GetComboAutoGenerate(self, AutoGenerate = None):
        """
This function retrieves the value of the automatically generated code-based design load combinations option for aluminum frame design.
The function returns zero if the options are successfully set; otherwise it returns a nonzero value.

AutoGenerate: If this item is True, the option to automatically generate code-based design load combinations for aluminum frame design is turned on. If it is False, the option is turned off.
        """

        all_args = [AutoGenerate]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.GetComboAutoGenerate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetComboAutoGenerate" failed')
        
        return ret

    def GetComboDeflection(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of all load combinations selected as design combinations for aluminum deflection design.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of load combinations selected as design combinations for aluminum deflection design.
MyName: This is an array that includes the name of each response combination selected as a design combination for aluminum deflection design.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.GetComboDeflection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetComboDeflection" failed')
        
        return ret

    def GetComboStrength(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of all load combinations selected as design combinations for aluminum strength design.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of load combinations selected as design combinations for aluminum strength design.
MyName: This is an array that includes the name of each response combination selected as a design combination for aluminum strength design.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.GetComboStrength(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetComboStrength" failed')
        
        return ret

    def GetDesignSection(self, Name = None, PropName = None):
        """
This function retrieves the design section for a specified aluminum frame object.
The function returns zero if the section is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a aluminum frame design procedure.
PropName: The name of the design section for the specified frame object.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.GetDesignSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDesignSection" failed')
        
        return ret

    def GetGroup(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of all groups selected for aluminum design.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of groups selected for aluminum design.
MyName: This is an array that includes the name of each group selected for aluminum design.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.GetGroup(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGroup" failed')
        
        return ret

    def GetResultsAvailable(self):
        """
The function returns True if the aluminum frame design results are available, otherwise False.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.GetResultsAvailable(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetResultsAvailable" failed')
        
        return ret

    def GetSummaryResults(self, Name = None, NumberItems = None, FrameName = None, Ratio = None, RatioType = None, Location = None, ComboName = None, ErrorSummary = None, WarningSummary = None, ItemType = None):
        """
This function retrieves summary results for aluminum design.
The function returns zero if the results are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The number of frame objects for which results are obtained.
FrameName: This is an array that includes each frame object name for which results are obtained.
Ratio: This is an array that includes the controlling stress or capacity ratio for each frame object.
RatioType: This is an array that includes 1, 3 or 4, indicating the controlling stress or capacity ratio type for each frame object.
1 = PMM
3 = Major shear
4 = Minor shear
Location: This is an array that includes the distance from the I-end of the frame object to the location where the controlling stress or capacity ratio occurs. [L]
ComboName: This is an array that includes the name of the design combination for which the controlling stress or capacity ratio occurs.
ErrorSummary: This is an array that includes the design error messages for the frame object, if any.
WarningSummary: This is an array that includes the design warning messages for the frame object, if any.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the design results are retrieved for the frame object specified by the Name item.
If this item is Group, the design results are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the design results are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, Ratio, RatioType, Location, ComboName, ErrorSummary, WarningSummary, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.GetSummaryResults(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSummaryResults" failed')
        
        return ret

    def ResetOverwrites(self):
        """
This function resets all aluminum frame design overwrites to default values.
The function returns zero if the overwrites are successfully reset; otherwise it returns a nonzero value.
The function will fail if no aluminum frame objects are present.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.ResetOverwrites(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ResetOverwrites" failed')
        
        return ret

    def SetAutoSelectNull(self, Name = None, ItemType = None):
        """
This function removes the auto select section assignments from all specified frame objects that have a aluminum frame design procedure.
The function returns zero if the auto select section assignments are successfully removed; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.SetAutoSelectNull(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAutoSelectNull" failed')
        
        return ret

    def SetCode(self, CodeName = None):
        """
This function sets the aluminum design code.
The function returns zero if the code is successfully set; otherwise it returns a nonzero value.

CodeName: This is one of the following aluminum design code names.
AA-ASD 2000
AA-LRFD 2000
        """

        all_args = [CodeName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.SetCode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCode" failed')
        
        return ret

    def SetComboAutoGenerate(self, AutoGenerate = None):
        """
This function turns on or off the option to automatically generate code-based design load combinations for aluminum frame design.
The function returns zero if the options are successfully set; otherwise it returns a nonzero value.

AutoGenerate: If this item is True, the option to automatically generate code-based design load combinations for aluminum frame design is turned on. If it is False, the option is turned off.
        """

        all_args = [AutoGenerate]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.SetComboAutoGenerate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetComboAutoGenerate" failed')
        
        return ret

    def SetComboDeflection(self, Name = None, Selected = None):
        """
This function selects or deselects a load combination for aluminum deflection design.
The function returns zero if the selection status is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing load combination.
Selected: If this item is True, the specified load combination is selected as a design combination for aluminum deflection design. If it is False, the combination is not selected for aluminum deflection design.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.SetComboDeflection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetComboDeflection" failed')
        
        return ret

    def SetComboStrength(self, Name = None, Selected = None):
        """
This function selects or deselects a load combination for aluminum strength design.
The function returns zero if the selection status is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing load combination.
Selected: If this item is True, the specified load combination is selected as a design combination for aluminum strength design. If it is False, the combination is not selected for aluminum strength design.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.SetComboStrength(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetComboStrength" failed')
        
        return ret

    def SetDesignSection(self, Name = None, PropName = None, LastAnalysis = None, ItemType = None):
        """
This function modifies the design section for all specified frame objects that have a aluminum frame design procedure.
The function returns zero if the design section is successfully modified; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
PropName: The name of an existing frame section property to be used as the design section for the specified frame objects. This item applies only when LastAnalysis = False.
LastAnalysis: If this item is True, the design section for the specified frame objects is reset to the last analysis section for the frame object. If it is False, the design section is set to that specified by PropName.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, LastAnalysis, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.SetDesignSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDesignSection" failed')
        
        return ret

    def SetGroup(self, Name = None, Selected = None):
        """
This function selects or deselects a group for aluminum design.
The function returns zero if the selection status is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing group.
Selected: If this item is True, the specified group is selected as a design group for aluminum design. If it is False, the group is not selected for aluminum design.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.SetGroup(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGroup" failed')
        
        return ret

    def StartDesign(self):
        """
This function starts the aluminum frame design.
The function returns zero if the aluminum frame design is successfully started; otherwise it returns a nonzero value.
The function will fail if no aluminum frame objects are present. It will also fail if analysis results are not available.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.StartDesign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"StartDesign" failed')
        
        return ret

    def VerifyPassed(self, NumberItems = None, n1 = None, n2 = None, MyName = None):
        """
This function retrieves the names of the frame objects that did not pass the design check or have not yet been checked, if any.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of aluminum frame objects that did not pass the design check or have not yet been checked.
n1: The number of aluminum frame objects that did not pass the design check.
n2: The number of aluminum frame objects that have not yet been checked.
MyName: This is an array that includes the name of each frame object that did not pass the design check or has not yet been checked.
        """

        all_args = [NumberItems, n1, n2, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.VerifyPassed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"VerifyPassed" failed')
        
        return ret

    def VerifySections(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of the frame objects that have different analysis and design sections, if any.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of frame objects that have different analysis and design sections.
MyName: This is an array that includes the name of each frame object that has different analysis and design sections.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.VerifySections(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"VerifySections" failed')
        
        return ret

class AA_2015:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of an aluminum design 
 overwrite item.
The function returns zero if the item is successfully 
 retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a aluminum frame design 
 procedure.
Item: This is an integer between 1 and 19, inclusive, indicating 
 the overwrite item considered.
1 = Live load reduction 
 factor
2 = Unbraced length ratio, 
 Major
3 = Unbraced length ratio, 
 Minor 
4 = Unbraced length, Lateral 
 Torsional Buckling (LTB)
5 = Effective length factor, 
 K Major
6 = Effective length factor, 
 K Minor
7 = Effective length factor, 
 K LTB
8 = Bending coefficient, 
 Cb
9 = Buckling constant 
 for compression, k1
10 = Buckling constant 
 for compression, k2
11 = Buckling constant 
 for bending, k1
12 = Buckling constant 
 for bending, k2
13 = Safety coefficient, 
 kt
14 = Bending coefficient, 
 C1
15 = Bending coefficient, 
 C2
16 = Net area over gross 
 area ratio
17 = Buckling constant, 
 Ct
18 = Coordinate of load 
 application, Za
19 = Demand/Capacity 
 ratio limit

Value: The value of the considered overwrite item.
1 = Live load reduction 
 factor
Value >= 0; 0 means 
 use a program determined value.

2 = Unbraced length ratio, 
 Major
Value >= 0; 0 means 
 use program determined value.

3 = Unbraced length ratio, 
 Minor 
Value >= 0; 0 means 
 use program determined value.

4 = Unbraced length ratio, 
 Lateral Torsional Buckling 
Value >= 0; 0 means 
 use program determined value.

5 = Effective length factor, 
 K Major
Value >= 0; 0 means 
 use program determined value.

6 = Effective length factor, 
 K Minor
Value >= 0; 0 means 
 use program determined value.

7 = Effective length factor, 
 K LTB
Value >= 0; 0 means 
 use program determined value.

8 = Bending coefficient, 
 Cb
Value >= 0; 0 means 
 use program determined value.

9 = Buckling constant 
 for compression, k1
Value >= 0; 0 means 
 use program determined value.

10 = Buckling constant 
 for compression, k2
Value >= 0; 0 means 
 use program determined value.

11 = Buckling constant 
 for bending, k1
Value >= 0; 0 means 
 use program determined value.

12 = Buckling constant 
 for bending, k2
Value >= 0; 0 means 
 use program determined value.

13 = Safety coefficient, 
 kt
Value >= 0; 0 means 
 use program determined value.

14 = Bending coefficient, 
 C1
Value >= 0; 0 means 
 use program determined value.

15 = Bending coefficient, 
 C2
Value >= 0; 0 means 
 use program determined value.

16 = Net area over gross 
 area ratio
Value >= 0; 0 means 
 use program determined value.

17 = Buckling constant, 
 Ct
Value >= 0; 0 means 
 use program determined value. 

18 = Coordinate of load 
 application, Za
Value >= 0; 0 means 
 use program determined value.

19 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program 
 determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_2015.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of an aluminum design 
 preference item.
The function returns zero if the item is successfully 
 retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 13, inclusive, indicating 
 the preference item considered.
1 = Demand/capacity ratio 
 limit
2 = Design Provision
3 = Lateral Factor
4 = Use Lateral Factor
5 = Bridge Type Structure
6 = PhiTy or OmegaTy safety 
 factor
7 = PhiTr or OmegaTr safety 
 factor
8 = PhiC or OmegaC safety 
 factor
9 = PhiBo or OmegaBo safetyfactor
10 = PhiBr or OmegaBr 
 safetyfactor
11 = PhicVo or OmegaVo 
 safetyfactor
12 = PhiVr or OmegaVr 
 safetyfactor
13 = Time history design

Value: The value of the considered preference item.
1 = Demand/capacity ratio 
 limit
Value > 0

2 = Design Provision
1 = LRFD
2 = ASD

3 = Lateral Factor
Value > 0

4 = Use Lateral Factor
1 = No
2 = Yes

5 = Bridge Type Structure
1 = No
2 = Yes

6 = PhiTy or OmegaTy safety 
 factor
PhiTy: 0 
 < Value ≤ 1 
OmegaTy: 1 
 ≤ Value

7 = PhiTr or OmegaTr safety 
 factor
PhiTr: 0 
 < Value ≤ 1 
OmegaTr: 1 
 ≤ Value

8 = PhiC or OmegaC safety 
 factor
PhiC: 0 
 < Value ≤ 1 
OmegaC: 1 
 ≤ Value

9 = PhiBo or OmegaBo safetyfactor
PhiBo: 0 
 < Value ≤ 1 
OmegaBo: 1 
 ≤ Value

10 = PhiBr or OmegaBr 
 safetyfactor
PhiBr: 0 
 < Value ≤ 1 
OmegaBr: 1 
 ≤ Value

11 = PhicVo or OmegaVo 
 safetyfactor
PhiVo: 0 
 < Value ≤ 1 
OmegaVo: 1 
 ≤ Value

12 = PhiVr or OmegaVr 
 safetyfactor
PhiVr: 0 
 < Value ≤ 1 
OmegaVr: 1 
 ≤ Value

13 = Time history design
1 = Envelopes
2 = Step-by-step

If Design Provision is 1 (LRFD), the values of items 
 6 through 12 will come from the Phi factors. Otherwise, if Design Provision 
 is 2 (ASD) , the values of items 6 through 12 will come from the Omega 
 factors .
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_2015.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of an aluminum design overwrite 
 item.
The function returns zero if the item is successfully 
 set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending 
 on the value of the ItemType item.
Item: This is an integer between 1 and 19, inclusive, indicating 
 the overwrite item considered.
1 = Live load reduction 
 factor
2 = Unbraced length ratio, 
 Major
3 = Unbraced length ratio, 
 Minor 
4 = Unbraced length, Lateral 
 Torsional Buckling (LTB)
5 = Effective length factor, 
 K Major
6 = Effective length factor, 
 K Minor
7 = Effective length factor, 
 K LTB
8 = Bending coefficient, 
 Cb
9 = Buckling constant 
 for compression, k1
10 = Buckling constant 
 for compression, k2
11 = Buckling constant 
 for bending, k1
12 = Buckling constant 
 for bending, k2
13 = Safety coefficient, 
 kt
14 = Bending coefficient, 
 C1
15 = Bending coefficient, 
 C2
16 = Net area over gross 
 area ratio
17 = Buckling constant, 
 Ct
18 = Coordinate of load 
 application, Za
19 = Demand/Capacity 
 ratio limit

Value: The value of the considered overwrite item.
1 = Live load reduction 
 factor
Value >= 0; 0 means 
 use a program determined value.

2 = Unbraced length ratio, 
 Major
Value >= 0; 0 means 
 use program determined value.

3 = Unbraced length ratio, 
 Minor 
Value >= 0; 0 means 
 use program determined value.

4 = Unbraced length ratio, 
 Lateral Torsional Buckling 
Value >= 0; 0 means 
 use program determined value.

5 = Effective length factor, 
 K Major
Value >= 0; 0 means 
 use program determined value.

6 = Effective length factor, 
 K Minor
Value >= 0; 0 means 
 use program determined value.

7 = Effective length factor, 
 K LTB
Value >= 0; 0 means 
 use program determined value.

8 = Bending coefficient, 
 Cb
Value >= 0; 0 means 
 use program determined value.

9 = Buckling constant 
 for compression, k1
Value >= 0; 0 means 
 use program determined value.

10 = Buckling constant 
 for compression, k2
Value >= 0; 0 means 
 use program determined value.

11 = Buckling constant 
 for bending, k1
Value >= 0; 0 means 
 use program determined value.

12 = Buckling constant 
 for bending, k2
Value >= 0; 0 means 
 use program determined value.

13 = Safety coefficient, 
 kt
Value >= 0; 0 means 
 use program determined value.

14 = Bending coefficient, 
 C1
Value >= 0; 0 means 
 use program determined value.

15 = Bending coefficient, 
 C2
Value >= 0; 0 means 
 use program determined value.

16 = Net area over gross 
 area ratio
Value >= 0; 0 means 
 use program determined value.

17 = Buckling constant, 
 Ct
Value >= 0; 0 means 
 use program determined value. 

18 = Coordinate of load 
 application, Za
Value >= 0; 0 means 
 use program determined value. 

19 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.

ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the 
 frame object specified by the Name item.
If this item is Group, the assignment is made to all 
 frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made 
 to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_2015.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of an aluminum design preference 
 item.
The function returns zero if the item is successfully 
 set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 13, inclusive, indicating 
 the preference item considered.
1 = Demand/capacity ratio 
 limit
2 = Design Provision
3 = Lateral Factor
4 = Use Lateral Factor
5 = Bridge Type Structure
6 = PhiTy or OmegaTy safety 
 factor
7 = PhiTr or OmegaTr safety 
 factor
8 = PhiC or OmegaC safety 
 factor
9 = PhiBo or OmegaBo safetyfactor
10 = PhiBr or OmegaBr 
 safetyfactor
11 = PhicVo or OmegaVo 
 safetyfactor
12 = PhiVr or OmegaVr 
 safetyfactor
13 = Time history design

Value: The value of the considered preference item.
1 = Demand/capacity ratio 
 limit
Value > 0

2 = Design Provision
1 = LRFD
2 = ASD

3 = Lateral Factor
Value > 0

4 = Use Lateral Factor
1 = No
2 = Yes

5 = Bridge Type Structure
1 = No
2 = Yes

6 = PhiTy or OmegaTy safety 
 factor
PhiTy: 0 
 < Value ≤ 1 
OmegaTy: 1 
 ≤ Value

7 = PhiTr or OmegaTr safety 
 factor
PhiTr: 0 
 < Value ≤ 1 
OmegaTr: 1 
 ≤ Value

8 = PhiC or OmegaC safety 
 factor
PhiC: 0 
 < Value ≤ 1 
OmegaC: 1 
 ≤ Value

9 = PhiBo or OmegaBo safetyfactor
PhiBo: 0 
 < Value ≤ 1 
OmegaBo: 1 
 ≤ Value

10 = PhiBr or OmegaBr 
 safetyfactor
PhiBr: 0 
 < Value ≤ 1 
OmegaBr: 1 
 ≤ Value

11 = PhicVo or OmegaVo 
 safetyfactor
PhiVo: 0 
 < Value ≤ 1 
OmegaVo: 1 
 ≤ Value

12 = PhiVr or OmegaVr 
 safetyfactor
PhiVr: 0 
 < Value ≤ 1 
OmegaVr: 1 
 ≤ Value

13 = Time history design
1 = Envelopes
2 = Step-by-step

If Design Provision is 1 (LRFD), the Phi factors will 
 be set to have the values of items 6 through 12. Otherwise, if Design 
 Provision is 2 (ASD), the Omega factors will be set to have the values 
 of items 6 through 12.
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_2015.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AA_2020:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of an aluminum design 
 overwrite item.
The function returns zero if the item is successfully 
 retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a aluminum frame design 
 procedure.
Item: This is an integer between 1 and 18, inclusive, indicating 
 the overwrite item considered.
1 = Live load reduction 
 factor
2 = Unbraced length ratio, 
 Major
3 = Unbraced length ratio, 
 Minor 
4 = Unbraced length, Lateral 
 Torsional Buckling (LTB)
5 = Effective length factor, 
 K Major
6 = Effective length factor, 
 K Minor
7 = Effective length factor, 
 K LTB
8 = Bending coefficient, 
 Cb
9 = Buckling constant 
 for compression, k1
10 = Buckling constant 
 for compression, k2
11 = Buckling constant 
 for bending, k1
12 = Buckling constant 
 for bending, k2
13 = Safety coefficient, 
 kt
14 = Bending coefficient, 
 C1
15 = Bending coefficient, 
 C2
16 = Net area over gross 
 area ratio
17 = Coordinate of load 
 application, Za
18 = Demand/Capacity 
 ratio limit

Value: The value of the considered overwrite item.
1 = Live load reduction 
 factor
Value >= 0; 0 means 
 use a program determined value.

2 = Unbraced length ratio, 
 Major
Value >= 0; 0 means 
 use program determined value.

3 = Unbraced length ratio, 
 Minor 
Value >= 0; 0 means 
 use program determined value.

4 = Unbraced length ratio, 
 Lateral Torsional Buckling 
Value >= 0; 0 means 
 use program determined value.

5 = Effective length factor, 
 K Major
Value >= 0; 0 means 
 use program determined value.

6 = Effective length factor, 
 K Minor
Value >= 0; 0 means 
 use program determined value.

7 = Effective length factor, 
 K LTB
Value >= 0; 0 means 
 use program determined value.

8 = Bending coefficient, 
 Cb
Value >= 0; 0 means 
 use program determined value.

9 = Buckling constant 
 for compression, k1
Value >= 0; 0 means 
 use program determined value.

10 = Buckling constant 
 for compression, k2
Value >= 0; 0 means 
 use program determined value.

11 = Buckling constant 
 for bending, k1
Value >= 0; 0 means 
 use program determined value.

12 = Buckling constant 
 for bending, k2
Value >= 0; 0 means 
 use program determined value.

13 = Safety coefficient, 
 kt
Value >= 0; 0 means 
 use program determined value.

14 = Bending coefficient, 
 C1
Value >= 0; 0 means 
 use program determined value.

15 = Bending coefficient, 
 C2
Value >= 0; 0 means 
 use program determined value.

16 = Net area over gross 
 area ratio
Value >= 0; 0 means 
 use program determined value.

17 = Coordinate of load 
 application, Za
Value >= 0; 0 means 
 use program determined value.

18 = Demand/capacity 
 ratio limit
Value >= 0; 0 means 
 use program determined value.

ProgDet: If this item is True, the specified value is program 
 determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_2020.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of an aluminum design 
 preference item.
The function returns zero if the item is successfully 
 retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 12, inclusive, indicating 
 the preference item considered.
1 = Demand/capacity ratio 
 limit
2 = Design Provision
3 = Lateral Factor
4 = Use Lateral Factor
5 = PhiTy or OmegaTy safety 
 factor
6 = PhiTr or OmegaTr safety 
 factor
7 = PhiC or OmegaC safety 
 factor
9 = PhiBo or OmegaBo safetyfactor
9 = PhiBr or OmegaBr safetyfactor
10 = PhicVo or OmegaVo 
 safetyfactor
11 = PhiVr or OmegaVr 
 safetyfactor
12 = Time history design

Value: The value of the considered preference item.
1 = Demand/capacity ratio 
 limit
Value > 0

2 = Design Provision
1 = LRFD
2 = ASD

3 = Lateral Factor
Value > 0

4 = Use Lateral Factor
1 = No
2 = Yes

5 = PhiTy or OmegaTy safety 
 factor
PhiTy: 0 
 < Value ≤ 1 
OmegaTy: 1 
 ≤ Value

6 = PhiTr or OmegaTr safety 
 factor
PhiTr: 0 
 < Value ≤ 1 
OmegaTr: 1 
 ≤ Value

7 = PhiC or OmegaC safety 
 factor
PhiC: 0 
 < Value ≤ 1 
OmegaC: 1 
 ≤ Value

8 = PhiBo or OmegaBo safetyfactor
PhiBo: 0 
 < Value ≤ 1 
OmegaBo: 1 
 ≤ Value

9 = PhiBr or OmegaBr safetyfactor
PhiBr: 0 
 < Value ≤ 1 
OmegaBr: 1 
 ≤ Value

10 = PhicVo or OmegaVo 
 safetyfactor
PhiVo: 0 
 < Value ≤ 1 
OmegaVo: 1 
 ≤ Value

11 = PhiVr or OmegaVr 
 safetyfactor
PhiVr: 0 
 < Value ≤ 1 
OmegaVr: 1 
 ≤ Value

12 = Time history design
1 = Envelopes
2 = Step-by-step

If Design Provision is 1 (LRFD), the values of items 
 5through 11 will come from the Phi factors. Otherwise, if Design Provision 
 is 2 (ASD) , the values of items 5 through 11 will come from the Omega 
 factors .
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_2020.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of an aluminum design overwrite 
 item.
The function returns zero if the item is successfully 
 set; otherwise it returns a nonzero value.

Name: The name of a frame object with a aluminum frame design 
 procedure.
Item: This is an integer between 1 and 18, inclusive, indicating 
 the overwrite item considered.
1 = Live load reduction 
 factor
2 = Unbraced length ratio, 
 Major
3 = Unbraced length ratio, 
 Minor 
4 = Unbraced length, Lateral 
 Torsional Buckling (LTB)
5 = Effective length factor, 
 K Major
6 = Effective length factor, 
 K Minor
7 = Effective length factor, 
 K LTB
8 = Bending coefficient, 
 Cb
9 = Buckling constant 
 for compression, k1
10 = Buckling constant 
 for compression, k2
11 = Buckling constant 
 for bending, k1
12 = Buckling constant 
 for bending, k2
13 = Safety coefficient, 
 kt
14 = Bending coefficient, 
 C1
15 = Bending coefficient, 
 C2
16 = Net area over gross 
 area ratio
17 = Coordinate of load 
 application, Za
18 = Demand/Capacity 
 ratio limit

Value: The value of the considered overwrite item.
1 = Live load reduction 
 factor
Value >= 0; 0 means 
 use a program determined value.

2 = Unbraced length ratio, 
 Major
Value >= 0; 0 means 
 use program determined value.

3 = Unbraced length ratio, 
 Minor 
Value >= 0; 0 means 
 use program determined value.

4 = Unbraced length ratio, 
 Lateral Torsional Buckling 
Value >= 0; 0 means 
 use program determined value.

5 = Effective length factor, 
 K Major
Value >= 0; 0 means 
 use program determined value.

6 = Effective length factor, 
 K Minor
Value >= 0; 0 means 
 use program determined value.

7 = Effective length factor, 
 K LTB
Value >= 0; 0 means 
 use program determined value.

8 = Bending coefficient, 
 Cb
Value >= 0; 0 means 
 use program determined value.

9 = Buckling constant 
 for compression, k1
Value >= 0; 0 means 
 use program determined value.

10 = Buckling constant 
 for compression, k2
Value >= 0; 0 means 
 use program determined value.

11 = Buckling constant 
 for bending, k1
Value >= 0; 0 means 
 use program determined value.

12 = Buckling constant 
 for bending, k2
Value >= 0; 0 means 
 use program determined value.

13 = Safety coefficient, 
 kt
Value >= 0; 0 means 
 use program determined value.

14 = Bending coefficient, 
 C1
Value >= 0; 0 means 
 use program determined value.

15 = Bending coefficient, 
 C2
Value >= 0; 0 means 
 use program determined value.

16 = Net area over gross 
 area ratio
Value >= 0; 0 means 
 use program determined value.

17 = Coordinate of load 
 application, Za
Value >= 0; 0 means 
 use program determined value.

18 = Demand/capacity 
 ratio limit
Value >= 0; 0 means 
 use program determined value.

ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the 
 frame object specified by the Name item.
If this item is Group, the assignment is made to all 
 frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made 
 to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_2020.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of an aluminum design preference 
 item.
The function returns zero if the item is successfully 
 set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 12, inclusive, indicating 
 the preference item considered.
1 = Demand/capacity ratio 
 limit
2 = Design Provision
3 = Lateral Factor
4 = Use Lateral Factor
5 = PhiTy or OmegaTy safety 
 factor
6 = PhiTr or OmegaTr safety 
 factor
7 = PhiC or OmegaC safety 
 factor
9 = PhiBo or OmegaBo safetyfactor
9 = PhiBr or OmegaBr safetyfactor
10 = PhicVo or OmegaVo 
 safetyfactor
11 = PhiVr or OmegaVr 
 safetyfactor
12 = Time history design

Value: The value of the considered preference item.
1 = Demand/capacity ratio 
 limit
Value > 0

2 = Design Provision
1 = LRFD
2 = ASD

3 = Lateral Factor
Value > 0

4 = Use Lateral Factor
1 = No
2 = Yes

5 = PhiTy or OmegaTy safety 
 factor
PhiTy: 0 
 < Value ≤ 1 
OmegaTy: 1 
 ≤ Value

6 = PhiTr or OmegaTr safety 
 factor
PhiTr: 0 
 < Value ≤ 1 
OmegaTr: 1 
 ≤ Value

7 = PhiC or OmegaC safety 
 factor
PhiC: 0 
 < Value ≤ 1 
OmegaC: 1 
 ≤ Value

8 = PhiBo or OmegaBo safetyfactor
PhiBo: 0 
 < Value ≤ 1 
OmegaBo: 1 
 ≤ Value

9 = PhiBr or OmegaBr safetyfactor
PhiBr: 0 
 < Value ≤ 1 
OmegaBr: 1 
 ≤ Value

10 = PhicVo or OmegaVo 
 safetyfactor
PhiVo: 0 
 < Value ≤ 1 
OmegaVo: 1 
 ≤ Value

11 = PhiVr or OmegaVr 
 safetyfactor
PhiVr: 0 
 < Value ≤ 1 
OmegaVr: 1 
 ≤ Value

12 = Time history design
1 = Envelopes
2 = Step-by-step

If Design Provision is 1 (LRFD), the Phi factors will 
 be set to have the values of items 5 through 11. Otherwise, if Design 
 Provision is 2 (ASD), the Omega factors will be set to have the values 
 of items 5 through 11.
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_2020.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AA_ASD_2000:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of an aluminum design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a aluminum frame design procedure.
Item: This is an integer between 1 and 23, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Bending coefficient, Cb
10 = Buckling constant for compression, k1
11 = Buckling constant for compression, k2
12 = Buckling constant for bending, k1
13 = Buckling constant for bending, k2
14 = Safety coefficient, kt
15 = Bending coefficient, C1
16 = Bending coefficient, C2
17 = Yield stress, Fy
18 = Compressive stress, Fa
19 = Tensile stress, Ft
20 = Major bending stress, Fb3
21 = Minor bending stress, Fb2
22 = Major shear stress, Fs2
23 = Minor shear stress, Fs3
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Live load reduction factor
Value >= 0; 0 means use a program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

10 = Buckling constant for compression, k1
Value >= 0; 0 means use program determined value.

11 = Buckling constant for compression, k2
Value >= 0; 0 means use program determined value.

12 = Buckling constant for bending, k1
Value >= 0; 0 means use program determined value.

13 = Buckling constant for bending, k2
Value >= 0; 0 means use program determined value.

14 = Safety coefficient, kt
Value >= 0; 0 means use program determined value.

15 = Bending coefficient, C1
Value >= 0; 0 means use program determined value.

16 = Bending coefficient, C2
Value >= 0; 0 means use program determined value.

17 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

18 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

19 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

20 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

21 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

22 = Major shear stress, Fs2
Value >= 0; 0 means use program determined value. [F/L2]

23 = Minor shear stress, Fs3
Value >= 0; 0 means use program determined value. [F/L2]
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_ASD_2000.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of an aluminum design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 6, inclusive, indicating the preference item considered.
1 = Framing type
2 = Demand/capacity ratio limit
3 = Lateral factor
4 = Use lateral factor
5 = Bridge type structure
6 = Time history design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Demand/capacity ratio limit
Value > 0

3 = Lateral factor
Value > 0

4 = Use lateral factor
0 = No
Any other value = Yes

5 = Bridge type structure
0 = No
Any other value = Yes

6 = Time history design
1 = Envelopes
2 = Step-by step
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_ASD_2000.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of an aluminum design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 23, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Bending coefficient, Cb
10 = Buckling constant for compression, k1
11 = Buckling constant for compression, k2
12 = Buckling constant for bending, k1
13 = Buckling constant for bending, k2
14 = Safety coefficient, kt
15 = Bending coefficient, C1
16 = Bending coefficient, C2
17 = Yield stress, Fy
18 = Compressive stress, Fa
19 = Tensile stress, Ft
20 = Major bending stress, Fb3
21 = Minor bending stress, Fb2
22 = Major shear stress, Fs2
23 = Minor shear stress, Fs3
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Live load reduction factor
Value >= 0; 0 means use a program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

10 = Buckling constant for compression, k1
Value >= 0; 0 means use program determined value.

11 = Buckling constant for compression, k2
Value >= 0; 0 means use program determined value.

12 = Buckling constant for bending, k1
Value >= 0; 0 means use program determined value.

13 = Buckling constant for bending, k2
Value >= 0; 0 means use program determined value.

14 = Safety coefficient, kt
Value >= 0; 0 means use program determined value.

15 = Bending coefficient, C1
Value >= 0; 0 means use program determined value.

16 = Bending coefficient, C2
Value >= 0; 0 means use program determined value.

17 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

18 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

19 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

20 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

21 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

22 = Major shear stress, Fs2
Value >= 0; 0 means use program determined value. [F/L2]

23 = Minor shear stress, Fs3
Value >= 0; 0 means use program determined value. [F/L2]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_ASD_2000.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of an aluminum design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 6, inclusive, indicating the preference item considered.
1 = Framing type
2 = Demand/capacity ratio limit
3 = Lateral factor
4 = Use lateral factor
5 = Bridge type structure
6 = Time history design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Demand/capacity ratio limit
Value > 0

3 = Lateral factor
Value > 0

4 = Use lateral factor
0 = No
Any other value = Yes

5 = Bridge type structure
0 = No
Any other value = Yes

6 = Time history design
1 = Envelopes
2 = Step-by step
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_ASD_2000.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AA_LRFD_2000:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of an aluminum design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a aluminum frame design procedure.
Item: This is an integer between 1 and 23, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Bending coefficient, Cb
10 = Buckling constant for compression, k1
11 = Buckling constant for compression, k2
12 = Buckling constant for bending, k1
13 = Buckling constant for bending, k2
14 = Safety coefficient, kt
15 = Bending coefficient, C1
16 = Bending coefficient, C2
17 = Yield stress, Fy
18 = Compressive stress, Fa
19 = Tensile stress, Ft
20 = Major bending stress, Fb3
21 = Minor bending stress, Fb2
22 = Major shear stress, Fs2
23 = Minor shear stress, Fs3
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Live load reduction factor
Value >= 0; 0 means use a program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

10 = Buckling constant for compression, k1
Value >= 0; 0 means use program determined value.

11 = Buckling constant for compression, k2
Value >= 0; 0 means use program determined value.

12 = Buckling constant for bending, k1
Value >= 0; 0 means use program determined value.

13 = Buckling constant for bending, k2
Value >= 0; 0 means use program determined value.

14 = Safety coefficient, kt
Value >= 0; 0 means use program determined value.

15 = Bending coefficient, C1
Value >= 0; 0 means use program determined value.

16 = Bending coefficient, C2
Value >= 0; 0 means use program determined value.

17 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

18 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

19 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

20 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

21 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

22 = Major shear stress, Fs2
Value >= 0; 0 means use program determined value. [F/L2]

23 = Minor shear stress, Fs3
Value >= 0; 0 means use program determined value. [F/L2]
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_LRFD_2000.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of an aluminum design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 6, inclusive, indicating the preference item considered.
1 = Framing type
2 = Demand/capacity ratio limit
3 = Phiy resistance factor
4 = Phib resistance factor
5 = Phic resistance factor
6 = Phiu resistance factor
7 = Phicc resistance factor
8 = Phicp resistance factor
9 = Phiv resistance factor
10 = Phivp resistance factor
11 = Phiw resistance factor
12 = Time history design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Demand/capacity ratio limit
Value > 0

3 = Phiy resistance factor
Value > 0

4 = Phib resistance factor
Value > 0

5 = Phic resistance factor
Value > 0

6 = Phiu resistance factor
Value > 0

7 = Phicc resistance factor
Value > 0

8 = Phicp resistance factor
Value > 0

9 = Phiv resistance factor
Value > 0

10 = Phivp resistance factor
Value > 0

11 = Phiw resistance factor
Value > 0

12 = Time history design
1 = Envelopes
2 = Step-by step
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_LRFD_2000.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of an aluminum design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 23, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Bending coefficient, Cb
10 = Buckling constant for compression, k1
11 = Buckling constant for compression, k2
12 = Buckling constant for bending, k1
13 = Buckling constant for bending, k2
14 = Safety coefficient, kt
15 = Bending coefficient, C1
16 = Bending coefficient, C2
17 = Yield stress, Fy
18 = Compressive stress, Fa
19 = Tensile stress, Ft
20 = Major bending stress, Fb3
21 = Minor bending stress, Fb2
22 = Major shear stress, Fs2
23 = Minor shear stress, Fs3
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Live load reduction factor
Value >= 0; 0 means use a program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

10 = Buckling constant for compression, k1
Value >= 0; 0 means use program determined value.

11 = Buckling constant for compression, k2
Value >= 0; 0 means use program determined value.

12 = Buckling constant for bending, k1
Value >= 0; 0 means use program determined value.

13 = Buckling constant for bending, k2
Value >= 0; 0 means use program determined value.

14 = Safety coefficient, kt
Value >= 0; 0 means use program determined value.

15 = Bending coefficient, C1
Value >= 0; 0 means use program determined value.

16 = Bending coefficient, C2
Value >= 0; 0 means use program determined value.

17 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

18 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

19 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

20 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

21 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

22 = Major shear stress, Fs2
Value >= 0; 0 means use program determined value. [F/L2]

23 = Minor shear stress, Fs3
Value >= 0; 0 means use program determined value. [F/L2]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_LRFD_2000.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of an aluminum design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 6, inclusive, indicating the preference item considered.
1 = Framing type
2 = Demand/capacity ratio limit
3 = Phiy resistance factor
4 = Phib resistance factor
5 = Phic resistance factor
6 = Phiu resistance factor
7 = Phicc resistance factor
8 = Phicp resistance factor
9 = Phiv resistance factor
10 = Phivp resistance factor
11 = Phiw resistance factor
12 = Time history design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Demand/capacity ratio limit
Value > 0

3 = Phiy resistance factor
Value > 0

4 = Phib resistance factor
Value > 0

5 = Phic resistance factor
Value > 0

6 = Phiu resistance factor
Value > 0

7 = Phicc resistance factor
Value > 0

8 = Phicp resistance factor
Value > 0

9 = Phiv resistance factor
Value > 0

10 = Phivp resistance factor
Value > 0

11 = Phiw resistance factor
Value > 0

12 = Time history design
1 = Envelopes
2 = Step-by step
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.AA_LRFD_2000.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Eurocode_9_2007:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of an aluminum design 
 overwrite item.
The function returns zero if the item is successfully 
 retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a aluminum frame design 
 procedure.
Item: This is an integer between 1 and 29, inclusive, indicating 
 the overwrite item considered.
1 = Demand/capacity ratio 
 limit
2 = Live load reduction 
 factor
3 = Net area to total area 
 ratio
4 = Material buckling class
5 = Unbraced length ratio, 
 Major
6 = Unbraced length ratio, 
 Minor
7 = Unbraced length ratio, 
 LTB
8 = Effective length factor 
 sway, K Major
9 = Effective length factor 
 sway, K Minor
10 = Effective length factor, 
 K LTB
11 = LTB fixed end
12 = Bending coefficient, 
 C1
13 = Bending coefficient, 
 C2
14 = Bending coefficient, 
 C3
15 = Torsional-flexural 
 buckling curve
16 = Buckling curve for 
 LTB
17 = Tensile capacity, 
 Nt,Rd
18 = Elastic torsional 
 buckling force, NcrT
19 = Elastic torsional-flexural 
 buckling force, NcrTF
20 = Compressive capacity, 
 NRk
21 = Major bending capacity, 
 MyRk
22 = Minor bending capacity, 
 MzRk
23 = Lateral-torsional 
 buckling moment capacity, Mcr
24 = Major shear capacity, 
 Vy.Rd
25 = Minor shear capacity, 
 Vz.Rd
26 = Torsion capacity, 
 TRd
27 = Shear stress due to 
 warping torsion moment, τw

28 = Warping coefficient, 
 kw
29 = Coordinate of load 
 application, za

Value: The value of the considered overwrite item.
1 = Demand/capacity ratio limit
Value 
 >= 0; 0 means use program determined value.

2 = Live load reduction factor
Value 
 >= 0; 0 means use a program determined value.

3 = Net area to total area ratio
Value 
 >= 0; 0 means use program default value.

4 = Material buckling class
0 = Program 
 default
1 = Class 
 A
2 = Class 
 B

5 = Unbraced length ratio, Major
Value 
 >= 0; 0 means use program determined value.

6 = Unbraced length ratio, Minor 
Value 
 >= 0; 0 means use program determined value.

7 = Unbraced length ratio, Lateral Torsional 
 Buckling 
Value 
 >= 0; 0 means use program determined value.

8 = Effective length factor, K Major
Value 
 >= 0; 0 means use program determined value.

9 = Effective length factor, K Minor
Value 
 >= 0; 0 means use program determined value.

10 = Effective length factor, K LTB
Value 
 >= 0; 0 means use program determined value.

11 = LTB Fixed End
0 
 = Program default
1 
 = Left
2 
 = Right

12 = Bending coefficient, C1
Value 
 >= 0; 0 means use program determined value.

13 = Bending coefficient, C2
Value 
 >= 0; 0 means use program determined value.

14 = Bending coefficient, C3
Value 
 >= 0; 0 means use program determined value.

15 = Torsional-flexural buckling curve
0 
 = Program default
1 
 = Curve 1
2 
 = Curve 2

16 = Buckling curve for LTB
0 
 = Program default
1 
 = Curve 1
2 
 = Curve 2

17 = Tensile capacity, Nt,Rd
Value 
 >= 0; 0 means use program determined value. [F]

18 = Elastic torsional buckling force, 
 NcrT
Value 
 >= 0; 0 means use program determined value. [F]

19 = Elastic torsional-flexural buckling 
 force, NcrTF
Value 
 >= 0; 0 means use program determined value. [F]

20 = Compressive capacity, NRk
Value 
 >= 0; 0 means use program determined value. [F]

21 = Major bending capacity, MyRk
Value 
 >= 0; 0 means use program determined value. [FL]

22 = Minor bending capacity, MzRk
Value 
 >= 0; 0 means use program determined value. [FL]

23 = Minor bending capacity, Mcr
Value 
 >= 0; 0 means use program determined value. [FL]

24 = Major shear capacity, Vy.Rd
Value 
 >= 0; 0 means use program determined value. [F]

25 = Minor shear capacity, Vz.Rd
Value 
 >= 0; 0 means use program determined value. [F]

26 = Torsion capacity, TRd
Value 
 >= 0; 0 means use program determined value. [FL]

27 = Shear Stress due to warping torsion 
 moment,τw

Value 
 >= 0; 0 means use program determined value. [F/L2]

28 = Warping coefficient, kw 
 (used in Mcr calculation)
0.5 
 =<Value =< 1; 0 means use program determined value which is defaulted 
 to 1.0.

29 = Coordinate of load application, za 
 (used in Mcr calculation)

ProgDet: If this item is True, the specified value is program 
 determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.Eurocode_9_2007.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of an aluminum design 
 preference item.
The function returns zero if the item is successfully 
 retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating 
 the preference item considered.
1 = Country
2 = Multi-response case 
 design
3 = Demand/capacity ratio 
 limit
4 = Combos equation
5 = Reliability class
6 = GammaM1
7 = GammaM2
8 = Consider P-Delta Done
9 = Consider Torsion
10 = Pattern live load 
 factor

Value: The value of the considered preference item.
1 
 = Country
1 
 = CEN Default
2 
 = United Kingdom
3 
 = Slovenia
4 
 = Bulgaria
5 
 = Norway
7 
 = Sweden
8 
 = Finland
9 
 = Denmark
10 
 = Portugal
11 
 = Germany

2 = Multi-response case 
 design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = 
 Step-by-step -- All

3 = Demand/capacity ratio 
 limit
Value > 
 0

4 = Combos equation
1 = Eq. 
 6.10
2 = Max 
 of Eqs. 6.10a and 6.10b

5 = Reliability class
1 = Class 
 1
2 = Class 
 2
3 = Class 
 3

6 = GammaM1
Value > 0

7 = GammaM2
Value 
 > 0

8 = Consider P-Delta Done
0 = No
Any other value = Yes

9 = Consider Torsion
0 = No
Any other value = Yes

10 = Pattern live load 
 factor
Value >= 
 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.Eurocode_9_2007.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of an aluminum design overwrite 
 item.
The function returns zero if the item is successfully 
 set; otherwise it returns a nonzero value.

Name: The name of a frame object with a aluminum frame design 
 procedure.
Item: This is an integer between 1 and 29, inclusive, indicating 
 the overwrite item considered.
1 
 = Demand/capacity ratio limit
2 = Live load reduction 
 factor
3 = Net area to total area 
 ratio
4 = Material buckling class
5 = Unbraced length ratio, 
 Major
6 = Unbraced length ratio, 
 Minor
7 = Unbraced length ratio, 
 LTB
8 = Effective length factor 
 sway, K Major
9 = Effective length factor 
 sway, K Minor
10 = Effective length factor, 
 K LTB
11 = LTB fixed end
12 = Bending coefficient, 
 C1
13 = Bending coefficient, 
 C2
14 = Bending coefficient, 
 C3
15 = Torsional-flexural 
 buckling curve
16 = Buckling curve for 
 LTB
17 = Tensile capacity, 
 Nt,Rd
18 = Elastic torsional 
 buckling force, NcrT
19 = Elastic torsional-flexural 
 buckling force, NcrTF
20 = Compressive capacity, 
 NRk
21 = Major bending capacity, 
 MyRk
22 = Minor bending capacity, 
 MzRk
23 = Lateral-torsional 
 buckling moment capacity, Mcr
24 = Major shear capacity, 
 Vy.Rd
25 = Minor shear capacity, 
 Vz.Rd
26 = Torsion capacity, 
 TRd
27 = Shear stress due to 
 warping torsion moment, τw

28 = Warping coefficient, 
 kw
29 = Coordinate of load 
 application, za

Value: The value of the considered overwrite item.
1 = Demand/capacity ratio limit
Value 
 >= 0; 0 means use program determined value.

2 = Live load reduction factor
Value 
 >= 0; 0 means use a program determined value.

3 = Net area to total area ratio
Value 
 >= 0; 0 means use program default value.

4 = Material buckling class
0 = Program 
 default
1 = Class 
 A
2 = Class 
 B

5 = Unbraced length ratio, Major
Value 
 >= 0; 0 means use program determined value.

6 = Unbraced length ratio, Minor 
Value 
 >= 0; 0 means use program determined value.

7 = Unbraced length ratio, Lateral Torsional 
 Buckling 
Value 
 >= 0; 0 means use program determined value.

8 = Effective length factor, K Major
Value 
 >= 0; 0 means use program determined value.

9 = Effective length factor, K Minor
Value 
 >= 0; 0 means use program determined value.

10 = Effective length factor, K LTB
Value 
 >= 0; 0 means use program determined value.

11 = LTB Fixed End
0 
 = Program default
1 
 = Left
2 
 = Right

12 = Bending coefficient, C1
Value 
 >= 0; 0 means use program determined value.

13 = Bending coefficient, C2
Value 
 >= 0; 0 means use program determined value.

14 = Bending coefficient, C3
Value 
 >= 0; 0 means use program determined value.

15 = Torsional-flexural buckling curve
0 
 = Program default
1 
 = Curve 1
2 
 = Curve 2

16 = Buckling curve for LTB
0 
 = Program default
1 
 = Curve 1
2 
 = Curve 2

17 = Tensile capacity, Nt,Rd
Value 
 >= 0; 0 means use program determined value. [F]

18 = Elastic torsional buckling force, 
 NcrT
Value 
 >= 0; 0 means use program determined value. [F]

19 = Elastic torsional-flexural buckling 
 force, NcrTF
Value 
 >= 0; 0 means use program determined value. [F]

20 = Compressive capacity, NRk
Value 
 >= 0; 0 means use program determined value. [F]

21 = Major bending capacity, MyRk
Value 
 >= 0; 0 means use program determined value. [FL]

22 = Minor bending capacity, MzRk
Value 
 >= 0; 0 means use program determined value. [FL]

23 = Minor bending capacity, Mcr
Value 
 >= 0; 0 means use program determined value. [FL]

24 = Major shear capacity, Vy.Rd
Value 
 >= 0; 0 means use program determined value. [F]

25 = Minor shear capacity, Vz.Rd
Value 
 >= 0; 0 means use program determined value. [F]

26 = Torsion capacity, TRd
Value 
 >= 0; 0 means use program determined value. [FL]

27 = Shear 
 stress due to warping torsion moment, τw 
Value 
 >= 0; 0 means use program determined value. [F/L2]

28 = Warping coefficient, kw 
 (used in Mcr calculation)
0.5 
 =<Value =< 1; 0 means use program determined value which is defaulted 
 to 1.0.

29 = Coordinate of load application, za 
 (used in Mcr calculation)

ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the 
 frame object specified by the Name item.
If this item is Group, the assignment is made to all 
 frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made 
 to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.Eurocode_9_2007.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of an aluminum design preference 
 item.
The function returns zero if the item is successfully 
 set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating 
 the preference item considered.
1 
 = Country
2 = Multi-response case 
 design
3 = Demand/capacity ratio 
 limit
4 = Combos equation
5 = Reliability class
6 = GammaM1
7 = GammaM2
8 = Consider P-Delta Done
9 = Consider Torsion
10 = Pattern live load 
 factor

Value: The value of the considered preference item.
1 = Country
1 
 = CEN Default
2 
 = United Kingdom
3 
 = Slovenia
4 
 = Bulgaria
5 
 = Norway
7 
 = Sweden
8 
 = Finland
9 
 = Denmark
10 
 = Portugal
11 
 = Germany

2 = Multi-response case 
 design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = 
 Step-by-step -- All

3 = Demand/capacity ratio 
 limit
Value > 
 0

4 = Combos equation
1 = Eq. 
 6.10
2 = Max 
 of Eqs. 6.10a and 6.10b

5 = Reliability class
1 = Class 
 1
2 = Class 
 2
3 = Class 
 3

6 = GammaM1
Value > 0

7 = GammaM2
Value 
 > 0

8 = Consider P-Delta Done
0 = No
Any other value = Yes

9 = Consider Torsion
0 = No
Any other value = Yes

10 = Pattern live load 
 factor
Value >= 
 0

        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignAluminum.Eurocode_9_2007.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class DesignColdFormed:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.AISI_16 = AISI_16(strict, api)
        self.AISI_ASD96 = AISI_ASD96(strict, api)
        self.AISI_LRFD96 = AISI_LRFD96(strict, api)
        self.EuroCold06 = EuroCold06(strict, api)

    def DeleteResults(self):
        """
This function deletes all cold formed frame design results.
The function returns zero if the results are successfully deleted; otherwise it returns a nonzero value.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.DeleteResults(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteResults" failed')
        
        return ret

    def GetCode(self, CodeName = None):
        """
This function retrieves the cold formed design code.
The function returns zero if the code is successfully 
 retrieved; otherwise it returns a nonzero value.

CodeName: This is one of the following cold formed design code 
 names.
AISI-ASD96
AISI-LRFD96
        """

        all_args = [CodeName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.GetCode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCode" failed')
        
        return ret

    def GetComboAutoGenerate(self, AutoGenerate = None):
        """
This function retrieves the value of the automatically generated code-based design load combinations option for cold formed frame design.
The function returns zero if the options are successfully set; otherwise it returns a nonzero value.

AutoGenerate: If this item is True, the option to automatically generate code-based design load combinations for cold formed frame design is turned on. If it is False, the option is turned off.
        """

        all_args = [AutoGenerate]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.GetComboAutoGenerate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetComboAutoGenerate" failed')
        
        return ret

    def GetComboDeflection(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of all load combinations selected as design combinations for cold formed deflection design.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of load combinations selected as design combinations for cold formed deflection design.
MyName: This is an array that includes the name of each response combination selected as a design combination for cold formed deflection design.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.GetComboDeflection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetComboDeflection" failed')
        
        return ret

    def GetComboStrength(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of all load combinations selected as design combinations for cold formed strength design.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of load combinations selected as design combinations for cold formed strength design.
MyName: This is an array that includes the name of each response combination selected as a design combination for cold formed strength design.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.GetComboStrength(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetComboStrength" failed')
        
        return ret

    def GetDesignSection(self, Name = None, PropName = None):
        """
This function retrieves the design section for a specified cold formed frame object.
The function returns zero if the section is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a cold formed frame design procedure.
PropName: The name of the design section for the specified frame object.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.GetDesignSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDesignSection" failed')
        
        return ret

    def GetGroup(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of all groups selected for cold formed design.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of groups selected for cold formed design.
MyName: This is an array that includes the name of each group selected for cold formed design.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.GetGroup(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGroup" failed')
        
        return ret

    def GetResultsAvailable(self):
        """
The function returns True if the cold formed frame design results are available, otherwise False.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.GetResultsAvailable(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetResultsAvailable" failed')
        
        return ret

    def GetSummaryResults(self, Name = None, NumberItems = None, FrameName = None, Ratio = None, RatioType = None, Location = None, ComboName = None, ErrorSummary = None, WarningSummary = None, ItemType = None):
        """
This function retrieves summary results for cold formed design.
The function returns zero if the results are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The number of frame objects for which results are obtained.
FrameName: This is an array that includes each frame object name for which results are obtained.
Ratio: This is an array that includes the controlling stress or capacity ratio for each frame object.
RatioType: This is an array that includes 1, 3 or 4, indicating the controlling stress or capacity ratio type for each frame object.
1 = PMM
3 = Major shear
4 = Minor shear
Location: This is an array that includes the distance from the I-end of the frame object to the location where the controlling stress or capacity ratio occurs. [L]
ComboName: This is an array that includes the name of the design combination for which the controlling stress or capacity ratio occurs.
ErrorSummary: This is an array that includes the design error messages for the frame object, if any.
WarningSummary: This is an array that includes the design warning messages for the frame object, if any.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the design results are retrieved for the frame object specified by the Name item.
If this item is Group, the design results are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the design results are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, Ratio, RatioType, Location, ComboName, ErrorSummary, WarningSummary, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.GetSummaryResults(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSummaryResults" failed')
        
        return ret

    def ResetOverwrites(self):
        """
This function resets all cold formed frame design overwrites to default values.
The function returns zero if the overwrites are successfully reset; otherwise it returns a nonzero value.
The function will fail if no cold formed frame objects are present.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.ResetOverwrites(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ResetOverwrites" failed')
        
        return ret

    def SetAutoSelectNull(self, Name = None, ItemType = None):
        """
This function removes the auto select section assignments from all specified frame objects that have a cold formed frame design procedure.
The function returns zero if the auto select section assignments are successfully removed; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.SetAutoSelectNull(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAutoSelectNull" failed')
        
        return ret

    def SetCode(self, CodeName = None):
        """
This function sets the cold formed design code.
The function returns zero if the code is successfully set; otherwise it returns a nonzero value.

CodeName: This is one of the following cold formed design code names.
AISI-ASD96
AISI-LRFD96
        """

        all_args = [CodeName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.SetCode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCode" failed')
        
        return ret

    def SetComboAutoGenerate(self, AutoGenerate = None):
        """
This function turns on or off the option to automatically generate code-based design load combinations for cold formed frame design.
The function returns zero if the options are successfully set; otherwise it returns a nonzero value.

AutoGenerate: If this item is True, the option to automatically generate code-based design load combinations for cold formed frame design is turned on. If it is False, the option is turned off.
        """

        all_args = [AutoGenerate]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.SetComboAutoGenerate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetComboAutoGenerate" failed')
        
        return ret

    def SetComboDeflection(self, Name = None, Selected = None):
        """
This function selects or deselects a load combination for cold formed deflection design.
The function returns zero if the selection status is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing load combination.
Selected: If this item is True, the specified load combination is selected as a design combination for cold formed deflection design. If it is False, the combination is not selected for cold formed deflection design.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.SetComboDeflection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetComboDeflection" failed')
        
        return ret

    def SetComboStrength(self, Name = None, Selected = None):
        """
This function selects or deselects a load combination for cold formed strength design.
The function returns zero if the selection status is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing load combination.
Selected: If this item is True, the specified load combination is selected as a design combination for cold formed strength design. If it is False, the combination is not selected for cold formed strength design.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.SetComboStrength(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetComboStrength" failed')
        
        return ret

    def SetDesignSection(self, Name = None, PropName = None, LastAnalysis = None, ItemType = None):
        """
This function modifies the design section for all specified frame objects that have a cold formed frame design procedure.
The function returns zero if the design section is successfully modified; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
PropName: The name of an existing frame section property to be used as the design section for the specified frame objects. This item applies only when LastAnalysis = False.
LastAnalysis: If this item is True, the design section for the specified frame objects is reset to the last analysis section for the frame object. If it is False, the design section is set to that specified by PropName.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, LastAnalysis, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.SetDesignSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDesignSection" failed')
        
        return ret

    def SetGroup(self, Name = None, Selected = None):
        """
This function selects or deselects a group for cold formed design.
The function returns zero if the selection status is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing group.
Selected: If this item is True, the specified group is selected as a design group for cold formed design. If it is False, the group is not selected for cold formed design.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.SetGroup(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGroup" failed')
        
        return ret

    def StartDesign(self):
        """
This function starts the cold formed frame design.
The function returns zero if the cold formed frame design is successfully started; otherwise it returns a nonzero value.
The function will fail if no cold formed frame objects are present. It will also fail if analysis results are not available.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.StartDesign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"StartDesign" failed')
        
        return ret

    def VerifyPassed(self, NumberItems = None, n1 = None, n2 = None, MyName = None):
        """
This function retrieves the names of the frame objects that did not pass the design check or have not yet been checked, if any.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of cold formed frame objects that did not pass the design check or have not yet been checked.
n1: The number of cold formed frame objects that did not pass the design check.
n2: The number of cold formed frame objects that have not yet been checked.
MyName: This is an array that includes the name of each frame object that did not pass the design check or has not yet been checked.
        """

        all_args = [NumberItems, n1, n2, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.VerifyPassed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"VerifyPassed" failed')
        
        return ret

    def VerifySections(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of the frame objects that have different analysis and design sections, if any.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of frame objects that have different analysis and design sections.
MyName: This is an array that includes the name of each frame object that has different analysis and design sections.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.VerifySections(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"VerifySections" failed')
        
        return ret

class AISI_16:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a cold formed design 
 overwrite item.
The function returns zero if the item is successfully 
 retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a cold formed frame 
 design procedure.
Item: This is an integer between 1 and 33, inclusive, indicating 
 the overwrite item considered.
1 = Framing type
2 = Demand/capacity ratio limit
3 = Live load reduction factor
4 = Unbraced length ratio, Major
5 = Unbraced length ratio, Minor
6 = Unbraced length ratio, Lateral Torsional 
 Buckling
7 = Unbraced length ratio, Distortional 
 Buckling
8 = Effective length factor, K Major
9 = Effective length factor, K Minor
10 = Effective length factor, K Lateral 
 Torsional Buckling
11 = Effective length factor, K Distortional 
 Buckling
12 = Rotational stiffness, kPhi (Distortional 
 Buckling)
13 = Moment coefficient, Cm Major
14 = Moment coefficient, Cm Minor
15 = Moment coefficient, Ctf Major
16 = Moment coefficient, Ctf Minor
17 = Bending coefficient, Cb Major
18 = Bending coefficient, Cb Minor
19 = Moment factor, Alpha Major
20 = Moment factor, Alpha Minor
21 = Nonsway moment factor, B1 Major
22 = Nonsway moment factor, B1 Minor
23 = Sway moment factor, B2 Major
24 = Sway moment factor, B2 Minor
25 = Through fastened to deck
26 = Fastener eccentricity, a/b
27 = Hole diameter on web
28 = Hole length on web
29 = Hole spacing on web
30 = Asymmetric integral ratio, Major
31 = Asymmetric integral ratio, Minor
32 = Nominal bending capacity for lateral 
 torsional buckling, Mn33
33 = Nominal bending capacity for lateral 
 torsional buckling, Mn22
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program 
 Default
1 = Moment 
 Frame
2 = Braced 
 Frame

2 = Demand/capacity ratio limit
Value >= 
 0; 0 means use program determined value

3 = Live load reduction factor
Value >= 
 0; 0 means use a program determined value.

4 = Unbraced length ratio, Major
Value >= 
 0; 0 means use program determined value.

5 = Unbraced length ratio, Minor
Value >= 
 0; 0 means use program determined value.

6 = Unbraced length ratio, Lateral Torsional 
 Buckling
Value >= 
 0; 0 means use program determined value.

7 = Unbraced length ratio, Distortional 
 Buckling
Value >= 
 0; 0 means use program determined value.

8 = Effective length factor, K Major
Value >= 
 0; 0 means use program determined value.

9 = Effective length factor, K Minor
Value >= 
 0; 0 means use program determined value.

10 = Effective length factor, K Lateral 
 Torsional Buckling
Value >= 
 0; 0 means use program determined value.

11 = Effective length factor, K Distortional 
 Buckling
Value >= 
 0; 0 means use program determined value.

12 = Rotational stiffness, kPhi (Distortional 
 Buckling)
Value >= 
 0; 0 means use program determined value. [F]

13 = Moment coefficient, Cm Major
Value >= 
 0; 0 means use program determined value.

14 = Moment coefficient, Cm Minor
Value >= 
 0; 0 means use program determined value.

15 = Moment coefficient, Ctf Major
Value >= 
 0; 0 means use program determined value.

16 = Moment coefficient, Ctf Minor
Value >= 
 0; 0 means use program determined value.

17 = Bending coefficient, Cb Major
Value >= 
 0; 0 means use program determined value.

18 = Bending coefficient, Cb Minor
Value >= 
 0; 0 means use program determined value.

19 = Moment factor, Alpha Major
Value >= 
 0; 0 means use program determined value.

20 = Moment factor, Alpha Minor
Value >= 
 0; 0 means use program determined value.

21 = Nonsway moment factor, B1 Major
Value >= 
 0; 0 means use program determined value.

22 = Nonsway moment factor, B1 Minor
Value >= 
 0; 0 means use program determined value.

23 = Sway moment factor, B2 Major
Value >= 
 0; 0 means use program determined value.

24 = Sway moment factor, B2 Minor
Value >= 
 0; 0 means use program determined value.

25 = Through fastened to deck
0 = No.
Any other 
 value = Yes.

26 = Fastener eccentricity, a/b
Value >= 
 0; 0 means use program determined value. [L]

27 = Hole diameter on web
Value >= 
 0; 0 means use program determined value. [L]

28 = Hole length on web
Value >= 
 hole diameter on web; 0 means use program determined value. [L]

29 = Hole spacing on web
Value >= 
 hole length on web; 0 means use program determined value. [L]

30 = Asymmetric integral ratio, Major
Value >= 
 0; 0 means use program determined value.

31 = Asymmetric integral ratio, Minor
Value >= 
 0; 0 means use program determined value.

32 = Nominal bending capacity for lateral 
 torsional buckling, Mn33
Value >= 
 0; 0 means use program determined value. [FL]

33 = Nominal bending capacity for lateral 
 torsional buckling, Mn22
Value >= 
 0; 0 means use program determined value. [FL]
ProgDet: If this item is True, the specified value is program 
 determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.AISI_16.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a cold formed design 
 preference item.
The function returns zero if the item is successfully 
 retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 13, inclusive, indicating 
 the preference item considered.
1 = Framing type
2 = Demand/capacity ratio limit
3 = Second order method
4 = Design provision
5 = Lateral factor
6 = Use lateral factor
7 = PhiTy resistance or OmegaTy safety 
 factor
8 = PhiTr resistance or OmegaTr safety 
 factor
9 = PhiC resistance or OmegaC safety factor
10 = PhiB resistance or OmegaB safety 
 factor
11 = PhiBPipe resistance or OmegaBPipe 
 safety factor
12 = PhiV resistance or OmegaV safety 
 factor
13 = Time history design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment 
 Frame
2 = Braced 
 Frame

2 = Demand/capacity ratio limit
Value > 
 0

3 = Second Order Method
1 = General 
 2nd Order
2 = Amplified 
 1st Order

4 = Design Provision
1 = LRFD
2 = ASD
3 = LSD

5 = Lateral Factor
Value > 
 0

6 = Use Lateral Factor
1 = No
2 = Yes

7 = PhiTy resistance or OmegaTy safety 
 factor
PhiTy:
OmegaTy:

8 = PhiTr resistance or OmegaTr safety 
 factor
PhiTr:
OmegaTr:

9 = PhiC resistance or OmegaC safety factor
PhiC:
OmegaC:

10 = PhiB resistance or OmegaB safety 
 factor
PhiB:
OmegaB:

11 = PhiBPipe resistance or OmegaBPipe 
 safety factor
PhiBr:
OmegaBr:

12 = PhiV or OmegaV safety factor
PhiV:
OmegaV:

13 = Time history design
1 = Envelopes
2 = Step-by 
 step

If Design Provision is 1 (LRFD) or 3 (LSD), the value 
 of items 7 through 12 will be obtained from Phi factors. Otherwise, if 
 Design Provision is 2 (ASD), the value of items 6 through 12 will come 
 from Omega factors.
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.AISI_16.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a cold formed design 
 preference item.
The function returns zero if the item is successfully 
 set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 13, inclusive, indicating 
 the preference item considered.
1 = Framing type
2 = Demand/capacity ratio limit
3 = Second order method
4 = Design provision
5 = Lateral factor
6 = Use lateral factor
7 = PhiTy resistance or OmegaTy safety 
 factor
8 = PhiTr resistance or OmegaTr safety 
 factor
9 = PhiC resistance or OmegaC safety factor
10 = PhiB resistance or OmegaB safety 
 factor
11 = PhiBPipe resistance or OmegaBPipe 
 safety factor
12 = PhiV resistance or OmegaV safety 
 factor
13 = Time history design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment 
 Frame
2 = Braced 
 Frame

2 = Demand/capacity ratio limit
Value > 
 0

3 = Second Order Method
1 = General 
 2nd Order
2 = Amplified 
 1st Order

4 = Design Provision
1 = LRFD
2 = ASD
3 = LSD

5 = Lateral Factor
Value > 
 0

6 = Use Lateral Factor
1 = No
2 = Yes

7 = PhiTy resistance or OmegaTy safety 
 factor
PhiTy:
OmegaTy:

8 = PhiTr resistance or OmegaTr safety 
 factor
PhiTr:
OmegaTr:

9 = PhiC resistance or OmegaC safety factor
PhiC:
OmegaC:

10 = PhiB resistance or OmegaB safety 
 factor
PhiB:
OmegaB:

11 = PhiBPipe resistance or OmegaBPipe 
 safety factor
PhiBr:
OmegaBr:

12 = PhiV or OmegaV safety factor
PhiV:
OmegaV:

13 = Time history design
1 = Envelopes
2 = Step-by 
 step

If Design Provision is 1 (LRFD) or 3 (LSD), Phi factors 
 will be set to have value of items 7 through 12. Otherwise, if Design 
 Provision is 2 (ASD), Omega factors will be set to have value of items 
 7 through 12.
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.AISI_16.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AISI_ASD96:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a cold formed design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a cold formed frame design procedure.
Item: This is an integer between 1 and 27, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Moment coefficient, Ctf Major
10 = Moment coefficient, Ctf Minor
11 = Bending coefficient, Cb
12 = Moment factor, Alpha Major
13 = Moment factor, Alpha Minor
14 = Through fastened to deck
15 = Fastener eccentricity, a/b
16 = Hole diameter at top flange
17 = Hole diameter at bottom flange
18 = Hole diameter on web
19 = Yield stress, Fy
20 = Nominal compressive capacity, Pnc
21 = Nominal tensile capacity, Pnt
22 = Nominal bending capacity for yielding, Mn33
23 = Nominal bending capacity for yielding, Mn22
24 = Nominal bending capacity for lateral torsional buckling, Mn33
25 = Nominal bending capacity for lateral torsional buckling, Mn22
26 = Nominal shear capacity, Vn2
27 = Nominal shear capacity, Vn3
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Live load reduction factor
Value >= 0; 0 means use a program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Moment coefficient, Ctf Major
Value >= 0; 0 means use program determined value.

10 = Moment coefficient, Ctf Minor
Value >= 0; 0 means use program determined value.

11 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

12 = Moment factor, Alpha Major
Value >= 0; 0 means use program determined value.

13 = Moment factor, Alpha Minor
Value >= 0; 0 means use program determined value.

14 = Through fastened to deck
0 = No.
Any other value = Yes.

15 = Fastener eccentricity, a/b
Value >= 0; 0 means use program determined value. [L]

16 = Hole diameter at top flange
Value >= 0; 0 means use program determined value. [L]

17 = Hole diameter at bottom flange
Value >= 0; 0 means use program determined value. [L]

18 = Hole diameter on web
Value >= 0; 0 means use program determined value. [L]

19 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

20 = Nominal compressive capacity, Pnc
Value >= 0; 0 means use program determined value. [F]

21 = Nominal tensile capacity, Pnt
Value >= 0; 0 means use program determined value. [F]

22 = Nominal bending capacity for yielding, Mn33
Value >= 0; 0 means use program determined value. [FL]

23 = Nominal bending capacity for yielding, Mn22
Value >= 0; 0 means use program determined value. [FL]

24 = Nominal bending capacity for lateral torsional buckling, Mn33
Value >= 0; 0 means use program determined value. [FL]

25 = Nominal bending capacity for lateral torsional buckling, Mn22
Value >= 0; 0 means use program determined value. [FL]

26 = Nominal shear capacity, Vn2
Value >= 0; 0 means use program determined value. [F]

27 = Nominal shear capacity, Vn3
Value >= 0; 0 means use program determined value. [F]
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.AISI_ASD96.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a cold formed design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Framing type
2 = Demand/capacity ratio limit
3 = Omega bending stiffened
4 = Omega bending unstiffened
5 = Omega bending lateral torsional buckling
6 = Omega shear slender
7 = Omega shear nonslender
8 = Omega axial tension
9 = Omega axial compression
10 = Time history design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Demand/capacity ratio limit
Value > 0

3 = Omega bending stiffened
Value > 0

4 = Omega bending unstiffened
Value > 0

5 = Omega bending lateral torsional buckling
Value > 0

6 = Omega shear slender
Value > 0

7 = Omega shear nonslender
Value > 0

8 = Omega axial tension
Value > 0

9 = Omega axial compression
Value > 0

10 = Time history design
1 = Envelopes
2 = Step-by step
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.AISI_ASD96.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a cold formed design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Framing type
2 = Demand/capacity ratio limit
3 = Omega bending stiffened
4 = Omega bending unstiffened
5 = Omega bending lateral torsional buckling
6 = Omega shear slender
7 = Omega shear nonslender
8 = Omega axial tension
9 = Omega axial compression
10 = Time history design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Demand/capacity ratio limit
Value > 0

3 = Omega bending stiffened
Value > 0

4 = Omega bending unstiffened
Value > 0

5 = Omega bending lateral torsional buckling
Value > 0

6 = Omega shear slender
Value > 0

7 = Omega shear nonslender
Value > 0

8 = Omega axial tension
Value > 0

9 = Omega axial compression
Value > 0

10 = Time history design
1 = Envelopes
2 = Step-by step
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.AISI_ASD96.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AISI_LRFD96:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a cold formed design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a cold formed frame design procedure.
Item: This is an integer between 1 and 27, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Moment coefficient, Ctf Major
10 = Moment coefficient, Ctf Minor
11 = Bending coefficient, Cb
12 = Moment factor, Alpha Major
13 = Moment factor, Alpha Minor
14 = Through fastened to deck
15 = Fastener eccentricity, a/b
16 = Hole diameter at top flange
17 = Hole diameter at bottom flange
18 = Hole diameter on web
19 = Yield stress, Fy
20 = Nominal compressive capacity, Pnc
21 = Nominal tensile capacity, Pnt
22 = Nominal bending capacity for yielding, Mn33
23 = Nominal bending capacity for yielding, Mn22
24 = Nominal bending capacity for lateral torsional buckling, Mn33
25 = Nominal bending capacity for lateral torsional buckling, Mn22
26 = Nominal shear capacity, Vn2
27 = Nominal shear capacity, Vn3
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Live load reduction factor
Value >= 0; 0 means use a program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Moment coefficient, Ctf Major
Value >= 0; 0 means use program determined value.

10 = Moment coefficient, Ctf Minor
Value >= 0; 0 means use program determined value.

11 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

12 = Moment factor, Alpha Major
Value >= 0; 0 means use program determined value.

13 = Moment factor, Alpha Minor
Value >= 0; 0 means use program determined value.

14 = Through fastened to deck
0 = No.
Any other value = Yes.

15 = Fastener eccentricity, a/b
Value >= 0; 0 means use program determined value. [L]

16 = Hole diameter at top flange
Value >= 0; 0 means use program determined value. [L]

17 = Hole diameter at bottom flange
Value >= 0; 0 means use program determined value. [L]

18 = Hole diameter on web
Value >= 0; 0 means use program determined value. [L]

19 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

20 = Nominal compressive capacity, Pnc
Value >= 0; 0 means use program determined value. [F]

21 = Nominal tensile capacity, Pnt
Value >= 0; 0 means use program determined value. [F]

22 = Nominal bending capacity for yielding, Mn33
Value >= 0; 0 means use program determined value. [FL]

23 = Nominal bending capacity for yielding, Mn22
Value >= 0; 0 means use program determined value. [FL]

24 = Nominal bending capacity for lateral torsional buckling, Mn33
Value >= 0; 0 means use program determined value. [FL]

25 = Nominal bending capacity for lateral torsional buckling, Mn22
Value >= 0; 0 means use program determined value. [FL]

26 = Nominal shear capacity, Vn2
Value >= 0; 0 means use program determined value. [F]

27 = Nominal shear capacity, Vn3
Value >= 0; 0 means use program determined value. [F]
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.AISI_LRFD96.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a cold formed design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Framing type
2 = Demand/capacity ratio limit
3 = Phi bending stiffened
4 = Phi bending unstiffened
5 = Phi bending lateral torsional buckling
6 = Phi shear slender
7 = Phi shear nonslender
8 = Phi axial tension
9 = Phi axial compression
10 = Time history design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Demand/capacity ratio limit
Value > 0

3 = Phi bending stiffened
Value > 0

4 = Phi bending unstiffened
Value > 0

5 = Phi bending lateral torsional buckling
Value > 0

6 = Phi shear slender
Value > 0

7 = Phi shear nonslender
Value > 0

8 = Phi axial tension
Value > 0

9 = Phi axial compression
Value > 0

10 = Time history design
1 = Envelopes
2 = Step-by step
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.AISI_LRFD96.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a cold formed design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 27, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Moment coefficient, Ctf Major
10 = Moment coefficient, Ctf Minor
11 = Bending coefficient, Cb
12 = Moment factor, Alpha Major
13 = Moment factor, Alpha Minor
14 = Through fastened to deck
15 = Fastener eccentricity, a/b
16 = Hole diameter at top flange
17 = Hole diameter at bottom flange
18 = Hole diameter on web
19 = Yield stress, Fy
20 = Nominal compressive capacity, Pnc
21 = Nominal tensile capacity, Pnt
22 = Nominal bending capacity for yielding, Mn33
23 = Nominal bending capacity for yielding, Mn22
24 = Nominal bending capacity for lateral torsional buckling, Mn33
25 = Nominal bending capacity for lateral torsional buckling, Mn22
26 = Nominal shear capacity, Vn2
27 = Nominal shear capacity, Vn3
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Live load reduction factor
Value >= 0; 0 means use a program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor and Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Moment coefficient, Ctf Major
Value >= 0; 0 means use program determined value.

10 = Moment coefficient, Ctf Minor
Value >= 0; 0 means use program determined value.

11 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

12 = Moment factor, Alpha Major
Value >= 0; 0 means use program determined value.

13 = Moment factor, Alpha Minor
Value >= 0; 0 means use program determined value.

14 = Through fastened to deck
0 = No.
Any other value = Yes.

15 = Fastener eccentricity, a/b
Value >= 0; 0 means use program determined value. [L]

16 = Hole diameter at top flange
Value >= 0; 0 means use program determined value. [L]

17 = Hole diameter at bottom flange
Value >= 0; 0 means use program determined value. [L]

18 = Hole diameter on web
Value >= 0; 0 means use program determined value. [L]

19 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

20 = Nominal compressive capacity, Pnc
Value >= 0; 0 means use program determined value. [F]

21 = Nominal tensile capacity, Pnt
Value >= 0; 0 means use program determined value. [F]

22 = Nominal bending capacity for yielding, Mn33
Value >= 0; 0 means use program determined value. [FL]

23 = Nominal bending capacity for yielding, Mn22
Value >= 0; 0 means use program determined value. [FL]

24 = Nominal bending capacity for lateral torsional buckling, Mn33
Value >= 0; 0 means use program determined value. [FL]

25 = Nominal bending capacity for lateral torsional buckling, Mn22
Value >= 0; 0 means use program determined value. [FL]

26 = Nominal shear capacity, Vn2
Value >= 0; 0 means use program determined value. [F]

27 = Nominal shear capacity, Vn3
Value >= 0; 0 means use program determined value. [F]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.AISI_LRFD96.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a cold formed design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Framing type
2 = Demand/capacity ratio limit
3 = Phi bending stiffened
4 = Phi bending unstiffened
5 = Phi bending lateral torsional buckling
6 = Phi shear slender
7 = Phi shear nonslender
8 = Phi axial tension
9 = Phi axial compression
10 = Time history design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Demand/capacity ratio limit
Value > 0

3 = Phi bending stiffened
Value > 0

4 = Phi bending unstiffened
Value > 0

5 = Phi bending lateral torsional buckling
Value > 0

6 = Phi shear slender
Value > 0

7 = Phi shear nonslender
Value > 0

8 = Phi axial tension
Value > 0

9 = Phi axial compression
Value > 0

10 = Time history design
1 = Envelopes
2 = Step-by step
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.AISI_LRFD96.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class EuroCold06:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design 
 overwrite item.
The function returns zero if the item is successfully 
 retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a cold-formed steel 
 frame design procedure.
Item: This is an integer between 1 and 33, inclusive, indicating 
 the overwrite item considered.
1 = Demand/capacity ratio limit
2 = Live load reduction factor
3 = Yield stress, Fy
4 = Net area to total area ratio
5 = Unbraced length ratio, Major
6 = Unbraced length ratio, Minor
7 = Unbraced length ratio, LTB
8 = Effective length factor sway, K2 Major
9 = Effective length factor sway, K2 Minor
10 = Effective length factor, K LTB
11 = Effective length factor braced, K1 
 Major
12 = Effective length factor braced, K1 
 Minor
13 = Bending coefficient, C1
14 = Bending coefficient, C2
15 = Bending coefficient, C3
16 = Moment coefficient, kyy
17 = Moment coefficient, kzz
18 = Moment coefficient, kzy
19 = Moment coefficient, kyz
20 = Column buckling curve, y-y
21 = Column buckling curve, z-z
22 = Buckling curve for LTB
23 = Elastic torsional buckling force, 
 Ncr T
24 = Elastic torsional-flexural buckling 
 force, Ncr TF
25 = Compressive capacity, NRk
26 = Tensile capacity, Nt.Rd
27 = Major bending capacity, MyRk
28 = Minor bending capacity, MzRk
29 = Major shear capacity, Vby.Rd
30 = Minor shear capacity, Vbz.Rd
31 = Warping coefficient, kw
32 = Coordinate of load application, za
33 = Lateral-torsional buckling moment 
 capacity, Mcr
Value: The value of the considered overwrite item.
1 = Demand/capacity ratio limit
Value 
 >= 0; 0 means use program determined value.

2 = Live load reduction factor
Value 
 >= 0; 0 means use program determined value.

3 = Yield stress, Fy
Value 
 >= 0; 0 means use program determined value. [F/L2]

4 = Net area to total area ratio
Value 
 >= 0; 0 means use program default value.

5 = Unbraced length ratio, Major
Value 
 >= 0; 0 means use program determined value.

6 = Unbraced length ratio, Minor
Value 
 >= 0; 0 means use program determined value.

7 = Unbraced length ratio, LTB
Value 
 >= 0; 0 means use program determined value.

8 = Effective length factor sway, K2 Major
Value >= 
 0; 0 means use program determined value.

9 = Effective length factor sway, K2 Minor
Value 
 >= 0; 0 means use program determined value.

10 = Effective length factor, K LTB
Value 
 >= 0; 0 means use program determined value.

11 = Effective length factor braced, K1 
 Major
Value 
 >= 0; 0 means use program determined value.

12 = Effective length factor braced, K1 
 Minor
Value 
 >= 0; 0 means use program determined value.

13 = Bending coefficient, C1
Value 
 >= 0; 0 means use program determined value.

14 = Bending coefficient, C2
Value >= 
 0; 0 means use program determined value.

15 = Bending coefficient, C3
Value 
 >= 0; 0 means use program determined value.

16 = Moment coefficient, kyy Major
Value 
 >= 0; 0 means use program determined value.

17 = Moment coefficient, kzz Minor
Value 
 >= 0; 0 means use program determined value.

18 = Moment coefficient, kzy
Value 
 >= 0; 0 means use program determined value.

19 = Moment coefficient, kyz
Value 
 >= 0; 0 means use program determined value.

20 = Column buckling curve, y-y
0 
 = Program default
1 
 = a0
2 
 = a
3 
 = b
4 
 = c
5 
 = d

21 = Column buckling curve, z-z
0 
 = Program default
1 
 = a0
2 
 = a
3 
 = b
4 
 = c
5 
 = d

22 = Buckling curve for LTB
0 
 = Program default
1 
 = a0
2 
 = a
3 
 = b
4 
 = c
5 
 = d

23 = Elastic torsional buckling force, 
 Ncr T
Value 
 >= 0; 0 means use program determined value. [F]

24 = Elastic torsional-flexural buckling 
 force, Ncr TF
Value 
 >= 0; 0 means use program determined value. [F]

25 = Compressive capacity, NRk
Value 
 >= 0; 0 means use program determined value. [F]

26 = Tensile capacity, Nt.Rd
Value 
 >= 0; 0 means use program determined value. [F]

27 = Major bending capacity, MyRk
Value 
 >= 0; 0 means use program determined value. [FL]

28 = Minor bending capacity, MzRk
Value 
 >= 0; 0 means use program determined value. [FL]

29 = Major shear capacity, Vby.Rd
Value 
 >= 0; 0 means use program determined value. [F]

30 = Minor shear capacity, Vbz.Rd
Value 
 >= 0; 0 means use program determined value. [F]

31 = Warping coefficient, kw 
 (used in Mcr calculation)
0.5 
 =<Value =< 1; 0 means use program determined value which is defaulted 
 to 1.0.

32 = Coordinate of load application, za 
 (used in Mcr calculation)
33 = Lateral-torsional buckling moment 
 capacity, Mcr
Value 
 >= 0; 0 means use program determined value. [FL]
ProgDet: If this item is True, the specified value is program 
 determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.EuroCold06.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a cold-formed steel 
 design preference item.
The function returns zero if the item is successfully 
 retrieved; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating 
 the preference item considered.
1 = Country
2 = Multi-response case design
3 = Demand/capacity ratio limit
4 = Combos equation
5 = Reliability class
6 = K factor method
7 = Consider P-Delta Done
8 = GammaM0
9 = GammaM1
10 = GammaM2
11 = Pattern live load factor
Value: The value of the considered preference 
 item.
1 = Country
1 = CEN 
 Default
2 = United 
 Kingdom
3 = Slovenia
4 = Bulgaria
5 = Norway
7 = Sweden
8 = Finland
9 = Denmark
10 = Portugal
11 = Germany

2 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

3 = Demand/capacity ratio limit
Value > 0

4 = Combos equation
1 = Eq. 6.10
2 = Max of Eqs. 
 6.10a and 6.10b

5 = Reliability class
1 = Class 1
2 = Class 2
3 = Class 3

6 = K factor method
1 = Method 1 (Annex 
 A)
2 = Method 2 (Annex 
 B)

7 = Consider P-Delta Done
0 = No
Any other value = Yes

8 = GammaM0
Value > 0

9 = GammaM1
Value > 0

10 = GammaM2
Value 
 > 0

11 = Pattern live load factor
Value >= 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.EuroCold06.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a cold-formed steel 
 design overwrite item.
The function returns zero if the item is successfully 
 set; otherwise, it returns a nonzero value.

Name: The name of a frame object with a cold-formed steel 
 frame design procedure.
Item: This is an integer between 1 and 33, inclusive, indicating 
 the overwrite item considered.
1 = Demand/capacity ratio limit
2 = Live load reduction factor
3 = Yield stress, Fy
4 = Net area to total area ratio
5 = Unbraced length ratio, Major
6 = Unbraced length ratio, Minor
7 = Unbraced length ratio, LTB
8 = Effective length factor sway, K2 Major
9 = Effective length factor sway, K2 Minor
10 = Effective length factor, K LTB
11 = Effective length factor braced, K1 
 Major
12 = Effective length factor braced, K1 
 Minor
13 = Bending coefficient, C1
14 = Bending coefficient, C2
15 = Bending coefficient, C3
16 = Moment coefficient, kyy
17 = Moment coefficient, kzz
18 = Moment coefficient, kzy
19 = Moment coefficient, kyz
20 = Column buckling curve, y-y
21 = Column buckling curve, z-z
22 = Buckling curve for LTB
23 = Elastic torsional buckling force, 
 Ncr T
24 = Elastic torsional-flexural buckling 
 force, Ncr TF
25 = Compressive capacity, NRk
26 = Tensile capacity, Nt.Rd
27 = Major bending capacity, MyRk
28 = Minor bending capacity, MzRk
29 = Major shear capacity, Vby.Rd
30 = Minor shear capacity, Vbz.Rd
31 = Warping coefficient, kw
32 = Coordinate of load application, za
33 = Lateral-torsional buckling moment 
 capacity, Mcr
Value: The value of the considered overwrite item.
1 = Demand/capacity ratio limit
Value 
 >= 0; 0 means use program determined value.

2 = Live load reduction factor
Value 
 >= 0; 0 means use program determined value.

3 = Yield stress, Fy
Value 
 >= 0; 0 means use program determined value. [F/L2]

4 = Net area to total area ratio
Value 
 >= 0; 0 means use program default value.

5 = Unbraced length ratio, Major
Value 
 >= 0; 0 means use program determined value.

6 = Unbraced length ratio, Minor
Value 
 >= 0; 0 means use program determined value.

7 = Unbraced length ratio, LTB
Value 
 >= 0; 0 means use program determined value.

8 = Effective length factor sway, K2 Major
Value >= 
 0; 0 means use program determined value.

9 = Effective length factor sway, K2 Minor
Value 
 >= 0; 0 means use program determined value.

10 = Effective length factor, K LTB
Value 
 >= 0; 0 means use program determined value.

11 = Effective length factor braced, K1 
 Major
Value 
 >= 0; 0 means use program determined value.

12 = Effective length factor braced, K1 
 Minor
Value 
 >= 0; 0 means use program determined value.

13 = Bending coefficient, C1
Value 
 >= 0; 0 means use program determined value.

14 = Bending coefficient, C2
Value >= 
 0; 0 means use program determined value.

15 = Bending coefficient, C3
Value 
 >= 0; 0 means use program determined value.

16 = Moment coefficient, kyy Major
Value 
 >= 0; 0 means use program determined value.

17 = Moment coefficient, kzz Minor
Value 
 >= 0; 0 means use program determined value.

18 = Moment coefficient, kzy
Value 
 >= 0; 0 means use program determined value.

19 = Moment coefficient, kyz
Value 
 >= 0; 0 means use program determined value.

20 = Column buckling curve, y-y
0 
 = Program default
1 
 = a0
2 
 = a
3 
 = b
4 
 = c
5 
 = d

21 = Column buckling curve, z-z
0 
 = Program default
1 
 = a0
2 
 = a
3 
 = b
4 
 = c
5 
 = d

22 = Buckling curve for LTB
0 
 = Program default
1 
 = a0
2 
 = a
3 
 = b
4 
 = c
5 
 = d

23 = Elastic torsional buckling force, 
 Ncr T
Value 
 >= 0; 0 means use program determined value. [F]

24 = Elastic torsional-flexural buckling 
 force, Ncr TF
Value 
 >= 0; 0 means use program determined value. [F]

25 = Compressive capacity, NRk
Value 
 >= 0; 0 means use program determined value. [F]

26 = Tensile capacity, Nt.Rd
Value 
 >= 0; 0 means use program determined value. [F]

27 = Major bending capacity, MyRk
Value 
 >= 0; 0 means use program determined value. [FL]

28 = Minor bending capacity, MzRk
Value 
 >= 0; 0 means use program determined value. [FL]

29 = Major shear capacity, Vby.Rd
Value 
 >= 0; 0 means use program determined value. [F]

30 = Minor shear capacity, Vbz.Rd
Value 
 >= 0; 0 means use program determined value. [F]

31 = Warping coefficient, kw 
 (used in Mcr calculation)
0.5 
 =<Value =< 1; 0 means use program determined value which is defaulted 
 to 1.0.

32 = Coordinate of load application, za 
 (used in Mcr calculation)
33 = Lateral-torsional buckling moment 
 capacity, Mcr
Value 
 >= 0; 0 means use program determined value. [FL]
ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the 
 frame object specified by the Name item.
If this item is Group, the assignment is made to all 
 frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made 
 to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.EuroCold06.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a cold-formed steel 
 design preference item.
The function returns zero if the item is successfully 
 set; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating 
 the preference item considered.
1 = Country
2 = Multi-response case design
3 = Demand/capacity ratio limit
4 = Combos equation
5 = Reliability class
6 = K factor method
7 = Consider P-Delta Done
8 = GammaM0
9 = GammaM1
10 = GammaM2
11 = Pattern live load factor

Value: The value of the considered preference 
 item.
1 = Country
1 = CEN 
 Default
2 = United 
 Kingdom
3 = Slovenia
4 = Bulgaria
5 = Norway
7 = Sweden
8 = Finland
9 = Denmark
10 = Portugal
11 = Germany

2 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

3 = Demand/capacity ratio limit
Value > 0

4 = Combos equation
1 = Eq. 
 6.10
2 = Max 
 of Eqs. 6.10a and 6.10b

5 = Reliability class
1 = Class 1
2 = Class 2
3 = Class 3

6 = K factor method
1 = Method 1 (Annex 
 A)
2 = Method 2 (Annex 
 B)

7 = Consider P-Delta Done
0 = No
Any other value = Yes

8 = GammaM0
Value > 0

9 = GammaM1
Value > 0

10 = GammaM2
Value 
 > 0

11 = Pattern live load factor
Value >= 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignColdFormed.EuroCold06.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class DesignConcrete:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.AASHTO_Concrete_07 = AASHTO_Concrete_07(strict, api)
        self.AASHTO_LRFD_2012 = AASHTO_LRFD_2012(strict, api)
        self.AASHTO_LRFD_2014 = AASHTO_LRFD_2014(strict, api)
        self.ACI_318_02 = ACI_318_02(strict, api)
        self.ACI318_05_IBC2003 = ACI318_05_IBC2003(strict, api)
        self.ACI318_08_IBC2009 = ACI318_08_IBC2009(strict, api)
        self.ACI_318_99 = ACI_318_99(strict, api)
        self.AS_3600_09 = AS_3600_09(strict, api)
        self.AS_3600_01 = AS_3600_01(strict, api)
        self.BS8110_89 = BS8110_89(strict, api)
        self.BS8110_97 = BS8110_97(strict, api)
        self.Chinese_2010 = Chinese_2010(strict, api)
        self.CSA_A23_3_04 = CSA_A23_3_04(strict, api)
        self.CSA_A23_3_94 = CSA_A23_3_94(strict, api)
        self.Eurocode_2_2004 = Eurocode_2_2004(strict, api)
        self.EUROCODE_2_1992 = EUROCODE_2_1992(strict, api)
        self.Hong_Kong_CP_2004 = Hong_Kong_CP_2004(strict, api)
        self.Hong_Kong_CP_2013 = Hong_Kong_CP_2013(strict, api)
        self.Indian_IS_456_2000 = Indian_IS_456_2000(strict, api)
        self.Indian_IS_456_2003 = Indian_IS_456_2003(strict, api)
        self.Italian_DM_14_2_92 = Italian_DM_14_2_92(strict, api)
        self.KCI_1999 = KCI_1999(strict, api)
        self.Mexican_RCDF_2001 = Mexican_RCDF_2001(strict, api)
        self.NZS_3101_95 = NZS_3101_95(strict, api)
        self.Singapore_CP_65_99 = Singapore_CP_65_99(strict, api)
        self.Singaopre_CP_65_99 = Singaopre_CP_65_99(strict, api)
        self.SP63_13330_2012 = SP63_13330_2012(strict, api)
        self.UBC97 = UBC97(strict, api)
        self.Chinese_2002 = Chinese_2002(strict, api)

    def DeleteResults(self):
        """
This function deletes all concrete frame design results.
The function returns zero if the results are successfully deleted; otherwise it returns a nonzero value.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.DeleteResults(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteResults" failed')
        
        return ret

    def GetCode(self, CodeName = None):
        """
This function retrieves the concrete design code.
The function returns zero if the code is successfully retrieved; otherwise it returns a nonzero value.

CodeName: This is one of the following concrete design code names.
AASHTO LRFD 2014
AASHTO LRFD 2012
AASHTO Concrete 07
ACI 318-14
ACI 318-11
ACI 318-08/IBC2009
AS 3600-09
BS8110 97
Chinese 2010
CSA A23.3-14
CSA A23.3-04
Eurocode 2-2004
Hong Kong CP 2013
Indian IS 456-2000
Italian NTC 2008
KBC 2009
Mexican RCDF 2004
NZS 3101:2006
Singapore CP 65:99
SP 63.13330.2012
TS 500-2000
        """

        all_args = [CodeName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.GetCode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCode" failed')
        
        return ret

    def GetComboAutoGenerate(self, AutoGenerate = None):
        """
This function retrieves the value of the automatically generated code-based design load combinations option for concrete frame design.
The function returns zero if the options are successfully set; otherwise it returns a nonzero value.

AutoGenerate: If this item is True, the option to automatically generate code-based design load combinations for concrete frame design is turned on. If it is False, the option is turned off.
        """

        all_args = [AutoGenerate]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.GetComboAutoGenerate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetComboAutoGenerate" failed')
        
        return ret

    def GetComboStrength(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of all load combinations selected as design combinations for concrete strength design.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of load combinations selected as design combinations for concrete strength design.
MyName: This is an array that includes the name of each response combination selected as a design combination for concrete strength design.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.GetComboStrength(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetComboStrength" failed')
        
        return ret

    def GetDesignSection(self, Name = None, PropName = None):
        """
This function retrieves the design section for a specified concrete frame object.
The function returns zero if the section is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
PropName: The name of the design section for the specified frame object.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.GetDesignSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDesignSection" failed')
        
        return ret

    def GetResultsAvailable(self):
        """
The function returns True if the concrete frame design results are available, otherwise False.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.GetResultsAvailable(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetResultsAvailable" failed')
        
        return ret

    def GetSummaryResultsBeam(self, Name = None, NumberItems = None, FrameName = None, Location = None, TopCombo = None, TopArea = None, BotCombo = None, BotArea = None, VmajorCombo = None, VmajorArea = None, TLCombo = None, TLArea = None, TTCombo = None, TTArea = None, ErrorSummary = None, WarningSummary = None, ItemType = None):
        """
This function retrieves summary results for concrete design.
The function returns zero if the results are successfully retrieved; otherwise it returns a nonzero value.
Note that torsional design is only included for some codes.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The number of frame objects for which results are obtained.
FrameName: This is an array that includes each frame object name for which results are obtained.
Location: This is an array that includes the distance from the I-end of the frame object to the location where the results are reported. [L]
TopCombo: This is an array that includes the name of the design combination for which the controlling top longitudinal rebar area for flexure occurs. A combination name followed by (Sp) indicates that the design loads were obtained by applying special, code-specific multipliers to all or part of the specified design load combination, or that the design was based on the capacity of other objects (or other design locations for the same object).
TopArea: This is an array that includes the total top longitudinal rebar area required for the flexure at the specified location. It does not include the area of steel required for torsion. [L2]
BotCombo: This is an array that includes the name of the design combination for which the controlling bottom longitudinal rebar area for flexure occurs. A combination name followed by (Sp) indicates that the design loads were obtained by applying special, code-specific, multipliers to all or part of the specified design load combination, or that the design was based on the capacity of other objects (or other design locations for the same object).
BotArea: This is an array that includes the total bottom longitudinal rebar area required for the flexure at the specified location. It does not include the area of steel required for torsion. [L2]
VmajorCombo: This is an array that includes the name of the design combination for which the controlling shear occurs. A combination name followed by (Sp) indicates that the design loads were obtained by applying special, code-specific, multipliers to all or part of the specified design load combination, or that the design was based on the capacity of other objects (or other design locations for the same object).
VmajorArea: This is an array that includes the required area of transverse shear reinforcing per unit length along the frame object for shear at the specified location. [L2/L]
TLCombo: This is an array that includes the name of the design combination for which the controlling longitudinal rebar area for torsion occurs. A combination name followed by (Sp) indicates that the design loads were obtained by applying special, code-specific, multipliers to all or part of the specified design load combination, or that the design was based on the capacity of other objects (or other design locations for the same object).
TLArea: This is an array that includes the total longitudinal rebar area required for torsion. [L2]
TTCombo: This is an array that includes the name of the design combination for which the controlling transverse reinforcing for torsion occurs. A combination name followed by (Sp) indicates that the design loads were obtained by applying special, code-specific, multipliers to all or part of the specified design load combination, or that the design was based on the capacity of other objects (or other design locations for the same object).
TTArea: This is an array that includes the required area of transverse torsional shear reinforcing per unit length along the frame object for torsion at the specified location. [L2/L]
ErrorSummary: This is an array that includes the design error messages for the frame object, if any.
WarningSummary: This is an array that includes the design warning messages for the frame object, if any.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the design results are retrieved for the frame object specified by the Name item.
If this item is Group, the design results are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the design results are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, Location, TopCombo, TopArea, BotCombo, BotArea, VmajorCombo, VmajorArea, TLCombo, TLArea, TTCombo, TTArea, ErrorSummary, WarningSummary, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.GetSummaryResultsBeam(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSummaryResultsBeam" failed')
        
        return ret

    def GetSummaryResultsColumn(self, Name = None, NumberItems = None, FrameName = None, MyOption = None, Location = None, PMMCombo = None, PMMArea = None, PMMRatio = None, VmajorCombo = None, AVmajor = None, VminorCombo = None, AVminor = None, ErrorSummary = None, WarningSummary = None, ItemType = None):
        """
This function retrieves summary results for concrete design.
The function returns zero if the results are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The number of frame objects for which results are obtained.
FrameName: This is an array that includes each frame object name for which results are obtained.
MyOption: This is an array that includes 1 or 2, indicating the design option for each frame object.
1 = Check
2 = Design
Location: This is an array that includes the distance from the I-end of the frame object to the location where the results are reported. [L]
PMMCombo: This is an array that includes the name of the design combination for which the controlling PMM ratio or rebar area occurs. A combination name followed by (Sp) indicates that the design loads were obtained by applying special, code-specific multipliers to all or part of the specified design load combination, or that the design was based on the capacity of other objects (or other design locations for the same object).
PMMArea: This is an array that includes the total longitudinal rebar area required for the axial force plus biaxial moment (PMM) design at the specified location. [L2]
This item applies only when MyOption = 2 (design).
PMMRatio: This is an array that includes the axial force plus biaxial moment (PMM) stress ratio at the specified location.
This item applies only when MyOption = 1 (check).
VmajorCombo: This is an array that includes the name of the design combination for which the controlling major shear occurs.
AVmajor: This is an array that includes the required area of transverse shear reinforcing per unit length along the frame object for major shear at the specified location. [L2/L]
VminorCombo: This is an array that includes the name of the design combination for which the controlling minor shear occurs.
AVminor: This is an array that includes the required area of transverse shear reinforcing per unit length along the frame object for minor shear at the specified location. [L2/L]
ErrorSummary: This is an array that includes the design error messages for the frame object, if any.
WarningSummary: This is an array that includes the design warning messages for the frame object, if any.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the design results are retrieved for the frame object specified by the Name item.
If this item is Group, the design results are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the design results are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, MyOption, Location, PMMCombo, PMMArea, PMMRatio, VmajorCombo, AVmajor, VminorCombo, AVminor, ErrorSummary, WarningSummary, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.GetSummaryResultsColumn(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSummaryResultsColumn" failed')
        
        return ret

    def GetSummaryResultsJoint(self, Name = None, NumberItems = None, FrameName = None, LCJSRatioMajor = None, JSRatioMajor = None, LCJSRatioMinor = None, JSRatioMinor = None, LCBCCRatioMajor = None, BCCRatioMajor = None, LCBCCRatioMinor = None, BCCRatioMinor = None, ErrorSummary = None, WarningSummary = None, ItemType = None):
        """
This function retrieves summary results for concrete design.
The function returns zero if the results are successfully retrieved; otherwise it returns a nonzero value.
Note that joint design is only included for some codes.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The number of frame objects for which results are obtained.
FrameName: This is an array that includes each frame object name for which results are obtained.
LCJSRatioMajor: This is an array that includes the name of the design combination for which the controlling joint shear ratio associated with the column major axis occurs. A combination name followed by (Sp) indicates that the design loads were obtained by applying special, code-specific multipliers to all or part of the specified design load combination, or that the design was based on the capacity of other objects (or other design locations for the same object).
JSRatioMajor: This is an array that includes the joint shear ratio associated with the column major axis. This is the joint shear divided by the joint shear capacity.
LCJSRatioMinor: This is an array that includes the name of the design combination for which the controlling joint shear ratio associated with the column minor axis occurs. A combination name followed by (Sp) indicates that the design loads were obtained by applying special, code-specific multipliers to all or part of the specified design load combination, or that the design was based on the capacity of other objects (or other design locations for the same object).
JSRatioMinor: This is an array that includes the joint shear ratio associated with the column minor axis. This is the joint shear divided by the joint shear capacity.
LCBCCRatioMajor: This is an array that includes the name of the design combination for which the controlling beam/column capacity ratio associated with the column major axis occurs. A combination name followed by (Sp) indicates that the design loads were obtained by applying special, code-specific multipliers to all or part of the specified design load combination, or that the design was based on the capacity of other objects (or other design locations for the same object).
BCCRatioMajor: This is an array that includes the beam/column capacity ratio associated with the column major axis. This is the sum of the column capacities divided by the sum of the beam capacities at the top of the specified column.
LCBCCRatioMinor: This is an array that includes the name of the design combination for which the controlling beam/column capacity ratio associated with the column minor axis occurs. A combination name followed by (Sp) indicates that the design loads were obtained by applying special, code-specific multipliers to all or part of the specified design load combination, or that the design was based on the capacity of other objects (or other design locations for the same object).
BCCRatioMinor: This is an array that includes the beam/column capacity ratio associated with the column minor axis. This is the sum of the column capacities divided by the sum of the beam capacities at the top of the specified column.
ErrorSummary: This is an array that includes the design error messages for the frame object, if any.
WarningSummary: This is an array that includes the design warning messages for the frame object, if any.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the design results are retrieved for the frame object specified by the Name item.
If this item is Group, the design results are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the design results are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, LCJSRatioMajor, JSRatioMajor, LCJSRatioMinor, JSRatioMinor, LCBCCRatioMajor, BCCRatioMajor, LCBCCRatioMinor, BCCRatioMinor, ErrorSummary, WarningSummary, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.GetSummaryResultsJoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSummaryResultsJoint" failed')
        
        return ret

    def ResetOverwrites(self):
        """
This function resets all concrete frame design overwrites to default values.
The function returns zero if the overwrites are successfully reset; otherwise it returns a nonzero value.
The function will fail if no concrete frame objects are present.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ResetOverwrites(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ResetOverwrites" failed')
        
        return ret

    def SetCode(self, CodeName = None):
        """
This function sets the concrete design code.
The function returns zero if the code is successfully set; otherwise it returns a nonzero value.

CodeName: This is one of the following concrete design code names.
AASHTO LRFD 2014
AASHTO LRFD 2012
AASHTO Concrete 07
ACI 318-14
ACI 318-11
ACI 318-08/IBC2009
AS 3600-09
BS8110 97
Chinese 2010
CSA A23.3-14
CSA A23.3-04
Eurocode 2-2004
Hong Kong CP 2013
Indian IS 456-2000
Italian NTC 2008
KBC 2009
Mexican RCDF 2004
NZS 3101:2006
Singapore CP 65:99
SP 63.13330.2012
TS 500-2000
        """

        all_args = [CodeName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.SetCode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCode" failed')
        
        return ret

    def SetComboAutoGenerate(self, AutoGenerate = None):
        """
This function turns on or off the option to automatically generate code-based design load combinations for concrete frame design.
The function returns zero if the options are successfully set; otherwise it returns a nonzero value.

AutoGenerate: If this item is True, the option to automatically generate code-based design load combinations for concrete frame design is turned on. If it is False, the option is turned off.
        """

        all_args = [AutoGenerate]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.SetComboAutoGenerate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetComboAutoGenerate" failed')
        
        return ret

    def SetComboStrength(self, Name = None, Selected = None):
        """
This function selects or deselects a load combination for concrete strength design.
The function returns zero if the selection status is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing load combination.
Selected: If this item is True, the specified load combination is selected as a design combination for concrete strength design. If it is False, the combination is not selected for concrete strength design.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.SetComboStrength(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetComboStrength" failed')
        
        return ret

    def SetDesignSection(self, Name = None, PropName = None, LastAnalysis = None, ItemType = None):
        """
This function modifies the design section for all specified frame objects that have a concrete frame design procedure.
The function returns zero if the design section is successfully modified; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
PropName: The name of an existing frame section property to be used as the design section for the specified frame objects. This item applies only when LastAnalysis = False.
LastAnalysis: If this item is True, the design section for the specified frame objects is reset to the last analysis section for the frame object. If it is False, the design section is set to that specified by PropName.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, LastAnalysis, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.SetDesignSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDesignSection" failed')
        
        return ret

    def StartDesign(self):
        """
This function starts the concrete frame design.
The function returns zero if the concrete frame design is successfully started; otherwise it returns a nonzero value.
The function will fail if no concrete frame objects are present. It also will fail if analysis results are not available.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.StartDesign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"StartDesign" failed')
        
        return ret

    def VerifyPassed(self, NumberItems = None, n1 = None, n2 = None, MyName = None):
        """
This function retrieves the names of the frame objects that did not pass the design check or have not yet been checked, if any.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of concrete frame objects that did not pass the design check or have not yet been checked.
n1: The number of concrete frame objects that did not pass the design check.
n2: The number of concrete frame objects that have not yet been checked.
MyName: This is an array that includes the name of each frame object that did not pass the design check or has not yet been checked.
        """

        all_args = [NumberItems, n1, n2, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.VerifyPassed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"VerifyPassed" failed')
        
        return ret

    def VerifySections(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of the frame objects that have different analysis and design sections, if any.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of frame objects that have different analysis and design sections.
MyName: This is an array that includes the name of each frame object that has different analysis and design sections.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.VerifySections(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"VerifySections" failed')
        
        return ret

class AASHTO_Concrete_07:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 11, inclusive, indicating the overwrite item considered.
1 = Live load reduction factor
2 = Unbraced length ratio, Major
3 = Unbraced length ratio, Minor
4 = Effective length factor, K Major
5 = Effective length factor, K Minor
6 = Moment coefficient, Cm Major
7 = Moment coefficient, Cm Minor
8 = Nonsway moment factor, Db Major
9 = Nonsway moment factor, Db Minor
10 = Sway moment factor, Ds Major
11 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Live load reduction factor
Value >= 0; 0 means use program determined value.

2 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

4 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

6 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

8 = Nonsway moment factor, Db Major
Value >= 0; 0 means use program determined value.

9 = Nonsway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

10 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AASHTO_Concrete_07.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 7, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Seismic Zone
5 = Pattern live load factor
6 = Utilization factor limit
7 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and divisible by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Seismic Zone
0 = Zone 0
1 = Zone 1
2 = Zone 2
3 = Zone 3
4 = Zone 4

5 = Pattern live load factor
Value >= 0

6 = Utilization factor limit
Value > 0

7 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AASHTO_Concrete_07.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 11, inclusive, indicating the overwrite item considered.
1 = Live load reduction factor
2 = Unbraced length ratio, Major
3 = Unbraced length ratio, Minor
4 = Effective length factor, K Major
5 = Effective length factor, K Minor
6 = Moment coefficient, Cm Major
7 = Moment coefficient, Cm Minor
8 = Nonsway moment factor, Db Major
9 = Nonsway moment factor, Db Minor
10 = Sway moment factor, Ds Major
11 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Live load reduction factor
Value >= 0; 0 means use program determined value.

2 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

4 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

6 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

8 = Nonsway moment factor, Db Major
Value >= 0; 0 means use program determined value.

9 = Nonsway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

10 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AASHTO_Concrete_07.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 7, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Seismic Zone
5 = Pattern live load factor
6 = Utilization factor limit
7 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and divisible by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Seismic Zone
0 = Zone 0
1 = Zone 1
2 = Zone 2
3 = Zone 3
4 = Zone 4

5 = Pattern live load factor
Value >= 0

6 = Utilization factor limit
Value > 0

7 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AASHTO_Concrete_07.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AASHTO_LRFD_2012:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 11, inclusive, indicating the overwrite item considered.
1 = Live load reduction factor
2 = Unbraced length ratio, Major
3 = Unbraced length ratio, Minor
4 = Effective length factor, K Major
5 = Effective length factor, K Minor
6 = Moment coefficient, Cm Major
7 = Moment coefficient, Cm Minor
8 = Nonsway moment factor, Db Major
9 = Nonsway moment factor, Db Minor
10 = Sway moment factor, Ds Major
11 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Live load reduction factor
Value >= 0; 0 means use program determined value.

2 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

4 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

6 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

8 = Nonsway moment factor, Db Major
Value >= 0; 0 means use program determined value.

9 = Nonsway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

10 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AASHTO_LRFD_2012.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 7, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Seismic Zone
5 = Pattern live load factor
6 = Utilization factor limit
7 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and divisible by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Seismic Zone
0 = Zone 0
1 = Zone 1
2 = Zone 2
3 = Zone 3
4 = Zone 4

5 = Pattern live load factor
Value >= 0

6 = Utilization factor limit
Value > 0

7 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AASHTO_LRFD_2012.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 11, inclusive, indicating the overwrite item considered.
1 = Live load reduction factor
2 = Unbraced length ratio, Major
3 = Unbraced length ratio, Minor
4 = Effective length factor, K Major
5 = Effective length factor, K Minor
6 = Moment coefficient, Cm Major
7 = Moment coefficient, Cm Minor
8 = Nonsway moment factor, Db Major
9 = Nonsway moment factor, Db Minor
10 = Sway moment factor, Ds Major
11 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Live load reduction factor
Value >= 0; 0 means use program determined value.

2 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

4 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

6 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

8 = Nonsway moment factor, Db Major
Value >= 0; 0 means use program determined value.

9 = Nonsway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

10 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AASHTO_LRFD_2012.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 7, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Seismic Zone
5 = Pattern live load factor
6 = Utilization factor limit
7 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and divisible by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Seismic Zone
0 = Zone 0
1 = Zone 1
2 = Zone 2
3 = Zone 3
4 = Zone 4

5 = Pattern live load factor
Value >= 0

6 = Utilization factor limit
Value > 0

7 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AASHTO_LRFD_2012.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AASHTO_LRFD_2014:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 11, inclusive, indicating the overwrite item considered.
1 = Live load reduction factor
2 = Unbraced length ratio, Major
3 = Unbraced length ratio, Minor
4 = Effective length factor, K Major
5 = Effective length factor, K Minor
6 = Moment coefficient, Cm Major
7 = Moment coefficient, Cm Minor
8 = Nonsway moment factor, Db Major
9 = Nonsway moment factor, Db Minor
10 = Sway moment factor, Ds Major
11 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Live load reduction factor
Value >= 0; 0 means use program determined value.

2 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

4 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

6 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

8 = Nonsway moment factor, Db Major
Value >= 0; 0 means use program determined value.

9 = Nonsway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

10 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AASHTO_LRFD_2014.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 7, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Seismic Zone
5 = Pattern live load factor
6 = Utilization factor limit
7 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and divisible by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Seismic Zone
0 = Zone 0
1 = Zone 1
2 = Zone 2
3 = Zone 3
4 = Zone 4

5 = Pattern live load factor
Value >= 0

6 = Utilization factor limit
Value > 0

7 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AASHTO_LRFD_2014.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 11, inclusive, indicating the overwrite item considered.
1 = Live load reduction factor
2 = Unbraced length ratio, Major
3 = Unbraced length ratio, Minor
4 = Effective length factor, K Major
5 = Effective length factor, K Minor
6 = Moment coefficient, Cm Major
7 = Moment coefficient, Cm Minor
8 = Nonsway moment factor, Db Major
9 = Nonsway moment factor, Db Minor
10 = Sway moment factor, Ds Major
11 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Live load reduction factor
Value >= 0; 0 means use program determined value.

2 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

4 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

6 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

8 = Nonsway moment factor, Db Major
Value >= 0; 0 means use program determined value.

9 = Nonsway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

10 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AASHTO_LRFD_2014.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 7, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Seismic Zone
5 = Pattern live load factor
6 = Utilization factor limit
7 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and divisible by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Seismic Zone
0 = Zone 0
1 = Zone 1
2 = Zone 2
3 = Zone 3
4 = Zone 4

5 = Pattern live load factor
Value >= 0

6 = Utilization factor limit
Value > 0

7 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AASHTO_LRFD_2014.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class ACI_318_02:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway intermediate
3 = Sway ordinary
4 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI_318_02.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 13, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Seismic design category
5 = Phi tension controlled
6 = Phi compression controlled tied
7 = Phi compression controlled spiral
8 = Phi shear and/or torsion
9 = Phi shear seismic
10 = Phi joint shear
11 = Pattern live load factor
12 = Utilization factor limit
13 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Seismic design category
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

5 = Phi tension controlled
Value > 0

6 = Phi compression controlled tied
Value > 0

7 = Phi compression controlled spiral
Value > 0

8 = Phi shear and/or torsion
Value > 0
9 = Phi shear seismic
Value > 0

10 = Phi joint shear
Value > 0

11 = Pattern live load factor
Value >= 0

12 = Utilization factor limit
Value > 0

13 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI_318_02.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway intermediate
3 = Sway ordinary
4 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI_318_02.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 13, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Seismic design category
5 = Phi tension controlled
6 = Phi compression controlled tied
7 = Phi compression controlled spiral
8 = Phi shear and/or torsion
9 = Phi shear seismic
10 = Phi joint shear
11 = Pattern live load factor
12 = Utilization factor limit
13 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Seismic design category
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

5 = Phi tension controlled
Value > 0

6 = Phi compression controlled tied
Value > 0

7 = Phi compression controlled spiral
Value > 0

8 = Phi shear and/or torsion
Value > 0

9 = Phi shear seismic
Value > 0

10 = Phi joint shear
Value > 0

11 = Pattern live load factor
Value >= 0

12 = Utilization factor limit
Value > 0

13 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI_318_02.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class ACI318_05_IBC2003:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Nonsway moment factor, Dns Major
10 = Nonsway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway Intermediate
3 = Sway Ordinary
4 = Nonsway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Nonsway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Nonsway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI318_05_IBC2003.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 13, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Seismic design category
5 = Phi tension controlled
6 = Phi compression controlled tied
7 = Phi compression controlled spiral
8 = Phi shear and/or torsion
9 = Phi shear seismic
10 = Phi joint shear
11 = Pattern live load factor
12 = Utilization factor limit
13 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and divisible by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Seismic design category
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

5 = Phi tension controlled
Value > 0

6 = Phi compression controlled tied
Value > 0

7 = Phi compression controlled spiral
Value > 0

8 = Phi shear and/or torsion
Value > 0

9 = Phi shear seismic
Value > 0

10 = Phi joint shear
Value > 0

11 = Pattern live load factor
Value >= 0

12 = Utilization factor limit
Value > 0

13 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI318_05_IBC2003.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway Intermediate
3 = Sway Ordinary
4 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects= 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI318_05_IBC2003.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 13, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Seismic design category
5 = Phi tension controlled
6 = Phi compression controlled tied
7 = Phi compression controlled spiral
8 = Phi shear and/or torsion
9 = Phi shear seismic
10 = Phi joint shear
11 = Pattern live load factor
12 = Utilization factor limit
13 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and divisible by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Seismic design category
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

5 = Phi tension controlled
Value > 0

6 = Phi compression controlled tied
Value > 0

7 = Phi compression controlled spiral
Value > 0

8 = Phi shear and/or torsion
Value > 0

9 = Phi shear seismic
Value > 0

10 = Phi joint shear
Value > 0

11 = Pattern live load factor
Value >= 0

12 = Utilization factor limit
Value > 0

13 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI318_05_IBC2003.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class ACI318_08_IBC2009:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Nonsway moment factor, Dns Major
10 = Nonsway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway Intermediate
3 = Sway Ordinary
4 = Nonsway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Nonsway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Nonsway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI318_08_IBC2009.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 13, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Seismic design category
5 = Phi tension controlled
6 = Phi compression controlled tied
7 = Phi compression controlled spiral
8 = Phi shear and/or torsion
9 = Phi shear seismic
10 = Phi joint shear
11 = Pattern live load factor
12 = Utilization factor limit
13 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Seismic design category
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

5 = Phi tension controlled
Value > 0

6 = Phi compression controlled tied
Value > 0

7 = Phi compression controlled spiral
Value > 0

8 = Phi shear and/or torsion
Value > 0

9 = Phi shear seismic
Value > 0

10 = Phi joint shear
Value > 0

11 = Pattern live load factor
Value >= 0

12 = Utilization factor limit
Value > 0

13 = Multi-response case design
1 = Envelopes
2 = Step-by step
3= Last step
4 = Envelopes - All
5 = Step-by step - All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI318_08_IBC2009.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway Intermediate
3 = Sway Ordinary
4 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects= 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI318_08_IBC2009.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 13, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Seismic design category
5 = Phi tension controlled
6 = Phi compression controlled tied
7 = Phi compression controlled spiral
8 = Phi shear and/or torsion
9 = Phi shear seismic
10 = Phi joint shear
11 = Pattern live load factor
12 = Utilization factor limit
13 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Seismic design category
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

5 = Phi tension controlled
Value > 0

6 = Phi compression controlled tied
Value > 0

7 = Phi compression controlled spiral
Value > 0

8 = Phi shear and/or torsion
Value > 0

9 = Phi shear seismic
Value > 0

10 = Phi joint shear
Value > 0

11 = Pattern live load factor
Value >= 0

12 = Utilization factor limit
Value > 0

13 = Multi-response case design
1 = Envelopes
2 = Step-by step
3= Last step
4 = Envelopes - All
5 = Step-by step - All

        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI318_08_IBC2009.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class ACI_318_99:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = No-nsway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway intermediate
3 = Sway ordinary
4 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI_318_99.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi bending torsion
5 = Phi compression controlled tied
6 = Phi compression controlled spiral
7 = Phi shear
8 = Pattern live load factor
9 = Utilization factor limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi bending torsion
Value > 0

5 = Phi compression controlled tied
Value > 0

6 = Phi compression controlled spiral
Value > 0

7 = Phi shear
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Utilization factor limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI_318_99.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway intermediate
3 = Sway ordinary
4 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI_318_99.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi bending torsion
5 = Phi compression controlled tied
6 = Phi compression controlled spiral
7 = Phi shear
8 = Pattern live load factor
9 = Utilization factor limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi bending torsion
Value > 0

5 = Phi compression controlled tied
Value > 0

6 = Phi compression controlled spiral
Value > 0

7 = Phi shear
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Utilization factor limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.ACI_318_99.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AS_3600_09:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, km Major
8 = Moment coefficient, km Minor
9 = Nonsway moment factor, Db Major
10 = Nonsway moment factor, Db Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor

Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = Sway special
2 = Sway intermediate
3 = Sway ordinary
4 = Nonsway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, km Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, km Minor
Value >= 0; 0 means use program determined value.

9 = Nonsway moment factor, Db Major
Value >= 0; 0 means use program determined value.

10 = Nonsway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.

ProgDet: If this item is True then the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AS_3600_09.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved, otherwise it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi tension controlled
5 = Phi compression controlled
6 = Phi shear and/or torsion
7 = Phi shear seismic
8 = Phi joint shear
9 = Pattern live load factor
10 = Utilization factor limit
11 = Multi-response case design

Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and divisible by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi tension controlled
Value > 0

5 = Phi compression controlled
Value > 0

6 = Phi shear and/or torsion
Value > 0

7 = Phi shear seismic
Value > 0

8 = Phi joint shear
Value > 0

9 = Pattern live load factor
Value >= 0

10 = Utilization factor limit
Value > 0

11 = Multi-response case design
1 = Envelopes
2 = Step-by step
3= Last step
4 = Envelopes - All
5 = Step-by step - All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AS_3600_09.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, km Major
8 = Moment coefficient, km Minor
9 = Nonsway moment factor, Db Major
10 = Nonsway moment factor, Db Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor

Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = Sway special
2 = Sway intermediate
3 = Sway ordinary
4 = Nonsway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, km Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, km Minor
Value >= 0; 0 means use program determined value.

9 = Nonsway moment factor, Db Major
Value >= 0; 0 means use program determined value.

10 = Nonsway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.

ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AS_3600_09.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi tension controlled
5 = Phi compression controlled
6 = Phi shear and/or torsion
7 = Phi shear seismic
8 = Phi joint shear
9 = Pattern live load factor
10 = Utilization factor limit
11 = Time history design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and divisible by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi tension controlled
Value > 0

5 = Phi compression controlled
Value > 0

6 = Phi shear and/or torsion
Value > 0

7 = Phi shear seismic
Value > 0

8 = Phi joint shear
Value > 0

9 = Pattern live load factor
Value >= 0

10 = Utilization factor limit
Value > 0

11 = Multi-response case design
1 = Envelopes
2 = Step-by step
3= Last step
4 = Envelopes - All
5 = Step-by step - All

        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AS_3600_09.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AS_3600_01:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, km Major
8 = Moment coefficient, km Minor
9 = Nonsway moment factor, Db Major
10 = Nonsway moment factor, Db Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor

Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway intermediate
3 = Sway ordinary
4 = Nonsway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, km Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, km Minor
Value >= 0; 0 means use program determined value.

9 = Nonsway moment factor, Db Major
Value >= 0; 0 means use program determined value.

10 = Nonsway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.

ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AS_3600_01.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi tension controlled
5 = Phi compression controlled
6 = Phi shear and/or torsion
7 = Phi shear seismic
8 = Phi joint shear
9 = Pattern live load factor
10 = Utilization factor limit
11 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and divisible by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi tension controlled
Value > 0

5 = Phi compression controlled
Value > 0

6 = Phi shear and/or torsion
Value > 0

7 = Phi shear seismic
Value > 0

8 = Phi joint shear
Value > 0

9 = Pattern live load factor
Value >= 0

10 = Utilization factor limit
Value > 0

11 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AS_3600_01.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise, it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, km Major
8 = Moment coefficient, km Minor
9 = Nonsway moment factor, Db Major
10 = Nonsway moment factor, Db Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway intermediate
3 = Sway ordinary
4 = Nonsway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, km Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, km Minor
Value >= 0; 0 means use program determined value.

9 = Nonsway moment factor, Db Major
Value >= 0; 0 means use program determined value.

10 = Nonsway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value

ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AS_3600_01.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi tension controlled
5 = Phi compression controlled
6 = Phi shear and/or torsion
7 = Phi shear seismic
8 = Phi joint shear
9 = Pattern live load factor
10 = Utilization factor limit
11 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and divisible by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi tension controlled
Value > 0

5 = Phi compression controlled
Value > 0

6 = Phi shear and/or torsion
Value > 0

7 = Phi shear seismic
Value > 0

8 = Phi joint shear
Value > 0

9 = Pattern live load factor
Value >= 0

10 = Utilization factor limit
Value > 0

11 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.AS_3600_01.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class BS8110_89:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, Beta Major
6 = Effective length factor, Beta Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.BS8110_89.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 6, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Pattern live load factor
5 = Utilization factor limit
6 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Pattern live load factor
Value >= 0

5 = Utilization factor limit
Value > 0

6 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.BS8110_89.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, Beta Major
6 = Effective length factor, Beta Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.BS8110_89.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 6, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Pattern live load factor
5 = Utilization factor limit
6 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Pattern live load factor
Value >= 0

5 = Utilization factor limit
Value > 0

6 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.BS8110_89.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class BS8110_97:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, Beta Major
6 = Effective length factor, Beta Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.BS8110_97.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 9, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Gamma steel
5 = Gamma concrete
6 = Gamma concrete shear
7 = Pattern live load factor
8 = Utilization factor limit
9 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and desvisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Gamma steel
Value > 0

5 = Gamma concrete
Value > 0

6 = Gamma concrete shear
Value > 0

7 = Pattern live load factor
Value >= 0

8 = Utilization factor limit
Value > 0

9 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.BS8110_97.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, Beta Major
6 = Effective length factor, Beta Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.BS8110_97.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

class Chinese_2010:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

class CSA_A23_3_04:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Db Major
10 = Non-sway moment factor, Db Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
13 = Force modification factor, Rd
14 = Force modification factor, Ro
15 = Maximum aggregate size
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Ductile
2 = Moderate
3 = Conventional

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Db Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.

13 = Force modification factor, Rd
Value >= 0; 0 means use program determined value.

14 = Force modification factor, Ro
Value >= 0; 0 means use program determined value.

15 = Maximum aggregate size
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.CSA_A23_3_04.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 8, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi steel
5 = Phi concrete
6 = Pattern live load factor
7 = Utilization factor limit
8 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi steel
Value > 0

5 = Phi concrete
Value > 0

6 = Pattern live load factor
Value >= 0

7 = Utilization factor limit
Value > 0

8 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.CSA_A23_3_04.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Db Major
10 = Non-sway moment factor, Db Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
13 = Force modification factor, Rd
14 = Force modification factor, Ro
15 = Maximum aggregate size
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Ductile
2 = Moderate
3 = Conventional

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Db Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.

13 = Force modification factor, Rd
Value >= 0; 0 means use program determined value.

14 = Force modification factor, Ro
Value >= 0; 0 means use program determined value.

15 = Maximum aggregate size
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.CSA_A23_3_04.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 8, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi steel
5 = Phi concrete
6 = Pattern live load factor
7 = Utilization factor limit
8 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi steel
Value > 0

5 = Phi concrete
Value > 0

6 = Pattern live load factor
Value >= 0

7 = Utilization factor limit
Value > 0

8 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.CSA_A23_3_04.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class CSA_A23_3_94:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Db Major
10 = Non-sway moment factor, Db Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Ductile
2 = Nominal
3 = Ordinary

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Db Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.CSA_A23_3_94.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 8, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi steel
5 = Phi concrete
6 = Pattern live load factor
7 = Utilization factor limit
8 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi steel
Value > 0

5 = Phi concrete
Value > 0

6 = Pattern live load factor
Value >= 0

7 = Utilization factor limit
Value > 0

8 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.CSA_A23_3_94.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, DbMajor
10 = Non-sway moment factor, DbMinor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Ductile
2 = Nominal
3 = Ordinary

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Db Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.CSA_A23_3_94.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 8, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi steel
5 = Phi concrete
6 = Pattern live load factor
7 = Utilization factor limit
8 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi steel
Value > 0

5 = Phi concrete
Value > 0

6 = Pattern live load factor
Value >= 0

7 = Utilization factor limit
Value > 0

8 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.CSA_A23_3_94.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Eurocode_2_2004:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design 
 overwrite item.
The function returns zero if the item is successfully 
 retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a concrete frame design 
 procedure.
Item: This is an integer between 1 and 24, inclusive, indicating 
 the overwrite item considered.
1 = Framing type
2 = Live load reduction 
 factor
3 = Unbraced length ratio, 
 Major
4 = Unbraced length ratio, 
 Minor
5 = Effective length factor, 
 Beta Major
6 = Effective length factor, 
 Beta Minor
7 = Moment coefficient, 
 Cm Major
8 = Moment coefficient, 
 Cm Minor
9 = Nonsway moment factor, 
 Dns Major
10 = Nonsway moment factor, 
 Dns Minor
11 = Sway moment factor, 
 Ds Major
12 = Sway moment factor, 
 Ds Minor
13 = Correction factor 
 depending on axial load in Nominal Curvature method, Kr Major
14 = Correction factor 
 depending on axial load in Nominal Curvature method, KPhi Major
15 = Shear compressive 
 strut angle, TanTheta
16 = Factor accounting 
 for creep in Nominal Curvature method, Kr Minor
17 = Factor accounting 
 for creep in Nominal Curvature method, KPhi Minor
18 = Coefficient depending 
 on the distribution of first-order moment in both Nominal Stiffness and 
 Nominal Curvature methods, c Major
19 = Coefficient depending 
 on the distribution of first-order moment in both Nominal Stiffness and 
 Nominal Curvature methods, c Minor
20 = Factor for contribution 
 of reinforcement, Ks Major
21 = Factor for contribution 
 of reinforcement, Ks Minor
22 = Factor for effects 
 of cracking, creep etc, Kc Major
23 = Factor for effects 
 of cracking, creep etc, Kc Minor
24 = Effective creep 
 coefficient, Phief

Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Nonsway

2 = Live load reduction 
 factor
Value >= 0; 0 means 
 use program determined value.

3 = Unbraced length ratio, 
 Major
Value >= 0; 0 means 
 use program determined value.

4 = Unbraced length ratio, 
 Minor
Value >= 0; 0 means 
 use program determined value.

5 = Effective length factor, 
 Beta Major
Value >= 0; 0 means 
 use program determined value.

6 = Effective length factor, 
 Beta Minor
Value >= 0; 0 means 
 use program determined value.

7 = Moment coefficient, 
 Cm Major
Value >= 0; 0 means 
 use program determined value.

8 = Moment coefficient, 
 Cm Minor
Value >= 0; 0 means 
 use program determined value.

9 = Nonsway moment factor, 
 Dns Major
Value >= 0; 0 means 
 use program determined value.

10 = Nonsway moment factor, 
 Dns Minor
Value >= 
 0; 0 means use program determined value.

11 = Sway moment factor, 
 Ds Major
Value >= 
 0; 0 means use program determined value.

12 = Sway moment factor, 
 Ds Minor
Value >= 
 0; 0 means use program determined value.

13 
 = Correction factor depending on axial load in Nominal Curvature method, 
 Kr Major
Value >= 0; 0 means 
 use program determined value.

14 = Correction factor 
 depending on axial load in Nominal Curvature method, KPhi Major
Value >= 0; 0 means 
 use program determined value.

15 = Shear compressive 
 strut angle, TanTheta
Value >= 0; 0 means 
 use program determined value.

16 = Factor accounting 
 for creep in Nominal Curvature method, Kr Minor
Value >= 0; 0 means 
 use program determined value.

17 = Factor accounting 
 for creep in Nominal Curvature method, KPhi Minor
Value >= 0; 0 means 
 use program determined value.

18 = Coefficient depending 
 on the distribution of first-order moment in both Nominal Stiffness and 
 Nominal Curvature methods, c Major
Value >= 0; 0 means 
 use program determined value.

19 = Coefficient depending 
 on the distribution of first-order moment in both Nominal Stiffness and 
 Nominal Curvature methods, c Minor
Value >= 0; 0 means 
 use program determined value.

20 = Factor for contribution 
 of reinforcement, Ks Major
Value >= 0; 0 means 
 use program determined value.

21 = Factor for contribution 
 of reinforcement, Ks Minor
Value >= 0; 0 means 
 use program determined value.

22 = Factor for effects 
 of cracking, creep etc, Kc Major
Value >= 0; 0 means 
 use program determined value.

23 = Factor for effects 
 of cracking, creep etc, Kc Minor
Value >= 0; 0 means 
 use program determined value.

24 = Effective creep 
 coefficient, Phief
Value >= 0; 0 means 
 use program determined value.

ProgDet: If this item is True, the specified value is program 
 determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Eurocode_2_2004.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design 
 preference item.
The function returns zero if the item is successfully 
 retrieved; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 19, inclusive, indicating 
 the preference item considered.
1 = Country
2 = Combos equation
3 = Second order method
4 = Number of interaction 
 curves
5 = Number of interaction 
 points
6 
 = Consider minimum eccentricity
7 
 = Theta0
8 
 = Gamma steel
9 = Gamma concrete
10 = AlphaCC
11 = AlphaCT
12 = AlphaLCC
13 = AlphaLCT
14 = Pattern live load 
 factor
15 = Utilization factor 
 limit
16 = Multi-response case design
17 = Reliability Class
18 = GammacE
19 
 = Alphae
Value: The value of the considered preference item.
1 = Country
1 
 = CEN Default
2 
 = United Kingdom
3 
 = Slovenia
5 
 = Norway
6 
 = Singapore
7 
 = Sweden
8 
 = Finland
9 
 = Denmark
10 
 = Portugal
11 
 = Germany

2 = Combos equation
1 
 = Eq. 6.10
2 
 = Max of Eqs. 6.10a and 6.10b

3 = Second order method
1 
 = Nominal stiffness
2 
 = Nominal curvature
3 
 = None

4 = Number of interaction 
 curves
Value >= 4 and divisible 
 by 4

5 = Number of interaction 
 points
Value >= 5 and odd

6 = Consider minimum eccentricity
0 = No
Any other value = Yes

7 
 = Theta0
Value 
 > 0

8 
 = Gamma steel
Value 
 > 0

9 
 = Gamma concrete
Value > 0

10 = AlphaCC
Value > 
 0

11 = AlphaCT
Value > 
 0

12 = AlphaLCC
Value > 
 0

13 = AlphaLCT
Value > 
 0

14 = Pattern live load 
 factor
Value >= 
 0

15 = Utilization factor 
 limit
Value > 
 0

16 = Multi-response case 
 design
1 = Envelopes
2 = Step-by-step
3 = Last 
 step
4 = Envelopes 
 -- All
5 = Step-by-step 
 -- All

17 
 = Reliability Class
1 = Class 1
2 = Class 2
3 = Class 
 3

18 
 = GammacE
Value 
 > 0

19 = Alphae
Value 
 > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Eurocode_2_2004.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite 
 item.
The function returns zero if the item is successfully 
 set, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending 
 on the value of the ItemType item.
Item: This is an integer between 1 and 24, inclusive, indicating 
 the overwrite item considered.
1 = Framing type
2 = Live load reduction 
 factor
3 = Unbraced length ratio, 
 Major
4 = Unbraced length ratio, 
 Minor
5 = Effective length factor, 
 Beta Major
6 = Effective length factor, 
 Beta Minor
7 = Moment coefficient, 
 Cm Major
8 = Moment coefficient, 
 Cm Minor
9 = Nonsway moment factor, 
 Dns Major
10 = Nonsway moment factor, 
 Dns Minor
11 = Sway moment factor, 
 Ds Major
12 = Sway moment factor, 
 Ds Minor
13 
 = Correction factor depending on axial load in Nominal Curvature method, 
 Kr Major
14 = Correction factor 
 depending on axial load in Nominal Curvature method, KPhi Major
15 = Shear compressive 
 strut angle, TanTheta
16 = Factor accounting 
 for creep in Nominal Curvature method, Kr Minor
17 = Factor accounting 
 for creep in Nominal Curvature method, KPhi Minor
18 = Coefficient depending 
 on the distribution of first-order moment in both Nominal Stiffness and 
 Nominal Curvature methods, c Major
19 = Coefficient depending 
 on the distribution of first-order moment in both Nominal Stiffness and 
 Nominal Curvature methods, c Minor
20 = Factor for contribution 
 of reinforcement, Ks Major
21 = Factor for contribution 
 of reinforcement, Ks Minor
22 = Factor for effects 
 of cracking, creep etc, Kc Major
23 = Factor for effects 
 of cracking, creep etc, Kc Minor
24 = Effective creep 
 coefficient, Phief

Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Nonsway

2 = Live load reduction 
 factor
Value >= 0; 0 means 
 use program determined value.

3 = Unbraced length ratio, 
 Major
Value >= 0; 0 means 
 use program determined value.

4 = Unbraced length ratio, 
 Minor
Value >= 0; 0 means 
 use program determined value.

5 = Effective length factor, 
 Beta Major
Value >= 0; 0 means 
 use program determined value.

6 = Effective length factor, 
 Beta Minor
Value >= 0; 0 means 
 use program determined value.

7 = Moment coefficient, 
 Cm Major
Value >= 0; 0 means 
 use program determined value.

8 = Moment coefficient, 
 Cm Minor
Value >= 0; 0 means 
 use program determined value.

9 = Nonsway moment factor, 
 Dns Major
Value >= 0; 0 means 
 use program determined value.

10 = Nonsway moment factor, 
 Dns Minor
Value >= 
 0; 0 means use program determined value.

11 = Sway moment factor, 
 Ds Major
Value >= 
 0; 0 means use program determined value.

12 = Sway moment factor, 
 Ds Minor
Value >= 
 0; 0 means use program determined value.

13 = Correction factor depending on axial 
 load in Nominal Curvature method, Kr Major
Value >= 0; 0 means 
 use program determined value.

14 = Correction factor 
 depending on axial load in Nominal Curvature method, KPhi Major
Value >= 0; 0 means 
 use program determined value.

15 = Shear compressive 
 strut angle, TanTheta
Value >= 0; 0 means 
 use program determined value.

16 = Factor accounting 
 for creep in Nominal Curvature method, Kr Minor
Value >= 0; 0 means 
 use program determined value.

17 = Factor accounting 
 for creep in Nominal Curvature method, KPhi Minor
Value >= 0; 0 means 
 use program determined value.

18 = Coefficient depending 
 on the distribution of first-order moment in both Nominal Stiffness and 
 Nominal Curvature methods, c Major
Value >= 0; 0 means 
 use program determined value.

19 = Coefficient depending 
 on the distribution of first-order moment in both Nominal Stiffness and 
 Nominal Curvature methods, c Minor
Value >= 0; 0 means 
 use program determined value.

20 = Factor for contribution 
 of reinforcement, Ks Major
Value >= 0; 0 means 
 use program determined value.

21 = Factor for contribution 
 of reinforcement, Ks Minor
Value >= 0; 0 means 
 use program determined value.

22 = Factor for effects 
 of cracking, creep etc, Kc Major
Value >= 0; 0 means 
 use program determined value.

23 = Factor for effects 
 of cracking, creep etc, Kc Minor
Value >= 0; 0 means 
 use program determined value.

24 = Effective creep 
 coefficient, Phief
Value >= 0; 0 means 
 use program determined value.

ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the 
 frame object specified by the Name item.
If this item is Group, the assignment is made to all 
 frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made 
 to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Eurocode_2_2004.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference 
 item.
The function returns zero if the item is successfully 
 set; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 19, inclusive, indicating 
 the preference item considered.
1 = Country
2 = Combos equation
3 = Second order method
4 = Number of interaction 
 curves
5 = Number of interaction 
 points
6 = Consider minimum eccentricity
7 = Theta0
8 = Gamma steel
9 = Gamma concrete
10 = AlphaCC
11 = AlphaCT
12 = AlphaLCC
13 = AlphaLCT
14 = Pattern live load 
 factor
15 = Utilization factor 
 limit
16 = Multi-response case design
17 = Reliability Class
18 = GammacE
19 
 = Alphae
Value: The value of the considered preference item.
1 = Country
1 
 = CEN Default
2 
 = United Kingdom
3 
 = Slovenia
5 
 = Norway
6 
 = Singapore
7 
 = Sweden
8 
 = Finland
9 
 = Denmark
10 
 = Portugal
11 
 = Germany

2 = Combos equation
1 
 = Eq. 6.10
2 
 = Max of Eqs. 6.10a and 6.10b

3 = Second order method
1 
 = Nominal stiffness
2 
 = Nominal curvature
3 
 = None

4 = Number of interaction 
 curves
Value >= 4 and divisible 
 by 4

5 = Number of interaction 
 points
Value >= 5 and odd

6 = Consider minimum eccentricity
0 = No
Any other value = Yes

7 = Theta0
Value > 0

8 = Gamma steel
Value > 0

9 = Gamma concrete
Value > 0

10 
 = AlphaCC
Value 
 > 0

11 
 = AlphaCT
Value 
 > 0

12 
 = AlphaLCC
Value 
 > 0

13 
 = AlphaLCT
Value 
 > 0

14 = Pattern live load 
 factor
Value >= 
 0

15 = Utilization factor 
 limit
Value > 
 0

16 = Multi-response case 
 design
1 = Envelopes
2 = Step-by-step
3 = Last 
 step
4 = Envelopes 
 -- All
5 = Step-by-step 
 -- All

17 
 = Reliability Class
1 = Class 1
2 = Class 2
3 = Class 3

18 
 = GammacE
Value 
 > 0

19 = Alphae
Value 
 > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Eurocode_2_2004.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class EUROCODE_2_1992:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, Beta Major
6 = Effective length factor, Beta Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.EUROCODE_2_1992.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 9, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Nu
5 = Gamma steel
6 = Gamma concrete
7 = Pattern live load factor
8 = Utilization factor limit
9 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Nu
Value > 0

5 = Gamma steel
Value > 0

6 = Gamma concrete
Value > 0

7 = Pattern live load factor
Value >= 0

8 = Utilization factor limit
Value > 0

9 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.EUROCODE_2_1992.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, Beta Major
6 = Effective length factor, Beta Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.EUROCODE_2_1992.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 9, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Nu
5 = Gamma steel
6 = Gamma concrete
7 = Pattern live load factor
8 = Utilization factor limit
9 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Nu
Value > 0

5 = Gamma steel
Value > 0

6 = Gamma concrete
Value > 0

7 = Pattern live load factor
Value >= 0

8 = Utilization factor limit
Value > 0

9 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.EUROCODE_2_1992.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Hong_Kong_CP_2004:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, Beta Major
6 = Effective length factor, Beta Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Hong_Kong_CP_2004.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 9, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Gamma steel
5 = Gamma concrete
6 = Gamma concrete shear
7 = Pattern live load factor
8 = Utilization factor limit
9 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Gamma steel
Value > 0

5 = Gamma concrete
Value > 0

6 = Gamma concrete shear
Value > 0

7 = Pattern live load factor
Value >= 0

8 = Utilization factor limit
Value > 0

9 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Hong_Kong_CP_2004.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, Beta Major
6 = Effective length factor, Beta Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Hong_Kong_CP_2004.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 9, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Gamma steel
5 = Gamma concrete
6 = Gamma concrete shear
7 = Pattern live load factor
8 = Utilization factor limit
9 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Gamma steel
Value > 0

5 = Gamma concrete
Value > 0

6 = Gamma concrete shear
Value > 0

7 = Pattern live load factor
Value >= 0

8 = Utilization factor limit
Value > 0

9 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Hong_Kong_CP_2004.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Hong_Kong_CP_2013:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, Beta Major
6 = Effective length factor, Beta Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Hong_Kong_CP_2013.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, Beta Major
6 = Effective length factor, Beta Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Hong_Kong_CP_2013.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 9, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Gamma steel
5 = Gamma concrete
6 = Gamma concrete shear
7 = Pattern live load factor
8 = Utilization factor limit
9 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Gamma steel
Value > 0

5 = Gamma concrete
Value > 0

6 = Gamma concrete shear
Value > 0

7 = Pattern live load factor
Value >= 0

8 = Utilization factor limit
Value > 0

9 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Hong_Kong_CP_2013.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 9, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Gamma steel
5 = Gamma concrete
6 = Gamma concrete shear
7 = Pattern live load factor
8 = Utilization factor limit
9 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Gamma steel
Value > 0

5 = Gamma concrete
Value > 0

6 = Gamma concrete shear
Value > 0

7 = Pattern live load factor
Value >= 0

8 = Utilization factor limit
Value > 0

9 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Hong_Kong_CP_2013.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Indian_IS_456_2000:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 16, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
13 = Top rebar area of a beam at the left end (I-end)
14 = Bottom rebar area of a beam at the left end (I-end)
15 = Top rebar area of a beam at the right end (J-end)
16 = Bottom rebar area of a beam at the right end (J-end)
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Ductile
2 = Ordinary
3 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.

13 = Top rebar area of a beam at the left end (I-end)
Value >= 0; 0 means use program determined value.
14 = Bottom rebar area of a beam at the left end (I-end)
Value >= 0; 0 means use program determined value.
15 = Top rebar area of a beam at the right end (J-end)
Value >= 0; 0 means use program determined value.
16 = Bottom rebar area of a beam at the right end (J-end)
Value >= 0; 0 means use program determined value.

ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Indian_IS_456_2000.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
13 = Top rebar area of a beam at the left end (I-end)
14 = Bottom rebar area of a beam at the left end (I-end)
15 = Top rebar area of a beam at the right end (J-end)
16 = Bottom rebar area of a beam at the right end (J-end)
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Ductile
2 = Ordinary
3 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
13 = Top rebar area of a beam at the left end (I-end)
Value >= 0; 0 means use program determined value.
14 = Bottom rebar area of a beam at the left end (I-end)
Value >= 0; 0 means use program determined value.
15 = Top rebar area of a beam at the right end (J-end)
Value >= 0; 0 means use program determined value.
16 = Bottom rebar area of a beam at the right end (J-end)
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group,the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Indian_IS_456_2000.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

class Indian_IS_456_2003:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 8, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Gamma steel
5 = Gamma concrete
6 = Pattern live load factor
7 = Utilization factor limit
8 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Gamma steel
Value > 0

5 = Gamma concrete
Value > 0

6 = Pattern live load factor
Value >= 0

7 = Utilization factor limit
Value > 0

8 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Indian_IS_456_2003.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 8, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Gamma steel
5 = Gamma concrete
6 = Pattern live load factor
7 = Utilization factor limit
8 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Gamma steel
Value > 0

5 = Gamma concrete
Value > 0

6 = Pattern live load factor
Value >= 0

7 = Utilization factor limit
Value > 0

8 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Indian_IS_456_2003.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Italian_DM_14_2_92:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Amplification Coefficient, Omega Major
8 = Amplification Coefficient, Omega Minor
9 = Moment coefficient, c Major
10 = Moment coefficient, c Minor
11 = Moment coefficient, c_sway Major
12 = Moment coefficient, c_sway Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Braced

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Amplification coefficient, Omega Major
Value >= 0; 0 means use program determined value.

8 = Amplification coefficient, Omega Minor
Value >= 0; 0 means use program determined value.

9 = Moment coefficient, c Major
Value >= 0; 0 means use program determined value.

10 = Moment coefficient, c Minor
Value >= 0; 0 means use program determined value.

11 = Moment coefficient, c_sway Major
Value >= 0; 0 means use program determined value.

12 = Moment coefficient, c_sway Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Italian_DM_14_2_92.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 5, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Pattern live load factor
4 = Utilization factor limit
5 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Pattern live load factor
Value >= 0

4 = Utilization factor limit
Value > 0

5 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Italian_DM_14_2_92.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Amplification Coefficient, Omega Major
8 = Amplification Coefficient, Omega Minor
9 = Moment coefficient, c Major
10 = Moment coefficient, c Minor
11 = Moment coefficient, c_sway Major
12 = Moment coefficient, c_sway Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Braced

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Amplification coefficient, Omega Major
Value >= 0; 0 means use program determined value.

8 = Amplification coefficient, Omega Minor
Value >= 0; 0 means use program determined value.

9 = Moment coefficient, c Major
Value >= 0; 0 means use program determined value.

10 = Moment coefficient, c Minor
Value >= 0; 0 means use program determined value.

11 = Moment coefficient, c_sway Major
Value >= 0; 0 means use program determined value.

12 = Moment coefficient, c_sway Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Italian_DM_14_2_92.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 5, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Pattern live load factor
4 = Utilization factor limit
5 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Pattern live load factor
Value >= 0

4 = Utilization factor limit
Value > 0

5 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Italian_DM_14_2_92.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class KCI_1999:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway intermediate
3 = Sway ordinary
4 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.KCI_1999.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi bending tension
5 = Phi compression controlled tied
6 = Phi compression controlled spiral
7 = Phi shear
8 = Pattern live load factor
9 = Utilization factor limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi bending tension
Value > 0

5 = Phi compression controlled tied
Value > 0

6 = Phi compression controlled spiral
Value > 0

7 = Phi shear
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Utilization factor limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.KCI_1999.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway intermediate
3 = Sway ordinary
4 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.KCI_1999.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi bending tension
5 = Phi compression controlled tied
6 = Phi compression controlled spiral
7 = Phi shear
8 = Pattern live load factor
9 = Utilization factor limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi bending tension
Value > 0

5 = Phi compression controlled tied
Value > 0

6 = Phi compression controlled spiral
Value > 0

7 = Phi shear
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Utilization factor limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.KCI_1999.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Mexican_RCDF_2001:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, k Major
6 = Effective length factor, k Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Fab Major
10 = Non-sway moment factor, Fab Minor
11 = Sway moment factor, Fas Major
12 = Sway moment factor, Fas Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway ordinary
3 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, k Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, k Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Fab Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, FabMinor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Fas Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Fas Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Mexican_RCDF_2001.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi bending
5 = Phi tension
6 = Phi compression controlled tied
7 = Phi compression controlled spiral
8 = Phi shear
9 = Pattern live load factor
10 = Utilization factor limit
11 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi bending
Value > 0

5 = Phi tension
Value > 0

6 = Phi compression controlled tied
Value > 0

7 = Phi compression controlled spiral
Value > 0

8 = Phi shear
Value > 0

9 = Pattern live load factor
Value >= 0

10 = Utilization factor limit
Value > 0

11 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Mexican_RCDF_2001.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, k Major
6 = Effective length factor, k Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Fab Major
10 = Non-sway moment factor, Fab Minor
11 = Sway moment factor, Fas Major
12 = Sway moment factor, Fas Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway ordinary
3 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, k Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, k Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Fab Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, FabMinor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Fas Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Fas Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Mexican_RCDF_2001.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi bending
5 = Phi tension
6 = Phi compression controlled tied
7 = Phi compression controlled spiral
8 = Phi shear
9 = Pattern live load factor
10 = Utilization factor limit
11 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi bending
Value > 0

5 = Phi tension
Value > 0

6 = Phi compression controlled tied
Value > 0

7 = Phi compression controlled spiral
Value > 0

8 = Phi shear
Value > 0

9 = Pattern live load factor
Value >= 0

10 = Utilization factor limit
Value > 0

11 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Mexican_RCDF_2001.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class NZS_3101_95:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Db Major
10 = Non-sway moment factor, Db Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Ductile
2 = Limited
3 = Elastic
4 = Ordinary

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Db Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.NZS_3101_95.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 14, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi bending
5 = Phi tension
6 = Phi compression
7 = Phi shear
8 = Omega
9 = Phi 0
10 = Rm
11 = Rv
12 = Pattern live load factor
13 = Utilization factor limit
14 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi bending
Value > 0

5 = Phi tension
Value > 0

6 = Phi compression
Value > 0

7 = Phi shear
Value > 0

8 = Omega
Value > 0

9 = Phi 0
Value > 0

10 = Rm
Value > 0

11 = Rv
Value > 0

12 = Pattern live load factor
Value >= 0

13 = Utilization factor limit
Value > 0

14 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.NZS_3101_95.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Db Major
10 = Non-sway moment factor, Db Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Ductile
2 = Limited
3 = Elastic
4 = Ordinary

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Db Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.NZS_3101_95.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 14, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi bending
5 = Phi tension
6 = Phi compression
7 = Phi shear
8 = Omega
9 = Phi 0
10 = Rm
11 = Rv
12 = Pattern live load factor
13 = Utilization factor limit
14 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi bending
Value > 0

5 = Phi tension
Value > 0

6 = Phi compression
Value > 0

7 = Phi shear
Value > 0

8 = Omega
Value > 0

9 = Phi 0
Value > 0

10 = Rm
Value > 0

11 = Rv
Value > 0

12 = Pattern live load factor
Value >= 0

13 = Utilization factor limit
Value > 0

14 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.NZS_3101_95.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Singapore_CP_65_99:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, Beta Major
6 = Effective length factor, Beta Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Singapore_CP_65_99.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 9, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Gamma steel
5 = Gamma concrete
6 = Gamma concrete shear
7 = Pattern live load factor
8 = Utilization factor limit
9 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Gamma steel
Value > 0

5 = Gamma concrete
Value > 0

6 = Gamma concrete shear
Value > 0

7 = Pattern live load factor
Value >= 0

8 = Utilization factor limit
Value > 0

9 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Singapore_CP_65_99.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 9, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Gamma steel
5 = Gamma concrete
6 = Gamma concrete shear
7 = Pattern live load factor
8 = Utilization factor limit
9 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Gamma steel
Value > 0

5 = Gamma concrete
Value > 0

6 = Gamma concrete shear
Value > 0

7 = Pattern live load factor
Value >= 0

8 = Utilization factor limit
Value > 0

9 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Singapore_CP_65_99.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Singaopre_CP_65_99:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, Beta Major
6 = Effective length factor, Beta Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway
2 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Singaopre_CP_65_99.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

class SP63_13330_2012:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 14, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment amplification factor, Eta Major
8 = Moment amplification factor, Eta Minor
9 = Gammab3 for column
10 = Gammab3 for beam
11 = Consider torsion?
12 = (qsw,1*Z1)/(Rs*As,1)
13 = Corner rebar fraction top
14 = Corner rebar fraction bottom

Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Determined
1 = Sway
2 = Nonsway

2 = Live load reduction factor
Value >=0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >=0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >=0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >=0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >=0; 0 means use program determined value.

7 = Moment amplification factor, Eta Major
Value >=0; 0 means use program determined value.

8 = Moment amplification factor, Eta Minor
Value >=0; 0 means use program determined value.

9 = Gammab3 for column
Value >=0; 0 means use program determined value.

10 = Gammab3 for beam
Value >=0; 0 means use program determined value.

11 = Consider torsion?
0 = Program Determined
1 = No
2 = Yes

12 = (qsw,1*Z1)/(Rs*As,1)
0.5 <= Value <= 1.5; 0 means use program determined value.

13 = Corner rebar fraction top
0 < Value <= 1; 0 means use program determined value.

14 = Corner rebar fraction bottom
0 < Value <= 1; 0 means use program determined value.

ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.SP63_13330_2012.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 23, inclusive, indicating the preference item considered.
1 = Multi-response case design
2 = Number of interaction curves
3 = Number of interaction points
4 = Consider minimum eccentricity?
5 = Consider torsion?
6 = (qsw,1*Z1)/(Rs*As,1)
7 = Corner rebar fraction top
8 = Corner rebar fraction bottom
9 = Relative humidity
10 = Moisture content
11 = Gamma_b
12 = Gamma_bt
13 = Gamma_b1 short term
14 = Gamma_b1 long term
15 = Gamma_b2
16 = Gamma_b3 beams
17 = Gamma_b3 columns
18 = Gamma_b4
19 = Gamma_b5
20 = Gamma_S
21 = Gamma_S1
22 = Pattern live load factor
23 = Utilization factor limit

Value: The value of the considered preference item.
1 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

2 = Number of interaction curves
Value >= 4 and divisible by 4

3 = Number of interaction points
Value >= 5 and odd

4 = Consider minimum eccentricity?
0 = No
Any other value = Yes

5 = Consider torsion?
0 = No
Any other value = Yes

6 = (qsw,1*Z1)/(Rs*As,1)
0.5 <= Value <= 1.5

7 = Corner rebar fraction top
0 < Value <= 1

8 = Corner rebar fraction bottom
0 < Value <= 1

9 = Relative humidity
0 <= Value <= 100

10 = Moisture content
0 <= Value <= 1

11 = Gamma_b
Value > 0

12 = Gamma_bt
Value > 0

13 = Gamma_b1 short term
Value > 0

14 = Gamma_b1 long term
Value > 0

15 = Gamma_b2
Value > 0

16 = Gamma_b3 beams
Value > 0

17 = Gamma_b3 columns
Value > 0

18 = Gamma_b4
Value > 0

19 = Gamma_b5
Value > 0

20 = Gamma_S
Value > 0

21 = Gamma_S1
Value > 0

22 = Pattern live load factor
Value >= 0

23 = Utilization factor limit
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.SP63_13330_2012.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 14, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment amplification factor, Eta Major
8 = Moment amplification factor, Eta Minor
9 = Gammab3 for column
10 = Gammab3 for beam
11 = Consider torsion?
12 = (qsw,1*Z1)/(Rs*As,1)
13 = Corner rebar fraction top
14 = Corner rebar fraction bottom

Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Determined
1 = Sway
2 = Nonsway

2 = Live load reduction factor
Value >=0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >=0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >=0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >=0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >=0; 0 means use program determined value.

7 = Moment amplification factor, Eta Major
Value >=0; 0 means use program determined value.

8 = Moment amplification factor, Eta Minor
Value >=0; 0 means use program determined value.

9 = Gammab3 for column
Value >=0; 0 means use program determined value.

10 = Gammab3 for beam
Value >=0; 0 means use program determined value.

11 = Consider torsion?
0 = Program Determined
1 = No
2 = Yes

12 = (qsw,1*Z1)/(Rs*As,1)
0.5 <= Value <= 1.5; 0 means use program determined value.

13 = Corner rebar fraction top
0 < Value <= 1; 0 means use program determined value.

14 = Corner rebar fraction bottom
0 < Value <= 1; 0 means use program determined value.

ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.SP63_13330_2012.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 23, inclusive, indicating the preference item considered.
1 = Multi-response case design
2 = Number of interaction curves
3 = Number of interaction points
4 = Consider minimum eccentricity?
5 = Consider torsion?
6 = (qsw,1*Z1)/(Rs*As,1)
7 = Corner rebar fraction top
8 = Corner rebar fraction bottom
9 = Relative humidity
10 = Moisture content
11 = Gamma_b
12 = Gamma_bt
13 = Gamma_b1 short term
14 = Gamma_b1 long term
15 = Gamma_b2
16 = Gamma_b3 beams
17 = Gamma_b3 columns
18 = Gamma_b4
19 = Gamma_b5
20 = Gamma_S
21 = Gamma_S1
22 = Pattern live load factor
23 = Utilization factor limit

Value: The value of the considered preference item.
1 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

2 = Number of interaction curves
Value >= 4 and divisible by 4

3 = Number of interaction points
Value >= 5 and odd

4 = Consider minimum eccentricity?
0 = No
Any other value = Yes

5 = Consider torsion?
0 = No
Any other value = Yes

6 = (qsw,1*Z1)/(Rs*As,1)
0.5 <= Value <= 1.5

7 = Corner rebar fraction top
0 < Value <= 1

8 = Corner rebar fraction bottom
0 < Value <= 1

9 = Relative humidity
0 <= Value <= 100

10 = Moisture content
0 <= Value <= 1

11 = Gamma_b
Value > 0

12 = Gamma_bt
Value > 0

13 = Gamma_b1 short term
Value > 0

14 = Gamma_b1 long term
Value > 0

15 = Gamma_b2
Value > 0

16 = Gamma_b3 beams
Value > 0

17 = Gamma_b3 columns
Value > 0

18 = Gamma_b4
Value > 0

19 = Gamma_b5
Value > 0

20 = Gamma_S
Value > 0

21 = Gamma_S1
Value > 0

22 = Pattern live load factor
Value >= 0

23 = Utilization factor limit
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.SP63_13330_2012.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class UBC97:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a concrete design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a concrete frame design procedure.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway Intermediate
3 = Sway Ordinary
4 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.UBC97.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi bending tension
5 = Phi compression controlled tied
6 = Phi compression controlled spiral
7 = Phi shear
8 = Pattern live load factor
9 = Utilization factor limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi bending tension
Value > 0

5 = Phi compression controlled tied
Value > 0

6 = Phi compression controlled spiral
Value > 0

7 = Phi shear
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Utilization factor limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.UBC97.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a concrete design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 12, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Live load reduction factor
3 = Unbraced length ratio, Major
4 = Unbraced length ratio, Minor
5 = Effective length factor, K Major
6 = Effective length factor, K Minor
7 = Moment coefficient, Cm Major
8 = Moment coefficient, Cm Minor
9 = Non-sway moment factor, Dns Major
10 = Non-sway moment factor, Dns Minor
11 = Sway moment factor, Ds Major
12 = Sway moment factor, Ds Minor
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway special
2 = Sway Intermediate
3 = Sway Ordinary
4 = Non-sway

2 = Live load reduction factor
Value >= 0; 0 means use program determined value.

3 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

4 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

5 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

6 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

7 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

8 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

9 = Non-sway moment factor, Dns Major
Value >= 0; 0 means use program determined value.

10 = Non-sway moment factor, Dns Minor
Value >= 0; 0 means use program determined value.

11 = Sway moment factor, Ds Major
Value >= 0; 0 means use program determined value.

12 = Sway moment factor, Ds Minor
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.UBC97.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Consider minimum eccentricity
4 = Phi bending tension
5 = Phi compression controlled tied
6 = Phi compression controlled spiral
7 = Phi shear
8 = Pattern live load factor
9 = Utilization factor limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Consider minimum eccentricity
0 = No
Any other value = Yes

4 = Phi bending tension
Value > 0

5 = Phi compression controlled tied
Value > 0

6 = Phi compression controlled spiral
Value > 0

7 = Phi shear
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Utilization factor limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.UBC97.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class DesignSteel:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.AISC360_05_IBC2006 = AISC360_05_IBC2006(strict, api)
        self.AISC360_10 = AISC360_10(strict, api)
        self.AISC360_16 = AISC360_16(strict, api)
        self.AISC_ASD01 = AISC_ASD01(strict, api)
        self.AISC_ASD89 = AISC_ASD89(strict, api)
        self.AISC_LRFD93 = AISC_LRFD93(strict, api)
        self.AISC_LRFD99 = AISC_LRFD99(strict, api)
        self.API_RP2A_LRFD97 = API_RP2A_LRFD97(strict, api)
        self.API_RP2A_WSD2000 = API_RP2A_WSD2000(strict, api)
        self.API_RP2A_WSD2014 = API_RP2A_WSD2014(strict, api)
        self.ASCE_10_97 = ASCE_10_97(strict, api)
        self.Australian_AS4100_1998 = Australian_AS4100_1998(strict, api)
        self.BS5950_2000 = BS5950_2000(strict, api)
        self.BS5950_90 = BS5950_90(strict, api)
        self.Canadian_S16_01 = Canadian_S16_01(strict, api)
        self.Chinese_2010 = Chinese_2010(strict, api)
        self.CISC_95 = CISC_95(strict, api)
        self.Canadian_S16_09 = Canadian_S16_09(strict, api)
        self.EUROCODE_3_1993 = EUROCODE_3_1993(strict, api)
        self.Eurocode_3_2005 = Eurocode_3_2005(strict, api)
        self.INDIAN_IS_800_1998 = INDIAN_IS_800_1998(strict, api)
        self.Indian_IS_800_2007 = Indian_IS_800_2007(strict, api)
        self.ITALIAN_UNI_10011 = ITALIAN_UNI_10011(strict, api)
        self.Italian_UNI_10011 = Italian_UNI_10011(strict, api)
        self.Norsok_N004 = Norsok_N004(strict, api)
        self.Norsok_N0042013 = Norsok_N0042013(strict, api)
        self.NewZealand_NZS3404_1997 = NewZealand_NZS3404_1997(strict, api)
        self.Italian_NTC_2008 = Italian_NTC_2008(strict, api)
        self.Italian_NTC_2018 = Italian_NTC_2018(strict, api)
        self.SP_16_13330_2011 = SP_16_13330_2011(strict, api)
        self.UBC97_ASD = UBC97_ASD(strict, api)
        self.UBC97_LRFD = UBC97_LRFD(strict, api)
        self.Chinese_2002 = Chinese_2002(strict, api)
        self.Chinese_2000 = Chinese_2000(strict, api)

    def DeleteResults(self):
        """
This function deletes all steel frame design results.
The function returns zero if the results are successfully deleted; otherwise it returns a nonzero value.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.DeleteResults(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteResults" failed')
        
        return ret

    def GetCode(self, CodeName = None):
        """
This function retrieves the steel design code.
The function returns zero if the code is successfully retrieved; otherwise it returns a nonzero value.

CodeName: This is one of the following steel design code names.
AASHTO LRFD 2007
AISC-ASD89
AISC 360-10
AISC360-05/IBC2006
AISC-LRFD93
API RP2A-LRFD 97
API RP2A-WSD2000
API RP2A-WSD2014
AS 4100-1998
ASCE 10-97
BS5950 2000
Chinese 2010
CSA S16-14
CSA-S16-09
EUROCODE 3-2005
Indian IS 800-2007
Italian NTC 2008
Italian UNI 10011
KBC 2009
Norsok N-004 2013
NZS 3404-1997
SP 16.13330.2011
        """

        all_args = [CodeName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.GetCode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCode" failed')
        
        return ret

    def GetComboAutoGenerate(self, AutoGenerate = None):
        """
This function retrieves the value of the automatically generated code-based design load combinations option for steel frame design.
The function returns zero if the options are successfully set; otherwise it returns a nonzero value.

AutoGenerate: If this item is True, the option to automatically generate code-based design load combinations for steel frame design is turned on. If it is False, the option is turned off.
        """

        all_args = [AutoGenerate]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.GetComboAutoGenerate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetComboAutoGenerate" failed')
        
        return ret

    def GetComboDeflection(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of all load combinations selected as design combinations for steel deflection design.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of load combinations selected as design combinations for steel deflection design.
MyName: This is an array that includes the name of each response combination selected as a design combination for steel deflection design.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.GetComboDeflection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetComboDeflection" failed')
        
        return ret

    def GetComboStrength(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of all load combinations selected as design combinations for steel strength design.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of load combinations selected as design combinations for steel strength design.
MyName: This is an array that includes the name of each response combination selected as a design combination for steel strength design.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.GetComboStrength(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetComboStrength" failed')
        
        return ret

    def GetDesignSection(self, Name = None, PropName = None):
        """
This function retrieves the design section for a specified steel frame object.
The function returns zero if the section is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
PropName: The name of the design section for the specified frame object.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.GetDesignSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDesignSection" failed')
        
        return ret

    def GetDetailResultsText(self):
        """
This function retrieves the design results from steel design output database tables. Note that the summary table of all design codes is not included in this function.
The function returns zero if the results are successfully retrieved; otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.GetDetailResultsText(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDetailResultsText" failed')
        
        return ret

    def GetDetailResultsValue(self):
        """
This function retrieves the design results from steel design output database tables. Note that the summary table of all design codes is not included in this function.
The function returns zero if the results are successfully retrieved; otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.GetDetailResultsValue(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDetailResultsValue" failed')
        
        return ret

    def GetGroup(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of all groups selected for steel design.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of groups selected for steel design.
MyName: This is an array that includes the name of each group selected for steel design.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.GetGroup(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGroup" failed')
        
        return ret

    def GetResultsAvailable(self):
        """
The function returns True if the steel frame design results are available, otherwise False.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.GetResultsAvailable(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetResultsAvailable" failed')
        
        return ret

    def GetSummaryResults(self, Name = None, NumberItems = None, FrameName = None, Ratio = None, RatioType = None, Location = None, ComboName = None, ErrorSummary = None, WarningSummary = None, ItemType = None):
        """
This function retrieves summary results for steel design.
The function returns zero if the results are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The number of frame objects for which results are obtained.
FrameName: This is an array that includes each frame object name for which results are obtained.
Ratio: This is an array that includes the controlling stress or capacity ratio for each frame object.
RatioType: This is an array that includes 1, 2, 3, 4, 5 or 6, indicating the controlling stress or capacity ratio type for each frame object.
1 = PMM
2 = Major shear
3 = Minor shear
4 = Major beam-column capacity ratio
5 = Minor beam-column capacity ratio
6 = Other
Location: This is an array that includes the distance from the I-end of the frame object to the location where the controlling stress or capacity ratio occurs. [L]
ComboName: This is an array that includes the name of the design combination for which the controlling stress or capacity ratio occurs.
ErrorSummary: This is an array that includes the design error messages for the frame object, if any.
WarningSummary: This is an array that includes the design warning messages for the frame object, if any.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the design results are retrieved for the frame object specified by the Name item.
If this item is Group, the design results are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the design results are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, Ratio, RatioType, Location, ComboName, ErrorSummary, WarningSummary, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.GetSummaryResults(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSummaryResults" failed')
        
        return ret

    def GetTargetDispl(self, NumberItems = None, LoadCase = None, Point = None, Displ = None, Active = None):
        """
This function retrieves lateral displacement targets for steel design.
The function returns zero if the targets are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of lateral displacement targets specified.
LoadCase: This is an array that includes the name of the static linear load case associated with each lateral displacement target.
Point: This is an array that includes the name of the point object associated to which the lateral displacement target applies.
Displ: This is an array that includes the lateral displacement target. [L]
Active: If this item is True, all specified lateral displacement targets are active. If it is False, they are inactive.
        """

        all_args = [NumberItems, LoadCase, Point, Displ, Active]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.GetTargetDispl(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTargetDispl" failed')
        
        return ret

    def GetTargetPeriod(self, NumberItems = None, ModalCase = None, Mode = None, Period = None, Active = None):
        """
This function retrieves time period targets for steel design.
The function returns zero if the targets are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of lateral displacement targets specified.
ModalCase: The name of the modal load case for which the target periods apply.
Mode: This is an array that includes the mode number associated with each target period.
Period: This is an array that includes the target periods. [s]
Active: If this item is True, all specified target periods are active. If it is False, they are inactive.
        """

        all_args = [NumberItems, ModalCase, Mode, Period, Active]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.GetTargetPeriod(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTargetPeriod" failed')
        
        return ret

    def ResetOverwrites(self):
        """
This function resets all steel frame design overwrites to default values.
The function returns zero if the overwrites are successfully reset; otherwise it returns a nonzero value.
The function will fail if no steel frame objects are present.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.ResetOverwrites(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ResetOverwrites" failed')
        
        return ret

    def SetAutoSelectNull(self, Name = None, ItemType = None):
        """
This function removes the auto select section assignments from all specified frame objects that have a steel frame design procedure.
The function returns zero if the auto select section assignments are successfully removed; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2
If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SetAutoSelectNull(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAutoSelectNull" failed')
        
        return ret

    def SetCode(self, CodeName = None):
        """
This function sets the steel design code.
The function returns zero if the code is successfully set; otherwise it returns a nonzero value.

CodeName: This is one of the following steel design code names.
AASHTO LRFD 2007
AISC-ASD89
AISC 360-10
AISC360-05/IBC2006
AISC-LRFD93
API RP2A-LRFD 97
API RP2A-WSD2000
API RP2A-WSD2014
AS 4100-1998
ASCE 10-97
BS5950 2000
Chinese 2010
CSA S16-14
CSA-S16-09
EUROCODE 3-2005
Indian IS 800-2007
Italian NTC 2008
Italian UNI 10011
KBC 2009
Norsok N-004 2013
NZS 3404-1997
SP 16.13330.2011
        """

        all_args = [CodeName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SetCode(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCode" failed')
        
        return ret

    def SetComboAutoGenerate(self, AutoGenerate = None):
        """
This function turns on or off the option to automatically generate code-based design load combinations for steel frame design.
The function returns zero if the options are successfully set; otherwise it returns a nonzero value.

AutoGenerate: If this item is True, the option to automatically generate code-based design load combinations for steel frame design is turned on. If it is False, the option is turned off.
        """

        all_args = [AutoGenerate]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SetComboAutoGenerate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetComboAutoGenerate" failed')
        
        return ret

    def SetComboDeflection(self, Name = None, Selected = None):
        """
This function selects or deselects a load combination for steel deflection design.
The function returns zero if the selection status is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing load combination.
Selected: If this item is True, the specified load combination is selected as a design combination for steel deflection design. If it is False, the combination is not selected for steel deflection design.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SetComboDeflection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetComboDeflection" failed')
        
        return ret

    def SetComboStrength(self, Name = None, Selected = None):
        """
This function selects or deselects a load combination for steel strength design.
The function returns zero if the selection status is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing load combination.
Selected: If this item is True, the specified load combination is selected as a design combination for steel strength design. If it is False, the combination is not selected for steel strength design.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SetComboStrength(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetComboStrength" failed')
        
        return ret

    def SetDesignSection(self, Name = None, PropName = None, LastAnalysis = None, ItemType = None):
        """
This function modifies the design section for all specified frame objects that have a steel frame design procedure.
The function returns zero if the design section is successfully modified; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
PropName: The name of an existing frame section property to be used as the design section for the specified frame objects. This item applies only when LastAnalysis = False.
LastAnalysis: If this item is True, the design section for the specified frame objects is reset to the last analysis section for the frame object. If it is False, the design section is set to that specified by PropName.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, LastAnalysis, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SetDesignSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDesignSection" failed')
        
        return ret

    def SetGroup(self, Name = None, Selected = None):
        """
This function selects or deselects a group for steel design.
The function returns zero if the selection status is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing group.
Selected: If this item is True, the specified group is selected as a design group for steel design. If it is False, the group is not selected for steel design.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SetGroup(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGroup" failed')
        
        return ret

    def SetTargetDispl(self, NumberItems = None, LoadCase = None, Point = None, Displ = None, Active = None):
        """
This function sets lateral displacement targets for steel design.
The function returns zero if the targets are successfully set; otherwise it returns a nonzero value.

NumberItems: The number of lateral displacement targets specified.
LoadCase: This is an array that includes the name of the static linear load case associated with each lateral displacement target.
Point: This is an array that includes the name of the point object associated to which the lateral displacement target applies.
Displ: This is an array that includes the lateral displacement target. [L]
Active: If this item is True, all specified lateral displacement targets are active. If it is False, they are inactive.
        """

        all_args = [NumberItems, LoadCase, Point, Displ, Active]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SetTargetDispl(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTargetDispl" failed')
        
        return ret

    def SetTargetPeriod(self, NumberItems = None, ModalCase = None, Mode = None, Period = None, Active = None):
        """
This function sets time period targets for steel design.
The function returns zero if the targets are successfully set; otherwise it returns a nonzero value.

NumberItems: The number of lateral displacement targets specified.
ModalCase: The name of the modal load case for which the target periods apply.
Mode: This is an array that includes the mode number associated with each target period.
Period: This is an array that includes the target periods. [s]
Active: If this item is True, all specified target periods are active. If it is False, they are inactive.
        """

        all_args = [NumberItems, ModalCase, Mode, Period, Active]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SetTargetPeriod(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTargetPeriod" failed')
        
        return ret

    def StartDesign(self):
        """
This function starts the steel frame design.
The function returns zero if the steel frame design is successfully started; otherwise it returns a nonzero value.
The function will fail if no steel frame objects are present. It will also fail if analysis results are not available.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.StartDesign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"StartDesign" failed')
        
        return ret

    def VerifyPassed(self, NumberItems = None, n1 = None, n2 = None, MyName = None):
        """
This function retrieves the names of the frame objects that did not pass the design check or have not yet been checked, if any.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of steel frame objects that did not pass the design check or have not yet been checked.
n1: The number of steel frame objects that did not pass the design check.
n2: The number of steel frame objects that have not yet been checked.
MyName: This is an array that includes the name of each frame object that did not pass the design check or has not yet been checked.
        """

        all_args = [NumberItems, n1, n2, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.VerifyPassed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"VerifyPassed" failed')
        
        return ret

    def VerifySections(self, NumberItems = None, MyName = None):
        """
This function retrieves the names of the frame objects that have different analysis and design sections, if any.
The function returns zero if the names are successfully retrieved; otherwise it returns a nonzero value.

NumberItems: The number of frame objects that have different analysis and design sections.
MyName: This is an array that includes the name of each frame object that has different analysis and design sections.
        """

        all_args = [NumberItems, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.VerifySections(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"VerifySections" failed')
        
        return ret

class AISC360_05_IBC2006:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 43, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor
20 = Unbraced length ratio, Lateral Torsional Buckling
21 = Effective length factor, K1 Major
22 = Effective length factor, K1 Minor
23 = Effective length factor, K2 Major
24 = Effective length factor, K2 Minor
25 = Effective length factor, K Lateral Torsional Buckling
26 = Moment coefficient, Cm Major
27 = Moment coefficient, Cm Minor
28 = Bending coefficient, Cb
29 = Nonsway moment factor, B1 Major
30 = Nonsway moment factor, B1 Minor
31 = Sway moment factor, B2 Major
32 = Sway moment factor, B2 Minor
33 = Reduce HSS thickness
34 = HSS welding type
35 = Yield stress, Fy
36 = Expected to specified Fy ratio, Ry
37 = Compressive capacity, Pnc
38 = Tensile capacity, Pnt
39 = Major bending capacity, Mn3
40 = Minor bending capacity, Mn2
41 = Major shear capacity, Vn2
42 = Minor shear capacity, Vn3
43 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = SMF
2 = IMF
3 = OMF
4 = SCBF
5 = OCBF
6 = OCBFI
7 = EBF

2 = Omega0
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program default
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]}

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L}

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

20 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K1 Major
Value >= 0; 0 means use program determined value.

22 = Effective length factor, K1 Minor
Value >= 0; 0 means use program determined value.

23 = Effective length factor, K2 Major
Value >= 0; 0 means use program determined value.

24 = Effective length factor, K2 Minor
Value >= 0; 0 means use program determined value.

25 = Effective length factor, K Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

26 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

27 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

28 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

29 = Nonsway moment factor, B1 Major
Value >= 0; 0 means use program determined value.

30 = Nonsway moment factor, B1 Minor
Value >= 0; 0 means use program determined value.

31 = Sway moment factor, B2 Major
Value >= 0; 0 means use program determined value.

32 = Sway moment factor, B2 Minor
Value >= 0; 0 means use program determined value.

33 = Reduce HSS thickness
0 = Program default
1 = No
2 = Yes

34 = HSS welding type
0 = Program default
1 = ERW
2 = SAW

35 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

36 = Expected to specified Fy ratio, Ry
Value >= 0; 0 means use program determined value.

37 = Compressive capacity, Pnc
Value >= 0; 0 means use program determined value. [F]

38 = Tensile capacity, Pnt
Value >= 0; 0 means use program determined value. [F]

39 = Major bending capacity, Mn3
Value >= 0; 0 means use program determined value. [FL]

40 = Minor bending capacity, Mn2
Value >= 0; 0 means use program determined value. [FL]

41 = Major shear capacity, Vn2
Value >= 0; 0 means use program determined value. [F]

42 = Minor shear capacity, Vn3
Value >= 0; 0 means use program determined value. [F]

43 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC360_05_IBC2006.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design 
 preference item.
The function returns zero if the item is successfully 
 retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 35, inclusive, indicating 
 the preference item considered.
1 = Framing type
2 = Seismic design category
3 = Design provision
4 = Analysis method (Obsolete, 
 replaced by 27, 28, and 29)
5 = Notional load coefficient
6 = Phi or Omega for bending
7 = Phi or Omega for compression
8 = Phi or Omega for tension 
 yielding
9 = Phi or Omega for tension 
 fracture
10 = Phi or Omega for 
 shear
11 = Phi or Omega for 
 shear short webbed rolled I
12 = Phi or Omega for 
 torsion
13 = Ignore seismic code
14 = Ignore special seismic 
 load
15 = Doubler plate is 
 plug welded
16 = HSS welding type
17 = Reduce HSS thickness
18 = Consider deflection
19 = DL deflection limit, 
 L/Value
20 = SDL + LL deflection 
 limit, L/Value
21 = LL deflection limit, 
 L/Value
22 = Total load deflection 
 limit, L/Value
23 = Total camber limit, 
 L/Value
24 = Pattern live load 
 factor
25 = Demand/capacity ratio 
 limit
26 = Multi-response case design
27 = Analysis Method
28 = Second Order Method
29 = Stiffness Reduction Method
30 = Importance Factor
31 = Design Systems Rho
32 = Design Systems Sds
33 = Design Systems R
34 = Design Systems Omega0
35 = Design Systems Cd

Value: The value of the considered preference item.
1 = Framing type
1 = SMF
2 = IMF
3 = OMF
4 = SCBF
5 = OCBF
6 = OCBFI
7 = EBF

2 = Seismic design category
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

3 = Design provision
1 = LRFD
2 = ASD

4 = Analysis method (Obsolete, 
 replaced by 27, 28, and 29)
1 = Gen 2nd Order Elastic
2 = 2nd Order By Amp 
 1st Order
3 = Limited 1st Order 
 Elastic
4 = DAM Gen 2nd Order 
 Taub Variable
5 = DAM Gen 2nd Order 
 Taub Fixed
6 = DAM Amp 1st Order 
 Taub Variable
7 = DAM Amp 1st Order 
 Taub Fixed

5 = Notional load coefficient
Value > 0

6 = Phi or Omega for bending
Value > 0

7 = Phi or Omega for compression
Value > 0

8 = Phi or Omega for tension 
 yielding
Value > 0

9 = Phi or Omega for tension 
 fracture
Value > 0

10 = Phi or Omega for 
 shear
Value > 0

11 = Phi or Omega for 
 shear short webbed rolled I
Value > 0

12 = Phi or Omega for 
 torsion
Value > 0

13 = Ignore seismic code
0 = No
Any other value = Yes

14 = Ignore special seismic 
 load
0 = No
Any other value = Yes

15 = Doubler plate is 
 plug welded
0 = No
Any other value = Yes

16 = HSS welding type
1 = ERW
2 = SAW

17 = Reduce HSS thickness
0 = No
Any other value = Yes

18 = Consider deflection
0 = No
Any other value = Yes

19 = DL deflection limit, 
 L/Value
Value > 0

20 = SDL + LL deflection 
 limit, L/Value
Value > 0

21 = LL deflection limit, 
 L/Value
Value > 0

22 = Total load deflection 
 limit, L/Value
Value > 0

23 = Total camber limit, 
 L/Value
Value > 0

24 = Pattern live load 
 factor
Value >= 0

25 = Demand/capacity ratio 
 limit
Value > 0

26 = Multi-response case 
 design
1 = Envelopes
2 = Step-by-step
3 = Last 
 step
4 = Envelopes 
 -- All
5 = Step-by-step 
 -- All

27 = Analysis Method
1 = Direct Analysis
2 = Effective Length
3 = Limited 1st Order

28 = Second Order Method
1 = General 2nd Order
2 = Amplified 1st Order

29 = Stiffness Reduction 
 Method
1 = Tau-b variable
2 = Tau-b Fixed
3 = No Modification

30 = Importance Factor
Value > 0

31 = Design System Rho
Value > 0

32 = Design System Sds
Value >= 0

33 = Design System R
Value > 0

34 = Design System Omega0
Value > 0

35 = Design System Cd
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC360_05_IBC2006.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 43, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor
20 = Unbraced length ratio, Lateral Torsional Buckling
21 = Effective length factor, K1 Major
22 = Effective length factor, K1 Minor
23 = Effective length factor, K2 Major
24 = Effective length factor, K2 Minor
25 = Effective length factor, K Lateral Torsional Buckling
26 = Moment coefficient, Cm Major
27 = Moment coefficient, Cm Minor
28 = Bending coefficient, Cb
29 = Nonsway moment factor, B1 Major
30 = Nonsway moment factor, B1 Minor
31 = Sway moment factor, B2 Major
32 = Sway moment factor, B2 Minor
33 = Reduce HSS thickness
34 = HSS welding type
35 = Yield stress, Fy
36 = Expected to specified Fy ratio, Ry
37 = Compressive capacity, Pnc
38 = Tensile capacity, Pnt
39 = Major bending capacity, Mn3
40 = Minor bending capacity, Mn2
41 = Major shear capacity, Vn2
42 = Minor shear capacity, Vn3
43 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = SMF
2 = IMF
3 = OMF
4 = SCBF
5 = OCBF
6 = OCBFI
7 = EBF

2 = Omega0
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program default
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]}

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L}

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

20 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K1 Major
Value >= 0; 0 means use program determined value.

22 = Effective length factor, K1 Minor
Value >= 0; 0 means use program determined value.

23 = Effective length factor, K2 Major
Value >= 0; 0 means use program determined value.

24 = Effective length factor, K2 Minor
Value >= 0; 0 means use program determined value.

25 = Effective length factor, K Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

26 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

27 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

28 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

29 = Nonsway moment factor, B1 Major
Value >= 0; 0 means use program determined value.

30 = Nonsway moment factor, B1 Minor
Value >= 0; 0 means use program determined value.

31 = Sway moment factor, B2 Major
Value >= 0; 0 means use program determined value.

32 = Sway moment factor, B2 Minor
Value >= 0; 0 means use program determined value.

33 = Reduce HSS thickness
0 = Program default
1 = No
2 = Yes

34 = HSS welding type
0 = Program default
1 = ERW
2 = SAW

35 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

36 = Expected to specified Fy ratio, Ry
Value >= 0; 0 means use program determined value.

37 = Compressive capacity, Pnc
Value >= 0; 0 means use program determined value. [F]

38 = Tensile capacity, Pnt
Value >= 0; 0 means use program determined value. [F]

39 = Major bending capacity, Mn3
Value >= 0; 0 means use program determined value. [FL]

40 = Minor bending capacity, Mn2
Value >= 0; 0 means use program determined value. [FL]

41 = Major shear capacity, Vn2
Value >= 0; 0 means use program determined value. [F]

42 = Minor shear capacity, Vn3
Value >= 0; 0 means use program determined value. [F]

43 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC360_05_IBC2006.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference 
 item.
The function returns zero if the item is successfully 
 set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 35, inclusive, indicating 
 the preference item considered.
1 = Framing type
2 = Seismic design category
3 = Design provision
4 = Analysis method (Obsolete, 
 replaced by 27, 28, and 29)
5 = Notional load coefficient
6 = Phi or Omega for bending
7 = Phi or Omega for compression
8 = Phi or Omega for tension 
 yielding
9 = Phi or Omega for tension 
 fracture
10 = Phi or Omega for 
 shear
11 = Phi or Omega for 
 shear short webbed rolled I
12 = Phi or Omega for 
 torsion
13 = Ignore seismic code
14 = Ignore special seismic 
 load
15 = Doubler plate is 
 plug welded
16 = HSS welding type
17 = Reduce HSS thickness
18 = Consider deflection
19 = DL deflection limit, 
 L/Value
20 = SDL + LL deflection 
 limit, L/Value
21 = LL deflection limit, 
 L/Value
22 = Total load deflection 
 limit, L/Value
23 = Total camber limit, 
 L/Value
24 = Pattern live load 
 factor
25 = Demand/capacity ratio 
 limit
26 = Multi-response case design
27 = Analysis Method
28 = Second Order Method
29 = Stiffness Reduction Method
30 = Importance Factor
31 = Design Systems Rho
32 = Design Systems Sds
33 = Design Systems R
34 = Design Systems Omega0
35 = Design Systems Cd
Value: The value of the considered preference item.
1 = Framing type
1 = SMF
2 = IMF
3 = OMF
4 = SCBF
5 = OCBF
6 = OCBFI
7 = EBF

2 = Seismic design category
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

3 = Design provision
1 = LRFD
2 = ASD

4 = Analysis method (Obsolete, 
 replaced by 27, 28, and 29)
1 = Gen 2nd Order Elastic
2 = 2nd Order By Amp 
 1st Order
3 = Limited 1st Order 
 Elastic
4 = DAM Gen 2nd Order 
 Taub Variable
5 = DAM Gen 2nd Order 
 Taub Fixed
6 = DAM Amp 1st Order 
 Taub Variable
7 = DAM Amp 1st Order 
 Taub Fixed

5 = Notional load coefficient
Value > 0

6 = Phi or Omega for bending
Value > 0

7 = Phi or Omega for compression
Value > 0

8 = Phi or Omega for tension 
 yielding
Value > 0

9 = Phi or Omega for tension 
 fracture
Value > 0

10 = Phi or Omega for 
 shear
Value > 0

11 = Phi or Omega for 
 shear short webbed rolled I
Value > 0

12 = Phi or Omega for 
 torsion
Value > 0

13 = Ignore seismic code
0 = No
Any other value = Yes

14 = Ignore special seismic 
 load
0 = No
Any other value = Yes

15 = Doubler plate is 
 plug welded
0 = No
Any other value = Yes

16 = HSS welding type
1 = ERW
2 = SAW

17 = Reduce HSS thickness
0 = No
Any other value = Yes

18 = Consider deflection
0 = No
Any other value = Yes

19 = DL deflection limit, 
 L/Value
Value > 0

20 = SDL + LL deflection 
 limit, L/Value
Value > 0

21 = LL deflection limit, 
 L/Value
Value > 0

22 = Total load deflection 
 limit, L/Value
Value > 0

23 = Total camber limit, 
 L/Value
Value > 0

24 = Pattern live load 
 factor
Value >= 0

25 = Demand/capacity ratio 
 limit
Value > 0

26 = Multi-response case 
 design
1 = Envelopes
2 = Step-by-step
3 = Last 
 step
4 = Envelopes 
 -- All
5 = Step-by-step 
 -- All

27 = Analysis Method
1 = Direct Analysis
2 = Effective Length
3 = Limited 1st Order

28 = Second Order 
 Method
1 = General 2nd Order
2 = Amplified 1st Order

29 = Stiffness Reduction 
 Method
1 = Tau-b variable
2 = Tau-b Fixed
3 = No Modification

30 = Importance Factor
Value > 0

31 = Design System Rho
Value > 0

32 = Design System Sds
Value >= 0

33 = Design System R
Value > 0

34 = Design System Omega0
Value > 0

35 = Design System Cd
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC360_05_IBC2006.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AISC360_10:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 43, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor
20 = Unbraced length ratio, Lateral Torsional Buckling
21 = Effective length factor, K1 Major
22 = Effective length factor, K1 Minor
23 = Effective length factor, K2 Major
24 = Effective length factor, K2 Minor
25 = Effective length factor, K Lateral Torsional Buckling
26 = Moment coefficient, Cm Major
27 = Moment coefficient, Cm Minor
28 = Bending coefficient, Cb
29 = Nonsway moment factor, B1 Major
30 = Nonsway moment factor, B1 Minor
31 = Sway moment factor, B2 Major
32 = Sway moment factor, B2 Minor
33 = Reduce HSS thickness
34 = HSS welding type
35 = Yield stress, Fy
36 = Expected to specified Fy ratio, Ry
37 = Compressive capacity, Pnc
38 = Tensile capacity, Pnt
39 = Major bending capacity, Mn3
40 = Minor bending capacity, Mn2
41 = Major shear capacity, Vn2
42 = Minor shear capacity, Vn3
43 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = SMF
2 = IMF
3 = OMF
4 = SCBF
5 = OCBF
6 = OCBFI
7 = EBF

2 = Omega0
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program default
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]}

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L}

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

20 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K1 Major
Value >= 0; 0 means use program determined value.

22 = Effective length factor, K1 Minor
Value >= 0; 0 means use program determined value.

23 = Effective length factor, K2 Major
Value >= 0; 0 means use program determined value.

24 = Effective length factor, K2 Minor
Value >= 0; 0 means use program determined value.

25 = Effective length factor, K Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

26 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

27 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

28 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

29 = Nonsway moment factor, B1 Major
Value >= 0; 0 means use program determined value.

30 = Nonsway moment factor, B1 Minor
Value >= 0; 0 means use program determined value.

31 = Sway moment factor, B2 Major
Value >= 0; 0 means use program determined value.

32 = Sway moment factor, B2 Minor
Value >= 0; 0 means use program determined value.

33 = Reduce HSS thickness
0 = Program default
1 = No
2 = Yes

34 = HSS welding type
0 = Program default
1 = ERW
2 = SAW

35 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

36 = Expected to specified Fy ratio, Ry
Value >= 0; 0 means use program determined value.

37 = Compressive capacity, Pnc
Value >= 0; 0 means use program determined value. [F]

38 = Tensile capacity, Pnt
Value >= 0; 0 means use program determined value. [F]

39 = Major bending capacity, Mn3
Value >= 0; 0 means use program determined value. [FL]

40 = Minor bending capacity, Mn2
Value >= 0; 0 means use program determined value. [FL]

41 = Major shear capacity, Vn2
Value >= 0; 0 means use program determined value. [F]

42 = Minor shear capacity, Vn3
Value >= 0; 0 means use program determined value. [F]

43 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC360_10.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design 
 preference item.
The function returns zero if the item is successfully 
 retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 35, inclusive, indicating 
 the preference item considered.
1 = Framing type
2 = Seismic design category
3 = Design provision
4 = Analysis method (Obsolete, 
 replaced by 27, 28, and 29)
5 = Notional load coefficient
6 = Phi or Omega for bending
7 = Phi or Omega for compression
8 = Phi or Omega for tension 
 yielding
9 = Phi or Omega for tension 
 fracture
10 = Phi or Omega for 
 shear
11 = Phi or Omega for 
 shear short webbed rolled I
12 = Phi or Omega for 
 torsion
13 = Ignore seismic code
14 = Ignore special seismic 
 load
15 = Doubler plate is 
 plug welded
16 = HSS welding type
17 = Reduce HSS thickness
18 = Consider deflection
19 = DL deflection limit, 
 L/Value
20 = SDL + LL deflection 
 limit, L/Value
21 = LL deflection limit, 
 L/Value
22 = Total load deflection 
 limit, L/Value
23 = Total camber limit, 
 L/Value
24 = Pattern live load 
 factor
25 = Demand/capacity ratio 
 limit
26 = Multi-response case design
27 = Analysis Method
28 = Second Order Method
29 = Stiffness Reduction Method
30 = Importance Factor
31 = Design Systems Rho
32 = Design Systems Sds
33 = Design Systems R
34 = Design Systems Omega0
35 = Design Systems Cd

Value: The value of the considered preference item.
1 = Framing type
1 = SMF
2 = IMF
3 = OMF
4 = SCBF
5 = OCBF
6 = OCBFI
7 = EBF

2 = Seismic design category
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

3 = Design provision
1 = LRFD
2 = ASD

4 = Analysis method (Obsolete, 
 replaced by 27, 28, and 29)
1 = Gen 2nd Order Elastic
2 = 2nd Order By Amp 
 1st Order
3 = Limited 1st Order 
 Elastic
4 = DAM Gen 2nd Order 
 Taub Variable
5 = DAM Gen 2nd Order 
 Taub Fixed
6 = DAM Amp 1st Order 
 Taub Variable
7 = DAM Amp 1st Order 
 Taub Fixed

5 = Notional load coefficient
Value > 0

6 = Phi or Omega for bending
Value > 0

7 = Phi or Omega for compression
Value > 0

8 = Phi or Omega for tension 
 yielding
Value > 0

9 = Phi or Omega for tension 
 fracture
Value > 0

10 = Phi or Omega for 
 shear
Value > 0

11 = Phi or Omega for 
 shear short webbed rolled I
Value > 0

12 = Phi or Omega for 
 torsion
Value > 0

13 = Ignore seismic code
0 = No
Any other value = Yes

14 = Ignore special seismic 
 load
0 = No
Any other value = Yes

15 = Doubler plate is 
 plug welded
0 = No
Any other value = Yes

16 = HSS welding type
1 = ERW
2 = SAW

17 = Reduce HSS thickness
0 = No
Any other value = Yes

18 = Consider deflection
0 = No
Any other value = Yes

19 = DL deflection limit, 
 L/Value
Value > 0

20 = SDL + LL deflection 
 limit, L/Value
Value > 0

21 = LL deflection limit, 
 L/Value
Value > 0

22 = Total load deflection 
 limit, L/Value
Value > 0

23 = Total camber limit, 
 L/Value
Value > 0

24 = Pattern live load 
 factor
Value >= 0

25 = Demand/capacity ratio 
 limit
Value > 0

26 = Multi-response case 
 design
1 = Envelopes
2 = Step-by-step
3 = Last 
 step
4 = Envelopes 
 -- All
5 = Step-by-step 
 -- All

27 = Analysis Method
1 = Direct Analysis
2 = Effective Length
3 = Limited 1st Order

28 = Second Order Method
1 = General 2nd Order
2 = Amplified 1st Order

29 = Stiffness Reduction 
 Method
1 = Tau-b variable
2 = Tau-b Fixed
3 = No Modification

30 = Importance Factor
Value > 0

31 = Design System Rho
Value > 0

32 = Design System Sds
Value >= 0

33 = Design System R
Value > 0

34 = Design System Omega0
Value > 0

35 = Design System Cd
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC360_10.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite 
 item.
The function returns zero if the item is successfully 
 set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending 
 on the value of the ItemType item.
Item: This is an integer between 1 and 43, inclusive, indicating 
 the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, 
 L/Value
6 = SDL + LL deflection 
 limit, L/Value
7 = LL deflection limit, 
 L/Value
8 = Total load deflection 
 limit, L/Value
9 = Total camber limit, 
 L/Value
10 = DL deflection limit, 
 absolute
11 = SDL + LL deflection 
 limit, absolute
12 = LL deflection limit, 
 absolute
13 = Total load deflection 
 limit, absolute
14 = Total camber limit, 
 absolute
15 = Specified camber
16 = Net area to total 
 area ratio
17 = Live load reduction 
 factor
18 = Unbraced length ratio, 
 Major
19 = Unbraced length ratio, 
 Minor
20 = Unbraced length ratio, 
 Lateral Torsional Buckling
21 = Effective length 
 factor, K1 Major
22 = Effective length 
 factor, K1 Minor
23 = Effective length 
 factor, K2 Major
24 = Effective length 
 factor, K2 Minor
25 = Effective length 
 factor, K Lateral Torsional Buckling
26 = Moment coefficient, 
 Cm Major
27 = Moment coefficient, 
 Cm Minor
28 = Bending coefficient, 
 Cb
29 = Nonsway moment factor, 
 B1 Major
30 = Nonsway moment factor, 
 B1 Minor
31 = Sway moment factor, 
 B2 Major
32 = Sway moment factor, 
 B2 Minor
33 = Reduce HSS thickness
34 = HSS welding type
35 = Yield stress, Fy
36 = Expected to specified 
 Fy ratio, Ry
37 = Compressive capacity, 
 Pnc
38 = Tensile capacity, 
 Pnt
39 = Major bending capacity, 
 Mn3
40 = Minor bending capacity, 
 Mn2
41 = Major shear capacity, 
 Vn2
42 = Minor shear capacity, 
 Vn3
43 = Demand/capacity ratio 
 limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = SMF
2 = IMF
3 = OMF
4 = SCBF
5 = OCBF
6 = OCBFI
7 = EBF

2 = Omega0
Value >= 0; 0 means 
 use a program determined value.

3 = Consider deflection
0 = Program default
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

6 = SDL + LL deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

7 = LL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

8 = Total load deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

9 = Total camber limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

10 = DL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

11 = SDL + LL deflection 
 limit, absolute
Value >= 0; 0 means 
 no check for this item. [L]

12 = LL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

13 = Total load deflection 
 limit, absolute
Value >= 0; 0 means 
 no check for this item. [L]}

14 = Total camber limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

15 = Specified camber
Value >= 0. [L}

16 = Net area to total 
 area ratio
Value >= 0; 0 means 
 use program default value.

17 = Live load reduction 
 factor
Value >= 0; 0 means 
 use program determined value.

18 = Unbraced length ratio, 
 Major
Value >= 0; 0 means 
 use program determined value.

19 = Unbraced length ratio, 
 Minor
Value >= 0; 0 means 
 use program determined value.

20 = Unbraced length ratio, 
 Lateral Torsional Buckling
Value >= 0; 0 means 
 use program determined value.

21 = Effective length 
 factor, K1 Major
Value >= 0; 0 means 
 use program determined value.

22 = Effective length 
 factor, K1 Minor
Value >= 0; 0 means 
 use program determined value.

23 = Effective length 
 factor, K2 Major
Value >= 0; 0 means 
 use program determined value.

24 = Effective length 
 factor, K2 Minor
Value >= 0; 0 means 
 use program determined value.

25 = Effective length 
 factor, K Lateral Torsional Buckling
Value >= 0; 0 means 
 use program determined value.

26 = Moment coefficient, 
 Cm Major
Value >= 0; 0 means 
 use program determined value.

27 = Moment coefficient, 
 Cm Minor
Value >= 0; 0 means 
 use program determined value.

28 = Bending coefficient, 
 Cb
Value >= 0; 0 means 
 use program determined value.

29 = Nonsway moment factor, 
 B1 Major
Value >= 0; 0 means 
 use program determined value.

30 = Nonsway moment factor, 
 B1 Minor
Value >= 0; 0 means 
 use program determined value.

31 = Sway moment factor, 
 B2 Major
Value >= 0; 0 means 
 use program determined value.

32 = Sway moment factor, 
 B2 Minor
Value >= 0; 0 means 
 use program determined value.

33 = Reduce HSS thickness
0 = Program default
1 = No
2 = Yes

34 = HSS welding type
0 = Program default
1 = ERW
2 = SAW

35 = Yield stress, Fy
Value >= 0; 0 means 
 use program determined value. [F/L2]

36 = Expected to specified 
 Fy ratio, Ry
Value >= 0; 0 means 
 use program determined value.

37 = Compressive capacity, 
 Pnc
Value >= 0; 0 means 
 use program determined value. [F]

38 = Tensile capacity, 
 Pnt
Value >= 0; 0 means 
 use program determined value. [F]

39 = Major bending capacity, 
 Mn3
Value >= 0; 0 means 
 use program determined value. [FL]

40 = Minor bending capacity, 
 Mn2
Value >= 0; 0 means 
 use program determined value. [FL]

41 = Major shear capacity, 
 Vn2
Value >= 0; 0 means 
 use program determined value. [F]

42 = Minor shear capacity, 
 Vn3
Value >= 0; 0 means 
 use program determined value. [F]

43 = Demand/capacity ratio 
 limit
Value >= 0; 0 means use 
 program determined value.
ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the 
 frame object specified by the Name item.
If this item is Group, the assignment is made to all 
 frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made 
 to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC360_10.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference 
 item.
The function returns zero if the item is successfully 
 set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 35, inclusive, indicating 
 the preference item considered.
1 = Framing type
2 = Seismic design category
3 = Design provision
4 = Analysis method (Obsolete, 
 replaced by 27, 28, and 29)
5 = Notional load coefficient
6 = Phi or Omega for bending
7 = Phi or Omega for compression
8 = Phi or Omega for tension 
 yielding
9 = Phi or Omega for tension 
 fracture
10 = Phi or Omega for 
 shear
11 = Phi or Omega for 
 shear short webbed rolled I
12 = Phi or Omega for 
 torsion
13 = Ignore seismic code
14 = Ignore special seismic 
 load
15 = Doubler plate is 
 plug welded
16 = HSS welding type
17 = Reduce HSS thickness
18 = Consider deflection
19 = DL deflection limit, 
 L/Value
20 = SDL + LL deflection 
 limit, L/Value
21 = LL deflection limit, 
 L/Value
22 = Total load deflection 
 limit, L/Value
23 = Total camber limit, 
 L/Value
24 = Pattern live load 
 factor
25 = Demand/capacity ratio 
 limit
26 = Multi-response case design
27 = Analysis Method
28 = Second Order Method
29 = Stiffness Reduction Method
30 = Importance Factor
31 = Design Systems Rho
32 = Design Systems Sds
33 = Design Systems R
34 = Design Systems Omega0
35 = Design Systems Cd
Value: The value of the considered preference item.
1 = Framing type
1 = SMF
2 = IMF
3 = OMF
4 = SCBF
5 = OCBF
6 = OCBFI
7 = EBF

2 = Seismic design category
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

3 = Design provision
1 = LRFD
2 = ASD

4 = Analysis method (Obsolete, 
 replaced by 27, 28, and 29)
1 = Gen 2nd Order Elastic
2 = 2nd Order By Amp 
 1st Order
3 = Limited 1st Order 
 Elastic
4 = DAM Gen 2nd Order 
 Taub Variable
5 = DAM Gen 2nd Order 
 Taub Fixed
6 = DAM Amp 1st Order 
 Taub Variable
7 = DAM Amp 1st Order 
 Taub Fixed

5 = Notional load coefficient
Value > 0

6 = Phi or Omega for bending
Value > 0

7 = Phi or Omega for compression
Value > 0

8 = Phi or Omega for tension 
 yielding
Value > 0

9 = Phi or Omega for tension 
 fracture
Value > 0

10 = Phi or Omega for 
 shear
Value > 0

11 = Phi or Omega for 
 shear short webbed rolled I
Value > 0

12 = Phi or Omega for 
 torsion
Value > 0

13 = Ignore seismic code
0 = No
Any other value = Yes

14 = Ignore special seismic 
 load
0 = No
Any other value = Yes

15 = Doubler plate is 
 plug welded
0 = No
Any other value = Yes

16 = HSS welding type
1 = ERW
2 = SAW

17 = Reduce HSS thickness
0 = No
Any other value = Yes

18 = Consider deflection
0 = No
Any other value = Yes

19 = DL deflection limit, 
 L/Value
Value > 0

20 = SDL + LL deflection 
 limit, L/Value
Value > 0

21 = LL deflection limit, 
 L/Value
Value > 0

22 = Total load deflection 
 limit, L/Value
Value > 0

23 = Total camber limit, 
 L/Value
Value > 0

24 = Pattern live load 
 factor
Value >= 0

25 = Demand/capacity ratio 
 limit
Value > 0

26 = Multi-response case 
 design
1 = Envelopes
2 = Step-by-step
3 = Last 
 step
4 = Envelopes 
 -- All
5 = Step-by-step 
 -- All

27 = Analysis Method
1 = Direct Analysis
2 = Effective Length
3 = Limited 1st Order

28 = Second Order 
 Method
1 = General 2nd Order
2 = Amplified 1st Order

29 = Stiffness Reduction 
 Method
1 = Tau-b variable
2 = Tau-b Fixed
3 = No Modification

30 = Importance Factor
Value > 0

31 = Design System Rho
Value > 0

32 = Design System Sds
Value >= 0

33 = Design System R
Value > 0

34 = Design System Omega0
Value > 0

35 = Design System Cd
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC360_10.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AISC360_16:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design 
 overwrite item.
The function returns zero if the item is successfully 
 retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design 
 procedure.
Item: This is an integer between 1 and 43, inclusive, indicating 
 the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, 
 L/Value
6 = SDL + LL deflection 
 limit, L/Value
7 = LL deflection limit, 
 L/Value
8 = Total load deflection 
 limit, L/Value
9 = Total camber limit, 
 L/Value
10 = DL deflection limit, 
 absolute
11 = SDL + LL deflection 
 limit, absolute
12 = LL deflection limit, 
 absolute
13 = Total load deflection 
 limit, absolute
14 = Total camber limit, 
 absolute
15 = Specified camber
16 = Net area to total 
 area ratio
17 = Live load reduction 
 factor
18 = Unbraced length ratio, 
 Major
19 = Unbraced length ratio, 
 Minor
20 = Unbraced length ratio, 
 Lateral Torsional Buckling
21 = Effective length 
 factor, K1 Major
22 = Effective length 
 factor, K1 Minor
23 = Effective length 
 factor, K2 Major
24 = Effective length 
 factor, K2 Minor
25 = Effective length 
 factor, K Lateral Torsional Buckling
26 = Moment coefficient, 
 Cm Major
27 = Moment coefficient, 
 Cm Minor
28 = Bending coefficient, 
 Cb
29 = Nonsway moment factor, 
 B1 Major
30 = Nonsway moment factor, 
 B1 Minor
31 = Sway moment factor, 
 B2 Major
32 = Sway moment factor, 
 B2 Minor
33 = Reduce HSS thickness
34 = HSS welding type
35 = Yield stress, Fy
36 = Expected to specified 
 Fy ratio, Ry
37 = Compressive capacity, 
 Pnc
38 = Tensile capacity, 
 Pnt
39 = Major bending capacity, 
 Mn3
40 = Minor bending capacity, 
 Mn2
41 = Major shear capacity, 
 Vn2
42 = Minor shear capacity, 
 Vn3
43 = Demand/capacity ratio 
 limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = SMF
2 = IMF
3 = OMF
4 = SCBF
5 = OCBF
6 = OCBFI
7 = EBF

2 = Omega0
Value >= 0; 0 means 
 use a program determined value.

3 = Consider deflection
0 = Program default
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

6 = SDL + LL deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

7 = LL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

8 = Total load deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

9 = Total camber limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

10 = DL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

11 = SDL + LL deflection 
 limit, absolute
Value >= 0; 0 means 
 no check for this item. [L]

12 = LL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

13 = Total load deflection 
 limit, absolute
Value >= 0; 0 means 
 no check for this item. [L]}

14 = Total camber limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

15 = Specified camber
Value >= 0. [L}

16 = Net area to total 
 area ratio
Value >= 0; 0 means 
 use program default value.

17 = Live load reduction 
 factor
Value >= 0; 0 means 
 use program determined value.

18 = Unbraced length ratio, 
 Major
Value >= 0; 0 means 
 use program determined value.

19 = Unbraced length ratio, 
 Minor
Value >= 0; 0 means 
 use program determined value.

20 = Unbraced length ratio, 
 Lateral Torsional Buckling
Value >= 0; 0 means 
 use program determined value.

21 = Effective length 
 factor, K1 Major
Value >= 0; 0 means 
 use program determined value.

22 = Effective length 
 factor, K1 Minor
Value >= 0; 0 means 
 use program determined value.

23 = Effective length 
 factor, K2 Major
Value >= 0; 0 means 
 use program determined value.

24 = Effective length 
 factor, K2 Minor
Value >= 0; 0 means 
 use program determined value.

25 = Effective length 
 factor, K Lateral Torsional Buckling
Value >= 0; 0 means 
 use program determined value.

26 = Moment coefficient, 
 Cm Major
Value >= 0; 0 means 
 use program determined value.

27 = Moment coefficient, 
 Cm Minor
Value >= 0; 0 means 
 use program determined value.

28 = Bending coefficient, 
 Cb
Value >= 0; 0 means 
 use program determined value.

29 = Nonsway moment factor, 
 B1 Major
Value >= 0; 0 means 
 use program determined value.

30 = Nonsway moment factor, 
 B1 Minor
Value >= 0; 0 means 
 use program determined value.

31 = Sway moment factor, 
 B2 Major
Value >= 0; 0 means 
 use program determined value.

32 = Sway moment factor, 
 B2 Minor
Value >= 0; 0 means 
 use program determined value.

33 = Reduce HSS thickness
0 = Program default
1 = No
2 = Yes

34 = HSS welding type
0 = Program default
1 = ERW
2 = SAW

35 = Yield stress, Fy
Value >= 0; 0 means 
 use program determined value. [F/L2]

36 = Expected to specified 
 Fy ratio, Ry
Value >= 0; 0 means 
 use program determined value.

37 = Compressive capacity, 
 Pnc
Value >= 0; 0 means 
 use program determined value. [F]

38 = Tensile capacity, 
 Pnt
Value >= 0; 0 means 
 use program determined value. [F]

39 = Major bending capacity, 
 Mn3
Value >= 0; 0 means 
 use program determined value. [FL]

40 = Minor bending capacity, 
 Mn2
Value >= 0; 0 means 
 use program determined value. [FL]

41 = Major shear capacity, 
 Vn2
Value >= 0; 0 means 
 use program determined value. [F]

42 = Minor shear capacity, 
 Vn3
Value >= 0; 0 means 
 use program determined value. [F]

43 = Demand/capacity ratio 
 limit
Value >= 0; 0 means use 
 program determined value.
ProgDet: If this item is True, the specified value is program 
 determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC360_16.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design 
 preference item.
The function returns zero if the item is successfully 
 retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 35, inclusive, indicating 
 the preference item considered.
1 = Framing type
2 = Seismic design category
3 = Design provision
4 = Analysis method (Obsolete, 
 replaced by 27, 28, and 29)
5 = Notional load coefficient
6 = Phi or Omega for bending
7 = Phi or Omega for compression
8 = Phi or Omega for tension 
 yielding
9 = Phi or Omega for tension 
 fracture
10 = Phi or Omega for 
 shear
11 = Phi or Omega for 
 shear short webbed rolled I
12 = Phi or Omega for 
 torsion
13 = Ignore seismic code
14 = Ignore special seismic 
 load
15 = Doubler plate is 
 plug welded
16 = HSS welding type
17 = Reduce HSS thickness
18 = Consider deflection
19 = DL deflection limit, 
 L/Value
20 = SDL + LL deflection 
 limit, L/Value
21 = LL deflection limit, 
 L/Value
22 = Total load deflection 
 limit, L/Value
23 = Total camber limit, 
 L/Value
24 = Pattern live load 
 factor
25 = Demand/capacity ratio 
 limit
26 = Multi-response case design
27 = Analysis Method
28 = Second Order Method
29 = Stiffness Reduction Method
30 = Importance Factor
31 = Design Systems Rho
32 = Design Systems Sds
33 = Design Systems R
34 = Design Systems Omega0
35 = Design Systems Cd

Value: The value of the considered preference item.
1 = Framing type
1 = SMF
2 = IMF
3 = OMF
4 = SCBF
5 = OCBF
6 = OCBFI
7 = EBF

2 = Seismic design category
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

3 = Design provision
1 = LRFD
2 = ASD

4 = Analysis method (Obsolete, 
 replaced by 27, 28, and 29)
1 = Gen 2nd Order Elastic
2 = 2nd Order By Amp 
 1st Order
3 = Limited 1st Order 
 Elastic
4 = DAM Gen 2nd Order 
 Taub Variable
5 = DAM Gen 2nd Order 
 Taub Fixed
6 = DAM Amp 1st Order 
 Taub Variable
7 = DAM Amp 1st Order 
 Taub Fixed

5 = Notional load coefficient
Value > 0

6 = Phi or Omega for bending
Value > 0

7 = Phi or Omega for compression
Value > 0

8 = Phi or Omega for tension 
 yielding
Value > 0

9 = Phi or Omega for tension 
 fracture
Value > 0

10 = Phi or Omega for 
 shear
Value > 0

11 = Phi or Omega for 
 shear short webbed rolled I
Value > 0

12 = Phi or Omega for 
 torsion
Value > 0

13 = Ignore seismic code
0 = No
Any other value = Yes

14 = Ignore special seismic 
 load
0 = No
Any other value = Yes

15 = Doubler plate is 
 plug welded
0 = No
Any other value = Yes

16 = HSS welding type
1 = ERW
2 = SAW

17 = Reduce HSS thickness
0 = No
Any other value = Yes

18 = Consider deflection
0 = No
Any other value = Yes

19 = DL deflection limit, 
 L/Value
Value > 0

20 = SDL + LL deflection 
 limit, L/Value
Value > 0

21 = LL deflection limit, 
 L/Value
Value > 0

22 = Total load deflection 
 limit, L/Value
Value > 0

23 = Total camber limit, 
 L/Value
Value > 0

24 = Pattern live load 
 factor
Value >= 0

25 = Demand/capacity ratio 
 limit
Value > 0

26 = Multi-response case 
 design
1 = Envelopes
2 = Step-by-step
3 = Last 
 step
4 = Envelopes 
 -- All
5 = Step-by-step 
 -- All

27 = Analysis Method
1 = Direct Analysis
2 = Effective Length
3 = Limited 1st Order

28 = Second Order Method
1 = General 2nd Order
2 = Amplified 1st Order

29 = Stiffness Reduction 
 Method
1 = Tau-b variable
2 = Tau-b Fixed
3 = No Modification

30 = Importance Factor
Value > 0

31 = Design System Rho
Value > 0

32 = Design System Sds
Value >= 0

33 = Design System R
Value > 0

34 = Design System Omega0
Value > 0

35 = Design System Cd
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC360_16.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite 
 item.
The function returns zero if the item is successfully 
 set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending 
 on the value of the ItemType item.
Item: This is an integer between 1 and 43, inclusive, indicating 
 the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, 
 L/Value
6 = SDL + LL deflection 
 limit, L/Value
7 = LL deflection limit, 
 L/Value
8 = Total load deflection 
 limit, L/Value
9 = Total camber limit, 
 L/Value
10 = DL deflection limit, 
 absolute
11 = SDL + LL deflection 
 limit, absolute
12 = LL deflection limit, 
 absolute
13 = Total load deflection 
 limit, absolute
14 = Total camber limit, 
 absolute
15 = Specified camber
16 = Net area to total 
 area ratio
17 = Live load reduction 
 factor
18 = Unbraced length ratio, 
 Major
19 = Unbraced length ratio, 
 Minor
20 = Unbraced length ratio, 
 Lateral Torsional Buckling
21 = Effective length 
 factor, K1 Major
22 = Effective length 
 factor, K1 Minor
23 = Effective length 
 factor, K2 Major
24 = Effective length 
 factor, K2 Minor
25 = Effective length 
 factor, K Lateral Torsional Buckling
26 = Moment coefficient, 
 Cm Major
27 = Moment coefficient, 
 Cm Minor
28 = Bending coefficient, 
 Cb
29 = Nonsway moment factor, 
 B1 Major
30 = Nonsway moment factor, 
 B1 Minor
31 = Sway moment factor, 
 B2 Major
32 = Sway moment factor, 
 B2 Minor
33 = Reduce HSS thickness
34 = HSS welding type
35 = Yield stress, Fy
36 = Expected to specified 
 Fy ratio, Ry
37 = Compressive capacity, 
 Pnc
38 = Tensile capacity, 
 Pnt
39 = Major bending capacity, 
 Mn3
40 = Minor bending capacity, 
 Mn2
41 = Major shear capacity, 
 Vn2
42 = Minor shear capacity, 
 Vn3
43 = Demand/capacity ratio 
 limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = SMF
2 = IMF
3 = OMF
4 = SCBF
5 = OCBF
6 = OCBFI
7 = EBF

2 = Omega0
Value >= 0; 0 means 
 use a program determined value.

3 = Consider deflection
0 = Program default
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

6 = SDL + LL deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

7 = LL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

8 = Total load deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

9 = Total camber limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

10 = DL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

11 = SDL + LL deflection 
 limit, absolute
Value >= 0; 0 means 
 no check for this item. [L]

12 = LL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

13 = Total load deflection 
 limit, absolute
Value >= 0; 0 means 
 no check for this item. [L]}

14 = Total camber limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

15 = Specified camber
Value >= 0. [L}

16 = Net area to total 
 area ratio
Value >= 0; 0 means 
 use program default value.

17 = Live load reduction 
 factor
Value >= 0; 0 means 
 use program determined value.

18 = Unbraced length ratio, 
 Major
Value >= 0; 0 means 
 use program determined value.

19 = Unbraced length ratio, 
 Minor
Value >= 0; 0 means 
 use program determined value.

20 = Unbraced length ratio, 
 Lateral Torsional Buckling
Value >= 0; 0 means 
 use program determined value.

21 = Effective length 
 factor, K1 Major
Value >= 0; 0 means 
 use program determined value.

22 = Effective length 
 factor, K1 Minor
Value >= 0; 0 means 
 use program determined value.

23 = Effective length 
 factor, K2 Major
Value >= 0; 0 means 
 use program determined value.

24 = Effective length 
 factor, K2 Minor
Value >= 0; 0 means 
 use program determined value.

25 = Effective length 
 factor, K Lateral Torsional Buckling
Value >= 0; 0 means 
 use program determined value.

26 = Moment coefficient, 
 Cm Major
Value >= 0; 0 means 
 use program determined value.

27 = Moment coefficient, 
 Cm Minor
Value >= 0; 0 means 
 use program determined value.

28 = Bending coefficient, 
 Cb
Value >= 0; 0 means 
 use program determined value.

29 = Nonsway moment factor, 
 B1 Major
Value >= 0; 0 means 
 use program determined value.

30 = Nonsway moment factor, 
 B1 Minor
Value >= 0; 0 means 
 use program determined value.

31 = Sway moment factor, 
 B2 Major
Value >= 0; 0 means 
 use program determined value.

32 = Sway moment factor, 
 B2 Minor
Value >= 0; 0 means 
 use program determined value.

33 = Reduce HSS thickness
0 = Program default
1 = No
2 = Yes

34 = HSS welding type
0 = Program default
1 = ERW
2 = SAW

35 = Yield stress, Fy
Value >= 0; 0 means 
 use program determined value. [F/L2]

36 = Expected to specified 
 Fy ratio, Ry
Value >= 0; 0 means 
 use program determined value.

37 = Compressive capacity, 
 Pnc
Value >= 0; 0 means 
 use program determined value. [F]

38 = Tensile capacity, 
 Pnt
Value >= 0; 0 means 
 use program determined value. [F]

39 = Major bending capacity, 
 Mn3
Value >= 0; 0 means 
 use program determined value. [FL]

40 = Minor bending capacity, 
 Mn2
Value >= 0; 0 means 
 use program determined value. [FL]

41 = Major shear capacity, 
 Vn2
Value >= 0; 0 means 
 use program determined value. [F]

42 = Minor shear capacity, 
 Vn3
Value >= 0; 0 means 
 use program determined value. [F]

43 = Demand/capacity ratio 
 limit
Value >= 0; 0 means use 
 program determined value.
ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the 
 frame object specified by the Name item.
If this item is Group, the assignment is made to all 
 frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made 
 to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC360_16.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference 
 item.
The function returns zero if the item is successfully 
 set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 35, inclusive, indicating 
 the preference item considered.
1 = Framing type
2 = Seismic design category
3 = Design provision
4 = Analysis method (Obsolete, 
 replaced by 27, 28, and 29)
5 = Notional load coefficient
6 = Phi or Omega for bending
7 = Phi or Omega for compression
8 = Phi or Omega for tension 
 yielding
9 = Phi or Omega for tension 
 fracture
10 = Phi or Omega for 
 shear
11 = Phi or Omega for 
 shear short webbed rolled I
12 = Phi or Omega for 
 torsion
13 = Ignore seismic code
14 = Ignore special seismic 
 load
15 = Doubler plate is 
 plug welded
16 = HSS welding type
17 = Reduce HSS thickness
18 = Consider deflection
19 = DL deflection limit, 
 L/Value
20 = SDL + LL deflection 
 limit, L/Value
21 = LL deflection limit, 
 L/Value
22 = Total load deflection 
 limit, L/Value
23 = Total camber limit, 
 L/Value
24 = Pattern live load 
 factor
25 = Demand/capacity ratio 
 limit
26 = Multi-response case design
27 = Analysis Method
28 = Second Order Method
29 = Stiffness Reduction Method
30 = Importance Factor
31 = Design Systems Rho
32 = Design Systems Sds
33 = Design Systems R
34 = Design Systems Omega0
35 = Design Systems Cd
Value: The value of the considered preference item.
1 = Framing type
1 = SMF
2 = IMF
3 = OMF
4 = SCBF
5 = OCBF
6 = OCBFI
7 = EBF

2 = Seismic design category
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

3 = Design provision
1 = LRFD
2 = ASD

4 = Analysis method (Obsolete, 
 replaced by 27, 28, and 29)
1 = Gen 2nd Order Elastic
2 = 2nd Order By Amp 
 1st Order
3 = Limited 1st Order 
 Elastic
4 = DAM Gen 2nd Order 
 Taub Variable
5 = DAM Gen 2nd Order 
 Taub Fixed
6 = DAM Amp 1st Order 
 Taub Variable
7 = DAM Amp 1st Order 
 Taub Fixed

5 = Notional load coefficient
Value > 0

6 = Phi or Omega for bending
Value > 0

7 = Phi or Omega for compression
Value > 0

8 = Phi or Omega for tension 
 yielding
Value > 0

9 = Phi or Omega for tension 
 fracture
Value > 0

10 = Phi or Omega for 
 shear
Value > 0

11 = Phi or Omega for 
 shear short webbed rolled I
Value > 0

12 = Phi or Omega for 
 torsion
Value > 0

13 = Ignore seismic code
0 = No
Any other value = Yes

14 = Ignore special seismic 
 load
0 = No
Any other value = Yes

15 = Doubler plate is 
 plug welded
0 = No
Any other value = Yes

16 = HSS welding type
1 = ERW
2 = SAW

17 = Reduce HSS thickness
0 = No
Any other value = Yes

18 = Consider deflection
0 = No
Any other value = Yes

19 = DL deflection limit, 
 L/Value
Value > 0

20 = SDL + LL deflection 
 limit, L/Value
Value > 0

21 = LL deflection limit, 
 L/Value
Value > 0

22 = Total load deflection 
 limit, L/Value
Value > 0

23 = Total camber limit, 
 L/Value
Value > 0

24 = Pattern live load 
 factor
Value >= 0

25 = Demand/capacity ratio 
 limit
Value > 0

26 = Multi-response case 
 design
1 = Envelopes
2 = Step-by-step
3 = Last 
 step
4 = Envelopes 
 -- All
5 = Step-by-step 
 -- All

27 = Analysis Method
1 = Direct Analysis
2 = Effective Length
3 = Limited 1st Order

28 = Second Order 
 Method
1 = General 2nd Order
2 = Amplified 1st Order

29 = Stiffness Reduction 
 Method
1 = Tau-b variable
2 = Tau-b Fixed
3 = No Modification

30 = Importance Factor
Value > 0

31 = Design System Rho
Value > 0

32 = Design System Sds
Value >= 0

33 = Design System R
Value > 0

34 = Design System Omega0
Value > 0

35 = Design System Cd
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC360_16.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AISC_ASD01:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 32, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Moment coefficient, Cm Major
23 = Moment coefficient, Cm Minor
24 = Bending coefficient, Cb
25 = Yield stress, Fy
26 = Compressive stress, Fa
27 = Tensile stress, Ft
28 = Major bending stress, Fb3
29 = Minor bending stress, Fb2
30 = Major shear stress, Fv2
31 = Minor shear stress, Fv3
32 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = OMF
2 = IMF
3 = SMF
4 = OCBF
5 = SCBF
6 = EBF

2 = Omega0
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L]

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

24 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

25 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

26 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

27 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

28 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

29 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

30 = Major shear stress, Fv2
Value >= 0; 0 means use program determined value. [F/L2]

31 = Minor shear stress, Fv3
Value >= 0; 0 means use program determined value. [F/L2]

32 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_ASD01.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 14, inclusive, indicating the preference item considered.
1 = Framing type
2 = Seismic design capacity
3 = Ignore seismic code
4 = Ignore special seismic load
5 = Isdoubler plate plug-welded
6 = Consider deflection
7 = DL deflection limit, L/Value
8 = SDL + LL deflection limit, L/Value
9 = LL deflection limit, L/Value
10 = Total deflection limit, L/Value
11 = Total camber limit, L/Value
12 = Pattern live load factor
13 = Demand/capacity ratio limit
14 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = OMF
2 = IMF
3 = SMF
4 = OCBF
5 = SCBF
6 = EBF

2 = Seismic design capacity
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

3 = Ignore seismic code
0 = No
Any other value = Yes

4 = Ignore special seismic load
0 = No
Any other value = Yes

5 = Isdoubler plate plug-welded
0 = No
Any other value = Yes

6 = Consider deflection
0 = No
Any other value = Yes

7 = DL DLdeflection limit, L/Value
Value > 0

8 = SDL + LL deflection limit, L/Value
Value > 0

9 = LL deflection limit, L/Value
Value > 0

10 = Total deflection limit, L/Value
Value > 0

11 = Total camber limit, L/Value
Value > 0

12 = Pattern live load factor
Value >= 0

13 = Demand/capacity ratio limit
Value > 0

14 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_ASD01.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 32, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Moment coefficient, Cm Major
23 = Moment coefficient, Cm Minor
24 = Bending coefficient, Cb
25 = Yield stress, Fy
26 = Compressive stress, Fa
27 = Tensile stress, Ft
28 = Major bending stress, Fb3
29 = Minor bending stress, Fb2
30 = Major shear stress, Fv2
31 = Minor shear stress, Fv3
32 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = OMF
2 = IMF
3 = SMF
4 = OCBF
5 = SCBF
6 = EBF

2 = Omega0
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L]

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

24 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

25 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

26 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

27 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

28 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

29 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

30 = Major shear stress, Fv2
Value >= 0; 0 means use program determined value. [F/L2]

31 = Minor shear stress, Fv3
Value >= 0; 0 means use program determined value. [F/L2]

32 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects= 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_ASD01.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 14, inclusive, indicating the preference item considered.
1 = Framing type
2 = Seismic design capacity
3 = Ignore seismic code
4 = Ignore special seismic load
5 = Isdoubler plate plug-welded
6 = Consider deflection
7 = DL deflection limit, L/Value
8 = SDL + LL deflection limit, L/Value
9 = LL deflection limit, L/Value
10 = Total deflection limit, L/Value
11 = Total camber limit, L/Value
12 = Pattern live load factor
13 = Demand/capacity ratio limit
14 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = OMF
2 = IMF
3 = SMF
4 = OCBF
5 = SCBF
6 = EBF

2 = Seismic design capacity
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

3 = Ignore seismic code
0 = No
Any other value = Yes

4 = Ignore special seismic load
0 = No
Any other value = Yes

5 = Is doubler plate plug-welded
0 = No
Any other value = Yes

6 = Consider deflection
0 = No
Any other value = Yes

7 = DL DLdeflection limit, L/Value
Value > 0

8 = SDL + LL deflection limit, L/Value
Value > 0

9 = LL deflection limit, L/Value
Value > 0

10 = Total deflection limit, L/Value
Value > 0

11 = Total camber limit, L/Value
Value > 0

12 = Pattern live load factor
Value >= 0

13 = Demand/capacity ratio limit
Value > 0

14 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_ASD01.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AISC_ASD89:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 31, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Cm Major
22 = Moment coefficient, Cm Minor
23 = Bending coefficient, Cb
24 = Yield stress, Fy
25 = Compressive stress, Fa
26 = Tensile stress, Ft
27 = Major bending stress, Fb3
28 = Minor bending stress, Fb2
29 = Major shear stress, Fv2
30 = Minor shear stress, Fv3
31 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Brace Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

24 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

25 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

26 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

27 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

28 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

29 = Major shear stress, Fv2
Value >= 0; 0 means use program determined value. [F/L2]

30 = Minor shear stress, Fv3
Value >= 0; 0 means use program determined value. [F/L2]

31 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_ASD89.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Framing type
2 = Lateral factor
3 = Consider deflection
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit
6 = LL deflection limit, L/Value
7 = Total deflection limit, L/Value
8 = Total camber limit, L/Value
9 = Pattern live load factor
10 = Demand/capacity ratio limit
11 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Lateral factor
Value > 0

3 = Consider deflection
0 = No
Any other value = Yes

4 = DL deflection limit, L/Value
Value > 0

5 = SDL + LL deflection limit
Value > 0

6 = LL deflection limit, L/Value
Value > 0

7 = Total deflection limit, L/Value
Value > 0

8 = Total camber limit, L/Value
Value > 0

9 = Pattern live load factor
Value >= 0

10 = Demand/capacity ratio limit
Value > 0

11 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_ASD89.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 31, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Cm Major
22 = Moment coefficient, Cm Minor
23 = Bending coefficient, Cb
24 = Yield stress, Fy
25 = Compressive stress, Fa
26 = Tensile stress, Ft
27 = Major bending stress, Fb3
28 = Minor bending stress, Fb2
29 = Major shear stress, Fv2
30 = Minor shear stress, Fv3
31 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Brace Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral TorsionalBuckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

24 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

25 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

26 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

27 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

28 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

29 = Major shear stress, Fv2
Value >= 0; 0 means use program determined value. [F/L2]

30 = Minor shear stress, Fv3
Value >= 0; 0 means use program determined value. [F/L2]

31 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_ASD89.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Framing type
2 = Lateral factor
3 = Consider deflection
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit
6 = LL deflection limit, L/Value
7 = Total deflection limit, L/Value
8 = Total camber limit, L/Value
9 = Pattern live load factor
10 = Demand/capacity ratio limit
11 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Lateral factor
Value > 0

3 = Consider deflection
0 = No
Any other value = Yes

4 = DL deflection limit, L/Value
Value > 0

5 = SDL + LL deflection limit
Value > 0

6 = LL deflection limit, L/Value
Value > 0

7 = Total deflection limit, L/Value
Value > 0

8 = Total camber limit, L/Value
Value > 0

9 = Pattern live load factor
Value >= 0

10 = Demand/capacity ratio limit
Value > 0

11 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_ASD89.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AISC_LRFD93:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 35, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Cm Major
22 = Moment coefficient, Cm Minor
23 = Bending coefficient, Cb
24 = Non-sway moment factor, B1 Major
25 = Non-sway moment factor, B1 Minor
26 = Sway moment factor, B2 Major
27 = Sway moment factor, B2 Minor
28 = Yield stress, Fy
29 = Compressive capacity, phi*Pnc
30 = Tensile capacity, phi*Pnt
31 = Major bending capacity, phi*Mn3
32 = Minor bending capacity, phi*Mn2
33 = Major shear capacity, phi*Vn2
34 = Minor shear capacity, phi*Vn3
35 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

24 = Non-sway moment factor, B1 Major
Value >= 0; 0 means use program determined value.

25 = Non-sway moment factor, B1 Minor
Value >= 0; 0 means use program determined value.

26 = Sway moment factor, B2 Major
Value >= 0; 0 means use program determined value.

27 = Sway moment factor, B2 Minor
Value >= 0; 0 means use program determined value.

28 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

29 = Compressive capacity, phi*Pnc
Value >= 0; 0 means use program determined value. [F]

30 = Tensile capacity, phi*Pnt
Value >= 0; 0 means use program determined value. [F]

31 = Major bending capacity, phi*Mn3
Value >= 0; 0 means use program determined value. [FL]

32 = Minor bending capacity, phi*Mn2
Value >= 0; 0 means use program determined value. [FL]

33 = Major shear capacity, phi*Vn2
Value >= 0; 0 means use program determined value. [F]

34 = Minor shear capacity, phi*Vn3
Value >= 0; 0 means use program determined value. [F]

35 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_LRFD93.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 15, inclusive, indicating the preference item considered.
1 = Framing type
2 = Phi bending
3 = Phi compression
4 = Phi tension
5 = Phi shear
6 = Phi compression, angle
7 = Consider deflection
8 = DL deflection limit, L/Value
9 = SDL + LL deflection limit, L/Value
10 = LL deflection limit, L/Value
11 = Total deflection limit, L/Value
12 = Total camber limit, L/Value
13 = Pattern live load factor
14 = Demand/capacity ratio limit
15 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Phi bending
Value > 0

3 = Phi compression
Value > 0

4 = Phi tension
Value > 0

5 = Phi shear
Value > 0

6 = Phi compression, angle
Value > 0

7 = Consider deflection
0 = No
Any other value = Yes

8 = DL deflection limit, L/Value
Value > 0

9 = SDL + LL deflection limit, L/Value
Value > 0

10 = LL deflection limit, L/Value
Value > 0

11 = Total deflection limit, L/Value
Value > 0

12 = Total camber limit, L/Value
Value > 0

13 = Pattern live load factor
Value >= 0

14 = Demand/capacity ratio limit
Value > 0

15 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_LRFD93.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 35, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Cm Major
22 = Moment coefficient, Cm Minor
23 = Bending coefficient, Cb
24 = Non-sway moment factor, B1 Major
25 = Non-sway moment factor, B1 Minor
26 = Sway moment factor, B2 Major
27 = Sway moment factor, B2 Minor
28 = Yield stress, Fy
29 = Compressive capacity, phi*Pnc
30 = Tensile capacity, phi*Pnt
31 = Major bending capacity, phi*Mn3
32 = Minor bending capacity, phi*Mn2
33 = Major shear capacity, phi*Vn2
34 = Minor shear capacity, phi*Vn3
35 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

24 = Nonsway moment factor, B1 Major
Value >= 0; 0 means use program determined value.

25 = Nonsway moment factor, B1 Minor
Value >= 0; 0 means use program determined value.

26 = Sway moment factor, B2 Major
Value >= 0; 0 means use program determined value.

27 = Sway moment factor, B2 Minor
Value >= 0; 0 means use program determined value.

28 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

29 = Compressive capacity, phi*Pnc
Value >= 0; 0 means use program determined value. [F]

30 = Tensile capacity, phi*Pnt
Value >= 0; 0 means use program determined value. [F]

31 = Major bending capacity, phi*Mn3
Value >= 0; 0 means use program determined value. [FL]

32 = Minor bending capacity, phi*Mn2
Value >= 0; 0 means use program determined value. [FL]

33 = Major shear capacity, phi*Vn2
Value >= 0; 0 means use program determined value. [F]

34 = Minor shear capacity, phi*Vn3
Value >= 0; 0 means use program determined value. [F]

35 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects= 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_LRFD93.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 15, inclusive, indicating the preference item considered.
1 = Framing type
2 = Phi bending
3 = Phi compression
4 = Phi tension
5 = Phi shear
6 = Phi compression, angle
7 = Consider deflection
8 = DL deflection limit, L/Value
9 = SDL + LL deflection limit, L/Value
10 = LL deflection limit, L/Value
11 = Total deflection limit, L/Value
12 = Total camber limit, L/Value
13 = Pattern live load factor
14 = Demand/capacity ratio limit
15 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Phi bending
Value > 0

3 = Phi compression
Value > 0

4 = Phi tension
Value > 0

5 = Phi shear
Value > 0

6 = Phi compression, angle
Value > 0

7 = Consider deflection
0 = No
Any other value = Yes

8 = DL deflection limit, L/Value
Value > 0

9 = SDL + LL deflection limit, L/Value
Value > 0

10 = LL deflection limit, L/Value
Value > 0

11 = Total deflection limit, L/Value
Value > 0

12 = Total camber limit, L/Value
Value > 0

13 = Pattern live load factor
Value >= 0

14 = Demand/capacity ratio limit
Value > 0

15 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_LRFD93.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class AISC_LRFD99:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 37, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Moment coefficient, Cm Major
23 = Moment coefficient, Cm Minor
24 = Bending coefficient, Cb
25 = Non-sway moment factor, B1 Major
26 = Non-sway moment factor, B1 Minor
27 = Sway moment factor, B2 Major
28 = Sway moment factor, B2 Minor
29 = Yield stress, Fy
30 = Expected to specified Fy ratio, Ry
31 = Compressive capacity, phi*Pnc
32 = Tensile capacity, phi*Pnt
33 = Major bending capacity, phi*Mn3
34 = Minor bending capacity, phi*Mn2
35 = Major shear capacity, phi*Vn2
36 = Minor shear capacity, phi*Vn3
37 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = OMF
2 = IMF
3 = SMF
4 = OCBF
5 = SCBF
6 = EBF

2 = Omega0
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L]

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

24 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

25 = Non-sway moment factor, B1 Major
Value >= 0; 0 means use program determined value.

26 = Non-sway moment factor, B1 Minor
Value >= 0; 0 means use program determined value.

27 = Sway moment factor, B2 Major
Value >= 0; 0 means use program determined value.

28 = Sway moment factor, B2 Minor
Value >= 0; 0 means use program determined value.

29 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

30 = Expected to specified Fy ratio, Ry
Value >= 0; 0 means use program determined value.

31 = Compressive capacity, phi*Pnc
Value >= 0; 0 means use program determined value. [F]

32 = Tensile capacity, phi*Pnt
Value >= 0; 0 means use program determined value. [F]

33 = Major bending capacity, phi*Mn3
Value >= 0; 0 means use program determined value. [FL]

34 = Minor bending capacity, phi*Mn2
Value >= 0; 0 means use program determined value. [FL]

35 = Major shear capacity, phi*Vn2
Value >= 0; 0 means use program determined value. [F]

36 = Minor shear capacity, phi*Vn3
Value >= 0; 0 means use program determined value. [F]

37 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_LRFD99.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 21, inclusive, indicating the preference item considered.
1 = Framing type
2 = Seismic design capacity
3 = Phi bending
4 = Phi compression
5 = Phi tension - yielding
6 = Phi tension - fracture
7 = Phi shear
8 = Phi shear - torsion
9 = Phi compression, angle
10 = Ignore seismic code
11 = Ignore special seismic code
12 = Is doubler plate plug-welded
13 = Consider deflection
14 = DL deflection limit, L/Value
15 = SDL + LL deflection limit, L/Value
16 = LL deflection limit, L/Value
17 = Total deflection limit, L/Value
18 = Total camber limit, L/Value
19 = Pattern live load factor
20 = Demand capacity ratio limit
21 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = OMF
2 = IMF
3 = SMF
4 = OCBF
5 = SCBF
6 = EBF

2 = Seismic design capacity
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

3 = Phi bending
Value > 0

4 = Phi compression
Value > 0

5 = Phi tension â€“ yielding
Value > 0

6 = Phi tension - fracture
Value > 0

7 = Phi shear
Value > 0

8 = Phi shear - torsion
Value > 0

9 = Phi compression, angle
Value > 0

10 = Ignore seismic code
0 = No
Any other value = Yes

11 = Ignore special seismic code
0 = No
Any other value = Yes

12 = Is doubler plate plug-welded
0 = No
Any other value = Yes

13 = Consider deflection
0 = No
Any other value = Yes

14 = DL deflection limit, L/Value
Value > 0

15 = SDL + LL deflection limit, L/Value
Value > 0

16 = LL deflection limit, L/Value
Value > 0

17 = Total deflection limit, L/Value
Value > 0

18 = Total camber limit, L/Value
Value > 0

19 = Pattern live load factor
Value >= 0

20 = Demand capacity ratio limit
Value > 0

21 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_LRFD99.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 37, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Moment coefficient, Cm Major
23 = Moment coefficient, Cm Minor
24 = Bending coefficient, Cb
25 = Non-sway moment factor, B1 Major
26 = Non-sway moment factor, B1 Minor
27 = Sway moment factor, B2 Major
28 = Sway moment factor, B2 Minor
29 = Yield stress, Fy
30 = Expected to specified Fy ratio, Ry
31 = Compressive capacity, phi*Pnc
32 = Tensile capacity, phi*Pnt
33 = Major bending capacity, phi*Mn3
34 = Minor bending capacity, phi*Mn2
35 = Major shear capacity, phi*Vn2
36 = Minor shear capacity, phi*Vn3
37 = Demand/capacity ratio limit

Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = OMF
2 = IMF
3 = SMF
4 = OCBF
5 = SCBF
6 = EBF

2 = Omega0
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L]

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

24 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

25 = Nonsway moment factor, B1 Major
Value >= 0; 0 means use program determined value.

26 = Nonsway moment factor, B1 Minor
Value >= 0; 0 means use program determined value.

27 = Sway moment factor, B2 Major
Value >= 0; 0 means use program determined value.

28 = Sway moment factor, B2 Minor
Value >= 0; 0 means use program determined value.

29 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

30 = Expected to specified Fy ratio, Ry
Value >= 0; 0 means use program determined value.

31 = Compressive capacity, phi*Pnc
Value >= 0; 0 means use program determined value. [F]

32 = Tensile capacity, phi*Pnt
Value >= 0; 0 means use program determined value. [F]

33 = Major bending capacity, phi*Mn3
Value >= 0; 0 means use program determined value. [FL]

34 = Minor bending capacity, phi*Mn2
Value >= 0; 0 means use program determined value. [FL]

35 = Major shear capacity, phi*Vn2
Value >= 0; 0 means use program determined value. [F]

36 = Minor shear capacity, phi*Vn3
Value >= 0; 0 means use program determined value. [F]

37 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_LRFD99.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 21, inclusive, indicating the preference item considered.
1 = Framing type
2 = Seismic design capacity
3 = Phi bending
4 = Phi compression
5 = Phi tension - yielding
6 = Phi tension - fracture
7 = Phi shear
8 = Phi shear - torsion
9 = Phi compression, angle
10 = Ignore seismic code
11 = Ignore special seismic code
12 = Is doubler plate plug-welded
13 = Consider deflection
14 = DL deflection limit, L/Value
15 = SDL + LL deflection limit, L/Value
16 = LL deflection limit, L/Value
17 = Total deflection limit, L/Value
18 = Total camber limit, L/Value
19 = Pattern live load factor
20 = Demand capacity ratio limit
21 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = OMF
2 = IMF
3 = SMF
4 = OCBF
5 = SCBF
6 = EBF

2 = Seismic design capacity
1 = A
2 = B
3 = C
4 = D
5 = E
6 = F

3 = Phi bending
Value > 0

4 = Phi compression
Value > 0

5 = Phi tension â€“ yielding
Value > 0

6 = Phi tension - fracture
Value > 0

7 = Phi shear
Value > 0

8 = Phi shear - torsion
Value > 0

9 = Phi compression, angle
Value > 0

10 = Ignore seismic code
0 = No
Any other value = Yes

11 = Ignore special seismic code
0 = No
Any other value = Yes

12 = Is doubler plate plug-welded
0 = No
Any other value = Yes

13 = Consider deflection
0 = No
Any other value = Yes

14 = DL deflection limit, L/Value
Value > 0

15 = SDL + LL deflection limit, L/Value
Value > 0

16 = LL deflection limit, L/Value
Value > 0

17 = Total deflection limit, L/Value
Value > 0

18 = Total camber limit, L/Value
Value > 0

19 = Pattern live load factor
Value >= 0

20 = Demand capacity ratio limit
Value > 0

21 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.AISC_LRFD99.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class API_RP2A_LRFD97:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 37, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Cm Major
22 = Moment coefficient, Cm Minor
23 = Bending coefficient, Cb
24 = Non-sway moment factor, B1 Major
25 = Non-sway moment factor, B1 Minor
26 = Sway moment factor, B2 Major
27 = Sway moment factor, B2 Minor
28 = Pressure equalized
29 = External pressure
30 = Yield stress, Fy
31 = Compressive capacity, phi*Pnc
32 = Tensile capacity, phi*Pnt
33 = Major bending capacity, phi*Mn3
34 = Minor bending capacity, phi*Mn2
35 = Major shear capacity, phi*Vn2
36 = Minor shear capacity, phi*Vn3
37 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

24 = Non-sway moment factor, B1 Major
Value >= 0; 0 means use program determined value.

25 = Non-sway moment factor, B1 Minor
Value >= 0; 0 means use program determined value.

26 = Sway moment factor, B2 Major
Value >= 0; 0 means use program determined value.

27 = Sway moment factor, B2 Minor
Value >= 0; 0 means use program determined value.

28 = Pressure equalized
0 = Program Determined
1 = No
2 = Yes

29 = External pressure. [F/L2]
Any value OK; Positive generates hoop compression and negative generates hoop tension. [F/L2]

30 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

31 = Compressive capacity, phi*Pnc
Value >= 0; 0 means use program determined value. [F]

32 = Tensile capacity, phi*Pnt
Value >= 0; 0 means use program determined value. [F]

33 = Major bending capacity, phi*Mn3
Value >= 0; 0 means use program determined value. [FL]

34 = Minor bending capacity, phi*Mn2
Value >= 0; 0 means use program determined value. [FL]

35 = Major shear capacity, phi*Vn2
Value >= 0; 0 means use program determined value. [F]

36 = Minor shear capacity, phi*Vn3
Value >= 0; 0 means use program determined value. [F]

37 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.API_RP2A_LRFD97.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Framing type
2 = Tubular joint punching load method
3 = Consider deflection
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total deflection limit, L/Value
8 = Total camber limit, L/Value
9 = Pattern live load factor
10 = Demand/capacity ratio limit
11 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Tubular joint punching load method
1 = Punching Shear
2 = Nominal Load

3 = Consider deflection
0 = No
Any other value = Yes

4 = DL deflection limit, L/Value
Value > 0

5 = SDL + LL deflection limit, L/Value
Value > 0

6 = LL deflection limit, L/Value
Value > 0

7 = Total deflection limit, L/Value
Value > 0

8 = Total camber limit, L/Value
Value > 0

9 = Pattern live load factor
Value >= 0

10 = Demand/capacity ratio limit
Value > 0

11 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.API_RP2A_LRFD97.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemTypeitem.
Item: This is an integer between 1 and 37, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Cm Major
22 = Moment coefficient, Cm Minor
23 = Bending coefficient, Cb
24 = Non-sway moment factor, B1 Major
25 = Non-sway moment factor, B1 Minor
26 = Sway moment factor, B2 Major
27 = Sway moment factor, B2 Minor
28 = Pressure equalized
29 = External pressure
30 = Yield stress, Fy
31 = Compressive capacity, phi*Pnc
32 = Tensile capacity, phi*Pnt
33 = Major bending capacity, phi*Mn3
34 = Minor bending capacity, phi*Mn2
35 = Major shear capacity, phi*Vn2
36 = Minor shear capacity, phi*Vn3
37 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

24 = Non-sway moment factor, B1 Major
Value >= 0; 0 means use program determined value.

25 = Non-sway moment factor, B1 Minor
Value >= 0; 0 means use program determined value.

26 = Sway moment factor, B2 Major
Value >= 0; 0 means use program determined value.

27 = Sway moment factor, B2 Minor
Value >= 0; 0 means use program determined value.

28 = Pressure equalized
0 = Program Determined
1 = No
2 = Yes

29 = External pressure
Any value OK; Positive generates hoop compression and negative generates hoop tension. [F/L2]

30 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

31 = Compressive capacity, phi*Pnc
Value >= 0; 0 means use program determined value. [F]

32 = Tensile capacity, phi*Pnt
Value >= 0; 0 means use program determined value. [F]

33 = Major bending capacity, phi*Mn3
Value >= 0; 0 means use program determined value. [FL]

34 = Minor bending capacity, phi*Mn2
Value >= 0; 0 means use program determined value. [FL]

35 = Major shear capacity, phi*Vn2
Value >= 0; 0 means use program determined value. [F]

36 = Minor shear capacity, phi*Vn3
Value >= 0; 0 means use program determined value. [F]

37 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.API_RP2A_LRFD97.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Framing type
2 = Tubular joint punching load method
3 = Consider deflection
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total deflection limit, L/Value
8 = Total camber limit, L/Value
9 = Pattern live load factor
10 = Demand/capacity ratio limit
11 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Tubular joint punching load method
1 = Punching Shear
2 = Nominal Load

3 = Consider deflection
0 = No
Any other value = Yes

4 = DL deflection limit, L/Value
Value > 0

5 = SDL + LL deflection limit, L/Value
Value > 0

6 = LL deflection limit, L/Value
Value > 0

7 = Total deflection limit, L/Value
Value > 0

8 = Total camber limit, L/Value
Value > 0

9 = Pattern live load factor
Value >= 0

10 = Demand/capacity ratio limit
Value > 0

11 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.API_RP2A_LRFD97.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class API_RP2A_WSD2000:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 33, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral TorsionalBuckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Cm Major
22 = Moment coefficient, Cm Minor
23 = Bending coefficient, Cb
24 = Pressure equalized
25 = External pressure
26 = Yield stress, Fy
27 = Compressive stress, Fa
28 = Tensile stress, Ft
29 = Major bending stress, Fb3
30 = Minor bending stress, Fb2
31 = Major shear stress, Fv2
32 = Minor shear stress, Fv3
33 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

24 = Pressure equalized
0 = Program Determined
1 = No
2 = Yes

25 = External pressure
Any value OK; Positive generates hoop compression and negative generates hoop tension.. [F/L2]

26 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

27 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

28 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

29 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

30 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

31 = Major shear stress, Fv2
Value >= 0; 0 means use program determined value. [F/L2]

32 = Minor shear stress, Fv3
Value >= 0; 0 means use program determined value. [F/L2]

33 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.API_RP2A_WSD2000.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 12, inclusive, indicating the preference item considered.
1 = Framing type
2 = Tubular joint punching load method
3 = Lateral factor, L/Value
4 = Consider deflection
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total deflection limit, L/Value
9 = Total camber limit, L/Value
10 = Pattern live load factor
11 = Demand/capacity ratio limit
12 = Multi-response case design
13 = Code supplements
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Tubular joint punching load method
1 = Punching Shear
2 = Nominal Load

3 = Lateral Factor
Value > 0

4 = Consider deflection
0 = No
Any other value = Yes

5 = DL deflection limit, L/Value
Value > 0

6 = SDL + LL deflection limit, L/Value
Value > 0

7 = LL deflection limit, L/Value
Value > 0

8 = Total deflection limit, L/Value
Value > 0

9 = Total camber limit, L/Value
Value > 0

10 = Pattern live load factor
Value >= 0

11 = Demand/capacity ratio limit
Value > 0

12 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

13 = Code supplements
1 = None
2 = Supplements 2 and 3
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.API_RP2A_WSD2000.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 33, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Cm Major
22 = Moment coefficient, Cm Minor
23 = Bending coefficient, Cb
24 = Pressure equalized
25 = External pressure
26 = Yield stress, Fy
27 = Compressive stress, Fa
28 = Tensile stress, Ft
29 = Major bending stress, Fb3
30 = Minor bending stress, Fb2
31 = Major shear stress, Fv2
32 = Minor shear stress, Fv3
33 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

24 = Pressure equalized
0 = Program Determined
1 = No
2 = Yes

25 = External pressure
Any value OK; Positive generates hoop compression and negative generates hoop tension. [F/L2]

26 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

27 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

28 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

29 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

30 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

31 = Major shear stress, Fv2
Value >= 0; 0 means use program determined value. [F/L2]

32 = Minor shear stress, Fv3
Value >= 0; 0 means use program determined value. [F/L2]

33 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.API_RP2A_WSD2000.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

class API_RP2A_WSD2014:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 33, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral TorsionalBuckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Cm Major
22 = Moment coefficient, Cm Minor
23 = Bending coefficient, Cb
24 = Pressure equalized
25 = External pressure
26 = Yield stress, Fy
27 = Compressive stress, Fa
28 = Tensile stress, Ft
29 = Major bending stress, Fb3
30 = Minor bending stress, Fb2
31 = Major shear stress, Fv2
32 = Minor shear stress, Fv3
33 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

24 = Pressure equalized
0 = Program Determined
1 = No
2 = Yes

25 = External pressure
Any value OK; Positive generates hoop compression and negative generates hoop tension.. [F/L2]

26 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

27 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

28 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

29 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

30 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

31 = Major shear stress, Fv2
Value >= 0; 0 means use program determined value. [F/L2]

32 = Minor shear stress, Fv3
Value >= 0; 0 means use program determined value. [F/L2]

33 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.API_RP2A_WSD2014.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Framing type
2 = Lateral factor, L/Value
3 = Consider deflection
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total deflection limit, L/Value
8 = Total camber limit, L/Value
9 = Pattern live load factor
10 = Demand/capacity ratio limit
11 = Multi-response case design

Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Lateral Factor
Value > 0

3 = Consider deflection
0 = No
Any other value = Yes

4 = DL deflection limit, L/Value
Value > 0

5 = SDL + LL deflection limit, L/Value
Value > 0

6 = LL deflection limit, L/Value
Value > 0

7 = Total deflection limit, L/Value
Value > 0

8 = Total camber limit, L/Value
Value > 0

9 = Pattern live load factor
Value >= 0

10 = Demand/capacity ratio limit
Value > 0

11 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.API_RP2A_WSD2014.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 33, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Cm Major
22 = Moment coefficient, Cm Minor
23 = Bending coefficient, Cb
24 = Pressure equalized
25 = External pressure
26 = Yield stress, Fy
27 = Compressive stress, Fa
28 = Tensile stress, Ft
29 = Major bending stress, Fb3
30 = Minor bending stress, Fb2
31 = Major shear stress, Fv2
32 = Minor shear stress, Fv3
33 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

24 = Pressure equalized
0 = Program Determined
1 = No
2 = Yes

25 = External pressure
Any value OK; Positive generates hoop compression and negative generates hoop tension. [F/L2]

26 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

27 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

28 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

29 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

30 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

31 = Major shear stress, Fv2
Value >= 0; 0 means use program determined value. [F/L2]

32 = Minor shear stress, Fv3
Value >= 0; 0 means use program determined value. [F/L2]

33 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.API_RP2A_WSD2014.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

class ASCE_10_97:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 31, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Cm Major
22 = Moment coefficient, Cm Minor
23 = Bending coefficient, Cb
24 = Yield stress, Fy
25 = Compressive capacity, Pac
26 = Tensile capacity, Pat
27 = Major bending capacity, Ma3
28 = Minor bending capacity, Ma2
29 = Major shear stress, Fv2
30 = Minor shear stress, Fv3
31 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Brace Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

24 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

25 = Compressive capacity, Pac
Value >= 0; 0 means use program determined value. [F]

26 = Tensile capacity, Pat
Value >= 0; 0 means use program determined value. [F]

27 = Major bending capacity, Ma3
Value >= 0; 0 means use program determined value. [FL]

28 = Minor bending capacity, Ma2
Value >= 0; 0 means use program determined value. [FL]

29 = Major shear stress, Fv2
Value >= 0; 0 means use program determined value. [F/L2]

30 = Minor shear stress, Fv3
Value >= 0; 0 means use program determined value. [F/L2]

31 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.ASCE_10_97.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Framing type
2 = Consider deflection
3 = DL deflection limit, L/Value
4 = SDL + LL deflection limit, L/Value
5 = LL deflection limit, L/Value
6 = Total deflection limit, L/Value
7 = Total camber limit, L/Value
8 = Pattern live load factor
9 = Demand/capacity ratio limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = No
Any other value = Yes

3 = DL deflection limit, L/Value
Value > 0

4 = SDL + LL deflection limit, L/Value
Value > 0

5 = LL deflection limit, L/Value
Value > 0

6 = Total deflection limit, L/Value
Value > 0

7 = Total camber limit, L/Value
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Demand/capacity ratio limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.ASCE_10_97.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 31, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Cm Major
22 = Moment coefficient, Cm Minor
23 = Bending coefficient, Cb
24 = Yield stress, Fy
25 = Compressive capacity, Pac
26 = Tensile capacity, Pat
27 = Major bending capacity, Ma3
28 = Minor bending capacity, Ma2
29 = Major shear stress, Fv2
30 = Minor shear stress, Fv3
31 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Brace Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

24 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

25 = Compressive capacity, Pac
Value >= 0; 0 means use program determined value. [F]

26 = Tensile capacity, Pat
Value >= 0; 0 means use program determined value. [F]

27 = Major bending capacity, Ma3
Value >= 0; 0 means use program determined value. [FL]

28 = Minor bending capacity, Ma2
Value >= 0; 0 means use program determined value. [FL]

29 = Major shear stress, Fv2
Value >= 0; 0 means use program determined value. [F/L2]

30 = Minor shear stress, Fv3
Value >= 0; 0 means use program determined value. [F/L2]

31 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.ASCE_10_97.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Framing type
2 = Consider deflection
3 = DL deflection limit, L/Value
4 = SDL + LL deflection limit, L/Value
5 = LL deflection limit, L/Value
6 = Total deflection limit, L/Value
7 = Total camber limit, L/Value
8 = Pattern live load factor
9 = Demand/capacity ratio limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = No
Any other value = Yes

3 = DL deflection limit, L/Value
Value > 0

4 = SDL + LL deflection limit, L/Value
Value > 0

5 = LL deflection limit, L/Value
Value > 0

6 = Total deflection limit, L/Value
Value > 0

7 = Total camber limit, L/Value
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Demand/capacity ratio limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.ASCE_10_97.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Australian_AS4100_1998:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.

Item: This is an integer between 1 and 46, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Steel type
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor
20 = Unbraced length ratio, Lateral Torsional Buckling
21 = Effective length factor, Ke Major Braced
22 = Effective length factor, Ke Minor Braced
23 = Effective length factor, Ke Major Sway
24 = Effective length factor, Ke Minor Sway
25 = Twist restraint factor for LTB (kt)
26 = lateral rotation restraint factor (kr)
27 = Load height factor for LTB (kl)
28 = Moment coefficient, Cm Major
29 = Moment coefficient, Cm Minor
30 = Moment modification factor, Alpha_m
31 = Slender reduction factor, Alpha_s
32 = Nonsway moment factor, Db Major
33 = Nonsway moment factor, Db Minor
34 = Sway moment factor, Ds Major
35 = Sway moment factor, Ds Minor
36 = Form factor, Kf
37 = Axial capacity correction factor, Kt
38 = Yield stress, Fy
39 = Compressive capacity, Nc
40 = Tensile capacity, Nt
41 = Major bending capacity, Ms33
42 = Minor bending capacity, Ms22
43 = Major bending capacity, Mb33
44 = Major shear capacity, Vu2
45 = Minor shear capacity, Vu3
46 = Demand/capacity ratio limit

Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = Moment frame
2 = Braced frame

2 = Steel type
1 = Hot rolled
2 = Hot finished
3 = Cold form
4 = Stress relieved
5 = Lightly welded
6 = Heavily welded

3 = Consider deflection
0 = No
Any other value = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]}

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L}

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

20 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

21 = Effective length factor, Ke Major Braced
Value >= 0; 0 means use program determined value.

22 = Effective length factor, Ke Minor Braced
Value >= 0; 0 means use program determined value.

23 = Effective length factor, Ke Major Sway
Value >= 0; 0 means use program determined value.

24 = Effective length factor, Ke Minor Sway
Value >= 0; 0 means use program determined value.

25 = Twist restraint factor for LTB (kt)
Value >= 0; 0 means use program determined value.

26 = Lateral rotation restraint factor (kr)
Value >= 0; 0 means use program determined value.

27 = Load height factor for LTB (kl)
Value >= 0; 0 means use program determined value.

28 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

29 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

30 = Moment modification factor, Alpha_m
Value >= 0; 0 means use program determined value.

31 = Slender reduction factor, Alpha_s
Value >= 0; 0 means use program determined value.

32 = Nonsway moment factor, Db Major
Value >= 0; 0 means use program determined value.

33 = Nonsway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

34 = Sway moment factor, Bs Major
Value >= 0; 0 means use program determined value.

35 = Sway moment factor, Bs Minor
Value >= 0; 0 means use program determined value.

36 = Form factor, Kf
Value >= 0; 0 means use program determined value.

37 = Axial capacity correction factor, Kt
Value >= 0; 0 means use program determined value.

38 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

39 = Compressive capacity, Nc
Value >= 0; 0 means use program determined value. [F]

40 = Tensile capacity, Nt
Value >= 0; 0 means use program determined value. [F]

41 = Major bending capacity, Ms33
Value >= 0; 0 means use program determined value. [FL]

42 = Minor bending capacity, Ms22
Value >= 0; 0 means use program determined value. [FL]

43 = Minor bending capacity, Mb33
Value >= 0; 0 means use program determined value. [FL]

44 = Major shear capacity, Vu2
Value >= 0; 0 means use program determined value. [F]

45 = Minor shear capacity, Vu3
Value >= 0; 0 means use program determined value. [F]

46 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.

ProgDet: If this item is True then the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Australian_AS4100_1998.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved, otherwise it returns a nonzero value.

Item: This is an integer between 1 and 17, inclusive, indicating the preference item considered.
1 = Multi-response case design
2 = Framing type
3 = Structural analysis method
4 = Steel type
5 = Capacity factor, Phi bending
6 = Capacity factor, Phi compression
7 = Capacity factor, Phi tension yielding
8 = Capacity factor, Phi tension fracture
9 = Capacity factor, Phi shear
10 = Consider deflection
11 = DL deflection limit, L/Value
12 = SDL + LL deflection limit, L/Value
13 = LL deflection limit, L/Value
14 = Total load deflection limit, L/Value
15 = Total camber limit, L/Value
16 = Pattern live load factor
17 = Demand/capacity ratio limit

Value: The value of the considered preference item.
1 = Multi-response case design
1 = Envelopes
2 = Step-by step
3 = Last step
4 = Envelopes - All
5 = Step-by step - All

2 = Framing type
1 = Moment frame
2 = Braced frame

3 = Structural analysis method
1 = General 2nd Order
2 = Amplified 1st Order

4 = Steel type
1 = Hot rolled
2 = Hot finished
3 = Cold form
4 = Stress relieved
5 = Lightly welded
6 = Heavily welded

5 = Capacity factor, Phi bending
Value > 0

6 = Capacity factor, Phi compression
Value > 0

7 = Capacity factor, Phi tension yielding
Value > 0

8 = Capacity factor, Phi tension fracture
Value > 0

9 = Capacity factor, Phi shear
Value > 0

10 = Consider deflection
0 = No
Any other value = Yes

11 = DL deflection limit, L/Value
Value > 0

12 = SDL + LL deflection limit, L/Value
Value > 0

13 = LL deflection limit, L/Value
Value > 0

14 = Total load deflection limit, L/Value
Value > 0

15 = Total camber limit, L/Value
Value > 0

16 = Pattern live load factor
Value >= 0

17 = Demand/capacity ratio limit
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Australian_AS4100_1998.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 46, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Steel type
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor
20 = Unbraced length ratio, Lateral Torsional Buckling
21 = Effective length factor, Ke Major Braced
22 = Effective length factor, Ke Minor Braced
23 = Effective length factor, Ke Major Sway
24 = Effective length factor, Ke Minor Sway
25 = Twist restraint factor for LTB (kt)
26 = lateral rotation restraint factor (kr)
27 = Load height factor for LTB (kl)
28 = Moment coefficient, Cm Major
29 = Moment coefficient, Cm Minor
30 = Moment modification factor, Alpha_m
31 = Slender reduction factor, Alpha_s
32 = Nonsway moment factor, Db Major
33 = Nonsway moment factor, Db Minor
34 = Sway moment factor, Ds Major
35 = Sway moment factor, Ds Minor
36 = Form factor, Kf
37 = Axial capacity correction factor, Kt
38 = Yield stress, Fy
39 = Compressive capacity, Nc
40 = Tensile capacity, Nt
41 = Major bending capacity, Ms33
42 = Minor bending capacity, Ms22
43 = Major bending capacity, Mb33
44 = Major shear capacity, Vu2
45 = Minor shear capacity, Vu3
46 = Demand/capacity ratio limit

Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = Moment frame
2 = Braced frame

2 = Steel type
1 = Hot rolled
2 = Hot finished
3 = Cold form
4 = Stress relieved
5 = Lightly welded
6 = Heavily welded

3 = Consider deflection
0 = No
Any other value = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]}

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L}

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

20 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

21 = Effective length factor, Ke Major Braced
Value >= 0; 0 means use program determined value.

22 = Effective length factor, Ke Minor Braced
Value >= 0; 0 means use program determined value.

23 = Effective length factor, Ke Major Sway
Value >= 0; 0 means use program determined value.

24 = Effective length factor, Ke Minor Sway
Value >= 0; 0 means use program determined value.

25 = Twist restraint factor for LTB (kt)
Value >= 0; 0 means use program determined value.

26 = Lateral rotation restraint factor (kr)
Value >= 0; 0 means use program determined value.

27 = Load height factor for LTB (kl)
Value >= 0; 0 means use program determined value.

28 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

29 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

30 = Moment modification factor, Alpha_m
Value >= 0; 0 means use program determined value.

31 = Slender reduction factor, Alpha_s
Value >= 0; 0 means use program determined value.

32 = Nonsway moment factor, Db Major
Value >= 0; 0 means use program determined value.

33 = Nonsway moment factor, Db Minor
Value >= 0; 0 means use program determined value.

34 = Sway moment factor, Bs Major
Value >= 0; 0 means use program determined value.

35 = Sway moment factor, Bs Minor
Value >= 0; 0 means use program determined value.

36 = Form factor, Kf
Value >= 0; 0 means use program determined value.

37 = Axial capacity correction factor, Kt
Value >= 0; 0 means use program determined value.

38 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

39 = Compressive capacity, Nc
Value >= 0; 0 means use program determined value. [F]

40 = Tensile capacity, Nt
Value >= 0; 0 means use program determined value. [F]

41 = Major bending capacity, Ms33
Value >= 0; 0 means use program determined value. [FL]

42 = Minor bending capacity, Ms22
Value >= 0; 0 means use program determined value. [FL]

43 = Minor bending capacity, Mb33
Value >= 0; 0 means use program determined value. [FL]

44 = Major shear capacity, Vu2
Value >= 0; 0 means use program determined value. [F]

45 = Minor shear capacity, Vu3
Value >= 0; 0 means use program determined value. [F]

46 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.

ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Australian_AS4100_1998.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set, otherwise it returns a nonzero value.

Item: This is an integer between 1 and 17, inclusive, indicating the preference item considered.
1 = Multi-response case design
2 = Framing type
3 = Structural analysis method
4 = Steel type
5 = Capacity factor, Phi bending
6 = Capacity factor, Phi compression
7 = Capacity factor, Phi tension yielding
8 = Capacity factor, Phi tension fracture
9 = Capacity factor, Phi shear
10 = Consider deflection
11 = DL deflection limit, L/Value
12 = SDL + LL deflection limit, L/Value
13 = LL deflection limit, L/Value
14 = Total load deflection limit, L/Value
15 = Total camber limit, L/Value
16 = Pattern live load factor
17 = Demand/capacity ratio limit

Value: The value of the considered preference item.
1 = Multi-response case design
1 = Envelopes
2 = Step-by step
3 = Last step
4 = Envelopes - All
5 = Step-by step - All

2 = Framing type
1 = Moment frame
2 = Braced frame

3 = Structural analysis method
1 = General 2nd Order
2 = Amplified 1st Order

4 = Steel type
1 = Hot rolled
2 = Hot finished
3 = Cold form
4 = Stress relieved
5 = Lightly welded
6 = Heavily welded

5 = Capacity factor, Phi bending
Value > 0

6 = Capacity factor, Phi compression
Value > 0

7 = Capacity factor, Phi tension yielding
Value > 0

8 = Capacity factor, Phi tension fracture
Value > 0

9 = Capacity factor, Phi shear
Value > 0

10 = Consider deflection
0 = No
Any other value = Yes

11 = DL deflection limit, L/Value
Value > 0

12 = SDL + LL deflection limit, L/Value
Value > 0

13 = LL deflection limit, L/Value
Value > 0

14 = Total load deflection limit, L/Value
Value > 0

15 = Total camber limit, L/Value
Value > 0

16 = Pattern live load factor
Value >= 0

17 = Demand/capacity ratio limit
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Australian_AS4100_1998.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class BS5950_2000:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 32, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Uniform moment factor, m Major
22 = Uniform moment factor, m Minor
23 = Eqv. uniform moment factor, mLT
24 = Yield stress, Fy
25 = Compressive capacity, Pc
26 = Tensile capacity, Pt
27 = Major bending capacity, Mc3
28 = Minor bending capacity, Mc2
29 = Buckling resistance moment, Mb
30 = Major shear capacity, Pv2
31 = Minor shear capacity, Pv3
32 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Uniform moment factor, m Major
Value >= 0; 0 means use program determined value.

22 = Uniform moment factor, m Minor
Value >= 0; 0 means use program determined value.

23 = Eqv. Uniform moment factor, mLT
Value >= 0; 0 means use program determined value.

24 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

25 = Compressive capacity, Pc
Value >= 0; 0 means use program determined value. [F]

26 = Tensile capacity, Pt
Value >= 0; 0 means use program determined value. [F]

27 = Major bending capacity, Mc3
Value >= 0; 0 means use program determined value. [FL]

28 = Minor bending capacity, Mc2
Value >= 0; 0 means use program determined value. [FL]

29 = Buckling resistance moment, Mb
Value >= 0; 0 means use program determined value. [FL]

30 = Major shear capacity, Pv2
Value >= 0; 0 means use program determined value. [F]

31 = Minor shear capacity, Pv3
Value >= 0; 0 means use program determined value. [F]

32 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.BS5950_2000.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Framing type
2 = Consider deflection
3 = DL deflection limit, L/Value
4 = SDL + LL deflection limit, L/Value
5 = LL deflection limit, L/Value
6 = Total deflection limit, L/Value
7 = Total camber limit, L/Value
8 = Pattern live load factor
9 = Demand/capacity ratio limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = No
Any other value = Yes

3 = DL deflection limit, L/Value
Value > 0

4 = SDL + LL deflection limit, L/Value
Value > 0

5 = LL deflection limit, L/Value
Value > 0

6 = Total deflection limit, L/Value
Value > 0

7 = Total camber limit, L/Value
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Demand/capacity ratio limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.BS5950_2000.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 32, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Uniform moment factor, m Major
22 = Uniform moment factor, m Minor
23 = Eqv. uniform moment factor, mLT
24 = Yield stress, Fy
25 = Compressive capacity, Pc
26 = Tensile capacity, Pt
27 = Major bending capacity, Mc3
28 = Minor bending capacity, Mc2
29 = Buckling resistance moment, Mb
30 = Major shear capacity, Pv2
31 = Minor shear capacity, Pv3
32 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Uniform moment factor, m Major
Value >= 0; 0 means use program determined value.

22 = Uniform moment factor, m Minor
Value >= 0; 0 means use program determined value.

23 = Eqv. Uniform moment factor, mLT
Value >= 0; 0 means use program determined value.

24 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

25 = Compressive capacity, Pc
Value >= 0; 0 means use program determined value. [F]

26 = Tensile capacity, Pt
Value >= 0; 0 means use program determined value. [F]

27 = Major bending capacity, Mc3
Value >= 0; 0 means use program determined value. [FL]

28 = Minor bending capacity, Mc2
Value >= 0; 0 means use program determined value. [FL]

29 = Buckling resistance moment, Mb
Value >= 0; 0 means use program determined value. [FL]

30 = Major shear capacity, Pv2
Value >= 0; 0 means use program determined value. [F]

31 = Minor shear capacity, Pv3
Value >= 0; 0 means use program determined value. [F]

32 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.BS5950_2000.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Framing type
2 = Consider deflection
3 = DL deflection limit, L/Value
4 = SDL + LL deflection limit, L/Value
5 = LL deflection limit, L/Value
6 = Total deflection limit, L/Value
7 = Total camber limit, L/Value
8 = Pattern live load factor
9 = Demand/capacity ratio limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = No
Any other value = Yes

3 = DL deflection limit, L/Value
Value > 0

4 = SDL + LL deflection limit, L/Value
Value > 0

5 = LL deflection limit, L/Value
Value > 0

6 = Total deflection limit, L/Value
Value > 0

7 = Total camber limit, L/Value
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Demand/capacity ratio limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.BS5950_2000.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class BS5950_90:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 32, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Uniform moment factor, m Major
22 = Uniform moment factor, m Minor
23 = Slenderness correction factor, n
24 = Yield stress, Fy
25 = Compressive capacity, Pc
26 = Tensile capacity, Pt
27 = Major bending capacity, Mc3
28 = Minor bending capacity, Mc2
29 = Buckling resistance moment, Mb
30 = Major shear capacity, Pv2
31 = Minor shear capacity, Pv3
32 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Uniform moment factor, m Major
Value >= 0; 0 means use program determined value.

22 = Uniform moment factor, m Minor
Value >= 0; 0 means use program determined value.

23 = Slenderness correction factor, n
Value >= 0; 0 means use program determined value.

24 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

25 = Compressive capacity, Pc
Value >= 0; 0 means use program determined value. [F]

26 = Tensile capacity, Pt
Value >= 0; 0 means use program determined value. [F]

27 = Major bending capacity, Mc3
Value >= 0; 0 means use program determined value. [FL]

28 = Minor bending capacity, Mc2
Value >= 0; 0 means use program determined value. [FL]

29 = Buckling resistance moment, Mb
Value >= 0; 0 means use program determined value. [FL]

30 = Major shear capacity, Pv2
Value >= 0; 0 means use program determined value. [F]

31 = Minor shear capacity, Pv3
Value >= 0; 0 means use program determined value. [F]

32 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.BS5950_90.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Framing type
2 = Consider deflection
3 = DL deflection limit, L/Value
4 = SDL + LL deflection limit, L/Value
5 = LL deflection limit, L/Value
6 = Total deflection limit, L/Value
7 = Total camber limit, L/Value
8 = Pattern live load factor
9 = Demand/capacity ratio limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = No
Any other value = Yes

3 = DL deflection limit, L/Value
Value > 0

4 = SDL + LL deflection limit, L/Value
Value > 0

5 = LL deflection limit, L/Value
Value > 0

6 = Total deflection limit, L/Value
Value > 0

7 = Total camber limit, L/Value
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Demand/capacity ratio limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.BS5950_90.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 32, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Uniform moment factor, m Major
22 = Uniform moment factor, m Minor
23 = Slenderness correction factor, n
24 = Yield stress, Fy
25 = Compressive capacity, Pc
26 = Tensile capacity, Pt
27 = Major bending capacity, Mc3
28 = Minor bending capacity, Mc2
29 = Buckling resistance moment, Mb
30 = Major shear capacity, Pv2
31 = Minor shear capacity, Pv3
32 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Uniform moment factor, m Major
Value >= 0; 0 means use program determined value.

22 = Uniform moment factor, m Minor
Value >= 0; 0 means use program determined value.

23 = Slenderness correction factor, n
Value >= 0; 0 means use program determined value.

24 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

25 = Compressive capacity, Pc
Value >= 0; 0 means use program determined value. [F]

26 = Tensile capacity, Pt
Value >= 0; 0 means use program determined value. [F]

27 = Major bending capacity, Mc3
Value >= 0; 0 means use program determined value. [FL]

28 = Minor bending capacity, Mc2
Value >= 0; 0 means use program determined value. [FL]

29 = Buckling resistance moment, Mb
Value >= 0; 0 means use program determined value. [FL]

30 = Major shear capacity, Pv2
Value >= 0; 0 means use program determined value. [F]

31 = Minor shear capacity, Pv3
Value >= 0; 0 means use program determined value. [F]

32 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.BS5950_90.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Framing type
2 = Consider deflection
3 = DL deflection limit, L/Value
4 = SDL + LL deflection limit, L/Value
5 = LL deflection limit, L/Value
6 = Total deflection limit, L/Value
7 = Total camber limit, L/Value
8 = Pattern live load factor
9 = Demand/capacity ratio limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = No
Any other value = Yes

3 = DL deflection limit, L/Value
Value > 0

4 = SDL + LL deflection limit, L/Value
Value > 0

5 = LL deflection limit, L/Value
Value > 0

6 = Total deflection limit, L/Value
Value > 0

7 = Total camber limit, L/Value
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Demand/capacity ratio limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.BS5950_90.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Canadian_S16_01:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 39, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor LTB
19 = Unbraced length ratio, Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Effective length factor, K LTB
23 = Moment coefficient, Omega1 Major
24 = Moment coefficient, Omega1 Minor
25 = Bending coefficient, Omega2
26 = Nonsway moment factor, U1 Major
27 = Nonsway moment factor, U1 Minor
28 = Sway moment factor, U2 Major
29 = Sway moment factor, U2 Minor
30 = Parameter for compressive resistance, n
31 = Yield stress, Fy
32 = Expected to specified Fy ratio, Ry
33 = Compressive resistance, Cr
34 = Tensile resistance, Tr
35 = Major bending resistance, Mr3
36 = Minor bending resistance, Mr2
37 = Major shear resistance, Vr2
38 = Minor shear resistance, Vr3
39 = Demand/capacity ratio limit

Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = Type LD MRF
2 = Type MD MRF
3 = Type D MRF
4 = Type LD CBF(V)
5 = Type LD CBF(TC)
6 = Type LD CBF(TO)
7 = Type LD CBF(OT)
8 = Type MD CBF(V)
9 = Type MD CBF(TC)
10 = Type MD CBF(TO)
11 = Type MD CBF(OT)
12 = EBF
13 = Cantilever Column
14 = Conventional MF
15 = Conventional BF

2 = Consider deflection
0 = No
Any other value = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]}

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L}

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Effective length factor, K LTB
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Omega1 Major
Value >= 0; 0 means use program determined value.

24 = Moment coefficient, Omega1 Minor
Value >= 0; 0 means use program determined value.

25 = Moment coefficient, Omega2
Value >= 0; 0 means use program determined value.

26 = Nonsway moment factor, U1 Major
Value >= 0; 0 means use program determined value.

27 = Nonsway moment factor, U1 Minor
Value >= 0; 0 means use program determined value.

28 = Sway moment factor, U2 Major
Value >= 0; 0 means use program determined value.

29 = Sway moment factor, U2 Minor
Value >= 0; 0 means use program determined value.

30 = Parameter for compressive resistance, n
Value >= 0; 0 means use program determined value.

31 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

32 = Expected to specified Fy ratio, Ry
Value >= 0; 0 means use program determined value. [F/L2]=

33 = Compressive resistance, Cr
Value >= 0; 0 means use program determined value. [F]

34 = Tensile resistance, Tr
Value >= 0; 0 means use program determined value. [F]

35 = Major bending resistance, Mr3
Value >= 0; 0 means use program determined value. [FL]

36 = Minor bending resistance, Mr2
Value >= 0; 0 means use program determined value. [FL]

37 = Major shear resistance, Vr2
Value >= 0; 0 means use program determined value. [F]

38 = Minor shear resistance, Vr3
Value >= 0; 0 means use program determined value. [F]

39 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.

ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Canadian_S16_01.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved, otherwise it returns a nonzero value.

Item: This is an integer between 1 and 21, inclusive, indicating the preference item considered.
1 = Multi-response case design
2 = Framing type
3 = Spectral Acceleration Ratio, Ie*Fa*Sa(0.2)
4 = Ductility related modification factor, Rd
5 = Overstrength related modification factor, Ro
6 = Capacity factor, Phi bending
7 = Capacity factor, Phi compression
8 = Capacity factor, Phi tension
9 = Capacity factor, Phi shear
10 = Slender section modification
11 = Ignore seismic code
12 = Ignore special seismic load
13 = Doubler plate is plug welded
14 = Consider deflection
15 = DL deflection limit, L/Value
16 = SDL + LL deflection limit, L/Value
17 = LL deflection limit, L/Value
18 = Total load deflection limit, L/Value
19 = Total camber limit, L/Value
20 = Pattern live load factor
21 = Demand/capacity ratio limit

Value: The value of the considered preference item.
1 = Multi-response case design
1 = Envelopes
2 = Step-by step
3 = Last step
4 = Envelopes - All
5 = Step-by step - All

2 = Framing type
1 = Type LD MRF
2 = Type MD MRF
3 = Type D MRF
4 = Type LD CBF(V)
5 = Type LD CBF(TC)
6 = Type LD CBF(TO)
7 = Type LD CBF(OT)
8 = Type MD CBF(V)
9 = Type MD CBF(TC)
10 = Type MD CBF(TO)
11 = Type MD CBF(OT)
12 = EBF
13 = Cantilever Column
14 = Conventional MF
15 = Conventional BF

3 = Spectral Acceleration Ratio, Ie*Fa*Sa(0.2)
Value > 0

4 = Ductility related modification factor, Rd
Value > 0

5 = Overstrength related modification factor, Ro
Value > 0

6 = Capacity factor, Phi bending
Value > 0

7 = Capacity factor, Phi compression
Value > 0

8 = Capacity factor, Phi tension
Value > 0

9 = Capacity factor, Phi shear
Value > 0

10 = Slender section modification
1 = Modified geometry
2 = modified Fy

11 = Ignore seismic code
0 = No
Any other value = Yes

12 = Ignore special seismic load
0 = No
Any other value = Yes

13 = Doubler plate is plug welded
0 = No
Any other value = Yes

14 = Consider deflection
0 = No
Any other value = Yes

15 = DL deflection limit, L/Value
Value > 0

16 = SDL + LL deflection limit, L/Value
Value > 0

17 = LL deflection limit, L/Value
Value > 0

18 = Total load deflection limit, L/Value
Value > 0

19 = Total camber limit, L/Value
Value > 0

20 = Pattern live load factor
Value >= 0

21 = Demand/capacity ratio limit
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Canadian_S16_01.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 39, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor LTB
19 = Unbraced length ratio, Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Effective length factor, K LTB
23 = Moment coefficient, Omega1 Major
24 = Moment coefficient, Omega1 Minor
25 = Bending coefficient, Omega2
26 = Nonsway moment factor, U1 Major
27 = Nonsway moment factor, U1 Minor
28 = Sway moment factor, U2 Major
29 = Sway moment factor, U2 Minor
30 = Parameter for compressive resistance, n
31 = Yield stress, Fy
32 = Expected to specified Fy ratio, Ry
33 = Compressive resistance, Cr
34 = Tensile resistance, Tr
35 = Major bending resistance, Mr3
36 = Minor bending resistance, Mr2
37 = Major shear resistance, Vr2
38 = Minor shear resistance, Vr3
39 = Demand/capacity ratio limit

Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = Type LD MRF
2 = Type MD MRF
3 = Type D MRF
4 = Type LD CBF(V)
5 = Type LD CBF(TC)
6 = Type LD CBF(TO)
7 = Type LD CBF(OT)
8 = Type MD CBF(V)
9 = Type MD CBF(TC)
10 = Type MD CBF(TO)
11 = Type MD CBF(OT)
12 = EBF
13 = Cantilever Column
14 = Conventional MF
15 = Conventional BF

2 = Consider deflection
0 = No
Any other value = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]}

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L}

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Effective length factor, K LTB
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Omega1 Major
Value >= 0; 0 means use program determined value.

24 = Moment coefficient, Omega1 Minor
Value >= 0; 0 means use program determined value.

25 = Moment coefficient, Omega2
Value >= 0; 0 means use program determined value.

26 = Nonsway moment factor, U1 Major
Value >= 0; 0 means use program determined value.

27 = Nonsway moment factor, U1 Minor
Value >= 0; 0 means use program determined value.

28 = Sway moment factor, U2 Major
Value >= 0; 0 means use program determined value.

29 = Sway moment factor, U2 Minor
Value >= 0; 0 means use program determined value.

30 = Parameter for compressive resistance, n
Value >= 0; 0 means use program determined value.

31 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

32 = Expected to specified Fy ratio, Ry
Value >= 0; 0 means use program determined value. [F/L2]=

33 = Compressive resistance, Cr
Value >= 0; 0 means use program determined value. [F]

34 = Tensile resistance, Tr
Value >= 0; 0 means use program determined value. [F]

35 = Major bending resistance, Mr3
Value >= 0; 0 means use program determined value. [FL]

36 = Minor bending resistance, Mr2
Value >= 0; 0 means use program determined value. [FL]

37 = Major shear resistance, Vr2
Value >= 0; 0 means use program determined value. [F]

38 = Minor shear resistance, Vr3
Value >= 0; 0 means use program determined value. [F]

39 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.

ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Canadian_S16_01.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set, otherwise it returns a nonzero value.

Item: This is an integer between 1 and 21, inclusive, indicating the preference item considered.
1 = Multi-response case design
2 = Framing type
3 = Spectral Acceleration Ratio, Ie*Fa*Sa(0.2)
4 = Ductility related modification factor, Rd
5 = Overstrength related modification factor, Ro
6 = Capacity factor, Phi bending
7 = Capacity factor, Phi compression
8 = Capacity factor, Phi tension
9 = Capacity factor, Phi shear
10 = Slender section modification
11 = Ignore seismic code
12 = Ignore special seismic load
13 = Doubler plate is plug welded
14 = Consider deflection
15 = DL deflection limit, L/Value
16 = SDL + LL deflection limit, L/Value
17 = LL deflection limit, L/Value
18 = Total load deflection limit, L/Value
19 = Total camber limit, L/Value
20 = Pattern live load factor
21 = Demand/capacity ratio limit

Value: The value of the considered preference item.
1 = Multi-response case design
1 = Envelopes
2 = Step-by step
3 = Last step
4 = Envelopes - All
5 = Step-by step - All

2 = Framing type
1 = Type LD MRF
2 = Type MD MRF
3 = Type D MRF
4 = Type LD CBF(V)
5 = Type LD CBF(TC)
6 = Type LD CBF(TO)
7 = Type LD CBF(OT)
8 = Type MD CBF(V)
9 = Type MD CBF(TC)
10 = Type MD CBF(TO)
11 = Type MD CBF(OT)
12 = EBF
13 = Cantilever Column
14 = Conventional MF
15 = Conventional BF

3 = Spectral Acceleration Ratio, Ie*Fa*Sa(0.2)
Value > 0

4 = Ductility related modification factor, Rd
Value > 0

5 = Overstrength related modification factor, Ro
Value > 0

6 = Capacity factor, Phi bending
Value > 0

7 = Capacity factor, Phi compression
Value > 0

8 = Capacity factor, Phi tension
Value > 0

9 = Capacity factor, Phi shear
Value > 0

10 = Slender section modification
1 = Modified geometry
2 = modified Fy

11 = Ignore seismic code
0 = No
Any other value = Yes

12 = Ignore special seismic load
0 = No
Any other value = Yes

13 = Doubler plate is plug welded
0 = No
Any other value = Yes

14 = Consider deflection
0 = No
Any other value = Yes

15 = DL deflection limit, L/Value
Value > 0

16 = SDL + LL deflection limit, L/Value
Value > 0

17 = LL deflection limit, L/Value
Value > 0

18 = Total load deflection limit, L/Value
Value > 0

19 = Total camber limit, L/Value
Value > 0

20 = Pattern live load factor
Value >= 0

21 = Demand/capacity ratio limit
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Canadian_S16_01.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class CISC_95:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 35, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Omega1 Major
22 = Moment coefficient, Omega1 Minor
23 = Bending coefficient, Cb
24 = Non-sway moment factor, U1 Major
25 = Non-sway moment factor, U1 Minor
26 = Sway moment factor, U2 Major
27 = Sway moment factor, U2 Minor
28 = Yield stress, Fy
29 = Compressive capacity, Cr
30 = Tensile capacity, Tr
31 = Major bending capacity, Mr3
32 = Minor bending capacity, Mr2
33 = Major shear capacity, Vr2
34 = Minor shear capacity, Vr3
35 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Omega1 Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Omega1 Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Omega2
Value >= 0; 0 means use program determined value.

24 = Nonsway moment factor, U1 Major
Value >= 0; 0 means use program determined value.

25 = Nonsway moment factor, U1 Minor
Value >= 0; 0 means use program determined value.

26 = Sway moment factor, U2 Major
Value >= 0; 0 means use program determined value.

27 = Sway moment factor, U2 Minor
Value >= 0; 0 means use program determined value.

28 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

29 = Compressive capacity, Cr
Value >= 0; 0 means use program determined value. [F]

30 = Tensile capacity, Tr
Value >= 0; 0 means use program determined value. [F]

31 = Major bending capacity, Mr3
Value >= 0; 0 means use program determined value. [FL]

32 = Minor bending capacity, Mr2
Value >= 0; 0 means use program determined value. [FL]

33 = Major shear capacity, Vr2
Value >= 0; 0 means use program determined value. [F]

34 = Minor shear capacity, Vr3
Value >= 0; 0 means use program determined value. [F]

35 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.CISC_95.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 14, inclusive, indicating the preference item considered.
1 = Framing type
2 = Phi bending
3 = Phi compression
4 = Phi tension
5 = Phi shear
6 = Consider deflection
7 = DL deflection limit, L/Value
8 = SDL + LL deflection limit, L/Value
9 = LL deflection limit, L/Value
10 = Total deflection limit, L/Value
11 = Total camber limit, L/Value
12 = Pattern live load factor
13 = Demand/capacity ratio limit
14 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Phi bending
Value > 0

3 = Phi compression
Value > 0

4 = Phi tension
Value > 0

5 = Phi shear
Value > 0

6 = Consider deflection
0 = No
Any other value = Yes

7 = DL deflection limit, L/Value
Value > 0

8 = SDL + LL deflection limit, L/Value
Value > 0

9 = LL deflection limit, L/Value
Value > 0

10 = Total load deflection limit, L/Value
Value > 0

11 = Total camber limit, L/Value
Value > 0

12 = Pattern live load factor
Value >= 0

13 = Demand/capacity ratio limit
Value > 0

14 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.CISC_95.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Item: This is an integer between 1 and 35, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, Omega1 Major
22 = Moment coefficient, Omega1 Minor
23 = Bending coefficient, Cb
24 = Non-sway moment factor, U1 Major
25 = Non-sway moment factor, U1 Minor
26 = Sway moment factor, U2 Major
27 = Sway moment factor, U2 Minor
28 = Yield stress, Fy
29 = Compressive capacity, Cr
30 = Tensile capacity, Tr
31 = Major bending capacity, Mr3
32 = Minor bending capacity, Mr2
33 = Major shear capacity, Vr2
34 = Minor shear capacity, Vr3
35 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, Omega1 Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Omega1 Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, Omega2
Value >= 0; 0 means use program determined value.

24 = Non-sway moment factor, U1 Major
Value >= 0; 0 means use program determined value.

25 = Non-sway moment factor, U1 Minor
Value >= 0; 0 means use program determined value.

26 = Sway moment factor, U2 Major
Value >= 0; 0 means use program determined value.

27 = Sway moment factor, U2 Minor
Value >= 0; 0 means use program determined value.

28 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

29 = Compressive capacity, Cr
Value >= 0; 0 means use program determined value. [F]

30 = Tensile capacity, Tr
Value >= 0; 0 means use program determined value. [F]

31 = Major bending capacity, Mr3
Value >= 0; 0 means use program determined value. [FL]

32 = Minor bending capacity, Mr2
Value >= 0; 0 means use program determined value. [FL]

33 = Major shear capacity, Vr2
Value >= 0; 0 means use program determined value. [F]

34 = Minor shear capacity, Vr3
Value >= 0; 0 means use program determined value. [F]

35 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.CISC_95.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 14, inclusive, indicating the preference item considered.
1 = Framing type
2 = Phi bending
3 = Phi compression
4 = Phi tension
5 = Phi shear
6 = Consider deflection
7 = DL deflection limit, L/Value
8 = SDL + LL deflection limit, L/Value
9 = LL deflection limit, L/Value
10 = Total deflection limit, L/Value
11 = Total camber limit, L/Value
12 = Pattern live load factor
13 = Demand/capacity ratio limit
14 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = Phi bending
Value > 0

3 = Phi compression
Value > 0

4 = Phi tension
Value > 0

5 = Phi shear
Value > 0

6 = Consider deflection
0 = No
Any other value = Yes

7 = DL deflection limit, L/Value
Value > 0

8 = SDL + LL deflection limit, L/Value
Value > 0

9 = LL deflection limit, L/Value
Value > 0

10 = Total load deflection limit, L/Value
Value > 0

11 = Total camber limit, L/Value
Value > 0

12 = Pattern live load factor
Value >= 0

13 = Demand/capacity ratio limit
Value > 0

14 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.CISC_95.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Canadian_S16_09:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 39, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor LTB
19 = Unbraced length ratio, Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Effective length factor, K LTB
23 = Moment coefficient, Omega1 Major
24 = Moment coefficient, Omega1 Minor
25 = Bending coefficient, Omega2
26 = Nonsway moment factor, U1 Major
27 = Nonsway moment factor, U1 Minor
28 = Sway moment factor, U2 Major
29 = Sway moment factor, U2 Minor
30 = Parameter for compressive resistance, n
31 = Yield stress, Fy
32 = Expected to specified Fy ratio, Ry
33 = Compressive resistance, Cr
34 = Tensile resistance, Tr
35 = Major bending resistance, Mr3
36 = Minor bending resistance, Mr2
37 = Major shear resistance, Vr2
38 = Minor shear resistance, Vr3
39 = Demand/capacity ratio limit

Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = Type LD MRF
2 = Type MD MRF
3 = Type D MRF
4 = Type LD CBF(V)
5 = Type LD CBF(TC)
6 = Type LD CBF(TO)
7 = Type LD CBF(OT)
8 = Type MD CBF(V)
9 = Type MD CBF(TC)
10 = Type MD CBF(TO)
11 = Type MD CBF(OT)
12 = EBF
13 = Cantilever Column
14 = Conventional MF
15 = Conventional BF

2 = Consider deflection
0 = No
Any other value = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]}

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L}

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Effective length factor, K LTB
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Omega1 Major
Value >= 0; 0 means use program determined value.

24 = Moment coefficient, Omega1 Minor
Value >= 0; 0 means use program determined value.

25 = Moment coefficient, Omega2
Value >= 0; 0 means use program determined value.

26 = Nonsway moment factor, U1 Major
Value >= 0; 0 means use program determined value.

27 = Nonsway moment factor, U1 Minor
Value >= 0; 0 means use program determined value.

28 = Sway moment factor, U2 Major
Value >= 0; 0 means use program determined value.

29 = Sway moment factor, U2 Minor
Value >= 0; 0 means use program determined value.

30 = Parameter for compressive resistance, n
Value >= 0; 0 means use program determined value.

31 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

32 = Expected to specified Fy ratio, Ry
Value >= 0; 0 means use program determined value. [F/L2]=

33 = Compressive resistance, Cr
Value >= 0; 0 means use program determined value. [F]

34 = Tensile resistance, Tr
Value >= 0; 0 means use program determined value. [F]

35 = Major bending resistance, Mr3
Value >= 0; 0 means use program determined value. [FL]

36 = Minor bending resistance, Mr2
Value >= 0; 0 means use program determined value. [FL]

37 = Major shear resistance, Vr2
Value >= 0; 0 means use program determined value. [F]

38 = Minor shear resistance, Vr3
Value >= 0; 0 means use program determined value. [F]

39 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.

ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Canadian_S16_09.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved, otherwise it returns a nonzero value.

Item: This is an integer between 1 and 21, inclusive, indicating the preference item considered.
1 = Multi-response case design
2 = Framing type
3 = Spectral Acceleration Ratio, Ie*Fa*Sa(0.2)
4 = Ductility related modification factor, Rd
5 = Overstrength related modification factor, Ro
6 = Capacity factor, Phi bending
7 = Capacity factor, Phi compression
8 = Capacity factor, Phi tension
9 = Capacity factor, Phi shear
10 = Slender section modification
11 = Ignore seismic code
12 = Ignore special seismic load
13 = Doubler plate is plug welded
14 = Consider deflection
15 = DL deflection limit, L/Value
16 = SDL + LL deflection limit, L/Value
17 = LL deflection limit, L/Value
18 = Total load deflection limit, L/Value
19 = Total camber limit, L/Value
20 = Pattern live load factor
21 = Demand/capacity ratio limit

Value: The value of the considered preference item.
1 = Multi-response case design
1 = Envelopes
2 = Step-by step
3 = Last step
4 = Envelopes - All
5 = Step-by step - All

2 = Framing type
1 = Type LD MRF
2 = Type MD MRF
3 = Type D MRF
4 = Type LD CBF(V)
5 = Type LD CBF(TC)
6 = Type LD CBF(TO)
7 = Type LD CBF(OT)
8 = Type MD CBF(V)
9 = Type MD CBF(TC)
10 = Type MD CBF(TO)
11 = Type MD CBF(OT)
12 = EBF
13 = Cantilever Column
14 = Conventional MF
15 = Conventional BF

3 = Spectral Acceleration Ratio, Ie*Fa*Sa(0.2)
Value > 0

4 = Ductility related modification factor, Rd
Value > 0

5 = Overstrength related modification factor, Ro
Value > 0

6 = Capacity factor, Phi bending
Value > 0

7 = Capacity factor, Phi compression
Value > 0

8 = Capacity factor, Phi tension
Value > 0

9 = Capacity factor, Phi shear
Value > 0

10 = Slender section modification
1 = Modified geometry
2 = modified Fy

11 = Ignore seismic code
0 = No
Any other value = Yes

12 = Ignore special seismic load
0 = No
Any other value = Yes

13 = Doubler plate is plug welded
0 = No
Any other value = Yes

14 = Consider deflection
0 = No
Any other value = Yes

15 = DL deflection limit, L/Value
Value > 0

16 = SDL + LL deflection limit, L/Value
Value > 0

17 = LL deflection limit, L/Value
Value > 0

18 = Total load deflection limit, L/Value
Value > 0

19 = Total camber limit, L/Value
Value > 0

20 = Pattern live load factor
Value >= 0

21 = Demand/capacity ratio limit
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Canadian_S16_09.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 39, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor LTB
19 = Unbraced length ratio, Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Effective length factor, K LTB
23 = Moment coefficient, Omega1 Major
24 = Moment coefficient, Omega1 Minor
25 = Bending coefficient, Omega2
26 = Nonsway moment factor, U1 Major
27 = Nonsway moment factor, U1 Minor
28 = Sway moment factor, U2 Major
29 = Sway moment factor, U2 Minor
30 = Parameter for compressive resistance, n
31 = Yield stress, Fy
32 = Expected to specified Fy ratio, Ry
33 = Compressive resistance, Cr
34 = Tensile resistance, Tr
35 = Major bending resistance, Mr3
36 = Minor bending resistance, Mr2
37 = Major shear resistance, Vr2
38 = Minor shear resistance, Vr3
39 = Demand/capacity ratio limit

Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = Type LD MRF
2 = Type MD MRF
3 = Type D MRF
4 = Type LD CBF(V)
5 = Type LD CBF(TC)
6 = Type LD CBF(TO)
7 = Type LD CBF(OT)
8 = Type MD CBF(V)
9 = Type MD CBF(TC)
10 = Type MD CBF(TO)
11 = Type MD CBF(OT)
12 = EBF
13 = Cantilever Column
14 = Conventional MF
15 = Conventional BF

2 = Consider deflection
0 = No
Any other value = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]}

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L}

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Effective length factor, K LTB
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Omega1 Major
Value >= 0; 0 means use program determined value.

24 = Moment coefficient, Omega1 Minor
Value >= 0; 0 means use program determined value.

25 = Moment coefficient, Omega2
Value >= 0; 0 means use program determined value.

26 = Nonsway moment factor, U1 Major
Value >= 0; 0 means use program determined value.

27 = Nonsway moment factor, U1 Minor
Value >= 0; 0 means use program determined value.

28 = Sway moment factor, U2 Major
Value >= 0; 0 means use program determined value.

29 = Sway moment factor, U2 Minor
Value >= 0; 0 means use program determined value.

30 = Parameter for compressive resistance, n
Value >= 0; 0 means use program determined value.

31 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

32 = Expected to specified Fy ratio, Ry
Value >= 0; 0 means use program determined value. [F/L2]=

33 = Compressive resistance, Cr
Value >= 0; 0 means use program determined value. [F]

34 = Tensile resistance, Tr
Value >= 0; 0 means use program determined value. [F]

35 = Major bending resistance, Mr3
Value >= 0; 0 means use program determined value. [FL]

36 = Minor bending resistance, Mr2
Value >= 0; 0 means use program determined value. [FL]

37 = Major shear resistance, Vr2
Value >= 0; 0 means use program determined value. [F]

38 = Minor shear resistance, Vr3
Value >= 0; 0 means use program determined value. [F]

39 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.

ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Canadian_S16_09.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set, otherwise it returns a nonzero value.

Item: This is an integer between 1 and 21, inclusive, indicating the preference item considered.
1 = Multi-response case design
2 = Framing type
3 = Spectral Acceleration Ratio, Ie*Fa*Sa(0.2)
4 = Ductility related modification factor, Rd
5 = Overstrength related modification factor, Ro
6 = Capacity factor, Phi bending
7 = Capacity factor, Phi compression
8 = Capacity factor, Phi tension
9 = Capacity factor, Phi shear
10 = Slender section modification
11 = Ignore seismic code
12 = Ignore special seismic load
13 = Doubler plate is plug welded
14 = Consider deflection
15 = DL deflection limit, L/Value
16 = SDL + LL deflection limit, L/Value
17 = LL deflection limit, L/Value
18 = Total load deflection limit, L/Value
19 = Total camber limit, L/Value
20 = Pattern live load factor
21 = Demand/capacity ratio limit

Value: The value of the considered preference item.
1 = Multi-response case design
1 = Envelopes
2 = Step-by step
3 = Last step
4 = Envelopes - All
5 = Step-by step - All

2 = Framing type
1 = Type LD MRF
2 = Type MD MRF
3 = Type D MRF
4 = Type LD CBF(V)
5 = Type LD CBF(TC)
6 = Type LD CBF(TO)
7 = Type LD CBF(OT)
8 = Type MD CBF(V)
9 = Type MD CBF(TC)
10 = Type MD CBF(TO)
11 = Type MD CBF(OT)
12 = EBF
13 = Cantilever Column
14 = Conventional MF
15 = Conventional BF

3 = Spectral Acceleration Ratio, Ie*Fa*Sa(0.2)
Value > 0

4 = Ductility related modification factor, Rd
Value > 0

5 = Overstrength related modification factor, Ro
Value > 0

6 = Capacity factor, Phi bending
Value > 0

7 = Capacity factor, Phi compression
Value > 0

8 = Capacity factor, Phi tension
Value > 0

9 = Capacity factor, Phi shear
Value > 0

10 = Slender section modification
1 = Modified geometry
2 = modified Fy

11 = Ignore seismic code
0 = No
Any other value = Yes

12 = Ignore special seismic load
0 = No
Any other value = Yes

13 = Doubler plate is plug welded
0 = No
Any other value = Yes

14 = Consider deflection
0 = No
Any other value = Yes

15 = DL deflection limit, L/Value
Value > 0

16 = SDL + LL deflection limit, L/Value
Value > 0

17 = LL deflection limit, L/Value
Value > 0

18 = Total load deflection limit, L/Value
Value > 0

19 = Total camber limit, L/Value
Value > 0

20 = Pattern live load factor
Value >= 0

21 = Demand/capacity ratio limit
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Canadian_S16_09.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class DesignResults:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api
        self.DesignForces = DesignForces(strict, api)

class DesignForces:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def BeamDesignForces(self):
        """
This function retrieves design forces for an existing designed beam.
The function returns zero if the forces are successfully recovered, otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignResults.DesignForces.BeamDesignForces(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"BeamDesignForces" failed')
        
        return ret

    def BraceDesignForces(self):
        """
This function retrieves design forces for an existing designed brace.
The function returns zero if the forces are successfully recovered, otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignResults.DesignForces.BraceDesignForces(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"BraceDesignForces" failed')
        
        return ret

    def ColumnDesignForces(self):
        """
This function retrieves design forces for an existing designed column.
The function returns zero if the forces are successfully recovered, otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignResults.DesignForces.ColumnDesignForces(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ColumnDesignForces" failed')
        
        return ret

class EUROCODE_3_1993:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 36, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, k Major
22 = Moment coefficient, k Minor
23 = Bending coefficient, C1
24 = Moment coefficient, k Lateral Torsional Buckling
25 = Non-sway moment factor
26 = Sway moment factor, Psi Major
27 = Sway moment factor, Psi Minor
28 = Yield stress, Fy
29 = Compressive capacity, Nc.Rd
30 = Tensile capacity, Nt.Rd
31 = Major bending capacity, Mc3.Rd
32 = Minor bending capacity, Mc2.Rd
33 = Buckling resistance moment, Mb.Rd
34 = Major shear capacity, V2.Rd
35 = Minor shear capacity, V3.RD
36 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, k Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, k Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, C1
Value >= 0; 0 means use program determined value.

24 = Moment coefficient, k Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

25 = Non-sway moment factor
Value >= 0; 0 means use program determined value.

26 = Sway moment factor, Psi Major
Value >= 0; 0 means use program determined value.

27 = Sway moment factor, Psi Minor
Value >= 0; 0 means use program determined value.

28 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

29 = Compressive capacity, Nc.Rd
Value >= 0; 0 means use program determined value. [F]

30 = Tensile capacity, Nt.Rd
Value >= 0; 0 means use program determined value. [F]

31 = Major bending capacity, Mc3.Rd
Value >= 0; 0 means use program determined value. [FL]

32 = Minor bending capacity, Mc2.Rd
Value >= 0; 0 means use program determined value. [FL]

33 = Buckling resistance moment, Mb.Rd
Value >= 0; 0 means use program determined value. [FL]

34 = Major shear capacity, Vn2.Rd
Value >= 0; 0 means use program determined value. [F]

35 = Minor shear capacity, Vn3.RD
Value >= 0; 0 means use program determined value. [F]

36 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.EUROCODE_3_1993.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 12, inclusive, indicating the preference item considered.
1 = Framing type
2 = GammaM0
3 = GammeM1
4 = Consider deflection
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total deflection limit, L/Value
9 = Total camber limit, L/Value
10 = Pattern live load factor
11 = Demand/capacity ratio limit
12 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = GammaM0
Value > 0

3 = GammeM1
Value > 0

4 = Consider deflection
0 = No
Any other value = Yes

5 = DL deflection limit, L/Value
Value > 0

6 = SDL + LL deflection limit, L/Value
Value > 0

7 = LL deflection limit, L/Value
Value > 0

8 = Total deflection limit, L/Value
Value > 0

9 = Total camber limit, L/Value
Value > 0

10 = Pattern live load factor
Value >= 0

11 = Demand/capacity ratio limit
Value > 0

12 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.EUROCODE_3_1993.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 36, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, k Major
22 = Moment coefficient, k Minor
23 = Bending coefficient, C1
24 = Moment coefficient, k Lateral Torsional Buckling
25 = Non-sway moment factor
26 = Sway moment factor, Psi Major
27 = Sway moment factor, Psi Minor
28 = Yield stress, Fy
29 = Compressive capacity, Nc.Rd
30 = Tensile capacity, Nt.Rd
31 = Major bending capacity, Mc3.Rd
32 = Minor bending capacity, Mc2.Rd
33 = Buckling resistance moment, Mb.Rd
34 = Major shear capacity, V2.Rd
35 = Minor shear capacity, V3.RD
36 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, k Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, k Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, C1
Value >= 0; 0 means use program determined value.

24 = Moment coefficient, k Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

25 = Non-sway moment factor
Value >= 0; 0 means use program determined value.

26 = Sway moment factor, Psi Major
Value >= 0; 0 means use program determined value.

27 = Sway moment factor, Psi Minor
Value >= 0; 0 means use program determined value.

28 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

29 = Compressive capacity, Nc.Rd
Value >= 0; 0 means use program determined value. [F]

30 = Tensile capacity, Nt.Rd
Value >= 0; 0 means use program determined value. [F]

31 = Major bending capacity, Mc3.Rd
Value >= 0; 0 means use program determined value. [FL]

32 = Minor bending capacity, Mc2.Rd
Value >= 0; 0 means use program determined value. [FL]

33 = Buckling resistance moment, Mb.Rd
Value >= 0; 0 means use program determined value. [FL]

34 = Major shear capacity, Vn2.Rd
Value >= 0; 0 means use program determined value. [F]

35 = Minor shear capacity, Vn3.RD
Value >= 0; 0 means use program determined value. [F]

36 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects= 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.EUROCODE_3_1993.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 12, inclusive, indicating the preference item considered.
1 = Framing type
2 = GammaM0
3 = GammeM1
4 = Consider deflection
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total deflection limit, L/Value
9 = Total camber limit, L/Value
10 = Pattern live load factor
11 = Demand/capacity ratio limit
12 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Moment Frame
2 = Braced Frame

2 = GammaM0
Value > 0

3 = GammeM1
Value > 0

4 = Consider deflection
0 = No
Any other value = Yes

5 = DL deflection limit, L/Value
Value > 0

6 = SDL + LL deflection limit, L/Value
Value > 0

7 = LL deflection limit, L/Value
Value > 0

8 = Total deflection limit, L/Value
Value > 0

9 = Total camber limit, L/Value
Value > 0

10 = Pattern live load factor
Value >= 0

11 = Demand/capacity ratio limit
Value > 0

12 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.EUROCODE_3_1993.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Eurocode_3_2005:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design 
 overwrite item.
The function returns zero if the item is successfully 
 retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a steel frame design 
 procedure.
Item: This is an integer between 1 and 54, inclusive, indicating 
 the overwrite item considered.
1 = Framing type
2= Consider deflection
3 = Deflection check type
4= DL deflection 
 limit, L/Value
5= SDL + LL deflection 
 limit, L/Value
6 = LL deflection limit, 
 L/Value
7 = Total load deflection 
 limit, L/Value
8 = Total camber limit, 
 L/Value
9 = DL deflection limit, 
 absolute
10 = SDL + LL deflection 
 limit, absolute
11 = LL deflection limit, 
 absolute
12 = Total load deflection 
 limit, absolute
13 = Total camber limit, 
 absolute
14 = Specified camber
15 = Net area to total 
 area ratio
16 = Live load reduction 
 factor
17 = Unbraced length ratio, 
 Major
18 = Unbraced length ratio, 
 Minor
19 = Effective length 
 factor sway, K2 Major
20 = Effective length 
 factor sway, K2 Minor
21 = Moment coefficient, 
 kyy Major
22 = Moment coefficient, 
 kzz Minor
23 = Bending coefficient, 
 C1
24 
 = Moment coefficient, kzy
25 
 = Moment coefficient, kyz
26 = Yield stress, Fy
27 = Compressive capacity, 
 Nc.Rd
28 = Tensile capacity, 
 Nt.Rd
29 = Major bending capacity, 
 Mc3.Rd
30 = Minor bending capacity, 
 Mc2.Rd
31 = Buckling resistance 
 moment, Mb.Rd
32 = Major shear capacity, 
 V2.Rd
33 = Minor shear capacity, 
 V3.Rd
34 = Demand/capacity ratio 
 limit
35 = Section class
36 = Column buckling curve, 
 y-y
37 = Column buckling curve, 
 z-z
38 = Buckling curve for LTB
39 = System overstrength factor, 
 Omega
40 = Is rolled section
41 = Unbraced length ratio, 
 LTB
42 = Effective length factor 
 braced, K1 Major
43 = Effective length factor 
 braced, K1 Minor
44 = Effective length factor, 
 K LTB
45 = Material overstrength 
 factor, GammaOV
46 = Warping constant, Iw
47 = Elastic torsional buckling 
 force, Ncr T
48 = Elastic torsional-flexural 
 buckling force, Ncr TF
49 
 = Bending coefficient, C2
50 = Bending coefficient, 
 C3
51 = Warping coefficient, 
 kw
52 = Coordinate of load application, 
 za
53 
 = Shear center coordinate, zs
54 
 = Lateral-torsional buckling moment capacity, Mcr
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = DCH MRF (Ductility 
 Class High â€“ Moment Frame)
2 = DCM MRF (Ductility 
 Class Medium â€“ Moment Frame)
3 = DCL MRF (Ductility 
 Class Low â€“ Moment Frame)
4 = DCH CBF (Ductility 
 Class High â€“ Concentrically Braced Frame)
5 = DCM CBF (Ductility 
 Class Medium â€“ Concentrically Braced Frame)
6 = DCL CBF (Ductility 
 Class Low â€“ Concentrically Braced Frame)
7 = DCH EBF (Ductility 
 Class High â€“ Eccentrically Braced Frame)
8 = DCM EBF (Ductility 
 Class Medium â€“ Eccentrically Braced Frame)
9 = DCL EBF (Ductility 
 Class Low â€“ Eccentrically Braced Frame)
10 = Inverted pendulum 
 structure
11 = Secondary

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

5 = SDL + LL deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

6 = LL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

7 = Total load deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

8 = Total camber limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

9 = DL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

10 = SDL + LL deflection 
 limit, absolute
Value >= 
 0; 0 means no check for this item. [L]

11 = LL deflection limit, 
 absolute
Value >= 
 0; 0 means no check for this item. [L]

12 = Total load deflection 
 limit, absolute
Value >= 
 0; 0 means no check for this item. [L]

13 = Total camber limit, 
 absolute
Value >= 
 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 
 0. [L]

15 = Net area to total 
 area ratio
Value >= 
 0; 0 means use program default value.

16 = Live load reduction 
 factor
Value >= 
 0; 0 means use program determined value.

17 = Unbraced length ratio, 
 Major
Value >= 
 0; 0 means use program determined value.

18 = Unbraced length ratio, 
 Minor
Value >= 
 0; 0 means use program determined value.

19 = Effective length 
 factor sway, K2 Major
Value >= 
 0; 0 means use program determined value.

20 = Effective length 
 factor sway, K2 Minor
Value >= 
 0; 0 means use program determined value.

21 = Moment coefficient, 
 kyy Major
Value >= 
 0; 0 means use program determined value.

22 = Moment coefficient, 
 kzz Minor
Value >= 
 0; 0 means use program determined value.

23 = Bending coefficient, 
 C1
Value >= 
 0; 0 means use program determined value.

24 = Moment coefficient, 
 kzy
Value >= 
 0; 0 means use program determined value.

25 = Moment coefficient, 
 kyz
Value >= 
 0; 0 means use program determined value.

26 = Yield stress, Fy
Value >= 
 0; 0 means use program determined value. [F/L2]

27 = Compressive capacity, 
 Nc.Rd
Value >= 
 0; 0 means use program determined value. [F]

28 = Tensile capacity, 
 Nt.Rd
Value >= 
 0; 0 means use program determined value. [F]

29 = Major bending capacity, 
 Mc3.Rd
Value >= 
 0; 0 means use program determined value. [FL]

30 = Minor bending capacity, 
 Mc2.Rd
Value >= 
 0; 0 means use program determined value. [FL]

31 = Buckling resistance 
 moment, Mb.Rd
Value >= 
 0; 0 means use program determined value. [FL]

32 = Major shear capacity, 
 V2.Rd
Value >= 
 0; 0 means use program determined value. [F]

33 = Minor shear capacity, 
 V3.Rd
Value >= 
 0; 0 means use program determined value. [F]

34 = Demand/capacity ratio 
 limit
Value >= 0; 
 0 means use program determined value.
35 = Section class
0 = Program default
1 = Class 1
2 = Class 2
3 = Class 3
4 = Class 4

36 = Column buckling curve, 
 y-y
0 = Program default
1 = a0
2 = a
3 = b
4 = c
5 = d

37 = Column buckling curve, 
 z-z
0 = Program default
1 = a0
2 = a
3 = b
4 = c
5 = d

38 
 = Buckling curve for LTB
0 = Program default
1 = a0
2 = a
3 = b
4 = c
5 = d

39 = System overstrength factor, 
 Omega
Value >= 0; 0 means use 
 program determined value.

40 = Is rolled section
0 = Program Determined
1 = No
2 = Yes

41 = Unbraced length ratio, 
 LTB
Value >= 0; 0 means use 
 program determined value.

42 = Effective length factor 
 braced, K1 Major
Value >= 0; 0 means use 
 program determined value.

43 = Effective length factor 
 braced, K1 Minor
Value >= 0; 0 means use 
 program determined value.

44 = Effective length factor, 
 K LTB
Value >= 0; 0 means use 
 program determined value.

45 = Material overstrength 
 factor, GammaOV
Value >= 0; 0 means use 
 program determined value.

46 = Warping constant, Iw
Value >= 0; 0 means use 
 program determined value. [L6]

47 = Elastic torsional buckling 
 force, Ncr T
Value >= 0; 0 means use 
 program determined value. [F]

48 = Elastic torsional-flexural 
 buckling force, Ncr TF
Value >= 0; 0 means use 
 program determined value. [F]

49 
 = Bending coefficient, C2
Value >= 0; 0 means 
 use program determined value.

50 = Bending coefficient, 
 C3
Value >= 0; 0 means 
 use program determined value.

51 = Warping coefficient, 
 kw (used in Mcr calculation)
0.5 =<Value =< 
 1; 0 means use program determined value which is defaulted to 1.0.

52 = Coordinate of load application, za 
 (used in Mcr calculation)
53 
 = Shear center coordinate, zs (used in Mcr calculation)
54 
 = Lateral-torsional buckling moment capacity, Mcr
Value >= 
 0; 0 means use program determined value. [FL]
ProgDet: If this item is True, the specified value is program 
 determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Eurocode_3_2005.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 24, inclusive, indicating the preference item considered.
1 = Country
2 = Combos equation
3 = Reliability class
4 = K factor method
5 = Multi-response case design
6 = Framing type
7 = Behavior factor, q
8 = System overstrength factor, Omega
9 = Consider P-Delta Done
10 = Consider torsion
11 = GammaM0
12 = GammaM1
13 = GammaM2
14 = Ignore seismic code
15 = Ignore special seismic load
16 = Doubler plate is plug-welded
17 = Consider deflection
18 = DL deflection limit, L/Value
19 = SDL + LL deflection limit, L/Value
20 = LL deflection limit, L/Value
21 = Total deflection limit, L/Value
22 = Total camber limit, L/Value
23 = Pattern live load factor
24 = Demand/capacity ratio limit

Value: The value of the considered preference item.
1 = Country
1 = CEN Default
2 = United Kingdom
3 = Slovenia
4 = Bulgaria
5 = Norway
7 = Sweden
8 = Finland
9 = Denmark
10 = Portugal
11 = Germany

2 = Combos equation
1 = 1 = Eq. 6.10
2 = Max of Eqs. 6.10a and 6.10b

3 = Reliability class
1 = Class 1
2 = Class 2
3 = Class 3

4 = K factor method
1 = Method 1 (Annex A)
2 = Method 2 (Annex B)

5 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

6 = Framing type
1 = DCH MRF (Ductility Class High - Moment Frame)
2 = DCM MRF (Ductility Class Medium - Moment Frame)
3 = DCL MRF (Ductility Class Low - Moment Frame)
4 = DCH CBF (Ductility Class High - Concentrically Braced Frame)
5 = DCH CBF (Ductility Class Medium - Concentrically Braced Frame)
6 = DCH CBF (Ductility Class Low - Concentrically Braced Frame)
7 = DCH EBF (Ductility Class High - Eccentrically Braced Frame)
8 = DCM EBF (Ductility Class Medium- Eccentrically Braced Frame)
9 = DCL EBF (Ductility Class Low- Eccentrically Braced Frame)
10 = Inverted pendulum structure
11 = Secondary

7 = Behavior factor, q
Value > 0

8 = System overstrength factor, Omega
Value > 0

9 = Consider P-Delta Done
0 = No
Any other value = Yes

10 = Consider torsion
0 = No
Any other value = Yes

11 = GammaM0
Value > 0

12 = GammaM1
Value > 0

13 = GammaM2
Value > 0

14 = Ignore seismic code
0 = No
Any other value = Yes

15 = Ignore special seismic load
0 = No
Any other value = Yes

16 = Doubler plate is plug-welded
0 = No
Any other value = Yes

17 = Consider deflection
0 = No
Any other value = Yes

18 = DL deflection limit, L/Value
Value > 0

19 = SDL + LL deflection limit, L/Value
Value > 0

20 = LL deflection limit, L/Value
Value > 0

21 = Total deflection limit, L/Value
Value > 0

22 = Total camber limit, L/Value
Value > 0

23 = Pattern live load factor
Value >= 0

24 = Demand/capacity ratio limit
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Eurocode_3_2005.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite 
 item.
The function returns zero if the item is successfully 
 set; otherwise, it returns a nonzero value.

Name: The name of an existing frame object or group depending 
 on the value of the ItemType item.
Item: This is an integer between 1 and 54, inclusive, indicating 
 the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, 
 L/Value
5 = SDL + LL deflection 
 limit, L/Value
6 = LL deflection limit, 
 L/Value
7 = Total load deflection 
 limit, L/Value
8 = Total camber limit, 
 L/Value
9 = DL deflection limit, 
 absolute
10 = SDL + LL deflection 
 limit, absolute
11 = LL deflection limit, 
 absolute
12 = Total load deflection 
 limit, absolute
13 = Total camber limit, 
 absolute
14 = Specified camber
15 = Net area to total 
 area ratio
16 = Live load reduction 
 factor
17 = Unbraced length ratio, 
 Major
18 = Unbraced length ratio, 
 Minor
19 = Effective length 
 factor, K2 Major
20 = Effective length 
 factor, K2 Minor
21 = Moment coefficient, 
 kyy Major
22 = Moment coefficient, 
 kzz Minor
23 = Bending coefficient, 
 C1
24 
 = Moment coefficient, kzy
25 
 = Moment coefficient, kyz
26 = Yield stress, Fy
27 = Compressive capacity, 
 Nc.Rd
28 = Tensile capacity, 
 Nt.Rd
29 = Major bending capacity, 
 Mc3.Rd
30 = Minor bending capacity, 
 Mc2.Rd
31 = Buckling resistance 
 moment, Mb.Rd
32 = Major shear capacity, 
 V2.Rd
33 = Minor shear capacity, 
 V3.RD
34 = Demand/capacity ratio 
 limit
35 = Section class
36 = Column buckling curve, 
 y-y
37 = Column buckling curve, 
 z-z
38 = Buckling curve for LTB
39 = System overstrength factor, 
 Omega
40 = Is rolled section
41 = Unbraced length ratio, 
 LTB
42 = Effective length factor 
 braced, K1 Major
43 = Effective length factor 
 braced, K1 Minor
44 = Effective length factor, 
 K LTB
45 = Material overstrength 
 factor, GammaOV
46 = Warping constant, Iw
47 = Elastic torsional buckling 
 force, Ncr T
48 = Elastic torsional-flexural 
 buckling force, Ncr TF
49 = Bending coefficient, 
 C2
50 = Bending coefficient, 
 C3
51 = Warping coefficient, 
 kw
52 = Coordinate 
 of load application, za (used in Mcr calculation)
53 
 = Shear center coordinate, zs (used in Mcr calculation)
54 
 = Lateral-torsional buckling moment capacity, Mcr
Value >= 
 0; 0 means use program determined value. [FL]
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = DCH MRF (Ductility 
 Class High â€“ Moment Frame)
2 = DCM MRF (Ductility 
 Class Medium â€“ Moment Frame)
3 = DCL MRF (Ductility 
 Class Low â€“ Moment Frame)
4 = DCH CBF (Ductility 
 Class High â€“ Concentrically Braced Frame)
5 = DCM CBF (Ductility 
 Class Medium â€“ Concentrically Braced Frame)
6 = DCL CBF (Ductility 
 Class Low â€“ Concentrically Braced Frame)
7 = DCH EBF (Ductility 
 Class High â€“ Eccentrically Braced Frame)
8 = DCM EBF (Ductility 
 Class Medium â€“ Eccentrically Braced Frame)
9 = DCL EBF (Ductility 
 Class Low â€“ Eccentrically Braced Frame)
10 = Inverted pendulum 
 structure
11 = Secondary

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

5 = SDL + LL deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

6 = LL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

7 = Total load deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

8 = Total camber limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

9 = DL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

10 = SDL + LL deflection 
 limit, absolute
Value >= 0; 0 means 
 no check for this item. [L]

11 = LL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

12 = Total load deflection 
 limit, absolute
Value >= 0; 0 means 
 no check for this item. [L]

13 = Total camber limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total 
 area ratio
Value >= 0; 0 means 
 use program default value.

16 = Live load reduction 
 factor
Value >= 0; 0 means 
 use program determined value.

17 = Unbraced length ratio, 
 Major
Value >= 0; 0 means 
 use program determined value.

18 = Unbraced length ratio, 
 Minor
Value >= 
 0; 0 means use program determined value.

19 = Effective length 
 factor sway, K2 Major
Value >= 
 0; 0 means use program determined value.

20 = Effective length 
 factor sway, K2 Minor
Value >= 
 0; 0 means use program determined value.

21 = Moment coefficient, 
 kyy Major
Value >= 
 0; 0 means use program determined value.

22 = Moment coefficient, 
 kzz Minor
Value >= 
 0; 0 means use program determined value.

23 = Bending coefficient, 
 C1
Value >= 
 0; 0 means use program determined value.

24 = Moment coefficient, 
 kzy
Value >= 
 0; 0 means use program determined value.

25 = Moment coefficient, 
 kyz
Value >= 
 0; 0 means use program determined value.

26 = Yield stress, Fy
Value >= 
 0; 0 means use program determined value. [F/L2]

27 = Compressive capacity, 
 Nc.Rd
Value >= 
 0; 0 means use program determined value. [F]

28 = Tensile capacity, 
 Nt.Rd
Value >= 
 0; 0 means use program determined value. [F]

29 = Major bending capacity, 
 Mc3.Rd
Value >= 
 0; 0 means use program determined value. [FL]

30 = Minor bending capacity, 
 Mc2.Rd
Value >= 
 0; 0 means use program determined value. [FL]

31 = Buckling resistance 
 moment, Mb.Rd
Value >= 
 0; 0 means use program determined value. [FL]

32 = Major shear capacity, 
 V2.Rd
Value >= 
 0; 0 means use program determined value. [F]

33 = Minor shear capacity, 
 V3.Rd
Value >= 
 0; 0 means use program determined value. [F]

34 = Demand/capacity ratio 
 limit
Value >= 0; 
 0 means use program determined value.
35 = Section class
0 = Program default
1 = Class 1
2 = Class 2
3 = Class 3
4 = Class 4

36 = Column buckling curve, 
 y-y
0 = Program default
1 = a0
2 = a
3 = b
4 = c
5 = d

37 = Column buckling curve, 
 z-z
0 = Program default
1 = a0
2 = a
3 = b
4 = c
5 = d

38 
 = Buckling curve for LTB
0 = Program default
1 = a0
2 = a
3 = b
4 = c
5 = d

39 = System overstrength factor, 
 Omega
Value >= 0; 0 means use 
 program determined value.

40 = Is rolled section
0 = Program Determined
1 = No
2 = Yes

41 = Unbraced length ratio, 
 LTB
Value >= 0; 0 means use 
 program determined value.

42 = Effective length factor 
 braced, K1 Major
Value >= 0; 0 means use 
 program determined value.

43 = Effective length factor 
 braced, K1 Minor
Value >= 0; 0 means use 
 program determined value.

44 = Effective length factor, 
 K LTB
Value >= 0; 0 means use 
 program determined value.

45 = Material overstrength 
 factor, GammaOV
Value >= 0; 0 means use 
 program determined value.

46 = Warping constant, Iw
Value >= 0; 0 means use 
 program determined value. [L6]

47 = Elastic torsional buckling 
 force, Ncr T
Value >= 0; 0 means use 
 program determined value. [F]

48 = Elastic torsional-flexural 
 buckling force, Ncr TF
Value >= 0; 0 means use 
 program determined value. [F]

49 
 = Bending coefficient, C2
Value >= 0; 0 means 
 use program determined value.

50 = Bending coefficient, 
 C3
Value >= 0; 0 means 
 use program determined value.

51 = Warping coefficient, 
 kw (used in Mcr calculation)
0.5 =<Value =< 
 1; 0 means use program determined value which is defaulted to 1.0.

52 = Coordinate of load application, za 
 (used in Mcr calculation)
53 
 = Shear center coordinate, zs (used in Mcr calculation)
54 
 = Lateral-torsional buckling moment capacity, Mcr
Value >= 
 0; 0 means use program determined value. [FL]
ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the 
 frame object specified by the Name item.
If this item is Group, the assignment is made to all 
 frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made 
 to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Eurocode_3_2005.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 16, inclusive, indicating the preference item considered.
1 = Country
2 = Combos equation
3 = Reliability class
4 = K factor method
5 = Multi-response case design
6 = Framing type
7 = Behavior factor, q
8 = System overstrength factor, Omega
9 = Consider P-Delta Done
10 = Consider torsion
11 = GammaM0
12 = GammaM1
13 = GammaM2
14 = Ignore seismic code
15 = Ignore special seismic load
16 = Doubler plate is plug-welded
17 = Consider deflection
18 = DL deflection limit, L/Value
19 = SDL + LL deflection limit, L/Value
20 = LL deflection limit, L/Value
21 = Total deflection limit, L/Value
22 = Total camber limit, L/Value
23 = Pattern live load factor
24 = Demand/capacity ratio limit

Value: The value of the considered preference item.
1 = Country
1 = CEN Default
2 = United Kingdom
3 = Slovenia
4 = Bulgaria
5 = Norway
7 = Sweden
8 = Finland
9 = Denmark
10 = Portugal
11 = Germany

2 = Combos equation
1 = 1 = Eq. 6.10
2 = Max of Eqs. 6.10a and 6.10b

3 = Reliability class
1 = Class 1
2 = Class 2
3 = Class 3

4 = K factor method
1 = Method 1 (Annex A)
2 = Method 2 (Annex B)

5 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

6 = Framing type
1 = DCH MRF (Ductility Class High - Moment Frame)
2 = DCM MRF (Ductility Class Medium - Moment Frame)
3 = DCL MRF (Ductility Class Low - Moment Frame)
4 = DCH CBF (Ductility Class High - Concentrically Braced Frame)
5 = DCH CBF (Ductility Class Medium - Concentrically Braced Frame)
6 = DCH CBF (Ductility Class Low - Concentrically Braced Frame)
7 = DCH EBF (Ductility Class High - Eccentrically Braced Frame)
8 = DCM EBF (Ductility Class Medium- Eccentrically Braced Frame)
9 = DCL EBF (Ductility Class Low- Eccentrically Braced Frame)
10 = Inverted pendulum structure
11 = Secondary

7 = Behavior factor, q
Value > 0

8 = System overstrength factor, Omega
Value > 0

9 = Consider P-Delta Done
0 = No
Any other value = Yes

10 = Consider torsion
0 = No
Any other value = Yes

11 = GammaM0
Value > 0

12 = GammaM1
Value > 0

13 = GammaM2
Value > 0

14 = Ignore seismic code
0 = No
Any other value = Yes

15 = Ignore special seismic load
0 = No
Any other value = Yes

16 = Doubler plate is plug-welded
0 = No
Any other value = Yes

17 = Consider deflection
0 = No
Any other value = Yes

18 = DL deflection limit, L/Value
Value > 0

19 = SDL + LL deflection limit, L/Value
Value > 0

20 = LL deflection limit, L/Value
Value > 0

21 = Total deflection limit, L/Value
Value > 0

22 = Total camber limit, L/Value
Value > 0

23 = Pattern live load factor
Value >= 0

24 = Demand/capacity ratio limit
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Eurocode_3_2005.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class INDIAN_IS_800_1998:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 34, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor
19 = Unbraced length ratio, Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Effective length factor, K Lateral Torsional Buckling
23 = Moment coefficient, Cm Major
24 = Moment coefficient, Cm Minor
25 = Yield stress, Fy
26 = Allowable compressive stress, Sigma_ac
27 = Allowable tensile stress, Sigma_at
28 = Allowable major bending stress, Sigma_bc33
29 = Allowable minor bending stress, Sigma_bc22
30 = Major average shear stress, Tau_va2
31 = Minor average shear stress, Tau_va3
32 = Maximum elastic shear stress, Tau_vm
33 = Allowable effective stress, Sigma_e
34 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway Frame
2 = Nonsway Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Effective length factor, K Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

24 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

25 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

26 = Allowable compressive stress, Sigma_ac
Value >= 0; 0 means use program determined value. [F/L2]

27 = Allowable tensile stress, Sigma_at
Value >= 0; 0 means use program determined value. [F/L2]

28 = Allowable major bending stress, Sigma_bc33
Value >= 0; 0 means use program determined value. [F/L2]

29 = Allowable minor bending stress, Sigma_bc22
Value >= 0; 0 means use program determined value. [F/L2]

30 = Major average shear stress, Tau_va2
Value >= 0; 0 means use program determined value. [F/L2]

31 = Minor average shear stress, Tau_va3
Value >= 0; 0 means use program determined value. [F/L2]

32 = Maximum elastic shear stress, Tau_vm
Value >= 0; 0 means use program determined value. [F/L2]

33 = Allowable effective stress, Sigma_e
Value >= 0; 0 means use program determined value. [F/L2]

34 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.INDIAN_IS_800_1998.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 34, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor
19 = Unbraced length ratio, Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Effective length factor, K Lateral Torsional Buckling
23 = Moment coefficient, Cm Major
24 = Moment coefficient, Cm Minor
25 = Yield stress, Fy
26 = Allowable compressive stress, Sigma_ac
27 = Allowable tensile stress, Sigma_at
28 = Allowable major bending stress, Sigma_bc33
29 = Allowable minor bending stress, Sigma_bc22
30 = Major average shear stress, Tau_va2
31 = Minor average shear stress, Tau_va3
32 = Maximum elastic shear stress, Tau_vm
33 = Allowable effective stress, Sigma_e
34 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway Frame
2 = Nonsway Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Effective length factor, K Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

24 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

25 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

26 = Allowable compressive stress, Sigma_ac
Value >= 0; 0 means use program determined value. [F/L2]

27 = Allowable tensile stress, Sigma_at
Value >= 0; 0 means use program determined value. [F/L2]

28 = Allowable major bending stress, Sigma_bc33
Value >= 0; 0 means use program determined value. [F/L2]

29 = Allowable minor bending stress, Sigma_bc22
Value >= 0; 0 means use program determined value. [F/L2]

30 = Major average shear stress, Tau_va2
Value >= 0; 0 means use program determined value. [F/L2]

31 = Minor average shear stress, Tau_va3
Value >= 0; 0 means use program determined value. [F/L2]

32 = Maximum elastic shear stress, Tau_vm
Value >= 0; 0 means use program determined value. [F/L2]

33 = Allowable effective stress, Sigma_e
Value >= 0; 0 means use program determined value. [F/L2]

34 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.INDIAN_IS_800_1998.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

class Indian_IS_800_2007:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 44, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Section class
3 = Column buckling curve (z-z)
4 = Column buckling curve (y-y)
5 = Is rolled section
6 = Consider deflection
7 = Deflection check type
8 = DL deflection limit, L/Value
9 = SDL + LL deflection limit, L/Value
10 = LL deflection limit, L/Value
11 = Total load deflection limit, L/Value
12 = Total camber limit, L/Value
13 = DL deflection limit, absolute
14 = SDL + LL deflection limit, absolute
15 = LL deflection limit, absolute
16 = Total load deflection limit, absolute
17 = Total camber limit, absolute
18 = Specified camber
19 = Net area to total area ratio
20 = Live load reduction factor
21 = Unbraced length ratio, Major
22 = Unbraced length ratio, Minor
23 = Unbraced length ratio, Lateral Torsional Buckling
24 = Effective length factor Braced, K1 Major
25 = Effective length factor Braced, K1 Minor
26 = Effective length factor Sway, K2 Major
27 = Effective length factor Sway, K2 Minor
28 = Effective length factor, K Lateral Torsional Buckling
29 = Bending coefficient, C1
30 = Uniform moment factor, Cmz
31 = Uniform moment factor, Cmy
32 = Uniform moment factor, CmLT
33 = Moment coefficient, kz
34 = Moment coefficient, ky
35 = Moment coefficient, k_LT
36 = Yield stress, Fy
37 = Compressive capacity, Pd
38 = Tensile capacity, Td
39 = Major bending capacity, Mdz
40 = Minor bending capacity, Mdy
41 = Critical buckling moment, Mcr
42 = Major shear capacity, Vdy
43 = Minor shear capacity, Vdz
44 = Demand/capacity ratio limit

Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = SMF
2 = OMF
3 = SCBF
4 = OCBF
5 = EBF
6 = Secondary

2 = Section class
1 = Class 1 (Plastic)
2 = Class 2 (Compact)
3 = Class 3 (Semicompact)
4 = Class 4 (Slender)

3 = Column buckling curve (z-z)
1 = a
2 = b
3 = c
4 = d

4 = Column buckling curve (y-y)
1 = a
2 = b
3 = c
4 = d

5 = Is rolled section
Value >= 0; 0 means use program default value

6 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

7 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

8 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

10 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

11 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

12 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

13 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

16 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

17 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

18 = Specified camber
Value >= 0. [L]

19 = Net area to total area ratio
Value >= 0; 0 means use program default value.

20 = Live load reduction factor
Value >= 0; 0 means use program determined value.

21 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

22 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

23 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

24 = Effective length factor Braced, K1 Major
Value >= 0; 0 means use program determined value.

25 = Effective length factor Braced, K1 Minor
Value >= 0; 0 means use program determined value.

26 = Effective length factor Sway, K2 Major
Value >= 0; 0 means use program determined value.

27 = Effective length Sway factor, K2 Minor
Value >= 0; 0 means use program determined value.

28 = Effective length factor, K Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

29 = Bending coefficient, C1
Value >= 0; 0 means use program determined value.

30 = Uniform moment factor, Cmz
Value >= 0; 0 means use program determined value.

31 = Uniform moment factor, Cmy
Value >= 0; 0 means use program determined value.

32 = Uniform moment factor, CmLT
Value >= 0; 0 means use program determined value.

33 = Moment coefficient, kz
Value >= 0; 0 means use program determined value.

34 = Moment coefficient, ky
Value >= 0; 0 means use program determined value.

35 = Moment coefficient, k_LT
Value >= 0; 0 means use program determined value.

36 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

37 = Compressive capacity, Pd
Value >= 0; 0 means use program determined value. [F]

38 = Tensile capacity, Td
Value >= 0; 0 means use program determined value. [F]

39 = Major bending capacity, Mdz
Value >= 0; 0 means use program determined value. [F-L]

40 = Minor bending capacity, Mdy
Value >= 0; 0 means use program determined value. [F-L]

41 = Critical buckling moment, Mcr
Value >= 0; 0 means use program determined value. [F-L]

42 = Major shear capacity, Vdy
Value >= 0; 0 means use program determined value. [F]

43 = Minor shear capacity, Vdz
Value >= 0; 0 means use program determined value. [F]

44 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.

ProgDet: If this item is True then the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Indian_IS_800_2007.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved, otherwise it returns a nonzero value.

Item: This is an integer between 1 and 18, inclusive, indicating the preference item considered.
1 = Framing type
2 = Importance factor
3 = Seismic Zone
4 = Consider P-delta Done
5 = GammaM0
6 = GammaM1
7 = Ignore sseismic code
8 = Ignore special seismic load
9 = Is doubler plate plug-welded
10 = Consider deflection
11 = DL deflection limit, L/Value
12 = SDL + LL deflection limit, L/Value
13 = LL deflection limit, L/Value
14 = Total deflection limit, L/Value
15 = Total camber limit, L/Value
16 = Pattern live load factor
17 = Demand/capacity ratio limit
18 = Multi-response case design

Value: The value of the considered preference item.
1 = Framing type
1 = SMF
2 = OMF
3 = SCBF
4 = OCBF
5 = EBF
6 = Secondary

2 = Importance factor
Value > 0

3 = Seismic Zone
1 = Zone I
2 = Zone II
3 = Zone III
4 = Zone IV
5 = Zone V

4 = Consider P-delta Done
0 = No
Any other value = Yes

5 = GammaM0
Value > 0

6 = GammaM1
Value > 0

7 = Ignore sseismic code
0 = No
Any other value = Yes

8 = Ignore special seismic load
0 = No
Any other value = Yes

9 = Is doubler plate plug-welded
0 = No
Any other value = Yes

10 = Consider deflection
0 = No
Any other value = Yes

11 = DL deflection limit, L/Value
Value > 0

12 = SDL + LL deflection limit, L/Value
Value > 0

13 = LL deflection limit, L/Value
Value > 0

14 = Total deflection limit, L/Value
Value > 0

15 = Total camber limit, L/Value
Value > 0

16 = Pattern live load factor
Value >= 0

17 = Demand/capacity ratio limit
Value > 0

18 = Time history design
1 = Envelopes
2 = Step-by step
3 = Last step
4 = Envelopes - All
5 = Step-by step - All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Indian_IS_800_2007.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 44, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Section class
3 = Column buckling curve (z-z)
4 = Column buckling curve (y-y)
5 = Is rolled section
6 = Consider deflection
7 = Deflection check type
8 = DL deflection limit, L/Value
9 = SDL + LL deflection limit, L/Value
10 = LL deflection limit, L/Value
11 = Total load deflection limit, L/Value
12 = Total camber limit, L/Value
13 = DL deflection limit, absolute
14 = SDL + LL deflection limit, absolute
15 = LL deflection limit, absolute
16 = Total load deflection limit, absolute
17 = Total camber limit, absolute
18 = Specified camber
19 = Net area to total area ratio
20 = Live load reduction factor
21 = Unbraced length ratio, Major
22 = Unbraced length ratio, Minor
23 = Unbraced length ratio, Lateral Torsional Buckling
24 = Effective length factor Braced, K1 Major
25 = Effective length factor Braced, K1 Minor
26 = Effective length factor Sway, K2 Major
27 = Effective length factor Sway, K2 Minor
28 = Effective length factor, K Lateral Torsional Buckling
29 = Bending coefficient, C1
30 = Uniform moment factor, Cmz
31 = Uniform moment factor, Cmy
32 = Uniform moment factor, CmLT
33 = Moment coefficient, kz
34 = Moment coefficient, ky
35 = Moment coefficient, k_LT
36 = Yield stress, Fy
37 = Compressive capacity, Pd
38 = Tensile capacity, Td
39 = Major bending capacity, Mdz
40 = Minor bending capacity, Mdy
41 = Critical buckling moment, Mcr
42 = Major shear capacity, Vdy
43 = Minor shear capacity, Vdz
44 = Demand/capacity ratio limit

Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = SMF
2 = OMF
3 = SCBF
4 = OCBF
5 = EBF
6 = Secondary

2 = Section class
1 = Class 1 (Plastic)
2 = Class 2 (Compact)
3 = Class 3 (Semicompact)
4 = Class 4 (Slender)

3 = Column buckling curve (z-z)
1 = a
2 = b
3 = c
4 = d

4 = Column buckling curve (y-y)
1 = a
2 = b
3 = c
4 = d

5 = Is rolled section
Value >= 0; 0 means use program default value

6 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

7 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

8 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

10 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

11 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

12 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

13 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

16 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

17 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

18 = Specified camber
Value >= 0. [L]

19 = Net area to total area ratio
Value >= 0; 0 means use program default value.

20 = Live load reduction factor
Value >= 0; 0 means use program determined value.

21 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

22 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

23 = Unbraced length ratio, Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

24 = Effective length factor Braced, K1 Major
Value >= 0; 0 means use program determined value.

25 = Effective length factor Braced, K1 Minor
Value >= 0; 0 means use program determined value.

26 = Effective length factor Sway, K2 Major
Value >= 0; 0 means use program determined value.

27 = Effective length Sway factor, K2 Minor
Value >= 0; 0 means use program determined value.

28 = Effective length factor, K Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

29 = Bending coefficient, C1
Value >= 0; 0 means use program determined value.

30 = Uniform moment factor, Cmz
Value >= 0; 0 means use program determined value.

31 = Uniform moment factor, Cmy
Value >= 0; 0 means use program determined value.

32 = Uniform moment factor, CmLT
Value >= 0; 0 means use program determined value.

33 = Moment coefficient, kz
Value >= 0; 0 means use program determined value.

34 = Moment coefficient, ky
Value >= 0; 0 means use program determined value.

35 = Moment coefficient, k_LT
Value >= 0; 0 means use program determined value.

36 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

37 = Compressive capacity, Pd
Value >= 0; 0 means use program determined value. [F]

38 = Tensile capacity, Td
Value >= 0; 0 means use program determined value. [F]

39 = Major bending capacity, Mdz
Value >= 0; 0 means use program determined value. [F-L]

40 = Minor bending capacity, Mdy
Value >= 0; 0 means use program determined value. [F-L]

41 = Critical buckling moment, Mcr
Value >= 0; 0 means use program determined value. [F-L]

42 = Major shear capacity, Vdy
Value >= 0; 0 means use program determined value. [F]

43 = Minor shear capacity, Vdz
Value >= 0; 0 means use program determined value. [F]

44 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.

ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Indian_IS_800_2007.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set, otherwise it returns a nonzero value.

Item: This is an integer between 1 and 18, inclusive, indicating the preference item considered.
1 = Framing type
2 = Importance factor
3 = Seismic Zone
4 = Consider P-delta Done
5 = GammaM0
6 = GammaM1
7 = Ignore seismic code
8 = Ignore special seismic load
9 = Is doubler plate plug-welded
10 = Consider deflection
11 = DL deflection limit, L/Value
12 = SDL + LL deflection limit, L/Value
13 = LL deflection limit, L/Value
14 = Total deflection limit, L/Value
15 = Total camber limit, L/Value
16 = Pattern live load factor
17 = Demand/capacity ratio limit
18 = Multi-response case design

Value: The value of the considered preference item.
The value of the considered preference item.
1 = Framing type
1 = SMF
2 = OMF
3 = SCBF
4 = OCBF
5 = EBF
6 = Secondary

2 = Importance factor
Value > 0

3 = Seismic Zone
1 = Zone I
2 = Zone II
3 = Zone III
4 = Zone IV
5 = Zone V

4 = Consider P-delta Done
0 = No
Any other value = Yes

5 = GammaM0
Value > 0

6 = GammaM1
Value > 0

7 = Ignore sseismic code
0 = No
Any other value = Yes

8 = Ignore special seismic load
0 = No
Any other value = Yes

9 = Is doubler plate plug-welded
0 = No
Any other value = Yes

10 = Consider deflection
0 = No
Any other value = Yes

11 = DL deflection limit, L/Value
Value > 0

12 = SDL + LL deflection limit, L/Value
Value > 0

13 = LL deflection limit, L/Value
Value > 0

14 = Total deflection limit, L/Value
Value > 0

15 = Total camber limit, L/Value
Value > 0

16 = Pattern live load factor
Value >= 0

17 = Demand/capacity ratio limit
Value > 0

18 = Time history design
1 = Envelopes
2 = Step-by step
3 = Last step
4 = Envelopes - All
5 = Step-by step - All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Indian_IS_800_2007.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class ITALIAN_UNI_10011:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 26, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Axial load amplification(Omega)
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor Lateral Torsional Buckling
20 = Effective length factor, Beta Major
21 = Effective length factor, Beta Minor
22 = Moment coefficient, Meq/Mmax Major
23 = Moment coefficient, Meq/Mmax Minor
24 = LTB moment coefficient (Omega1)
25 = Yield stress, Fy
26 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway Frame
2 = NonSway Frame

2 = Axial load amplification(Omega)
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L]

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Meq/Mmax Major
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Meq/Mmax Minor
Value >= 0; 0 means use program determined value.

24 = LTB moment coefficient (Omega1)
Value >= 0; 0 means use program determined value.

25 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

26 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.ITALIAN_UNI_10011.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 26, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Axial load amplification(Omega)
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor Lateral TorsionalBuckling
20 = Effective length factor, Beta Major
21 = Effective length factor, Beta Minor
22 = Moment coefficient, Meq/Mmax Major
23 = Moment coefficient, Meq/Mmax Minor
24 = LTB moment coefficient (Omega1)
25 = Yield stress, Fy
26 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Sway Frame
2 = NonSway Frame

2 = Axial load amplification(Omega)
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L]

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor Lateral TorsionalBuckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, Beta Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, Beta Minor
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Meq/Mmax Major
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Meq/Mmax Minor
Value >= 0; 0 means use program determined value.

24 = LTB moment coefficient (Omega1)
Value >= 0; 0 means use program determined value.

25 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

26 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjectst, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.ITALIAN_UNI_10011.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

class Italian_UNI_10011:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Framing type
2 = Consider deflection
3 = DL deflection limit, L/Value
4 = SDL + LL deflectionlimit, L/Value
5 = LL deflection limit, L/Value
6 = Total deflectionlimit, L/Value
7 = Total camber limit, L/Value
8 = Pattern live load factor
9 = Demand/capacity ratio limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Sway Frame
2 = NonSway Frame

2 = Consider deflection
0 = No
Any other value = Yes

3 = DL deflection limit, L/Value
Value > 0

4 = SDL + LL deflection limit, L/Value
Value > 0

5 = LL deflection limit, L/Value
Value > 0

6 = Total deflection limit, L/Value
Value > 0

7 = Total camber limit, L/Value
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Demand/capacity ratio limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Italian_UNI_10011.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 10, inclusive, indicating the preference item considered.
1 = Framing type
2 = Consider deflection
3 = DL deflection limit, L/Value
4 = SDL + LL deflectionlimit, L/Value
5 = LL deflection limit, L/Value
6 = Total deflectionlimit, L/Value
7 = Total camber limit, L/Value
8 = Pattern live load factor
9 = Demand/capacity ratio limit
10 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Sway Frame
2 = NonSway Frame

2 = Consider deflection
0 = No
Any other value = Yes

3 = DL deflection limit, L/Value
Value > 0

4 = SDL + LL deflection limit, L/Value
Value > 0

5 = LL deflection limit, L/Value
Value > 0

6 = Total deflection limit, L/Value
Value > 0

7 = Total camber limit, L/Value
Value > 0

8 = Pattern live load factor
Value >= 0

9 = Demand/capacity ratio limit
Value > 0

10 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Italian_UNI_10011.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Norsok_N004:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 36, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, k Major
22 = Moment coefficient, k Minor
23 = Bending coefficient, C1
24 = Moment coefficient, kzy
25 = Moment coefficient, kyz
26 = Pressure equalized
27 = External pressure
28 = Yield stress, Fy
29 = Compressive capacity, Nc.Rd
30 = Tensile capacity, Nt.Rd
31 = Major bending capacity, Mc3.Rd
32 = Minor bending capacity, Mc2.Rd
33 = Buckling resistance moment, Mb.Rd
34 = Major shear capacity, V2.Rd
35 = Minor shear capacity, V3.RD
36 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, k Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, k Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, C1
Value >= 0; 0 means use program determined value.

24 = Moment coefficient, kzy
Value >= 0; 0 means use program determined value.

25 = Moment coefficient, kyz
Value >= 0; 0 means use program determined value.

26 = Pressure equalized
0 = Program Determined
1 = No
2 = Yes

27 = External pressure
Any value OK; Positive generates hoop compression and negative generates hoop tension. [F/L2]

28 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

29 = Compressive capacity, Nc.Rd
Value >= 0; 0 means use program determined value. [F]

30 = Tensile capacity, Nt.Rd
Value >= 0; 0 means use program determined value. [F]

31 = Major bending capacity, Mc3.Rd
Value >= 0; 0 means use program determined value. [FL]

32 = Minor bending capacity, Mc2.Rd
Value >= 0; 0 means use program determined value. [FL]

33 = Buckling resistance moment, Mb.Rd
Value >= 0; 0 means use program determined value. [FL]

34 = Major shear capacity, V2.Rd
Value >= 0; 0 means use program determined value. [F]

35 = Minor shear capacity, V3.RD
Value >= 0; 0 means use program determined value. [F]

36 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Norsok_N004.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 16, inclusive, indicating the preference item considered.
1 = Combos equation
2 = K factor method
3 = Pressure interaction method
4 = Framing type
5 = GammaM0
6 = GammeM1
7 = GammaM2
8 = Consider deflection
9 = DL deflection limit, L/Value
10 = SDL + LL deflection limit, L/Value
11 = LL deflection limit, L/Value
12 = Total deflection limit, L/Value
13 = Total camber limit, L/Value
14 = Pattern live load factor
15 = Demand/capacity ratio limit
16 = Multi-response case design
Value: The value of the considered preference item.
1 = Combos equation
1 = 1 = Eq. 6.10
2 = Max of Eqs. 6.10a and 6.10b

2 = K factor method
1 = Method 1 (Annex A)
2 = Method 2 (Annex B)

3 = Pressure interaction method
1 = Method A
2 = Method B

4 = Framing type
1 = Moment Frame
2 = Braced Frame

5 = GammaM0
Value > 0

6 = GammeM1
Value > 0

7 = GammeM2
Value > 0

8 = Consider deflection
0 = No
Any other value = Yes

9 = DL deflection limit, L/Value
Value > 0

10 = SDL + LL deflection limit, L/Value
Value > 0

11 = LL deflection limit, L/Value
Value > 0

12 = Total deflection limit, L/Value
Value > 0

13 = Total camber limit, L/Value
Value > 0

14 = Pattern live load factor
Value >= 0

15 = Demand/capacity ratio limit
Value > 0

16 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Norsok_N004.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 36, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, k Major
22 = Moment coefficient, k Minor
23 = Bending coefficient, C1
24 = Moment coefficient, kzy
25 = Moment coefficient, kyz
26 = Pressure equalized
27 = External pressure
28 = Yield stress, Fy
29 = Compressive capacity, Nc.Rd
30 = Tensile capacity, Nt.Rd
31 = Major bending capacity, Mc3.Rd
32 = Minor bending capacity, Mc2.Rd
33 = Buckling resistance moment, Mb.Rd
34 = Major shear capacity, V2.Rd
35 = Minor shear capacity, V3.RD
36 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, k Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, k Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, C1
Value >= 0; 0 means use program determined value.

24 = Moment coefficient, kzy
Value >= 0; 0 means use program determined value.

25 = Moment coefficient, kyz
Value >= 0; 0 means use program determined value.

26 = Pressure equalized
0 = Program Determined
1 = No
2 = Yes

27 = External pressure
Any value OK; Positive generates hoop compression and negative generates hoop tension. [F/L2]

28 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

29 = Compressive capacity, Nc.Rd
Value >= 0; 0 means use program determined value. [F]

30 = Tensile capacity, Nt.Rd
Value >= 0; 0 means use program determined value. [F]

31 = Major bending capacity, Mc3.Rd
Value >= 0; 0 means use program determined value. [FL]

32 = Minor bending capacity, Mc2.Rd
Value >= 0; 0 means use program determined value. [FL]

33 = Buckling resistance moment, Mb.Rd
Value >= 0; 0 means use program determined value. [FL]

34 = Major shear capacity, V2.Rd
Value >= 0; 0 means use program determined value. [F]

35 = Minor shear capacity, V3.RD
Value >= 0; 0 means use program determined value. [F]

36 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Norsok_N004.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 16, inclusive, indicating the preference item considered.
1 = Combos equation
2 = K factor method
3 = Pressure interaction method
4 = Framing type
5 = GammaM0
6 = GammeM1
7 = GammaM2
8 = Consider deflection
9 = DL deflection limit, L/Value
10 = SDL + LL deflection limit, L/Value
11 = LL deflection limit, L/Value
12 = Total deflection limit, L/Value
13 = Total camber limit, L/Value
14 = Pattern live load factor
15 = Demand/capacity ratio limit
16 = Multi-response case design
Value: The value of the considered preference item.
1 = Combos equation
1 = 1 = Eq. 6.10
2 = Max of Eqs. 6.10a and 6.10b

2 = K factor method
1 = Method 1 (Annex A)
2 = Method 2 (Annex B)

3 = Pressure interaction method
1 = Method A
2 = Method B

4 = Framing type
1 = Moment Frame
2 = Braced Frame

5 = GammaM0
Value > 0

6 = GammeM1
Value > 0

7 = GammeM2
Value > 0

8 = Consider deflection
0 = No
Any other value = Yes

9 = DL deflection limit, L/Value
Value > 0

10 = SDL + LL deflection limit, L/Value
Value > 0

11 = LL deflection limit, L/Value
Value > 0

12 = Total deflection limit, L/Value
Value > 0

13 = Total camber limit, L/Value
Value > 0

14 = Pattern live load factor
Value >= 0

15 = Demand/capacity ratio limit
Value > 0

16 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Norsok_N004.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Norsok_N0042013:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 16, inclusive, indicating the preference item considered.
1 = Combos equation
2 = K factor method
3 = Pressure interaction method
4 = Framing type
5 = GammaM0
6 = GammeM1
7 = GammaM2
8 = Consider deflection
9 = DL deflection limit, L/Value
10 = SDL + LL deflection limit, L/Value
11 = LL deflection limit, L/Value
12 = Total deflection limit, L/Value
13 = Total camber limit, L/Value
14 = Pattern live load factor
15 = Demand/capacity ratio limit
16 = Multi-response case design
Value: The value of the considered preference item.
1 = Combos equation
1 = 1 = Eq. 6.10
2 = Max of Eqs. 6.10a and 6.10b

2 = K factor method
1 = Method 1 (Annex A)
2 = Method 2 (Annex B)

3 = Pressure interaction method
1 = Method A
2 = Method B

4 = Framing type
1 = Moment Frame
2 = Braced Frame

5 = GammaM0
Value > 0

6 = GammeM1
Value > 0

7 = GammeM2
Value > 0

8 = Consider deflection
0 = No
Any other value = Yes

9 = DL deflection limit, L/Value
Value > 0

10 = SDL + LL deflection limit, L/Value
Value > 0

11 = LL deflection limit, L/Value
Value > 0

12 = Total deflection limit, L/Value
Value > 0

13 = Total camber limit, L/Value
Value > 0

14 = Pattern live load factor
Value >= 0

15 = Demand/capacity ratio limit
Value > 0

16 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Norsok_N0042013.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 36, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, k Major
22 = Moment coefficient, k Minor
23 = Bending coefficient, C1
24 = Moment coefficient, kzy
25 = Moment coefficient, kyz
26 = Pressure equalized
27 = External pressure
28 = Yield stress, Fy
29 = Compressive capacity, Nc.Rd
30 = Tensile capacity, Nt.Rd
31 = Major bending capacity, Mc3.Rd
32 = Minor bending capacity, Mc2.Rd
33 = Buckling resistance moment, Mb.Rd
34 = Major shear capacity, V2.Rd
35 = Minor shear capacity, V3.RD
36 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, k Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, k Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, C1
Value >= 0; 0 means use program determined value.

24 = Moment coefficient, kzy
Value >= 0; 0 means use program determined value.

25 = Moment coefficient, kyz
Value >= 0; 0 means use program determined value.

26 = Pressure equalized
0 = Program Determined
1 = No
2 = Yes

27 = External pressure
Any value OK; Positive generates hoop compression and negative generates hoop tension. [F/L2]

28 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

29 = Compressive capacity, Nc.Rd
Value >= 0; 0 means use program determined value. [F]

30 = Tensile capacity, Nt.Rd
Value >= 0; 0 means use program determined value. [F]

31 = Major bending capacity, Mc3.Rd
Value >= 0; 0 means use program determined value. [FL]

32 = Minor bending capacity, Mc2.Rd
Value >= 0; 0 means use program determined value. [FL]

33 = Buckling resistance moment, Mb.Rd
Value >= 0; 0 means use program determined value. [FL]

34 = Major shear capacity, V2.Rd
Value >= 0; 0 means use program determined value. [F]

35 = Minor shear capacity, V3.RD
Value >= 0; 0 means use program determined value. [F]

36 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Norsok_N0042013.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 16, inclusive, indicating the preference item considered.
1 = Combos equation
2 = K factor method
3 = Pressure interaction method
4 = Framing type
5 = GammaM0
6 = GammeM1
7 = GammaM2
8 = Consider deflection
9 = DL deflection limit, L/Value
10 = SDL + LL deflection limit, L/Value
11 = LL deflection limit, L/Value
12 = Total deflection limit, L/Value
13 = Total camber limit, L/Value
14 = Pattern live load factor
15 = Demand/capacity ratio limit
16 = Multi-response case design
Value: The value of the considered preference item.
1 = Combos equation
1 = 1 = Eq. 6.10
2 = Max of Eqs. 6.10a and 6.10b

2 = K factor method
1 = Method 1 (Annex A)
2 = Method 2 (Annex B)

3 = Pressure interaction method
1 = Method A
2 = Method B

4 = Framing type
1 = Moment Frame
2 = Braced Frame

5 = GammaM0
Value > 0

6 = GammeM1
Value > 0

7 = GammeM2
Value > 0

8 = Consider deflection
0 = No
Any other value = Yes

9 = DL deflection limit, L/Value
Value > 0

10 = SDL + LL deflection limit, L/Value
Value > 0

11 = LL deflection limit, L/Value
Value > 0

12 = Total deflection limit, L/Value
Value > 0

13 = Total camber limit, L/Value
Value > 0

14 = Pattern live load factor
Value >= 0

15 = Demand/capacity ratio limit
Value > 0

16 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Norsok_N0042013.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 36, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, L/Value
5 = SDL + LL deflection limit, L/Value
6 = LL deflection limit, L/Value
7 = Total load deflection limit, L/Value
8 = Total camber limit, L/Value
9 = DL deflection limit, absolute
10 = SDL + LL deflection limit, absolute
11 = LL deflection limit, absolute
12 = Total load deflection limit, absolute
13 = Total camber limit, absolute
14 = Specified camber
15 = Net area to total area ratio
16 = Live load reduction factor
17 = Unbraced length ratio, Major
18 = Unbraced length ratio, Minor Lateral Torsional Buckling
19 = Effective length factor, K Major
20 = Effective length factor, K Minor
21 = Moment coefficient, k Major
22 = Moment coefficient, k Minor
23 = Bending coefficient, C1
24 = Moment coefficient, kzy
25 = Moment coefficient, kyz
26 = Pressure equalized
27 = External pressure
28 = Yield stress, Fy
29 = Compressive capacity, Nc.Rd
30 = Tensile capacity, Nt.Rd
31 = Major bending capacity, Mc3.Rd
32 = Minor bending capacity, Mc2.Rd
33 = Buckling resistance moment, Mb.Rd
34 = Major shear capacity, V2.Rd
35 = Minor shear capacity, V3.RD
36 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = As specified in preferences
1 = Moment Frame
2 = Braced Frame

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

5 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

9 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

10 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 0. [L]

15 = Net area to total area ratio
Value >= 0; 0 means use program default value.

16 = Live load reduction factor
Value >= 0; 0 means use program determined value.

17 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

19 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

21 = Moment coefficient, k Major
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, k Minor
Value >= 0; 0 means use program determined value.

23 = Bending coefficient, C1
Value >= 0; 0 means use program determined value.

24 = Moment coefficient, kzy
Value >= 0; 0 means use program determined value.

25 = Moment coefficient, kyz
Value >= 0; 0 means use program determined value.

26 = Pressure equalized
0 = Program Determined
1 = No
2 = Yes

27 = External pressure
Any value OK; Positive generates hoop compression and negative generates hoop tension. [F/L2]

28 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

29 = Compressive capacity, Nc.Rd
Value >= 0; 0 means use program determined value. [F]

30 = Tensile capacity, Nt.Rd
Value >= 0; 0 means use program determined value. [F]

31 = Major bending capacity, Mc3.Rd
Value >= 0; 0 means use program determined value. [FL]

32 = Minor bending capacity, Mc2.Rd
Value >= 0; 0 means use program determined value. [FL]

33 = Buckling resistance moment, Mb.Rd
Value >= 0; 0 means use program determined value. [FL]

34 = Major shear capacity, V2.Rd
Value >= 0; 0 means use program determined value. [F]

35 = Minor shear capacity, V3.RD
Value >= 0; 0 means use program determined value. [F]

36 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Norsok_N0042013.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

class NewZealand_NZS3404_1997:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

class Italian_NTC_2008:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design 
 overwrite item.
The function returns zero if the item is successfully 
 retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a steel frame design 
 procedure.
Item: This is an integer between 1 and 54, inclusive, indicating 
 the overwrite item considered.
1 
 = Framing type
2= 
 Consider deflection
3 
 = Deflection check type
4= 
 DL deflection limit, L/Value
5= 
 SDL + LL deflection limit, L/Value
6 
 = LL deflection limit, L/Value
7 
 = Total load deflection limit, L/Value
8 
 = Total camber limit, L/Value
9 
 = DL deflection limit, absolute
10 
 = SDL + LL deflection limit, absolute
11 
 = LL deflection limit, absolute
12 
 = Total load deflection limit, absolute
13 
 = Total camber limit, absolute
14 
 = Specified camber
15 
 = Net area to total area ratio
16 
 = Live load reduction factor
17 
 = Unbraced length ratio, Major
18 
 = Unbraced length ratio, Minor
19 
 = Effective length factor sway, K2 Major
20 
 = Effective length factor sway, K2 Minor
21 
 = Moment coefficient, kyy Major
22 
 = Moment coefficient, kzz Minor
23 
 = Bending coefficient, C1
24 = Moment coefficient, kzy
25 = Moment coefficient, kyz
26 
 = Yield stress, Fy
27 
 = Compressive capacity, Nc.Rd
28 
 = Tensile capacity, Nt.Rd
29 
 = Major bending capacity, Mc3.Rd
30 
 = Minor bending capacity, Mc2.Rd
31 
 = Buckling resistance moment, Mb.Rd
32 
 = Major shear capacity, V2.Rd
33 
 = Minor shear capacity, V3.Rd
34 
 = Demand/capacity ratio limit
35 
 = Section class
36 
 = Column buckling curve, y-y
37 
 = Column buckling curve, z-z
38 
 = Buckling curve for LTB
39 
 = System overstrength factor, Omega
40 
 = Is rolled section
41 
 = Unbraced length ratio, LTB
42 
 = Effective length factor braced, K1 Major
43 
 = Effective length factor braced, K1 Minor
44 
 = Effective length factor, K LTB
45 
 = Material overstrength factor, GammaRd
46 
 = Warping constant, Iw
47 
 = Elastic torsional buckling force, Ncr T
48 
 = Elastic torsional-flexural buckling force, Ncr TF
49 
 = Bending coefficient, C2
50 
 = Bending coefficient, C3
51 = Warping coefficient, kw
52 = Coordinate 
 of load application, za (used in Mcr calculation)
53 
 = Shear center coordinate, zs (used in Mcr calculation)
54 
 = Lateral-torsional buckling moment capacity, Mcr
Value >= 
 0; 0 means use program determined value. [FL]

Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = DCH-MRF
2 = DCL-MRF
3 = DCH-CBF
4 = DCL-CBF
5 = DCH-EBF
6 = DCL-EBF
7 = InvPendulum
8 = NonDissipative

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

5 = SDL + LL deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

6 = LL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

7 = Total load deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

8 = Total camber limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

9 = DL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

10 = SDL + LL deflection 
 limit, absolute
Value >= 
 0; 0 means no check for this item. [L]

11 = LL deflection limit, 
 absolute
Value >= 
 0; 0 means no check for this item. [L]

12 = Total load deflection 
 limit, absolute
Value >= 
 0; 0 means no check for this item. [L]

13 = Total camber limit, 
 absolute
Value >= 
 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 
 0. [L]

15 = Net area to total 
 area ratio
Value >= 
 0; 0 means use program default value.

16 = Live load reduction 
 factor
Value >= 
 0; 0 means use program determined value.

17 = Unbraced length ratio, 
 Major
Value >= 
 0; 0 means use program determined value.

18 = Unbraced length ratio, 
 Minor
Value >= 
 0; 0 means use program determined value.

19 = Effective length 
 factor sway, K2 Major
Value >= 
 0; 0 means use program determined value.

20 = Effective length 
 factor sway, K2 Minor
Value >= 
 0; 0 means use program determined value.

21 = Moment coefficient, 
 kyy Major
Value >= 
 0; 0 means use program determined value.

22 = Moment coefficient, 
 kzz Minor
Value >= 
 0; 0 means use program determined value.

23 = Bending coefficient, 
 C1
Value >= 
 0; 0 means use program determined value.

24 = Moment coefficient, 
 kzy
Value >= 
 0; 0 means use program determined value.

25 = Moment coefficient, 
 kyz
Value >= 
 0; 0 means use program determined value.

26 = Yield stress, Fy
Value >= 
 0; 0 means use program determined value. [F/L2]

27 = Compressive capacity, 
 Nc.Rd
Value >= 
 0; 0 means use program determined value. [F]

28 = Tensile capacity, 
 Nt.Rd
Value >= 
 0; 0 means use program determined value. [F]

29 = Major bending capacity, 
 Mc3.Rd
Value >= 
 0; 0 means use program determined value. [FL]

30 = Minor bending capacity, 
 Mc2.Rd
Value >= 
 0; 0 means use program determined value. [FL]

31 = Buckling resistance 
 moment, Mb.Rd
Value >= 
 0; 0 means use program determined value. [FL]

32 = Major shear capacity, 
 V2.Rd
Value >= 
 0; 0 means use program determined value. [F]

33 = Minor shear capacity, 
 V3.Rd
Value >= 
 0; 0 means use program determined value. [F]

34 = Demand/capacity ratio 
 limit
Value >= 0; 
 0 means use program determined value.
35 = Section class
0 = Program default
1 = Class 1
2 = Class 2
3 = Class 3
4 = Class 4

36 = Column buckling curve, 
 y-y
0 = Program default
1 = a0
2 = a
3 = b
4 = c
5 = d

37 = Column buckling curve, 
 z-z
0 = Program default
1 = a0
2 = a
3 = b
4 = c
5 = d

38 
 = Buckling curve for LTB
0 = Program default
1 = a0
2 = a
3 = b
4 = c
5 = d

39 = System overstrength factor, 
 Omega
Value >= 0; 0 means use 
 program determined value.

40 = Is rolled section
0 = Program Determined
1 = No
2 = Yes

41 = Unbraced length ratio, 
 LTB
Value >= 0; 0 means use 
 program determined value.

42 = Effective length factor 
 braced, K1 Major
Value >= 0; 0 means use 
 program determined value.

43 = Effective length factor 
 braced, K1 Minor
Value >= 0; 0 means use 
 program determined value.

44 = Effective length factor, 
 K LTB
Value >= 0; 0 means use 
 program determined value.

45 = Material overstrength 
 factor, GammaRd
Value >= 0; 0 means use 
 program determined value.

46 = Warping constant, Iw
Value >= 0; 0 means use 
 program determined value. [L6]

47 = Elastic torsional buckling 
 force, Ncr T
Value >= 0; 0 means use 
 program determined value. [F]

48 = Elastic torsional-flexural 
 buckling force, Ncr TF
Value >= 0; 0 means use 
 program determined value. [F]

49 = Bending coefficient, 
 C2
Value >= 0; 0 means 
 use program determined value.

50 = Bending coefficient, 
 C3
Value >= 0; 0 means 
 use program determined value.

51 = Warping coefficient, 
 kw (used in Mcr calculation)
0.5 =<Value =< 
 1; 0 means use program determined value which is defaulted to 1.0.

52 
 = Coordinate of load application, za (used in Mcr 
 calculation)
53 
 = Shear center coordinate, zs (used in Mcr calculation)
54 
 = Lateral-torsional buckling moment capacity, Mcr
Value >= 
 0; 0 means use program determined value. [FL] 
ProgDet: If this item is True, the specified value is program 
 determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Italian_NTC_2008.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Item: This is an integer between 3 and 23, inclusive, indicating the preference item considered.
3 = Method Used for Buckling in P-M-M
4 = Framing type
5 = GammaM0
6 = GammeM1
7 = GammaM2
8 = Consider deflection
9 = DL deflection limit, L/Value
10 = SDL + LL deflection limit, L/Value
11 = LL deflection limit, L/Value
12 = Total deflection limit, L/Value
13 = Total camber limit, L/Value
14 = Pattern live load factor
15 = Demand/capacity ratio limit
16 = Multi-Response Case Design
17 = Behavior Factor, q0
18 = System Overstrength Factor, W
19 = Consider P-Delta
20 = Consider Torsion
21 = Ignore Seismic Code
22 = Ignore Special Seismic Load
23 = Is Doubler Plate Plug-Welded

Value: The value of the considered preference item.
3 = K factor method
1 = Method A
2 = Method B (default)
3 = Both

4 = Framing type
1 = DCH-MRF (Default)
2 = DCL-MRF
3 = DCH-CBF
4 = DCL-CBF
5 = DCH-EBF
6 = DCL-EBF
7 = InvPendulum
8 = NonDissipative

5 = GammaM0
Default = 1.05, Value > 0

6 = GammaM1
Default = 1.05, Value > 0

7 = GammaM2
Default = 1.25, Value > 0

8 = Consider deflection
Default = No = 1, Yes = 2

9 = DL deflection limit, L/Value
Default = 120, Value > 0

10 = SDL + LL deflection limit, L/Value
Default = 120, Value > 0

11 = LL deflection limit, L/Value
Default = 360, Value > 0

12 = Total deflection limit, L/Value
Default = 240, Value > 0

13 = Total camber limit, L/Value
Default = 240, Value > 0

14 = Pattern live load factor
Default = 0, Value >= 0

15 = Demand/capacity ratio limit
Default = 0.95, Value > 0

16 = Multi-response case design
1 = Envelopes (Default)
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

17 = Behavior Factor, q0
Default = 4, Value > 0

18 = System Overstrength Factor, W
Default = 1.0, Value > 0

19 = Consider P-Delta
Default = No = 1, Yes = 2

20 = Consider Torsion
Default = No = 1, Yes = 2

21 = Ignore Seismic Code
Default = No = 1, Yes = 2

22 = Ignore Special Seismic Load
Default = No = 1, Yes = 2

23 = Is Doubler Plate Plug-Welded
No = 1, Default = Yes = 2

        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Italian_NTC_2008.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite 
 item.
The function returns zero if the item is successfully 
 set; otherwise, it returns a nonzero value.

Name: The name of an existing frame object or group depending 
 on the value of the ItemType item.
Item: This is an integer between 1 and 54, inclusive, indicating 
 the overwrite item considered.
1 = Framing type
2 = Consider deflection
3 = Deflection check type
4 = DL deflection limit, 
 L/Value
5 = SDL + LL deflection 
 limit, L/Value
6 = LL deflection limit, 
 L/Value
7 = Total load deflection 
 limit, L/Value
8 = Total camber limit, 
 L/Value
9 = DL deflection limit, 
 absolute
10 = SDL + LL deflection 
 limit, absolute
11 = LL deflection limit, 
 absolute
12 = Total load deflection 
 limit, absolute
13 = Total camber limit, 
 absolute
14 = Specified camber
15 = Net area to total 
 area ratio
16 = Live load reduction 
 factor
17 = Unbraced length ratio, 
 Major
18 = Unbraced length ratio, 
 Minor
19 = Effective length 
 factor, K2 Major
20 = Effective length 
 factor, K2 Minor
21 = Moment coefficient, 
 kyy Major
22 = Moment coefficient, 
 kzz Minor
23 = Bending coefficient, 
 C1
24 
 = Moment coefficient, kzy
25 
 = Moment coefficient, kyz
26 = Yield stress, Fy
27 = Compressive capacity, 
 Nc.Rd
28 = Tensile capacity, 
 Nt.Rd
29 = Major bending capacity, 
 Mc3.Rd
30 = Minor bending capacity, 
 Mc2.Rd
31 = Buckling resistance 
 moment, Mb.Rd
32 = Major shear capacity, 
 V2.Rd
33 = Minor shear capacity, 
 V3.RD
34 = Demand/capacity ratio 
 limit
35 = Section class
36 = Column buckling curve, 
 y-y
37 = Column buckling curve, 
 z-z
38 = Buckling curve for LTB
39 = System overstrength factor, 
 Omega
40 = Is rolled section
41 = Unbraced length ratio, 
 LTB
42 = Effective length factor 
 braced, K1 Major
43 = Effective length factor 
 braced, K1 Minor
44 = Effective length factor, 
 K LTB
45 = Material overstrength 
 factor, GammaRd
46 = Warping constant, Iw
47 = Elastic torsional buckling 
 force, Ncr T
48 = Elastic torsional-flexural 
 buckling force, Ncr TF
49 
 = Bending coefficient, C2
50 = Bending coefficient, C3
51 = Warping coefficient, kw
52 = Coordinate of load 
 application, za
53 
 = Shear center coordinate, zs
54 
 = Lateral-torsional buckling moment capacity, Mcr
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = DCH-MRF
2 = DCL-MRF
3 = DCH-CBF
4 = DCL-CBF
5 = DCH-EBF
6 = DCL-EBF
7 = InvPendulum
8 = NonDissipative

2 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

3 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

4 = DL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

5 = SDL + LL deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

6 = LL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

7 = Total load deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

8 = Total camber limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

9 = DL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

10 = SDL + LL deflection 
 limit, absolute
Value >= 
 0; 0 means no check for this item. [L]

11 = LL deflection limit, 
 absolute
Value >= 
 0; 0 means no check for this item. [L]

12 = Total load deflection 
 limit, absolute
Value >= 
 0; 0 means no check for this item. [L]

13 = Total camber limit, 
 absolute
Value >= 
 0; 0 means no check for this item. [L]

14 = Specified camber
Value >= 
 0. [L]

15 = Net area to total 
 area ratio
Value >= 
 0; 0 means use program default value.

16 = Live load reduction 
 factor
Value >= 
 0; 0 means use program determined value.

17 = Unbraced length ratio, 
 Major
Value >= 
 0; 0 means use program determined value.

18 = Unbraced length ratio, 
 Minor
Value >= 
 0; 0 means use program determined value.

19 = Effective length 
 factor sway, K2 Major
Value >= 
 0; 0 means use program determined value.

20 = Effective length 
 factor sway, K2 Minor
Value >= 
 0; 0 means use program determined value.

21 = Moment coefficient, 
 kyy Major
Value >= 
 0; 0 means use program determined value.

22 = Moment coefficient, 
 kzz Minor
Value >= 
 0; 0 means use program determined value.

23 = Bending coefficient, 
 C1
Value >= 
 0; 0 means use program determined value.

24 = Moment coefficient, 
 kzy
Value >= 
 0; 0 means use program determined value.

25 = Moment coefficient, 
 kyz
Value >= 
 0; 0 means use program determined value.

26 = Yield stress, Fy
Value >= 
 0; 0 means use program determined value. [F/L2]

27 = Compressive capacity, 
 Nc.Rd
Value >= 
 0; 0 means use program determined value. [F]

28 = Tensile capacity, 
 Nt.Rd
Value >= 
 0; 0 means use program determined value. [F]

29 = Major bending capacity, 
 Mc3.Rd
Value >= 
 0; 0 means use program determined value. [FL]

30 = Minor bending capacity, 
 Mc2.Rd
Value >= 
 0; 0 means use program determined value. [FL]

31 = Buckling resistance 
 moment, Mb.Rd
Value >= 
 0; 0 means use program determined value. [FL]

32 = Major shear capacity, 
 V2.Rd
Value >= 
 0; 0 means use program determined value. [F]

33 = Minor shear capacity, 
 V3.Rd
Value >= 
 0; 0 means use program determined value. [F]

34 = Demand/capacity ratio 
 limit
Value >= 0; 
 0 means use program determined value.
35 = Section class
0 = Program default
1 = Class 1
2 = Class 2
3 = Class 3
4 = Class 4

36 = Column buckling curve, 
 y-y
0 = Program default
1 = a0
2 = a
3 = b
4 = c
5 = d

37 = Column buckling curve, 
 z-z
0 = Program default
1 = a0
2 = a
3 = b
4 = c
5 = d

38 
 = Buckling curve for LTB
0 = Program default
1 = a0
2 = a
3 = b
4 = c
5 = d

39 = System overstrength factor, 
 Omega
Value >= 0; 0 means use 
 program determined value.

40 = Is rolled section
0 = Program Determined
1 = No
2 = Yes

41 = Unbraced length ratio, 
 LTB
Value >= 0; 0 means use 
 program determined value.

42 = Effective length factor 
 braced, K1 Major
Value >= 0; 0 means use 
 program determined value.

43 = Effective length factor 
 braced, K1 Minor
Value >= 0; 0 means use 
 program determined value.

44 = Effective length factor, 
 K LTB
Value >= 0; 0 means use 
 program determined value.

45 = Material overstrength 
 factor, GammaRd
Value >= 0; 0 means use 
 program determined value.

46 = Warping constant, Iw
Value >= 0; 0 means use 
 program determined value. [L6]

47 = Elastic torsional buckling 
 force, Ncr T
Value >= 0; 0 means use 
 program determined value. [F]

48 = Elastic torsional-flexural 
 buckling force, Ncr TF
Value >= 0; 0 means 
 use program determined value. [F]

49 
 = Bending coefficient, C2
Value >= 0; 0 means 
 use program determined value.

50 = Bending coefficient, 
 C3
Value >= 0; 0 means 
 use program determined value.

51 = Warping coefficient, 
 kw (used in Mcr calculation)
0.5 =<Value =< 
 1; 0 means use program determined value which is defaulted to 1.0.

52 = Coordinate 
 of load application, za (used in Mcr calculation)
53 
 = Shear center coordinate, zs (used in Mcr calculation)
54 
 = Lateral-torsional buckling moment capacity, Mcr
Value >= 
 0; 0 means use program determined value. [FL]
ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the 
 frame object specified by the Name item.
If this item is Group, the assignment is made to all 
 frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made 
 to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Italian_NTC_2008.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise, it returns a nonzero value.

Item: This is an integer between 3 and 23, inclusive, indicating the preference item considered.
3 = Method Used for Buckling in P-M-M
4 = Framing type
5 = GammaM0
6 = GammeM1
7 = GammaM2
8 = Consider deflection
9 = DL deflection limit, L/Value
10 = SDL + LL deflection limit, L/Value
11 = LL deflection limit, L/Value
12 = Total deflection limit, L/Value
13 = Total camber limit, L/Value
14 = Pattern live load factor
15 = Demand/capacity ratio limit
16 = Multi-Response Case Design
17 = Behavior Factor, q0
18 = System Overstrength Factor, W
19 = Consider P-Delta
20 = Consider Torsion
21 = Ignore Seismic Code
22 = Ignore Special Seismic Load
23 = Is Doubler Plate Plug-Welded

Value: The value of the considered preference item.
3 = K factor method
1 = Method A
2 = Method B (default)
3 = Both

4 = Framing type
1 = DCH-MRF (Default)
2 = DCL-MRF
3 = DCH-CBF
4 = DCL-CBF
5 = DCH-EBF
6 = DCL-EBF
7 = InvPendulum
8 = NonDissipative

5 = GammaM0
Default = 1.05, Value > 0

6 = GammaM1
Default = 1.05, Value > 0

7 = GammaM2
Default = 1.25, Value > 0

8 = Consider deflection
Default = No = 1, Yes = 2

9 = DL deflection limit, L/Value
Default = 120, Value > 0

10 = SDL + LL deflection limit, L/Value
Default = 120, Value > 0

11 = LL deflection limit, L/Value
Default = 360, Value > 0

12 = Total deflection limit, L/Value
Default = 240, Value > 0

13 = Total camber limit, L/Value
Default = 240, Value > 0

14 = Pattern live load factor
Default = 0, Value >= 0

15 = Demand/capacity ratio limit
Default = 0.95, Value > 0

16 = Multi-response case design
1 = Envelopes (Default)
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

17 = Behavior Factor, q0
Default = 4, Value > 0

18 = System Overstrength Factor, W
Default = 1.0, Value > 0

19 = Consider P-Delta
Default = No = 1, Yes = 2

20 = Consider Torsion
Default = No = 1, Yes = 2

21 = Ignore Seismic Code
Default = No = 1, Yes = 2

22 = Ignore Special Seismic Load
Default = No = 1, Yes = 2

23 = Is Doubler Plate Plug-Welded
No = 1, Default = Yes = 2
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Italian_NTC_2008.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Italian_NTC_2018:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design 
 preference item.
The function returns zero if the item is successfully 
 retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a steel frame design 
 procedure.
Item: This is an integer between 1 and 55, inclusive, indicating 
 the overwrite item considered.
1 = Current Design Section
2 = Framing type
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, 
 L/Value
6 = SDL + LL deflection 
 limit, L/Value
7 = LL deflection limit, 
 L/Value
8 = Total load deflection 
 limit, L/Value
9 = Total camber limit, 
 L/Value
10 = DL deflection limit, 
 absolute
11 = SDL + LL deflection 
 limit, absolute
12 = LL deflection limit, 
 absolute
13 = Total load deflection 
 limit, absolute
14 = Total camber limit, 
 absolute
15 = Specified camber
16 = Net area to total 
 area ratio
17 = Live load reduction 
 factor
18 = Unbraced length ratio, 
 Major
19 = Unbraced length ratio, 
 Minor
20 = Effective length 
 factor, K2 Major
21 = Effective length 
 factor, K2 Minor
22 = Moment coefficient, 
 kyy Major
23 = Moment coefficient, 
 kzz Minor
24 = Bending coefficient, 
 C1
25 
 = Moment coefficient, kzy
26 
 = Moment coefficient, kyz
27 = Yield stress, Fy
28 = Compressive capacity, 
 Nc.Rd
29 = Tensile capacity, 
 Nt.Rd
30 = Major bending capacity, 
 Mc3.Rd
31 = Minor bending capacity, 
 Mc2.Rd
32 = Buckling resistance 
 moment, Mb.Rd
33 = Major shear capacity, 
 V2.Rd
34 = Minor shear capacity, 
 V3.RD
35 = Demand/capacity ratio 
 limit
36 = Section class
37 = Column buckling curve, 
 y-y
38 = Column buckling curve, 
 z-z
39 = Buckling curve for LTB
40 = System overstrength factor, 
 Omega
41 = Is rolled section
42 = Unbraced length ratio, 
 LTB
43 = Effective length factor 
 braced, K1 Major
44 = Effective length factor 
 braced, K1 Minor
45 = Effective length factor, 
 K LTB
46 = Material overstrength 
 factor, GammaRd
47 = Warping constant, Iw
48 = Elastic torsional buckling 
 force, Ncr T
49 = Elastic torsional-flexural 
 buckling force, Ncr TF
50 
 = Bending coefficient, C2
51 = Bending coefficient, 
 C3
52 = Warping coefficient, 
 kw 
53 
 = Coordinate of load application, za 
54 
 = Shear center coordinate, zs
55 
 = Lateral-torsional buckling moment capacity, Mcr

Value: The value of the considered overwrite item.
1 = Current design section
0 or "Program 
 Determined"
String corresponding 
 to desired shape overwrite, e.g. "W14x26" or "W14X26".

2 = Framing type
0 or "Program Default"
1 or "DCH-MRF"
2 or "DCL-MRF"
3 or "DCH-CBF"
4 or "DCL-CBF"
5 or "DCH-EBF"
6 or "DCL-EBF"
7 or "InvPendulum"
8 or "NonDissipative"

3 = Consider deflection
0 or "Program Default"
1 or "No"
2 or "Yes"

4 = Deflection check type
0 or "Program Default"
1 or "Ratio"
2 or "Absolute"
3 or "Both"

5 = DL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

6 = SDL + LL deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

7 = LL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

8 = Total load deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

9 = Total camber limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

10 = DL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

11 = SDL + LL deflection 
 limit, absolute
Value >= 
 0; 0 means no check for this item. [L]

12 = LL deflection limit, 
 absolute
Value >= 
 0; 0 means no check for this item. [L]

13 = Total load deflection 
 limit, absolute
Value >= 
 0; 0 means no check for this item. [L]

14 = Total camber limit, 
 absolute
Value >= 
 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 
 0. [L]

16 = Net area to total 
 area ratio
Value >= 
 0; 0 means use program default value.

17 = Live load reduction 
 factor
Value >= 
 0; 0 means use program determined value.

18 = Unbraced length ratio, 
 Major
Value >= 
 0; 0 means use program determined value.

19 = Unbraced length ratio, 
 Minor
Value >= 
 0; 0 means use program determined value.

20 = Effective length 
 factor sway, K2 Major
Value >= 
 0; 0 means use program determined value.

21 = Effective length 
 factor sway, K2 Minor
Value >= 
 0; 0 means use program determined value.

22 = Moment coefficient, 
 kyy Major
Value >= 
 0; 0 means use program determined value.

23 = Moment coefficient, 
 kzz Minor
Value >= 
 0; 0 means use program determined value.

24 = Bending coefficient, 
 C1
Value >= 
 0; 0 means use program determined value.

25 = Moment coefficient, 
 kzy
Value >= 
 0; 0 means use program determined value.

26 = Moment coefficient, 
 kyz
Value >= 
 0; 0 means use program determined value.

27 = Yield stress, Fy
Value >= 
 0; 0 means use program determined value. [F/L2]

28 = Compressive capacity, 
 Nc.Rd
Value >= 
 0; 0 means use program determined value. [F]

29 = Tensile capacity, 
 Nt.Rd
Value >= 
 0; 0 means use program determined value. [F]

30 = Major bending capacity, 
 Mc3.Rd
Value >= 
 0; 0 means use program determined value. [FL]

31 = Minor bending capacity, 
 Mc2.Rd
Value >= 
 0; 0 means use program determined value. [FL]

32 = Buckling resistance 
 moment, Mb.Rd
Value >= 
 0; 0 means use program determined value. [FL]

33 = Major shear capacity, 
 V2.Rd
Value >= 
 0; 0 means use program determined value. [F]

34 = Minor shear capacity, 
 V3.Rd
Value >= 
 0; 0 means use program determined value. [F]

35 = Demand/capacity ratio 
 limit
Value >= 0; 
 0 means use program determined value.
36 = Section class
0 or "Program default"
1 or "Class 1"
2 or "Class 2"
3 or "Class 3"
4 or "Class 4"

37 = Column buckling curve, 
 y-y
0 or "Program default"
1 or "a0"
2 or "a"
3 or "b"
4 or "c"
5 or "d"

38 = Column buckling curve, 
 z-z
0 or "Program default"
1 or "a0"
2 or "a"
3 or "b"
4 or "c"
5 or "d"

39 = Buckling curve for LTB
0 or "Program default"
1 or "a0"
2 or "a"
3 or "b"
4 or "c"
5 or "d"

40 = System overstrength factor, 
 Omega
Value >= 0; 0 means use 
 program determined value.

41 = Is rolled section
0 or "Program Determined"
1 or "No"
2 or "Yes"

42 = Unbraced length ratio, 
 LTB
Value >= 0; 0 means use 
 program determined value.

43 = Effective length factor 
 braced, K1 Major
Value >= 0; 0 means use 
 program determined value.

44 = Effective length factor 
 braced, K1 Minor
Value >= 0; 0 means use 
 program determined value.

45 = Effective length factor, 
 K LTB
Value >= 0; 0 means use 
 program determined value.

46 = Material overstrength 
 factor, GammaRd
Value >= 0; 0 means use 
 program determined value.

47 = Warping constant, Iw
Value >= 0; 0 means use 
 program determined value. [L6]

48 = Elastic torsional buckling 
 force, Ncr T
Value >= 0; 0 means use 
 program determined value. [F]

49 = Elastic torsional-flexural 
 buckling force, Ncr TF
Value >= 0; 0 means 
 use program determined value. [F]

50 
 = Bending coefficient, C2
Value >= 0; 0 means 
 use program determined value.

51 = Bending coefficient, 
 C3
Value >= 0; 0 means 
 use program determined value.

52 = Warping coefficient, 
 kw (used in Mcr calculation)
0.5 =<Value =< 
 1; 0 means use program determined value which is defaulted to 1.0.

53 = Coordinate of load 
 application, za (used in Mcr calculation)
54 
 = Shear center coordinate, zs (used in Mcr calculation)
55 
 = Lateral-torsional buckling moment capacity, Mcr
Value >= 
 0; 0 means use program determined value. [FL] 
ProgDet: If this item is True, the specified value is program 
 determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Italian_NTC_2018.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Item: This is an integer between 3 and 23, inclusive, indicating the preference item considered.
3 = Method Used for Buckling in P-M-M
4 = Framing type
5 = GammaM0
6 = GammeM1
7 = GammaM2
8 = Consider deflection
9 = DL deflection limit, L/Value
10 = SDL + LL deflection limit, L/Value
11 = LL deflection limit, L/Value
12 = Total deflection limit, L/Value
13 = Total camber limit, L/Value
14 = Pattern live load factor
15 = Demand/capacity ratio limit
16 = Multi-Response Case Design
17 = Behavior Factor, q0
18 = System Overstrength Factor, W
19 = Consider P-Delta
20 = Consider Torsion
21 = Ignore Seismic Code
22 = Ignore Special Seismic Load
23 = Is Doubler Plate Plug-Welded

Value: The value of the considered preference item.
3 = K factor method
1 or "Method A"
2 or "Method B" - Default
3 or "Both"

4 = Framing type
1 or "DCH-MRF"
2 or "DCL-MRF"
3 or "DCH-CBF"
4 or "DCL-CBF"
5 or "DCH-EBF"
6 or "DCL-EBF"
7 or "InvPendulum"
8 or "Non Dissipative" - (Default)

5 = GammaM0
Default = 1.05, Value > 0

6 = GammaM1
Default = 1.05, Value > 0

7 = GammaM2
Default = 1.25, Value > 0

8 = Consider deflection
1 or "No" - Default
2 or "Yes"

9 = DL deflection limit, L/Value
Default = 0, Value > 0

10 = SDL + LL deflection limit, L/Value
Default = 0, Value > 0

11 = LL deflection limit, L/Value
Default = 300, Value > 0

12 = Total deflection limit, L/Value
Default = 0, Value > 0

13 = Total camber limit, L/Value
Default = 250, Value > 0

14 = Pattern live load factor
Default = 0, Value >= 0

15 = Demand/capacity ratio limit
Default = 1.0, Value > 0

16 = Multi-response case design
1 or "Envelopes" - (Default)
2 or "Step-by-step"
3 or "Last step"
4 or "Envelopes -- All"
5 or "Step-by-step -- All"

17 = Behavior Factor, q0
Default = 1, Value > 0

18 = System Overstrength Factor, W
Default = 1.0, Value > 0

19 = Consider P-Delta
1 or "No" - Default
2 or "Yes"

20 = Consider Torsion
1 or "No" - Default
2 or "Yes"

21 = Ignore Seismic Code
1 or "No" - Default
2 or "Yes"

22 = Ignore Special Seismic Load
1 or "No" - Default
2 or "Yes"

23 = Is Doubler Plate Plug-Welded
1 or "No" - Default
2 or "Yes"

        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Italian_NTC_2018.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite 
 item.
The function returns zero if the item is successfully 
 set; otherwise, it returns a nonzero value.

Name: The name of an existing frame object or group depending 
 on the value of the ItemType item.
Item: This is an integer between 1 and 55, inclusive, indicating 
 the overwrite item considered.
1 = Current Design Section
2 = Framing type
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, 
 L/Value
6 = SDL + LL deflection 
 limit, L/Value
7 = LL deflection limit, 
 L/Value
8 = Total load deflection 
 limit, L/Value
9 = Total camber limit, 
 L/Value
10 = DL deflection limit, 
 absolute
11 = SDL + LL deflection 
 limit, absolute
12 = LL deflection limit, 
 absolute
13 = Total load deflection 
 limit, absolute
14 = Total camber limit, 
 absolute
15 = Specified camber
16 = Net area to total 
 area ratio
17 = Live load reduction 
 factor
18 = Unbraced length ratio, 
 Major
19 = Unbraced length ratio, 
 Minor
20 = Effective length 
 factor, K2 Major
21 = Effective length 
 factor, K2 Minor
22 = Moment coefficient, 
 kyy Major
23 = Moment coefficient, 
 kzz Minor
24 = Bending coefficient, 
 C1
25 
 = Moment coefficient, kzy
26 
 = Moment coefficient, kyz
27 = Yield stress, Fy
28 = Compressive capacity, 
 Nc.Rd
29 = Tensile capacity, 
 Nt.Rd
30 = Major bending capacity, 
 Mc3.Rd
31 = Minor bending capacity, 
 Mc2.Rd
32 = Buckling resistance 
 moment, Mb.Rd
33 = Major shear capacity, 
 V2.Rd
34 = Minor shear capacity, 
 V3.RD
35 = Demand/capacity ratio 
 limit
36 = Section class
37 = Column buckling curve, 
 y-y
38 = Column buckling curve, 
 z-z
39 = Buckling curve for LTB
40 = System overstrength factor, 
 Omega
41 = Is rolled section
42 = Unbraced length ratio, 
 LTB
43 = Effective length factor 
 braced, K1 Major
44 = Effective length factor 
 braced, K1 Minor
45 = Effective length factor, 
 K LTB
46 = Material overstrength 
 factor, GammaRd
47 = Warping constant, Iw
48 = Elastic torsional buckling 
 force, Ncr T
49 = Elastic torsional-flexural 
 buckling force, Ncr TF
50 
 = Bending coefficient, C2
51 = Bending coefficient, 
 C3
52 = Warping coefficient, 
 kw 
53 = Coordinate of load 
 application, za 
54 
 = Shear center coordinate, zs
55 
 = Lateral-torsional buckling moment capacity, Mcr
Value: The value of the considered overwrite item.
1 = Current design section
0 or "Program 
 Determined"
String corresponding 
 to desired shape overwrite, e.g. "W14x26" or "W14X26".

2 = Framing type
0 or "Program Default"
1 or "DCH-MRF"
2 or "DCL-MRF"
3 or "DCH-CBF"
4 or "DCL-CBF"
5 or "DCH-EBF"
6 or "DCL-EBF"
7 or "InvPendulum"
8 or "NonDissipative"

3 = Consider deflection
0 or "Program Default"
1 or "No"
2 or "Yes"

4 = Deflection check type
0 or "Program Default"
1 or "Ratio"
2 or "Absolute"
3 or "Both"

5 = DL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

6 = SDL + LL deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

7 = LL deflection limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

8 = Total load deflection 
 limit, L/Value
Value >= 0; 0 means 
 no check for this item.

9 = Total camber limit, 
 L/Value
Value >= 0; 0 means 
 no check for this item.

10 = DL deflection limit, 
 absolute
Value >= 0; 0 means 
 no check for this item. [L]

11 = SDL + LL deflection 
 limit, absolute
Value >= 
 0; 0 means no check for this item. [L]

12 = LL deflection limit, 
 absolute
Value >= 
 0; 0 means no check for this item. [L]

13 = Total load deflection 
 limit, absolute
Value >= 
 0; 0 means no check for this item. [L]

14 = Total camber limit, 
 absolute
Value >= 
 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 
 0. [L]

16 = Net area to total 
 area ratio
Value >= 
 0; 0 means use program default value.

17 = Live load reduction 
 factor
Value >= 
 0; 0 means use program determined value.

18 = Unbraced length ratio, 
 Major
Value >= 
 0; 0 means use program determined value.

19 = Unbraced length ratio, 
 Minor
Value >= 
 0; 0 means use program determined value.

20 = Effective length 
 factor sway, K2 Major
Value >= 
 0; 0 means use program determined value.

21 = Effective length 
 factor sway, K2 Minor
Value >= 
 0; 0 means use program determined value.

22 = Moment coefficient, 
 kyy Major
Value >= 
 0; 0 means use program determined value.

23 = Moment coefficient, 
 kzz Minor
Value >= 
 0; 0 means use program determined value.

24 = Bending coefficient, 
 C1
Value >= 
 0; 0 means use program determined value.

25 = Moment coefficient, 
 kzy
Value >= 
 0; 0 means use program determined value.

26 = Moment coefficient, 
 kyz
Value >= 
 0; 0 means use program determined value.

27 = Yield stress, Fy
Value >= 
 0; 0 means use program determined value. [F/L2]

28 = Compressive capacity, 
 Nc.Rd
Value >= 
 0; 0 means use program determined value. [F]

29 = Tensile capacity, 
 Nt.Rd
Value >= 
 0; 0 means use program determined value. [F]

30 = Major bending capacity, 
 Mc3.Rd
Value >= 
 0; 0 means use program determined value. [FL]

31 = Minor bending capacity, 
 Mc2.Rd
Value >= 
 0; 0 means use program determined value. [FL]

32 = Buckling resistance 
 moment, Mb.Rd
Value >= 
 0; 0 means use program determined value. [FL]

33 = Major shear capacity, 
 V2.Rd
Value >= 
 0; 0 means use program determined value. [F]

34 = Minor shear capacity, 
 V3.Rd
Value >= 
 0; 0 means use program determined value. [F]

35 = Demand/capacity ratio 
 limit
Value >= 0; 
 0 means use program determined value.
36 = Section class
0 or "Program default"
1 or "Class 1"
2 or "Class 2"
3 or "Class 3"
4 or "Class 4"

37 = Column buckling curve, 
 y-y
0 or "Program default"
1 or "a0"
2 or "a"
3 or "b"
4 or "c"
5 or "d"

38 = Column buckling curve, 
 z-z
0 or "Program default"
1 or "a0"
2 or "a"
3 or "b"
4 or "c"
5 or "d"

39 = Buckling curve for LTB
0 or "Program default"
1 or "a0"
2 or "a"
3 or "b"
4 or "c"
5 or "d"

40 = System overstrength factor, 
 Omega
Value >= 0; 0 means use 
 program determined value.

41 = Is rolled section
0 or "Program Determined"
1 or "No"
2 or "Yes"

42 = Unbraced length ratio, 
 LTB
Value >= 0; 0 means use 
 program determined value.

43 = Effective length factor 
 braced, K1 Major
Value >= 0; 0 means use 
 program determined value.

44 = Effective length factor 
 braced, K1 Minor
Value >= 0; 0 means use 
 program determined value.

45 = Effective length factor, 
 K LTB
Value >= 0; 0 means use 
 program determined value.

46 = Material overstrength 
 factor, GammaRd
Value >= 0; 0 means use 
 program determined value.

47 = Warping constant, Iw
Value >= 0; 0 means use 
 program determined value. [L6]

48 = Elastic torsional buckling 
 force, Ncr T
Value >= 0; 0 means use 
 program determined value. [F]

49 = Elastic torsional-flexural 
 buckling force, Ncr TF
Value >= 0; 0 means 
 use program determined value. [F]

50 
 = Bending coefficient, C2
Value >= 0; 0 means 
 use program determined value.

51 = Bending coefficient, 
 C3
Value >= 0; 0 means 
 use program determined value.

52 = Warping coefficient, 
 kw (used in Mcr calculation)
0.5 =<Value =< 
 1; 0 means use program determined value which is defaulted to 1.0.

53 = Coordinate of load 
 application, za (used in Mcr calculation)
54 = Shear center coordinate, 
 zs (used in Mcr calculation)
55 
 = Lateral-torsional buckling moment capacity, Mcr
Value >= 
 0; 0 means use program determined value. [FL] 

ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the 
 frame object specified by the Name item.
If this item is Group, the assignment is made to all 
 frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made 
 to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Italian_NTC_2018.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise, it returns a nonzero value.

Item: This is an integer between 3 and 23, inclusive, indicating the preference item considered.
3 = Method Used for Buckling in P-M-M
4 = Framing type
5 = GammaM0
6 = GammeM1
7 = GammaM2
8 = Consider deflection
9 = DL deflection limit, L/Value
10 = SDL + LL deflection limit, L/Value
11 = LL deflection limit, L/Value
12 = Total deflection limit, L/Value
13 = Total camber limit, L/Value
14 = Pattern live load factor
15 = Demand/capacity ratio limit
16 = Multi-Response Case Design
17 = Behavior Factor, q0
18 = System Overstrength Factor, W
19 = Consider P-Delta
20 = Consider Torsion
21 = Ignore Seismic Code
22 = Ignore Special Seismic Load
23 = Is Doubler Plate Plug-Welded

Value: The value of the considered preference item.
3= K factor method
1 or "Method A"
2 or "Method B" - Default
3 or "Both"

4 = Framing type
1 or "DCH-MRF"
2 or "DCL-MRF"
3 or "DCH-CBF"
4 or "DCL-CBF"
5 or "DCH-EBF"
6 or "DCL-EBF"
7 or "InvPendulum"
8 or "Non Dissipative" - (Default)

5 = GammaM0
Default = 1.05, Value > 0

6 = GammaM1
Default = 1.05, Value > 0

7 = GammaM2
Default = 1.25, Value > 0

8 = Consider deflection
1 or "No" - Default
2 or "Yes"

9 = DL deflection limit, L/Value
Default = 0, Value > 0

10 = SDL + LL deflection limit, L/Value
Default = 0, Value > 0

11 = LL deflection limit, L/Value
Default = 300, Value > 0

12 = Total deflection limit, L/Value
Default = 0, Value > 0

13 = Total camber limit, L/Value
Default = 250, Value > 0

14 = Pattern live load factor
Default = 0, Value >= 0

15 = Demand/capacity ratio limit
Default = 1.0, Value > 0

16 = Multi-response case design
1 or "Envelopes" - (Default)
2 or "Step-by-step"
3 or "Last step"
4 or "Envelopes -- All"
5 or "Step-by-step -- All"

17 = Behavior Factor, q0
Default = 1, Value > 0

18 = System Overstrength Factor, W
Default = 1.0, Value > 0

19 = Consider P-Delta
1 or "No" - Default
2 or "Yes"

20 = Consider Torsion
1 or "No" - Default
2 or "Yes"

21 = Ignore Seismic Code
1 or "No" - Default
2 or "Yes"

22 = Ignore Special Seismic Load
1 or "No" - Default
2 or "Yes"

23 = Is Doubler Plate Plug-Welded
1 or "No" - Default
2 or "Yes"
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Italian_NTC_2018.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class SP_16_13330_2011:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 37, inclusive, indicating the overwrite item considered.
1 = Framing type
2= Section Class
3 = Service Factor, GammaC
4= Service Factor, GammaU
5= Factor for L-Shapes , GammaC1
6 = Column buckling curve major
7 = Column buckling curve minor
8 = Is rolled section?
9 = Is beam top loaded?
10 = Consider Deflection
11 = Deflection check type
12 = DL deflection limit, L/Value
13 = SDL+LL deflection limit, L/Value
14 = LL deflection limit, L/Value
15 = Total deflection limit, L/Value
16 = Total-camber limit, L/Value
17 = DL deflection limit, absolute
18 = SDL+LL deflection limit, absolute
19 = LL deflection limit, absolute
20 = Total deflection limit, absolute
21 = Total-camber deflection limit, absolute
22 = Specified camber
23 = Net area to total area ratio
24 = Live load reduction factor
25 = Unbraced length ratio, Major
26 = Unbraced length ratio, Minor
27 = Unbraced length ratio, LTB
28 = Effective length factor, K1 Major
29 = Effective length factor, K1 Minor
30 = Effective length factor, K2 Major
31 = Effective length factor, K2 Minor
32 = Effective length factor, LTB
33 = Characteristic strength, Ryn
34 = Design yield strength, Ry
35 = Design fracture strength, Ru
36 = Design shear strength, Rs
37 = Demand/capacity ratio, limit

Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Section Class
0 = Program Determined
1 = Class 1
2 = Class 2
3 = Class 3
4 = Class 4

3 = Service Factor, GammaC
Value >= 0; 0 means use program determined value.

4 = Service Factor, GammaU
Value >= 0; 0 means use program determined value.

5 = Factor for L-Shapes , GammaC1
Value >= 0; 0 means use program determined value.

6 = Column buckling curve major
0 = Program Determined
1 = a
2 = b
3 = c

7 =Column buckling curve minor
0 = Program Determined
1 = a
2 = b
3 = c

8 = Is rolled section?
0 = Program Determined
1 = No
2 = Yes

9 = Is beam top loaded?
0 = Program Determined
1 = No
2 = Yes

10 = Consider Deflection
0 = Program Determined
1 = No
2 = Yes

11 = Deflection check type
0 = Program Determined
1 = Ratio
2 = Absolute
3 = Both

12 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

13 = SDL+LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

14 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

15 = Total deflection limit, L/Value
Value >= 0; 0 means no check for this item.

16 = Total-camber limit, L/Value
Value >= 0; 0 means no check for this item.

17 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

18 = SDL+LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

19 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

20 = Total deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

21 = Total-camber deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

22 = Specified camber
Value >= 0. [L]

23 = Net area to total area ratio
Value >= 0; 0 means use program default value.

24 = Live load reduction factor
Value >= 0; 0 means use program determined value.

25 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

26 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

27 = Unbraced length ratio, LTB
Value >= 0; 0 means use program determined value.

28 = Effective length factor, K1 Major
Value >= 0; 0 means use program determined value.

29 = Effective length factor, K1 Minor
Value >= 0; 0 means use program determined value.

30 = Effective length factor, K2 Major
Value >= 0; 0 means use program determined value.

31 = Effective length factor, K2 Minor
Value >= 0; 0 means use program determined value.

32 = Effective length factor, LTB
Value >= 0; 0 means use program determined value.

33 = Characteristic strength, Ryn
Value >= 0; 0 means use program determined value. [F/L2]

34 = Design yield strength, Ry
Value >= 0; 0 means use program determined value. [F/L2]
35 = Design fracture strength, Ru
Value >= 0; 0 means use program determined value. [F/L2]

36 = Design shear strength, Rs
Value >= 0; 0 means use program determined value. [F/L2]

37 = Demand/capacity ratio, limit
Value >= 0; 0 means use program determined value.

ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SP_16_13330_2011.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 15, inclusive, indicating the preference item considered.
1 = Multi-response case design
2 = Framing type
3 = Section class
4 = GammaM
5 = GammaC
6 = GammaU
7 = GammaC1
8 = Consider deflection
9 = DL deflection limit, L/Value
10 = SDL + LL deflection limit, L/Value
11 = LL deflection limit, L/Value
12 = Total load deflection limit, L/Value
13 = Total camber limit, L/Value
14 = Pattern live load factor
15 = Demand/capacity ratio limit

Value: The value of the considered preference item.
1 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

2 = Framing type
1 = Moment frame
2 = Braced frame

3 = Section class
1 = Class 1
2 = Class 2
3 = Class 3
4 = Class 4

4 = GammaM
Value > 0

5 = GammaC
Value > 0

6 = GammaU
Value > 0

7 = GammaC1
Value > 0

8 = Consider deflection
0 = No
Any other value = Yes

9 = DL deflection limit, L/Value
Value > 0

10 = SDL + LL deflection limit, L/Value
Value > 0

11 = LL deflection limit, L/Value
Value > 0

12 = Total deflection limit, L/Value
Value > 0

13 = Total camber limit, L/Value
Value > 0

14 = Pattern live load factor
Value >= 0

15 = Demand/capacity ratio limit
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SP_16_13330_2011.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise, it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 37, inclusive, indicating the overwrite item considered.
1 = Framing type
2= Section Class
3 = Service Factor, GammaC
4= Service Factor, GammaU
5= Factor for L-Shapes , GammaC1
6 = Column buckling curve major
7 = Column buckling curve minor
8 = Is rolled section?
9 = Is beam top loaded?
10 = Consider Deflection
11 = Deflection check type
12 = DL deflection limit, L/Value
13 = SDL+LL deflection limit, L/Value
14 = LL deflection limit, L/Value
15 = Total deflection limit, L/Value
16 = Total-camber limit, L/Value
17 = DL deflection limit, absolute
18 = SDL+LL deflection limit, absolute
19 = LL deflection limit, absolute
20 = Total deflection limit, absolute
21 = Total-camber deflection limit, absolute
22 = Specified camber
23 = Net area to total area ratio
24 = Live load reduction factor
25 = Unbraced length ratio, Major
26 = Unbraced length ratio, Minor
27 = Unbraced length ratio, LTB
28 = Effective length factor, K1 Major
29 = Effective length factor, K1 Minor
30 = Effective length factor, K2 Major
31 = Effective length factor, K2 Minor
32 = Effective length factor, LTB
33 = Characteristic strength, Ryn
34 = Design yield strength, Ry
35 = Design fracture strength, Ru
36 = Design shear strength, Rs
37 = Demand/capacity ratio, limit

Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Moment Frame
2 = Braced Frame

2 = Section Class
0 = Program Determined
1 = Class 1
2 = Class 2
3 = Class 3
4 = Class 4

3 = Service Factor, GammaC
Value >= 0; 0 means use program determined value.

4 = Service Factor, GammaU
Value >= 0; 0 means use program determined value.

5 = Factor for L-Shapes , GammaC1
Value >= 0; 0 means use program determined value.

6 = Column buckling curve major
0 = Program Determined
1 = a
2 = b
3 = c

7 =Column buckling curve minor
0 = Program Determined
1 = a
2 = b
3 = c

8 = Is rolled section?
0 = Program Determined
1 = No
2 = Yes

9 = Is beam top loaded?
0 = Program Determined
1 = No
2 = Yes

10 = Consider Deflection
0 = Program Determined
1 = No
2 = Yes

11 = Deflection check type
0 = Program Determined
1 = Ratio
2 = Absolute
3 = Both

12 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

13 = SDL+LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

14 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

15 = Total deflection limit, L/Value
Value >= 0; 0 means no check for this item.

16 = Total-camber limit, L/Value
Value >= 0; 0 means no check for this item.

17 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

18 = SDL+LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

19 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

20 = Total deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

21 = Total-camber deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

22 = Specified camber
Value >= 0. [L]

23 = Net area to total area ratio
Value >= 0; 0 means use program default value.

24 = Live load reduction factor
Value >= 0; 0 means use program determined value.

25 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

26 = Unbraced length ratio, Minor
Value >= 0; 0 means use program determined value.

27 = Unbraced length ratio, LTB
Value >= 0; 0 means use program determined value.

28 = Effective length factor, K1 Major
Value >= 0; 0 means use program determined value.

29 = Effective length factor, K1 Minor
Value >= 0; 0 means use program determined value.

30 = Effective length factor, K2 Major
Value >= 0; 0 means use program determined value.

31 = Effective length factor, K2 Minor
Value >= 0; 0 means use program determined value.

32 = Effective length factor, LTB
Value >= 0; 0 means use program determined value.

33 = Characteristic strength, Ryn
Value >= 0; 0 means use program determined value. [F/L2]

34 = Design yield strength, Ry
Value >= 0; 0 means use program determined value. [F/L2]
35 = Design fracture strength, Ru
Value >= 0; 0 means use program determined value. [F/L2]

36 = Design shear strength, Rs
Value >= 0; 0 means use program determined value. [F/L2]

37 = Demand/capacity ratio, limit
Value >= 0; 0 means use program determined value.

ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SP_16_13330_2011.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise, it returns a nonzero value.

Item: This is an integer between 1 and 15, inclusive, indicating the preference item considered.
1 = Multi-response case design
2 = Framing type
3 = Section class
4 = GammaM
5 = GammaC
6 = GammaU
7 = GammaC1
8 = Consider deflection
9 = DL deflection limit, L/Value
10 = SDL + LL deflection limit, L/Value
11 = LL deflection limit, L/Value
12 = Total load deflection limit, L/Value
13 = Total camber limit, L/Value
14 = Pattern live load factor
15 = Demand/capacity ratio limit

Value: The value of the considered preference item.
1 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

2 = Framing type
1 = Moment frame
2 = Braced frame

3 = Section class
1 = Class 1
2 = Class 2
3 = Class 3
4 = Class 4

4 = GammaM
Value > 0

5 = GammaC
Value > 0

6 = GammaU
Value > 0

7 = GammaC1
Value > 0

8 = Consider deflection
0 = No
Any other value = Yes

9 = DL deflection limit, L/Value
Value > 0

10 = SDL + LL deflection limit, L/Value
Value > 0

11 = LL deflection limit, L/Value
Value > 0

12 = Total deflection limit, L/Value
Value > 0

13 = Total camber limit, L/Value
Value > 0

14 = Pattern live load factor
Value >= 0

15 = Demand/capacity ratio limit
Value > 0
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.SP_16_13330_2011.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class UBC97_ASD:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 32, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Moment coefficient, Cm Major
23 = Moment coefficient, Cm Minor
24 = Bending coefficient, Cb
25 = Yield stress, Fy
26 = Compressive stress, Fa
27 = Tensile stress, Ft
28 = Major bending stress, Fb3
29 = Minor bending stress, Fb2
30 = Major shear stress, Fv2
31 = Minor shear stress, Fv3
32 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Ordinary MRF
2 = Special MRF
3 = Braced Frame
4 = Special CBF
5 = EBF

2 = Omega0
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L]

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

24 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

25 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

26 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

27 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

28 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

29 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

30 = Major shear stress, Fv2
Value >= 0; 0 means use program determined value. [F/L2]

31 = Minor shear stress, Fv3
Value >= 0; 0 means use program determined value. [F/L2]

32 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.UBC97_ASD.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 12, inclusive, indicating the preference item considered.
1 = Framing type
2 = Seismic zone
3 = Lateral factor
4 = Consider deflection
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total deflection limit, L/Value
9 = Total camber limit, L/Value
10 = Pattern live load factor
11 = Demand/capacity ratio limit
12 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Ordinary MRF
2 = Special MRF
3 = Braced Frame
4 = Special CBF
5 = EBF

2 = Seismic zone
1 = Zone 0
2 = Zone 1
3 = Zone 2
4 = Zone 3
5 = Zone 4

3 = Lateral factor
Value > 0

4 = Consider deflection
0 = No
Any other value = Yes

5 = DL deflection limit, L/Value5
Value > 0
6 = SDL + LL deflection limit, L/Value
Value > 0
7 = LL deflection limit, L/Value
Value > 0
8 = Total deflection limit, L/Value
Value > 0
9 = Total camber limit, L/Value
Value > 0

10 = Pattern live load factor
Value >= 0

11 = Demand/capacity ratio limit
Value > 0

12 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.UBC97_ASD.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemTypeitem.
Item: This is an integer between 1 and 32, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Moment coefficient, Cm Major
23 = Moment coefficient, Cm Minor
24 = Bending coefficient, Cb
25 = Yield stress, Fy
26 = Compressive stress, Fa
27 = Tensile stress, Ft
28 = Major bending stress, Fb3
29 = Minor bending stress, Fb2
30 = Major shear stress, Fv2
31 = Minor shear stress, Fv3
32 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Ordinary MRF
2 = Special MRF
3 = Braced Frame
4 = Special CBF
5 = EBF

2 = Omega0
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L]

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

24 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

25 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

26 = Compressive stress, Fa
Value >= 0; 0 means use program determined value. [F/L2]

27 = Tensile stress, Ft
Value >= 0; 0 means use program determined value. [F/L2]

28 = Major bending stress, Fb3
Value >= 0; 0 means use program determined value. [F/L2]

29 = Minor bending stress, Fb2
Value >= 0; 0 means use program determined value. [F/L2]

30 = Major shear stress, Fv2
Value >= 0; 0 means use program determined value. [F/L2]

31 = Minor shear stress, Fv3
Value >= 0; 0 means use program determined value. [F/L2]

32 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.UBC97_ASD.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 12, inclusive, indicating the preference item considered.
1 = Framing type
2 = Seismic zone
3 = Lateral factor
4 = Consider deflection
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total deflection limit, L/Value
9 = Total camber limit, L/Value
10 = Pattern live load factor
11 = Demand/capacity ratio limit
12 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Ordinary MRF
2 = Special MRF
3 = Braced Frame
4 = Special CBF
5 = EBF

2 = Seismic zone
1 = Zone 0
2 = Zone 1
3 = Zone 2
4 = Zone 3
5 = Zone 4

3 = Lateral factor
Value > 0

4 = Consider deflection
0 = No
Any other value = Yes

5 = DL limit, L/Value
Value > 0

6 = Super DL + LL limit, L/Value
Value > 0

7 = Live load limit, L/Value
Value > 0

8 = Total limit, L/Value
Value > 0

9 = Total camber limit, L/Value
Value > 0

10 = Pattern live load factor
Value >= 0

11 = Demand/capacity ratio limit
Value > 0

12 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.UBC97_ASD.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class UBC97_LRFD:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetOverwrite(self, Name = None, Item = None, Value = None, ProgDet = None):
        """
This function retrieves the value of a steel design overwrite item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a frame object with a steel frame design procedure.
Item: This is an integer between 1 and 36, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Moment coefficient, Cm Major
23 = Moment coefficient, Cm Minor
24 = Bending coefficient, Cb
25 = Non-sway moment factor, B1 Major
26 = Non-sway moment factor, B1 Minor
27 = Sway moment factor, B2 Major
28 = Sway moment factor, B2 Minor
29 = Yield stress, Fy
30 = Compressive capacity, phi*Pnc
31 = Tensile capacity, phi*Pnt
32 = Major bending capacity, phi*Mn3
33 = Minor bending capacity, phi*Mn2
34 = Major shear capacity, phi*Vn2
35 = Minor shear capacity, phi*Vn3
36 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Ordinary MRF
2 = Special MRF
3 = Braced Frame
4 = Special CBF
5 = EBF

2 = Omega0
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L]

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

24 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

25 = Nonsway moment factor, B1 Major
Value >= 0; 0 means use program determined value.

26 = Nonsway moment factor, B1 Minor
Value >= 0; 0 means use program determined value.

27 = Sway moment factor, B2 Major
Value >= 0; 0 means use program determined value.

28 = Sway moment factor, B2 Minor
Value >= 0; 0 means use program determined value.

29 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

30 = Compressive capacity, phi*Pnc
Value >= 0; 0 means use program determined value. [F]

31 = Tensile capacity, phi*Pnt
Value >= 0; 0 means use program determined value. [F]

32 = Major bending capacity, phi*Mn3
Value >= 0; 0 means use program determined value. [FL]

33 = Minor bending capacity, phi*Mn2
Value >= 0; 0 means use program determined value. [FL]

34 = Major shear capacity, phi*Vn2
Value >= 0; 0 means use program determined value. [F]

35 = Minor shear capacity, phi*Vn3
Value >= 0; 0 means use program determined value. [F]

36 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ProgDet: If this item is True, the specified value is program determined.
        """

        all_args = [Name, Item, Value, ProgDet]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.UBC97_LRFD.GetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOverwrite" failed')
        
        return ret

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 12, inclusive, indicating the preference item considered.
1 = Framing type
2 = Importance factor
3 = Seismic zone
4 = Phi bending
5 = Phi compression
6 = Phi tension
7 = Phi shear
8 = Phi compression angle
9 = Consider deflection
10 = DL deflection limit, L/Value
11 = SDL + LL deflection limit, L/Value
12 = LL deflection limit, L/Value
13 = Total deflection limit, L/Value
14 = Total camber limit, L/Value
15 = Pattern live load factor
16 = Demand/capacity ratio limit
17 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Ordinary MRF
2 = Special MRF
3 = Braced Frame
4 = Special CBF
5 = EBF

2 = Importance factor
Value > 0

3 = Seismic zone
1 = Zone 0
2 = Zone 1
3 = Zone 2
4 = Zone 3
5 = Zone 4

3 = Lateral factor
Value > 0

4 = Phi bending
Value > 0
5 = Phi compression
Value > 0

6 = Phi tension
Value > 0

7 = Phi shear
Value > 0

8 = Phi compression angle
Value > 0

9 = Consider deflection
0 = No
Any other value = Yes

10 = DL deflection limit, L/Value
Value > 0

11 = SDL + LL deflection limit, L/Value
Value > 0

12 = LL deflection limit, L/Value
Value > 0

13 = Total deflection limit, L/Value
Value > 0

14 = Total camber limit, L/Value
Value > 0

15 = Pattern live load factor
Value >= 0

16 = Demand/capacity ratio limit
Value > 0

17 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.UBC97_LRFD.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetOverwrite(self, Name = None, Item = None, Value = None, ItemType = None):
        """
This function sets the value of a steel design overwrite item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Item: This is an integer between 1 and 36, inclusive, indicating the overwrite item considered.
1 = Framing type
2 = Omega0
3 = Consider deflection
4 = Deflection check type
5 = DL deflection limit, L/Value
6 = SDL + LL deflection limit, L/Value
7 = LL deflection limit, L/Value
8 = Total load deflection limit, L/Value
9 = Total camber limit, L/Value
10 = DL deflection limit, absolute
11 = SDL + LL deflection limit, absolute
12 = LL deflection limit, absolute
13 = Total load deflection limit, absolute
14 = Total camber limit, absolute
15 = Specified camber
16 = Net area to total area ratio
17 = Live load reduction factor
18 = Unbraced length ratio, Major
19 = Unbraced length ratio, Minor Lateral Torsional Buckling
20 = Effective length factor, K Major
21 = Effective length factor, K Minor
22 = Moment coefficient, Cm Major
23 = Moment coefficient, Cm Minor
24 = Bending coefficient, Cb
25 = Non-sway moment factor, B1 Major
26 = Non-sway moment factor, B1 Minor
27 = Sway moment factor, B2 Major
28 = Sway moment factor, B2 Minor
29 = Yield stress, Fy
30 = Compressive capacity, phi*Pnc
31 = Tensile capacity, phi*Pnt
32 = Major bending capacity, phi*Mn3
33 = Minor bending capacity, phi*Mn2
34 = Major shear capacity, phi*Vn2
35 = Minor shear capacity, phi*Vn3
36 = Demand/capacity ratio limit
Value: The value of the considered overwrite item.
1 = Framing type
0 = Program Default
1 = Ordinary MRF
2 = Special MRF
3 = Braced Frame
4 = Special CBF
5 = EBF

2 = Omega0
Value >= 0; 0 means use a program determined value.

3 = Consider deflection
0 = Program Determined
1 = No
2 = Yes

4 = Deflection check type
0 = Program default
1 = Ratio
2 = Absolute
3 = Both

5 = DL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

6 = SDL + LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

7 = LL deflection limit, L/Value
Value >= 0; 0 means no check for this item.

8 = Total load deflection limit, L/Value
Value >= 0; 0 means no check for this item.

9 = Total camber limit, L/Value
Value >= 0; 0 means no check for this item.

10 = DL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

11 = SDL + LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

12 = LL deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

13 = Total load deflection limit, absolute
Value >= 0; 0 means no check for this item. [L]

14 = Total camber limit, absolute
Value >= 0; 0 means no check for this item. [L]

15 = Specified camber
Value >= 0. [L]

16 = Net area to total area ratio
Value >= 0; 0 means use program default value.

17 = Live load reduction factor
Value >= 0; 0 means use program determined value.

18 = Unbraced length ratio, Major
Value >= 0; 0 means use program determined value.

19 = Unbraced length ratio, Minor Lateral Torsional Buckling
Value >= 0; 0 means use program determined value.

20 = Effective length factor, K Major
Value >= 0; 0 means use program determined value.

21 = Effective length factor, K Minor
Value >= 0; 0 means use program determined value.

22 = Moment coefficient, Cm Major
Value >= 0; 0 means use program determined value.

23 = Moment coefficient, Cm Minor
Value >= 0; 0 means use program determined value.

24 = Bending coefficient, Cb
Value >= 0; 0 means use program determined value.

25 = Nonsway moment factor, B1 Major
Value >= 0; 0 means use program determined value.

26 = Nonsway moment factor, B1 Minor
Value >= 0; 0 means use program determined value.

27 = Sway moment factor, B2 Major
Value >= 0; 0 means use program determined value.

28 = Sway moment factor, B2 Minor
Value >= 0; 0 means use program determined value.

29 = Yield stress, Fy
Value >= 0; 0 means use program determined value. [F/L2]

30 = Compressive capacity, phi*Pnc
Value >= 0; 0 means use program determined value. [F]

31 = Tensile capacity, phi*Pnt
Value >= 0; 0 means use program determined value. [F]

32 = Major bending capacity, phi*Mn3
Value >= 0; 0 means use program determined value. [FL]

33 = Minor bending capacity, phi*Mn2
Value >= 0; 0 means use program determined value. [FL]

34 = Major shear capacity, phi*Vn2
Value >= 0; 0 means use program determined value. [F]

35 = Minor shear capacity, phi*Vn3
Value >= 0; 0 means use program determined value. [F]

36 = Demand/capacity ratio limit
Value >= 0; 0 means use program determined value.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Item, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.UBC97_LRFD.SetOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOverwrite" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 17, inclusive, indicating the preference item considered.
1 = Framing type
2 = Importance factor
3 = Seismic zone
4 = Phi bending
5 = Phi compression
6 = Phi tension
7 = Phi shear
8 = Phi compression angle
9 = Consider deflection
10 = DL deflection limit, L/Value
11 = SDL + LL limit, L/Value
12 = Live load limit, L/Value
13 = Total limit, L/Value
14 = Total camber limit, L/Value
15 = Pattern live load factor
16 = Demand/capacity ratio limit
17 = Multi-response case design
Value: The value of the considered preference item.
1 = Framing type
1 = Ordinary MRF
2 = Special MRF
3 = Braced Frame
4 = Special CBF
5 = EBF

2 = Importance factor
Value > 0

3 = Seismic zone
1 = Zone 0
2 = Zone 1
3 = Zone 2
4 = Zone 3
5 = Zone 4

3 = Lateral factor
Value > 0

4 = Phi bending
Value > 0

5 = Phi compression
Value > 0

6 = Phi tension
Value > 0

7 = Phi shear
Value > 0

8 = Phi compression angle
Value > 0

9 = Consider deflection
0 = No
Any other value = Yes

10 = DL limit, L/Value
Value > 0

11 = Super DL + LL limit, L/Value
Value > 0

12 = Live load limit, L/Value
Value > 0

13 = Total limit, L/Value
Value > 0

14 = Total camber limit, L/Value
Value > 0

15 = Pattern live load factor
Value >= 0

16 = Demand/capacity ratio limit
Value > 0

17 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.UBC97_LRFD.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class EditArea:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeConnectivity(self, Name = None, NumberPoints = None, Point = None):
        """
This function modifies the connectivity of an area object.
The function returns zero if the area object connectivity is successfully modified; otherwise it returns a nonzero value.

Name: The name of an existing area object.
NumberPoints: The number of points in the area abject.
Point: This is an array containing the names of the point objects that define the added area object. The point object names should be ordered to run clockwise or counter-clockwise around the area object.
        """

        all_args = [Name, NumberPoints, Point]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditArea.ChangeConnectivity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeConnectivity" failed')
        
        return ret

    def Divide(self, Name = None, MeshType = None, NumberAreas = None, AreaName = None, n1 = None, n2 = None, MaxSize1 = None, MaxSize2 = None, PointOnEdgeFromGrid = None, PointOnEdgeFromLine = None, PointOnEdgeFromPoint = None, ExtendCookieCutLines = None, Rotation = None, MaxSizeGeneral = None, LocalAxesOnEdge = None, LocalAxesOnFace = None, RestraintsOnEdge = None, RestraintsOnFace = None):
        """
This function meshes area objects.
The function returns zero if the meshing is successful; otherwise it returns a nonzero value.

Name: The name of an existing area object.
MeshType: This item is 1, 2, 3, 4, 5 or 6, indicating the mesh type for the area object.
1 = Mesh area into a specified number of objects
2 = Mesh area into objects of a specified maximum size
3 = Mesh area based on points on area edges
4 = Cookie cut mesh area based on lines intersecting edges
5 = Cookie cut mesh area based on points
6 = Mesh area using General Divide Tool

Mesh options 1, 2 and 3 apply to quadrilaterals and triangles only.
NumberAreas: The number of area objects created when the specified area object is divided.
AreaName: This is an array of the name of each area object created when the specified area object is divided.
n1: This item applies when MeshType = 1. It is the number of objects created along the edge of the meshed area object that runs from point 1 to point 2.
n2: This item applies when MeshType = 1. It is the number of objects created along the edge of the meshed area object that runs from point 1 to point 3.
MaxSize1: This item applies when MeshType = 2. It is the maximum size of objects created along the edge of the meshed area object that runs from point 1 to point 2. [L]
If this item is input as 0, the default value is used. The default value is 48 inches if the database units are English or 120 centimeters if the database units are metric.
MaxSize2: This item applies when MeshType = 2. It is the maximum size of objects created along the edge of the meshed area object that runs from point 1 to point 3. [L]
If this item is input as 0, the default value is used. The default value is 48 inches if the database units are English or 120 centimeters if the database units are metric.
PointOnEdgeFromGrid: This item applies when MeshType = 3. If it is True, points on the area object edges are determined from intersections of visible grid lines with the area object edges.
PointOnEdgeFromLine: This item applies when MeshType = 3. If it is True, points on the area object edges are determined from intersections of selected straight line objects with the area object edges.
PointOnEdgeFromPoint: This item applies when MeshType = 3. If it is True, points on the area object edges are determined from selected point objects that lie on the area object edges.
ExtendCookieCutLines: This item applies when MeshType = 4. MeshType = 4 provides cookie cut meshing based on selected straight line objects that intersect the area object edges. If the ExtendCookieCutLines item is True, all selected straight line objects are extended to intersect the area object edges for the purpose of meshing the area object.
Rotation: This item applies when MeshType = 5. MeshType = 5 provides cookie cut meshing based on two perpendicular lines passing through selected point objects. By default these lines align with the area object local 1 and 2 axes. The Rotation item is an angle in degrees that the meshing lines are rotated from their default orientation. [deg]
MaxSizeGeneral: This item applies when MeshType = 6. It is the maximum size of objects created by the General Divide Tool.
If this item is input as 0, the default value is used. The default value is 48 inches if the database units are English or 120 centimeters if the database units are metric.
LocalAxesOnEdge: If this item is True, and if both points along an edge of the original area object have the same local axes, the program makes the local axes for added points along the edge the same as the edge end points.
LocalAxesOnFace: If this item is True, and if all points around the perimeter of the original area object have the same local axes, the program makes the local axes for all added points the same as the perimeter points.
RestraintsOnEdge: If this item is True, and if both points along an edge of the original area object have the same restraint/constraint, then, if the added point and the adjacent corner points have the same local axes definition, the program includes the restraint/constraint for added points along the edge.
RestraintsOnFace: If this item is True, and if all points around the perimeter of the original area object have the same restraint/constraint, then, if an added point and the perimeter points have the same local axes definition, the program includes the restraint/constraint for the added point.
        """

        all_args = [Name, MeshType, NumberAreas, AreaName, n1, n2, MaxSize1, MaxSize2, PointOnEdgeFromGrid, PointOnEdgeFromLine, PointOnEdgeFromPoint, ExtendCookieCutLines, Rotation, MaxSizeGeneral, LocalAxesOnEdge, LocalAxesOnFace, RestraintsOnEdge, RestraintsOnFace]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditArea.Divide(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Divide" failed')
        
        return ret

    def ExpandShrink(self, OffsetType = None, Offset = None):
        """
This function expands or shrinks selected area objects.
The function returns zero if it is successful; otherwise it returns a nonzero value.

OffsetType: This item is 0, 1 or 2, indicating the offset type for the selected area objects.
0 = Offset all area edges
1 = Offset selected area edges only
2 = Offset selected points of selected areas only
Offset: The area edge offset distance. Positive distances expand the object and negative distances shrink the object.[L]
        """

        all_args = [OffsetType, Offset]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditArea.ExpandShrink(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ExpandShrink" failed')
        
        return ret

    def Merge(self, NumberAreas = None, AreaName = None):
        """
This function merges selected area objects.
The function returns zero if it is successful; otherwise it returns a nonzero value.

NumberAreas: The number of originally selected area objects that remain when the merge is successfully completed.
AreaName: This is an array that includes the names of the selected area objects that remain when the merge is successfully completed.
        """

        all_args = [NumberAreas, AreaName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditArea.Merge(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Merge" failed')
        
        return ret

    def PointAdd(self):
        """
This function adds a point object at the midpoint of selected area object edges.
The function returns zero if it is successful; otherwise it returns a nonzero value.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditArea.PointAdd(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PointAdd" failed')
        
        return ret

    def PointRemove(self):
        """
This function removes selected point objects from selected area objects. Note that in some cases this command can cause the area object to be deleted.
The function returns zero if it is successful; otherwise it returns a nonzero value.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditArea.PointRemove(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PointRemove" failed')
        
        return ret

class EditFrame:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def ChangeConnectivity(self, Name = None, Point1 = None, Point2 = None):
        """
This function modifies the connectivity of a frame object.
The function returns zero if the frame object connectivity is successfully modified; otherwise it returns a nonzero value.

Name: The name of an existing frame object.
Point1: The name of the point object at the I-End of the frame object.
Point2: The name of the point object at the J-End of the frame object.
        """

        all_args = [Name, Point1, Point2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditFrame.ChangeConnectivity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeConnectivity" failed')
        
        return ret

    def DivideAtDistance(self, Name = None, Dist = None, IEnd = None, Num = None, NewName = None):
        """
This function divides straight frame objects into two objects at a location defined by the Dist and IEnd items. Curved frame objects are not divided.
The function returns zero if the frame objects are successfully divided; otherwise it returns a nonzero value.

Name: The name of an existing straight frame object.
Dist: The frame object is divided at this distance from the end specified by the IEnd item.[L]
IEnd: If this item is True, the Dist item is measured from the I-end of the frame object. Otherwise it is measured from the J-end of the frame object.
Num: This is the number of frame objects into which the specified frame object is divided.
NewName: This is an array that includes the names of the two new frame objects.
        """

        all_args = [Name, Dist, IEnd, Num, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditFrame.DivideAtDistance(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DivideAtDistance" failed')
        
        return ret

    def DivideAtIntersections(self, Name = None, Num = None, NewName = None):
        """
This function divides straight frame objects at intersections with selected point objects, line objects, area edges and solid edges. Curved frame objects are not divided.
The function returns zero if the frame objects are successfully divided; otherwise it returns a nonzero value.

Name: The name of an existing straight frame object.
Num: This is the number of frame objects into which the specified frame object is divided.
NewName: This is an array that includes the names of the new frame objects.
        """

        all_args = [Name, Num, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditFrame.DivideAtIntersections(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DivideAtIntersections" failed')
        
        return ret

    def DivideByRatio(self, Name = None, Num = None, Ratio = None, NewName = None):
        """
This function divides straight frame objects based on a specified Last/First length ratio. Curved frame objects are not divided.
The function returns zero if the frame objects are successfully divided; otherwise it returns a nonzero value.

Name: The name of an existing straight frame object.
Num: The frame object is divided into this number of new objects.
Ratio: The Last/First length ratio for the new frame objects.
NewName: This is an array that includes the names of the new frame objects.
        """

        all_args = [Name, Num, Ratio, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditFrame.DivideByRatio(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DivideByRatio" failed')
        
        return ret

    def Extend(self, Name = None, IEnd = None, JEnd = None, Item1 = None, Item2 = None):
        """
This function extends straight frame objects. Curved frame objects are not extended.
The function returns zero if the frame objects are successfully extended; otherwise it returns a nonzero value.

Name: The name of an existing straight frame object to be extended.
IEnd: This item is True if the I-End of the frame object specified by the Name item is to be extended.
JEnd: This item is True if the J-End of the frame object specified by the Name item is to be extended.
Item1: The name of an existing straight frame object used as a extension line.
Item2: The name of an existing straight frame object used as a extension line.
        """

        all_args = [Name, IEnd, JEnd, Item1, Item2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditFrame.Extend(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Extend" failed')
        
        return ret

    def Join(self, Name = None, Item2 = None):
        """
This function joins two straight frame objects that have a common end point and are colinear.
The function returns zero if the frame objects are successfully joined; otherwise it returns a nonzero value.

Name: The name of an existing frame object to be joined. The new, joined frame object keeps this name.
Item2: The name of an existing frame object to be joined.
        """

        all_args = [Name, Item2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditFrame.Join(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Join" failed')
        
        return ret

    def Trim(self, Name = None, IEnd = None, JEnd = None, Item1 = None, Item2 = None):
        """
This function trims straight frame objects. Curved frame objects are not trimmed.
The function returns zero if the frame objects are successfully trimmed; otherwise it returns a nonzero value.

Name: The name of an existing straight frame object to be trimmed.
IEnd: This item is True if the I-End of the frame object specified by the Name item is to be trimmed.
JEnd: This item is True if the J-End of the frame object specified by the Name item is to be trimmed.
Item1: The name of an existing straight frame object used as a trim line.
Item2: The name of an existing straight frame object used as a trim line.
        """

        all_args = [Name, IEnd, JEnd, Item1, Item2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditFrame.Trim(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Trim" failed')
        
        return ret

class EditPoint:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def Align(self, MyType = None, Ordinate = None, NumberPoints = None, PointName = None):
        """
This function aligns selected point objects.
The function returns zero if the alignment is successful; otherwise it returns a nonzero value.

MyType: This is 1, 2, 3 or 4, indicating the alignment option.
1 = Align points to X-ordinate in present coordinate system
2 = Align points to Y-ordinate in present coordinate system
3 = Align points to Z-ordinate in present coordinate system
4 = Align points to nearest selected line object, area object edge or solid object edge
Ordinate: The X, Y or Z ordinate that applies if MyType is 1, 2 or 3, respectively. [L]
NumberPoints: The number of point objects that are in a new location after the alignment is complete.
PointName: This is an array of the name of each point object that is in a new location after the alignment is complete.
        """

        all_args = [MyType, Ordinate, NumberPoints, PointName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditPoint.Align(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Align" failed')
        
        return ret

    def ChangeCoordinates_1(self, Name = None, x = None, y = None, z = None, NoRefresh = None):
        """
This function changes the coordinates of a specified point object.
The function returns zero if the coordinate change is successful; otherwise it returns a nonzero value.

Name: The name of an existing point object.
x: These are the new x, y and z coordinates, in the present coordinate system, for the specified point object.
y: These are the new x, y and z coordinates, in the present coordinate system, for the specified point object.
z: These are the new x, y and z coordinates, in the present coordinate system, for the specified point object.
NoRefresh: If this item is True, the model display window is not refreshed after the point object is moved.
        """

        all_args = [Name, x, y, z, NoRefresh]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditPoint.ChangeCoordinates_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeCoordinates_1" failed')
        
        return ret

    def Connect(self, NumberPoints = None, PointName = None):
        """
This function connects objects that have been disconnected using the Disconnect function. If two or more objects have different end points objects that are at the same location, all of those objects can be connected together by selecting the objects, and selecting their end points, and calling the Connect function. The result will be that all of the objects are connected at a single point.
The function returns zero if the connect is successful; otherwise it returns a nonzero value.

NumberPoints: The number of the point objects that remain at locations where connections were made.
PointName: This is an array of the name of each point object that remains at locations where connections were made.
        """

        all_args = [NumberPoints, PointName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditPoint.Connect(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Connect" failed')
        
        return ret

    def Disconnect(self, NumberPoints = None, PointName = None):
        """
This function disconnects selected point objects. Disconnect creates a separate point for each object that frames into the selected point object.
The function returns zero if the disconnect is successful; otherwise it returns a nonzero value.

NumberPoints: The number of the point objects (including the original selected point objects) that are created by the disconnect action.
PointName: This is an array of the name of each point object (including the original selected point objects) that is created by the disconnect action.
        """

        all_args = [NumberPoints, PointName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditPoint.Disconnect(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Disconnect" failed')
        
        return ret

    def Merge(self, MergeTol = None, NumberPoints = None, PointName = None):
        """
This function merges selected point objects that are within a specified distance of one another.
The function returns zero if the merge is successful; otherwise it returns a nonzero value.

MergeTol: Point objects within this distance of one another are merged into one point object. [L]
NumberPoints: The number of the selected point objects that still exist after the merge is complete.
PointName: This is an array of the name of each selected point object that still exists after the merge is complete.
        """

        all_args = [MergeTol, NumberPoints, PointName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditPoint.Merge(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Merge" failed')
        
        return ret

    def ChangeCoordinates(self, Name = None, x = None, y = None, z = None):
        """
This function changes the coordinates of a specified point object.
The function returns zero if the coordinate change is successful; otherwise it returns a nonzero value.

Name: The name of an existing point object.
x: These are the new x, y and z coordinates, in the present coordinate system, for the specified point object.
y: These are the new x, y and z coordinates, in the present coordinate system, for the specified point object.
z: These are the new x, y and z coordinates, in the present coordinate system, for the specified point object.
        """

        all_args = [Name, x, y, z]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditPoint.ChangeCoordinates(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeCoordinates" failed')
        
        return ret

class EditSolid:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def Divide(self, Name = None, n1 = None, n2 = None, n3 = None, NumberSolids = None, SolidName = None):
        """
This function meshes solid objects.
The function returns zero if the meshing is successful; otherwise it returns a nonzero value.

Name: The name of an existing solid object.
n1: This is the number of objects created between faces 2 and 4 of the solid object.
n2: This is the number of objects created between faces 1 and 3 of the solid object.
n3: This is the number of objects created between faces 5 and 6 of the solid object.
NumberSolids: The number of solid objects created when the specified solid object is divided.
SolidName: This is an array of the name of each solid object created when the specified solid object is divided.
        """

        all_args = [Name, n1, n2, n3, NumberSolids, SolidName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditSolid.Divide(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Divide" failed')
        
        return ret

    def ExtrudeAreaToSolidLinearNormal(self, Name = None, PropName = None, nPlus3 = None, tPlus3 = None, nMinus3 = None, tMinus3 = None, NumberSolids = None, SolidName = None, Remove = None):
        """
This function creates new solid objects by linearly extruding a specified area object, in the local 3-axis direction of the area object, into solid objects.
The function returns zero if the extrusion is successful; otherwise it returns a nonzero value.

Name: The name of an existing area object to be extruded.
PropName: This is either Default or the name of a defined solid property to be used for the new extruded solid objects.
nPlus3: The number of solid objects created in the positive local 3-axis direction of the specified area object.
tPlus3: The thickness of the solid objects created in the positive local 3-axis direction of the specified area object.
nMinus3: The number of solid objects created in the negative local 3-axis direction of the specified area object.
tMinus3: The thickness of the solid objects created in the negative local 3-axis direction of the specified area object.
NumberSolids: The number of solid objects created when the specified area object is extruded.
SolidName: This is an array of the name of each solid object created when the specified area object is extruded.
Remove: If this item is True, the area object indicated by the Name item is deleted after the extrusion is complete.
        """

        all_args = [Name, PropName, nPlus3, tPlus3, nMinus3, tMinus3, NumberSolids, SolidName, Remove]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditSolid.ExtrudeAreaToSolidLinearNormal(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ExtrudeAreaToSolidLinearNormal" failed')
        
        return ret

    def ExtrudeAreaToSolidLinearUser(self, Name = None, PropName = None, dx = None, dy = None, dz = None, Number = None, NumberSolids = None, SolidName = None, Remove = None):
        """
This function creates new solid objects by linearly extruding a specified area object, in a user specified direction, into solid objects.
The function returns zero if the extrusion is successful; otherwise it returns a nonzero value.

Name: The name of an existing area object to be extruded.
PropName: This is either Default or the name of a defined solid property to be used for the new extruded solid objects.
dx: These are the x, y and z offsets used, in the present coordinate system, to create each new solid object.
dy: These are the x, y and z offsets used, in the present coordinate system, to create each new solid object.
dz: These are the x, y and z offsets used, in the present coordinate system, to create each new solid object.
Number: The number of increments for the extrusion.
NumberSolids: The number of solid objects created when the specified area object is extruded. Usually this item is returned the same as the Number item. However, in some cases, such as when an area object with more than four sides is extruded, this item will be larger than the Number item.
SolidName: This is an array of the name of each solid object created when the specified area object is extruded.
Remove: If this item is True, the area object indicated by the Name item is deleted after the extrusion is complete.
        """

        all_args = [Name, PropName, dx, dy, dz, Number, NumberSolids, SolidName, Remove]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditSolid.ExtrudeAreaToSolidLinearUser(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ExtrudeAreaToSolidLinearUser" failed')
        
        return ret

    def ExtrudeAreaToSolidRadial(self, Name = None, PropName = None, RotateAxis = None, x = None, y = None, z = None, IncrementAng = None, TotalRise = None, Number = None, NumberSolids = None, SolidName = None, Remove = None):
        """
This function creates new solid objects by radially extruding a specified area object into solid objects.
The function returns zero if the extrusion is successful; otherwise it returns a nonzero value.

Name: The name of an existing area object to be extruded.
PropName: This is either Default or the name of a defined solid property to be used for the new extruded solid objects.
RotateAxis: This is 0, 1 or 2, indicating the axis that the radial extrusion is around.
0 = X axis
1 = Y axis
2 = Z axis
x: These are the x, y and z coordinates, in the present coordinate system, of the point that the radial extrusion is around. For rotation about the X axis the value of the x coordinate is irrelevant. Similarly, for rotation about the Y and Z axes the y and z coordinates, respectively, are irrelevant. [L]
y: These are the x, y and z coordinates, in the present coordinate system, of the point that the radial extrusion is around. For rotation about the X axis the value of the x coordinate is irrelevant. Similarly, for rotation about the Y and Z axes the y and z coordinates, respectively, are irrelevant. [L]
z: These are the x, y and z coordinates, in the present coordinate system, of the point that the radial extrusion is around. For rotation about the X axis the value of the x coordinate is irrelevant. Similarly, for rotation about the Y and Z axes the y and z coordinates, respectively, are irrelevant. [L]
IncrementAng: The angle is rotated by this amount for each added solid object. [deg]
TotalRise: The total rise over the full length of the extrusion. [L]
Number: The number of angle increments for the extrusion.
NumberSolids: The number of solid objects created when the specified area object is extruded. Usually this item is returned the same as the Number item. However, in some cases, such as when an area object with more than four sides is extruded, this item will be larger than the Number item.
SolidName: This is an array of the name of each solid object created when the specified area object is extruded.
Remove: If this item is True, the area object indicated by the Name item is deleted after the extrusion is complete.
        """

        all_args = [Name, PropName, RotateAxis, x, y, z, IncrementAng, TotalRise, Number, NumberSolids, SolidName, Remove]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditSolid.ExtrudeAreaToSolidRadial(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ExtrudeAreaToSolidRadial" failed')
        
        return ret

    def ExtrudeFrameToAreaLinear(self, Name = None, PropName = None, dx = None, dy = None, dz = None, NumberAreas = None, AreaName = None, Remove = None):
        """
This function creates new area objects by linearly extruding a specified straight frame object into area objects.
The function returns zero if the extrusion is successful; otherwise it returns a nonzero value.

Name: The name of an existing straight frame object to be extruded.
PropName: This is Default, None or the name of a defined area property to be used for the new extruded area objects.
dx: These are the x, y and z offsets used, in the present coordinate system, to create each new area object.
dy: These are the x, y and z offsets used, in the present coordinate system, to create each new area object.
dz: These are the x, y and z offsets used, in the present coordinate system, to create each new area object.
NumberAreas: The number of area objects created when the specified line object is extruded.
AreaName: This is an array of the name of each area object created when the specified line object is extruded.
Remove: If this item is True, the straight frame object indicated by the Name item is deleted after the extrusion is complete.
        """

        all_args = [Name, PropName, dx, dy, dz, NumberAreas, AreaName, Remove]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditSolid.ExtrudeFrameToAreaLinear(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ExtrudeFrameToAreaLinear" failed')
        
        return ret

    def ExtrudeFrameToAreaRadial(self, Name = None, PropName = None, RotateAxis = None, x = None, y = None, z = None, IncrementAng = None, TotalRise = None, NumberAreas = None, AreaName = None, Remove = None):
        """
This function creates new area objects by radially extruding a specified straight frame object into area objects.
The function returns zero if the extrusion is successful; otherwise it returns a nonzero value.

Name: The name of an existing line object to be extruded.
PropName: This is Default, None or the name of a defined area property to be used for the new extruded area objects.
RotateAxis: This is 0, 1 or 2, indicating the axis that the radial extrusion is around.
0 = X axis
1 = Y axis
2 = Z axis
x: These are the x, y and z coordinates, in the present coordinate system, of the point that the radial extrusion is around. For rotation about the X axis the value of the x coordinate is irrelevant. Similarly, for rotation about the Y and Z axes the y and z coordinates, respectively, are irrelevant. [L]
y: These are the x, y and z coordinates, in the present coordinate system, of the point that the radial extrusion is around. For rotation about the X axis the value of the x coordinate is irrelevant. Similarly, for rotation about the Y and Z axes the y and z coordinates, respectively, are irrelevant. [L]
z: These are the x, y and z coordinates, in the present coordinate system, of the point that the radial extrusion is around. For rotation about the X axis the value of the x coordinate is irrelevant. Similarly, for rotation about the Y and Z axes the y and z coordinates, respectively, are irrelevant. [L]
IncrementAng: The angle is rotated by this amount for each added area object. [deg]
TotalRise: The total rise over the full length of the extrusion. [L]
NumberAreas: The number of area objects created when the specified line object is extruded.
AreaName: This is an array of the name of each area object created when the specified line object is extruded.
Remove: If this item is True, the straight frame object indicated by the Name item is deleted after the extrusion is complete.
        """

        all_args = [Name, PropName, RotateAxis, x, y, z, IncrementAng, TotalRise, NumberAreas, AreaName, Remove]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditSolid.ExtrudeFrameToAreaRadial(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ExtrudeFrameToAreaRadial" failed')
        
        return ret

    def ExtrudePointToFrameLinear(self, Name = None, PropName = None, dx = None, dy = None, dz = None, NumberFrames = None, FrameName = None):
        """
This function creates new frame objects by linearly extruding a specified point object into frame objects.
The function returns zero if the extrusion is successful; otherwise it returns a nonzero value.

Name: The name of an existing point object to be extruded.
PropName: This is Default, None or the name of a defined frame section property to be used for the new extruded frame objects.
dx: These are the x, y and z offsets used, in the present coordinate system, to create each new frame object.
dy: These are the x, y and z offsets used, in the present coordinate system, to create each new frame object.
dz: These are the x, y and z offsets used, in the present coordinate system, to create each new frame object.
NumberFrames: The number of frame objects created when the specified point object is extruded.
FrameName: This is an array of the name of each frame object created when the specified point object is extruded.
        """

        all_args = [Name, PropName, dx, dy, dz, NumberFrames, FrameName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditSolid.ExtrudePointToFrameLinear(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ExtrudePointToFrameLinear" failed')
        
        return ret

    def ExtrudePointToFrameRadial(self, Name = None, PropName = None, RotateAxis = None, x = None, y = None, z = None, IncrementAng = None, TotalRise = None, NumberFrames = None, FrameName = None):
        """
This function creates new frame objects by radially extruding a specified point object into frame objects.
The function returns zero if the extrusion is successful; otherwise it returns a nonzero value.

Name: The name of an existing point object to be extruded.
PropName: This is Default, None or the name of a defined frame section property to be used for the new extruded frame objects.
RotateAxis: This is 0, 1 or 2, indicating the axis that the radial extrusion is around.
0 = X axis
1 = Y axis
2 = Z axis
x: These are the x, y and z coordinates, in the present coordinate system, of the point that the radial extrusion is around. For rotation about the X axis, the value of the x coordinate is irrelevant. Similarly, for rotation about the Y and Z axes, the y and z coordinates, respectively, are irrelevant. [L]
y: These are the x, y and z coordinates, in the present coordinate system, of the point that the radial extrusion is around. For rotation about the X axis, the value of the x coordinate is irrelevant. Similarly, for rotation about the Y and Z axes, the y and z coordinates, respectively, are irrelevant. [L]
z: These are the x, y and z coordinates, in the present coordinate system, of the point that the radial extrusion is around. For rotation about the X axis, the value of the x coordinate is irrelevant. Similarly, for rotation about the Y and Z axes, the y and z coordinates, respectively, are irrelevant. [L]
IncrementAng: The angle is rotated by this amount for each added frame object. [deg]
TotalRise: The total rise over the full length of the extrusion. [L]
NumberFrames: The number of frame objects created when the specified point object is extruded.
FrameName: This is an array of the name of each frame object created when the specified point object is extruded.
        """

        all_args = [Name, PropName, RotateAxis, x, y, z, IncrementAng, TotalRise, NumberFrames, FrameName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditSolid.ExtrudePointToFrameRadial(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ExtrudePointToFrameRadial" failed')
        
        return ret

    def ReplicateLinear(self, dx = None, dy = None, dz = None, Number = None, NumberObjects = None, ObjectName = None, ObjectType = None, Remove = None):
        """
This function linearly replicates selected objects.
The function returns zero if the replication is successful; otherwise it returns a nonzero value.

dx: These are the x, y and z offsets used, in the present coordinate system, to replicate the selected objects.
dy: These are the x, y and z offsets used, in the present coordinate system, to replicate the selected objects.
dz: These are the x, y and z offsets used, in the present coordinate system, to replicate the selected objects.
Number: The number of times the selected objects are to be replicated.
NumberObjects: The number of new objects created by the replication process.
ObjectName: This is an array of the name of each object created by the replication process.
ObjectType: This is an array of the type of each object created by the replication process.
1 = Point object
2 = Frame object
3 = Cable object
4 = Tendon object
5 = Area object
6 = Solid object
7 = Link object
Remove: If this item is True, the originally selected objects are deleted after the replication is complete.
        """

        all_args = [dx, dy, dz, Number, NumberObjects, ObjectName, ObjectType, Remove]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditSolid.ReplicateLinear(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ReplicateLinear" failed')
        
        return ret

    def ReplicateMirror(self, Plane = None, x1 = None, y1 = None, z1 = None, x2 = None, y2 = None, z2 = None, x3 = None, y3 = None, z3 = None, NumberObjects = None, ObjectName = None, ObjectType = None, Remove = None):
        """
This function mirror replicates selected objects.
The function returns zero if the replication is successful; otherwise it returns a nonzero value.

Plane: This is 1, 2, 3 or 4, indicating the mirror plane type.
1 = Parallel to Z
2 = Parallel to X
3 = Parallel to Y
4 = 3D plane
x1: These are the coordinates of three points used to define the mirror plane. [L]
When Plane = 1, x1, y1, x2 and y2 define the intersection of the mirror plane with the XY plane.
When Plane = 2, y1, z1, y2 and z2 define the intersection of the mirror plane with the YZ plane.
When Plane = 3, x1, z1, x2 and z2 define the intersection of the mirror plane with the XZ plane.
When Plane = 4, x1, y1, z1, x2, y2, z2, x3, y3 and z3 define three points that define the mirror plane.
y1: These are the coordinates of three points used to define the mirror plane. [L]
When Plane = 1, x1, y1, x2 and y2 define the intersection of the mirror plane with the XY plane.
When Plane = 2, y1, z1, y2 and z2 define the intersection of the mirror plane with the YZ plane.
When Plane = 3, x1, z1, x2 and z2 define the intersection of the mirror plane with the XZ plane.
When Plane = 4, x1, y1, z1, x2, y2, z2, x3, y3 and z3 define three points that define the mirror plane.
z1: These are the coordinates of three points used to define the mirror plane. [L]
When Plane = 1, x1, y1, x2 and y2 define the intersection of the mirror plane with the XY plane.
When Plane = 2, y1, z1, y2 and z2 define the intersection of the mirror plane with the YZ plane.
When Plane = 3, x1, z1, x2 and z2 define the intersection of the mirror plane with the XZ plane.
When Plane = 4, x1, y1, z1, x2, y2, z2, x3, y3 and z3 define three points that define the mirror plane.
x2: These are the coordinates of three points used to define the mirror plane. [L]
When Plane = 1, x1, y1, x2 and y2 define the intersection of the mirror plane with the XY plane.
When Plane = 2, y1, z1, y2 and z2 define the intersection of the mirror plane with the YZ plane.
When Plane = 3, x1, z1, x2 and z2 define the intersection of the mirror plane with the XZ plane.
When Plane = 4, x1, y1, z1, x2, y2, z2, x3, y3 and z3 define three points that define the mirror plane.
y2: These are the coordinates of three points used to define the mirror plane. [L]
When Plane = 1, x1, y1, x2 and y2 define the intersection of the mirror plane with the XY plane.
When Plane = 2, y1, z1, y2 and z2 define the intersection of the mirror plane with the YZ plane.
When Plane = 3, x1, z1, x2 and z2 define the intersection of the mirror plane with the XZ plane.
When Plane = 4, x1, y1, z1, x2, y2, z2, x3, y3 and z3 define three points that define the mirror plane.
z2: These are the coordinates of three points used to define the mirror plane. [L]
When Plane = 1, x1, y1, x2 and y2 define the intersection of the mirror plane with the XY plane.
When Plane = 2, y1, z1, y2 and z2 define the intersection of the mirror plane with the YZ plane.
When Plane = 3, x1, z1, x2 and z2 define the intersection of the mirror plane with the XZ plane.
When Plane = 4, x1, y1, z1, x2, y2, z2, x3, y3 and z3 define three points that define the mirror plane.
x3: These are the coordinates of three points used to define the mirror plane. [L]
When Plane = 1, x1, y1, x2 and y2 define the intersection of the mirror plane with the XY plane.
When Plane = 2, y1, z1, y2 and z2 define the intersection of the mirror plane with the YZ plane.
When Plane = 3, x1, z1, x2 and z2 define the intersection of the mirror plane with the XZ plane.
When Plane = 4, x1, y1, z1, x2, y2, z2, x3, y3 and z3 define three points that define the mirror plane.
y3: These are the coordinates of three points used to define the mirror plane. [L]
When Plane = 1, x1, y1, x2 and y2 define the intersection of the mirror plane with the XY plane.
When Plane = 2, y1, z1, y2 and z2 define the intersection of the mirror plane with the YZ plane.
When Plane = 3, x1, z1, x2 and z2 define the intersection of the mirror plane with the XZ plane.
When Plane = 4, x1, y1, z1, x2, y2, z2, x3, y3 and z3 define three points that define the mirror plane.
z3: These are the coordinates of three points used to define the mirror plane. [L]
When Plane = 1, x1, y1, x2 and y2 define the intersection of the mirror plane with the XY plane.
When Plane = 2, y1, z1, y2 and z2 define the intersection of the mirror plane with the YZ plane.
When Plane = 3, x1, z1, x2 and z2 define the intersection of the mirror plane with the XZ plane.
When Plane = 4, x1, y1, z1, x2, y2, z2, x3, y3 and z3 define three points that define the mirror plane.
NumberObjects: The number of new objects created by the replication process.
ObjectName: This is an array of the name of each object created by the replication process.
ObjectType: This is an array of the type of each object created by the replication process.
1 = Point object
2 = Frame object
3 = Cable object
4 = Tendon object
5 = Area object
6 = Solid object
7 = Link object
Remove: If this item is True, the originally selected objects are deleted after the replication is complete.
        """

        all_args = [Plane, x1, y1, z1, x2, y2, z2, x3, y3, z3, NumberObjects, ObjectName, ObjectType, Remove]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditSolid.ReplicateMirror(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ReplicateMirror" failed')
        
        return ret

    def ReplicateRadial(self, RotateAxis = None, x1 = None, y1 = None, z1 = None, x2 = None, y2 = None, z2 = None, Number = None, Ang = None, NumberObjects = None, ObjectName = None, ObjectType = None, Remove = None):
        """
This function radially replicates selected objects.
The function returns zero if the replication is successful; otherwise it returns a nonzero value.

RotateAxis: This is 1, 2, 3 or 4, indicating the rotation axis.
1 = Parallel to X axis
2 = Parallel to Y axis
3 = Parallel to Z axis
4 = 3D line
x1: These are coordinates used to define the rotation axis. [L]
When RotateAxis = 1, y1 and z1 define the intersection of the rotation axis with the YZ plane.
When RotateAxis = 2, x1 and z1 define the intersection of the rotation axis with the XZ plane.
When RotateAxis = 3, x1 and y1 define the intersection of the rotation axis with the XY plane.
When RotateAxis = 4, x1, y1 and z1 define one point on the rotation axis.
y1: These are coordinates used to define the rotation axis. [L]
When RotateAxis = 1, y1 and z1 define the intersection of the rotation axis with the YZ plane.
When RotateAxis = 2, x1 and z1 define the intersection of the rotation axis with the XZ plane.
When RotateAxis = 3, x1 and y1 define the intersection of the rotation axis with the XY plane.
When RotateAxis = 4, x1, y1 and z1 define one point on the rotation axis.
z1: These are coordinates used to define the rotation axis. [L]
When RotateAxis = 1, y1 and z1 define the intersection of the rotation axis with the YZ plane.
When RotateAxis = 2, x1 and z1 define the intersection of the rotation axis with the XZ plane.
When RotateAxis = 3, x1 and y1 define the intersection of the rotation axis with the XY plane.
When RotateAxis = 4, x1, y1 and z1 define one point on the rotation axis.
x2: These are coordinates used to define the rotation axis when RotateAxis = 4. x2, y2 and z2 define a second point on the rotation axis. [L]
y2: These are coordinates used to define the rotation axis when RotateAxis = 4. x2, y2 and z2 define a second point on the rotation axis. [L]
z2: These are coordinates used to define the rotation axis when RotateAxis = 4. x2, y2 and z2 define a second point on the rotation axis. [L]
Number: The increment angle for each replication.
Ang: The number of times the selected objects are to be replicated.
NumberObjects: The number of new objects created by the replication process.
ObjectName: This is an array of the name of each object created by the replication process.
ObjectType: This is an array of the type of each object created by the replication process.
1 = Point object
2 = Frame object
3 = Cable object
4 = Tendon object
5 = Area object
6 = Solid object
7 = Link object
Remove: If this item is True, the originally selected objects are deleted after the replication is complete.
        """

        all_args = [RotateAxis, x1, y1, z1, x2, y2, z2, Number, Ang, NumberObjects, ObjectName, ObjectType, Remove]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditSolid.ReplicateRadial(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ReplicateRadial" failed')
        
        return ret

class EditGeneral:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def Move(self, dx = None, dy = None, dz = None):
        """
This function moves selected point, frame, cable, tendon, area, solid and link objects.
The function returns zero if the move is successful; otherwise it returns a nonzero value.

dx: These are the x, y and z offsets used, in the present coordinate system, for moving the selected objects.
dy: These are the x, y and z offsets used, in the present coordinate system, for moving the selected objects.
dz: These are the x, y and z offsets used, in the present coordinate system, for moving the selected objects.
        """

        all_args = [dx, dy, dz]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.EditGeneral.Move(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Move" failed')
        
        return ret

class File:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def New2DFrame(self, TempType = None, NumberStorys = None, StoryHeight = None, NumberBays = None, BayWidth = None, Restraint = None, Beam = None, Column = None, Brace = None):
        """
Do not use this function to add to an existing model. This function should be used only for creating a new model and typically would be preceded by calls to ApplicationStart or InitializeNewModel.
The function returns zero if the new 2D frame model is successfully created, otherwise it returns a nonzero value.

TempType: One of the following 2D frame template types in the e2DFrameType enumeration.
PortalFrame = 0
ConcentricBraced = 1
EccentricBraced = 2

NumberStorys: The number of stories in the frame.
StoryHeight: The height of each story. [L]
NumberBays: The number of bays in the frame.
BayWidth: The width of each bay. [L]
Restraint: Joint restraints are provided at the base of the frame when this item is True.
Beam: The frame section property used for all beams in the frame. This must either be Default or the name of a defined frame section property.
Column: The frame section property used for all columns in the frame. This must either be Default or the name of a defined frame section property.
Brace: The frame section property used for all braces in the frame. This must either be Default or the name of a defined frame section property. This item does not apply to the portal frame.
        """

        all_args = [TempType, NumberStorys, StoryHeight, NumberBays, BayWidth, Restraint, Beam, Column, Brace]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.File.New2DFrame(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"New2DFrame" failed')
        
        return ret

    def New3DFrame(self, TempType = None, NumberStorys = None, StoryHeight = None, NumberBaysX = None, BayWidthX = None, NumberBaysY = None, BayWidthY = None, Restraint = None, Beam = None, Column = None, Area = None, NumberXDivisions = None, NumberYDivisions = None):
        """
Do not use this function to add to an existing model. This function should be used only for creating a new model and typically would be preceded by calls to ApplicationStart or InitializeNewModel.
The function returns zero if the new 3D frame model is successfully created, otherwise it returns a nonzero value.

TempType: One of the following 3D frame template types in the e3DFrameType enumeration.
OpenFrame = 0
PerimeterFrame = 1
BeamSlab = 2
FlatPlate = 3
NumberStorys: The number of stories in the frame.
StoryHeight: The height of each story. [L]
NumberBaysX: The number of bays in the global X direction of the frame.
BayWidthX: The width of each bay in the global X direction of the frame. [L]
NumberBaysY: The number of bays in the global Y direction of the frame.
BayWidthY: The width of each bay in the global Y direction of the frame. [L]
Restraint: Joint restraints are provided at the base of the frame when this item is True.
Beam: The frame section property used for all beams in the frame. This must either be Default or the name of a defined frame section property.
Column: The frame section property used for all columns in the frame. This must either be Default or the name of a defined frame section property.
Area: The shell section property used for all floor slabs in the frame. This must either be Default or the name of a defined shell section property. This item does not apply to the open and perimeter frames.
NumberXDivisions: The number of divisions for each floor area object in the global X direction. This item does not apply to the open and perimeter frames.
NumberYDivisions: The number of divisions for each floor area object in the global Y direction. This item does not apply to the open and perimeter frames.
        """

        all_args = [TempType, NumberStorys, StoryHeight, NumberBaysX, BayWidthX, NumberBaysY, BayWidthY, Restraint, Beam, Column, Area, NumberXDivisions, NumberYDivisions]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.File.New3DFrame(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"New3DFrame" failed')
        
        return ret

    def NewBeam(self, NumberSpans = None, SpanLength = None, Restraint = None, Beam = None):
        """
Do not use this function to add to an existing model. This function should be used only for creating a new model and typically would be preceded by calls to ApplicationStart or InitializeNewModel.
The function returns zero if the new beam model is successfully created, otherwise it returns a nonzero value.

NumberSpans: The number of spans for the beam.
SpanLength: The length of each span. [L]
Restraint: Joint restraints are provided at the ends of each span when this item is True.
Beam: The frame section property used for the beam. This must either be Default or the name of a defined frame section property.
        """

        all_args = [NumberSpans, SpanLength, Restraint, Beam]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.File.NewBeam(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"NewBeam" failed')
        
        return ret

    def NewBlank(self):
        """
Do not use this function to add to an existing model. This function should be used only for creating a new model and typically would be preceded by calls to ApplicationStart or InitializeNewModel.
The function returns zero if the new blank model is successfully created, otherwise it returns a nonzero value.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.File.NewBlank(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"NewBlank" failed')
        
        return ret

    def NewSolidBlock(self, XWidth = None, YWidth = None, Height = None, Restraint = None, Solid = None, NumberXDivisions = None, NumberYDivisions = None, NumberZDivisions = None):
        """
The function returns zero if the new solid block model is successfully created, otherwise it returns a nonzero value.

XWidth: The total width of the solid block measured in the global X direction. [L]
YWidth: The total width of the solid block measured in the global Y direction. [L]
Height: The total height of the solid block measured in the global Z direction. [L]
Restraint: Joint restraints are provided at the base of the solid block when this item is True.
Solid: The solid property used for the solid block. This must either be Default or the name of a defined solid property.
NumberXDivisions: The number of solid objects in the global X direction of the block.
NumberYDivisions: The number of solid objects in the global Y direction of the block.
NumberZDivisions: The number of solid objects in the global Z direction of the block.
        """

        all_args = [XWidth, YWidth, Height, Restraint, Solid, NumberXDivisions, NumberYDivisions, NumberZDivisions]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.File.NewSolidBlock(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"NewSolidBlock" failed')
        
        return ret

    def NewWall(self, NumberXDivisions = None, DivisionWidthX = None, NumberZDivisions = None, DivisionWidthZ = None, Restraint = None, Area = None):
        """
Do not use this function to add to an existing model. This function should be used only for creating a new model and typically would be preceded by calls to ApplicationStart or InitializeNewModel.
The function returns zero if the new wall model is successfully created, otherwise it returns a nonzero value.

NumberXDivisions: The number of area objects in the global X direction of the wall.
DivisionWidthX: The width of each area object measured in the global X direction. [L]
NumberZDivisions: The number of area objects in the global Z direction of the wall.
DivisionWidthZ: The height of each area object measured in the global Z direction. [L]
Restraint: Joint restraints are provided at the base of the wall when this item is True.
Area: The shell section property used for the wall. This must either be Default or the name of a defined shell section property.
        """

        all_args = [NumberXDivisions, DivisionWidthX, NumberZDivisions, DivisionWidthZ, Restraint, Area]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.File.NewWall(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"NewWall" failed')
        
        return ret

    def OpenFile(self, FileName = None):
        """
This function opens an existing Sap2000 file. The file name must have an sdb, $2k, s2k, xlsx, xls, or mdb extension. Files with sdb extensions are opened as standard Sap2000 files. Files with $2k and s2k extensions are imported as text files. Files with xlsx and xls extensions are imported as Microsoft Excel files. Files with mdb extensions are imported as Microsoft Access files.
This function returns zero if the file is successfully opened and nonzero if it is not opened.
The function is only applicable when you are accessing the Sap2000 API from an external application. It will return an error if you call it from VBA inside Sap2000.

FileName: The full path of a model file to be opened in the Sap2000 application.
        """

        all_args = [FileName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.File.OpenFile(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"OpenFile" failed')
        
        return ret

    def Save(self, FileName = None):
        """
If a file name is specified, it should have an .sdb extension. If no file name is specified, the file is saved using its current name.
If there is no current name for the file (the file has not been saved previously) and this function is called with no file name specified, an error will be returned.
This function returns zero if the file is successfully saved and nonzero if it is not saved.

FileName: The full path to which the model file is saved.
        """

        all_args = [FileName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.File.Save(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Save" failed')
        
        return ret

class AreaObj:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def AddByCoord(self, NumberPoints = None, x = None, y = None, z = None, Name = None, PropName = None, UserName = None, CSys = None):
        """
This function adds a new area object, defining points at the specified coordinates.
The function returns zero if the area object is successfully added, otherwise it returns a nonzero value.

NumberPoints: The number of points in the area abject.
x: These are arrays of x, y and z coordinates, respectively, for the corner points of the area object. The coordinates are in the coordinate system defined by the CSys item. The coordinates should be ordered to run clockwise or counter clockwise around the area object.
y: These are arrays of x, y and z coordinates, respectively, for the corner points of the area object. The coordinates are in the coordinate system defined by the CSys item. The coordinates should be ordered to run clockwise or counter clockwise around the area object.
z: These are arrays of x, y and z coordinates, respectively, for the corner points of the area object. The coordinates are in the coordinate system defined by the CSys item. The coordinates should be ordered to run clockwise or counter clockwise around the area object.
Name: This is the name that the program ultimately assigns to the area object. If no UserName is specified, the program assigns a default name to the area object. If a UserName is specified and that name is not used for another area object, the UserName is assigned to the area object; otherwise a default name is assigned to the area object.
PropName: This is Default, None or the name of a defined area property.
If it is Default, the program assigns a default area property to the area object. If it is None, no area property is assigned to the area object. If it is the name of a defined area property, that property is assigned to the area object.
UserName: This is an optional user specified name for the area object. If a UserName is specified and that name is already used for another area object, the program ignores the UserName.
CSys: The name of the coordinate system in which the area object point coordinates are defined.
        """

        all_args = [NumberPoints, x, y, z, Name, PropName, UserName, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.AddByCoord(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddByCoord" failed')
        
        return ret

    def AddByPoint(self, NumberPoints = None, Point = None, Name = None, PropName = None, UserName = None):
        """
This function adds a new area object whose defining points are specified by name.
The function returns zero if the area object is successfully added; otherwise it returns a nonzero value.

NumberPoints: The number of points in the area abject.
Point: This is an array containing the names of the point objects that define the added area object. The point object names should be ordered to run clockwise or counter clockwise around the area object.
Name: This is the name that the program ultimately assigns for the area object. If no UserName is specified, the program assigns a default name to the area object. If a UserName is specified and that name is not used for another area object, the UserName is assigned to the area object; otherwise a default name is assigned to the area object.
PropName: This is Default, None or the name of a defined area property.
If it is Default, the program assigns a default area property to the area object. If it is None, no area property is assigned to the area object. If it is the name of a defined area property, that property is assigned to the area object.
UserName: This is an optional user specified name for the area object. If a UserName is specified and that name is already used for another area object, the program ignores the UserName.
        """

        all_args = [NumberPoints, Point, Name, PropName, UserName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.AddByPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddByPoint" failed')
        
        return ret

    def ChangeName(self, Name = None, NewName = None):
        """
This function applies a new name to an area object.
The function returns zero if the new name is successfully applied, otherwise it returns a nonzero value.

Name: The existing name of a defined area object.
NewName: The new name for the area object.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def GetLoadWindPressure_1(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, MyType = None, Cp = None, DistributionType = None, ItemType = None):
        """
This function retrieves the wind pressure load assignments 
 to area objects.
The function returns zero if the load assignments are 
 successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending 
 on the value of the ItemType item.
NumberItems: The total number of wind pressure loads retrieved for 
 the specified area objects.
AreaName: This is an array that includes the name of the area 
 object associated with each wind pressure load.
LoadPat: This is an array that includes the name of the load 
 pattern associated with each wind pressure load.
MyType: This is an array that includes either 1 or 2, indicating 
 the wind pressure type.
1 = Windward, pressure 
 varies over height
2 = Other, pressure is constant 
 over height
Cp: This is an array that includes the wind pressure coefficient 
 value.
DistributionType: This is either 1 or 2, indicating the distribution type.
1 = To Joints
2 = To Frames – One-way
3 = To Frames – Two-way
ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved 
 for the area object specified by the Name item.
If this item is Group, the assignments are retrieved 
 for all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved 
 for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, MyType, Cp, DistributionType, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetLoadWindPressure_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadWindPressure_1" failed')
        
        return ret

    def Count(self):
        """
This function returns a count of the area objects in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def DeleteLoadGravity(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the gravity load assignments to the specified area objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the area object specified by the Name item.
If this item is Group, the load assignments are deleted for all area objects in the group specified by the Name item.
If this item is SelectedObjects,the load assignments are deleted for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.DeleteLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadGravity" failed')
        
        return ret

    def DeleteLoadPorePressure(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the pore pressure load assignments to the specified area objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the area object specified by the Name item.
If this item is Group, the load assignments are deleted for all area objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.DeleteLoadPorePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadPorePressure" failed')
        
        return ret

    def DeleteLoadRotate(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the rotate load assignments to the specified area objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the area object specified by the Name item.
If this item is Group, the load assignments are deleted for all area objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.DeleteLoadRotate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadRotate" failed')
        
        return ret

    def DeleteLoadStrain(self, Name = None, LoadPat = None, Component = None, ItemType = None):
        """
This function deletes the strain load assignments to the specified area objects, for the specified load pattern, for the specified components.
The function returns zero if the load assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Component: This is 1, 2, 3, 4, 5, 6, 7, 8, or 9, indicating the component to which the strain load is applied.
1 = Strain11
2 = Strain12
3 = Strain13
4 = Curvature11
5 = Curvature22
6 = Curvature33
7 = Strain13
8 = Strain23
9 = Strain33
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the area object specified by the Name item.
If this item is Group, the load assignments are deleted for all area objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Component, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.DeleteLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadStrain" failed')
        
        return ret

    def DeleteLoadSurfacePressure(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the surface pressure load assignments to the specified area objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the area object specified by the Name item.
If this item is Group, the load assignments are deleted for all area objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.DeleteLoadSurfacePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadSurfacePressure" failed')
        
        return ret

    def DeleteLoadTemperature(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the temperature load assignments to the specified area objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the area object specified by the Name item.
If this item is Group, the load assignments are deleted for all area objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.DeleteLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadTemperature" failed')
        
        return ret

    def DeleteLoadUniform(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the uniform load assignments to the specified area objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the area object specified by the Name item.
If this item is Group, the load assignments are deleted for all area objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.DeleteLoadUniform(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadUniform" failed')
        
        return ret

    def DeleteLoadUniformToFrame(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the uniform to frame load assignments to the specified area objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the area object specified by the Name item.
If this item is Group, the load assignments are deleted for all area objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.DeleteLoadUniformToFrame(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadUniformToFrame" failed')
        
        return ret

    def DeleteLoadWindPressure(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the wind pressure load assignments 
 to the specified area objects for the specified load pattern.
The function returns zero if the load assignments are 
 successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending 
 on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted 
 for the area object specified by the Name item.
If this item is Group, the load assignments are deleted 
 for all area objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments 
 are deleted for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.DeleteLoadWindPressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadWindPressure" failed')
        
        return ret

    def DeleteMass(self, Name = None, ItemType = None):
        """
This function deletes the mass assignments for area objects.
The function returns zero if the mass assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the mass assignments are deleted for the area object specified by the Name item.
If this item is Group, the mass assignments are deleted for all area objects in the group specified by the Name item.
If this item is SelectedObjects, the mass assignments are deleted for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.DeleteMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteMass" failed')
        
        return ret

    def DeleteModifiers(self, Name = None, ItemType = None):
        """
This function deletes the modifier assignments for area objects.
The function returns zero if the modifier assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the modifier assignments are deleted for the area object specified by the Name item.
If this item is Group, the modifier assignments are deleted for all area objects in the group specified by the Name item.
If this item is SelectedObjects, the modifier assignments are deleted for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.DeleteModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteModifiers" failed')
        
        return ret

    def DeleteSpring(self, Name = None, ItemType = None):
        """
This function deletes all spring assignments for the specified area objects.
The function returns zero if the assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the spring assignments are deleted for the area object specified by the Name item.
If this item is Group, the spring assignments are deleted for all area objects in the group specified by the Name item.
If this item is SelectedObjects, the spring assignments are deleted for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.DeleteSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteSpring" failed')
        
        return ret

    def Delete(self, Name = None, ItemType = None):
        """
The function deletes area objects.
The function returns zero if the area objects are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the area object specified by the Name item is deleted.
If this item is Group, all of the area objects in the group specified by the Name item are deleted.
If this item is SelectedObjects, all of the selected area objects are deleted, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetAutoMesh(self, Name = None, MeshType = None, n1 = None, n2 = None, MaxSize1 = None, MaxSize2 = None, PointOnEdgeFromLine = None, PointOnEdgeFromPoint = None, ExtendCookieCutLines = None, Rotation = None, MaxSizeGeneral = None, LocalAxesOnEdge = None, LocalAxesOnFace = None, RestraintsOnEdge = None, RestraintsOnFace = None, Group = None, SubMesh = None, SubMeshSize = None):
        """
This function retrieves the automatic meshing assignments to area objects.
The function returns zero if the meshing assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing area object.
MeshType: This item is 0, 1, 2, 3, 4, 5 or 6, indicating the automatic mesh type for the area object.
0 = No automatic meshing
1 = Mesh area into a specified number of objects
2 = Mesh area into objects of a specified maximum size
3 = Mesh area based on points on area edges
4 = Cookie cut mesh area based on lines intersecting edges
5 = Cookie cut mesh area based on points
6 = Mesh area using General Divide Tool

Mesh options 1, 2 and 3 apply to quadrilaterals and triangles only.
n1: This item applies when MeshType = 1. It is the number of objects created along the edge of the meshed area object that runs from point 1 to point 2.
n2: This item applies when MeshType = 1. It is the number of objects created along the edge of the meshed area object that runs from point 1 to point 3.
MaxSize1: This item applies when MeshType = 2. It is the maximum size of objects created along the edge of the meshed area object that runs from point 1 to point 2. [L]
MaxSize2: This item applies when MeshType = 2. It is the maximum size of objects created along the edge of the meshed area object that runs from point 1 to point 3. [L]
PointOnEdgeFromLine: This item applies when MeshType = 3. If it is True, points on the area object edges are determined from intersections of straight line objects included in the group specified by the Group item with the area object edges.
PointOnEdgeFromPoint: This item applies when MeshType = 3. If it is True, points on the area object edges are determined from point objects included in the group specified by the Group item that lie on the area object edges.
ExtendCookieCutLines: This item applies when MeshType = 4. MeshType = 4 provides cookie cut meshing based on straight line objects included in the group specified by the Group item that intersect the area object edges. If the ExtendCookieCutLines item is True, all straight line objects included in the group specified by the Group item are extended to intersect the area object edges for the purpose of meshing the area object.
Rotation: This item applies when MeshType = 5. MeshType = 5 provides cookie cut meshing based on two perpendicular lines passing through point objects included in the group specified by the Group item. By default these lines align with the area object local 1 and 2 axes. The Rotation item is an angle in degrees that the meshing lines are rotated from their default orientation. [deg]
MaxSizeGeneral: This item applies when MeshType = 6. It is the maximum size of objects created by the General Divide Tool.
LocalAxesOnEdge: If this item is True, and if both points along an edge of the original area object have the same local axes, the program makes the local axes for added points along the edge the same as the edge end points.
LocalAxesOnFace: If this item is True, and if all points around the perimeter of the original area object have the same local axes, the program makes the local axes for all added points the same as the perimeter points.
RestraintsOnEdge: If this item is True, and if both points along an edge of the original area object have the same restraint/constraint, then, if the added point and the adjacent corner points have the same local axes definition, the program includes the restraint/constraint for added points along the edge.
RestraintsOnFace: If this item is True, and if all points around the perimeter of the original area object have the same restraint/constraint, then, if an added point and the perimeter points have the same local axes definition, the program includes the restraint/constraint for the added point.
Group: The name of a defined group. Some of the meshing options make use of point and line objects included in this group.
SubMesh: If this item is True, after initial meshing, the program further meshes any area objects that have an edge longer than the length specified by the SubMeshSize item.
SubMeshSize: This item applies when the SubMesh item is True. It is the maximum size of area objects to remain when the auto meshing is complete. [L]
        """

        all_args = [Name, MeshType, n1, n2, MaxSize1, MaxSize2, PointOnEdgeFromLine, PointOnEdgeFromPoint, ExtendCookieCutLines, Rotation, MaxSizeGeneral, LocalAxesOnEdge, LocalAxesOnFace, RestraintsOnEdge, RestraintsOnFace, Group, SubMesh, SubMeshSize]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetAutoMesh(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAutoMesh" failed')
        
        return ret

    def GetEdgeConstraint(self, Name = None, ConstraintExists = None):
        """
This function retrieves the generated edge constraint assignments to area objects.
The function returns zero if the assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object.
ConstraintExists: This item is True if an automatic edge constraint is generated by the program for the area object in the analysis model.
        """

        all_args = [Name, ConstraintExists]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetEdgeConstraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEdgeConstraint" failed')
        
        return ret

    def GetElm(self, Name = None, nelm = None, Elm = None):
        """
This function retrieves the names of the area elements (analysis model area) associated with a specified area object in the object-based model.
This function returns zero if the area element information is successfully returned; otherwise it returns nonzero. An error occurs if the analysis model does not currently exist.

Name: The name of an existing area object.
nelm: The number of area elements created from the specified area object.
Elm: An array that includes the name of a area element created from the specified area object.
        """

        all_args = [Name, nelm, Elm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetElm(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetElm" failed')
        
        return ret

    def GetGroupAssign(self, Name = None, NumberGroups = None, Groups = None):
        """
This function retrieves the names of the groups to which a specified area object is assigned.
The function returns zero if the group assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing area object.
NumberGroups: The number of group names retrieved.
Groups: The names of the groups to which the area object is assigned.
        """

        all_args = [Name, NumberGroups, Groups]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGroupAssign" failed')
        
        return ret

    def GetGUID(self, Name = None, GUID = None):
        """
This function retrieves the GUID for the specified area object.
This function returns zero if the area object GUID is successfully retrieved; otherwise, it returns nonzero.

Name: The name of an existing area object.
GUID: The GUID (Global Unique ID) for the specified area object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGUID" failed')
        
        return ret

    def GetLoadGravity(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, CSys = None, x = None, y = None, z = None, ItemType = None):
        """
This function retrieves the gravity load assignments to area objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
NumberItems: The total number of gravity loads retrieved for the specified area objects.
AreaName: This is an array that includes the name of the area object associated with each gravity load.
LoadPat: This is an array that includes the name of the coordinate system in which the gravity load multipliers are specified.
CSys: This is an array that includes the name of the coordinate system associated with each gravity load.
x: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the area object specified by the Name item.
If this item is Group, the assignments are retrieved for all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, CSys, x, y, z, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadGravity" failed')
        
        return ret

    def GetLoadPorePressure(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, Value = None, PatternName = None, ItemType = None):
        """
This function retrieves the pore pressure load assignments to area objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
NumberItems: The total number of pore pressure loads retrieved for the specified area objects.
AreaName: This is an array that includes the name of the area object associated with each pore pressure load.
LoadPat: This is an array that includes the name of the load pattern associated with each pore pressure load.
Value: This is an array that includes the pore pressure load value. [F/L2]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the pore pressure load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the area object specified by the Name item.
If this item is Group, the assignments are retrieved for all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, Value, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetLoadPorePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadPorePressure" failed')
        
        return ret

    def GetLoadRotate(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, Value = None, ItemType = None):
        """
This function retrieves the rotate load assignments to area objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
NumberItems: The total number of rotate loads retrieved for the specified area objects.
AreaName: This is an array that includes the name of the area object associated with each rotate load.
LoadPat: This is an array that includes the name of the load pattern associated with each rotate load.
Value: This is an array that includes the angular velocity value. [Cyc/T]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the area object specified by the Name item.
If this item is Group, the assignments are retrieved for all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetLoadRotate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadRotate" failed')
        
        return ret

    def GetLoadStrain(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, Component = None, Value = None, PatternName = None, ItemType = None):
        """
This function retrieves the strain load assignments to area objects.
The function returns zero if the strain load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
NumberItems: The total number of strain loads retrieved for the specified area objects.
AreaName: This is an array that includes the name of the area object associated with each strain load.
LoadPat: This is an array that includes the name of the load pattern associated with each strain load.
Component: This is an array that includes 1, 2, 3, 4, 5, 6, 7, 8, or 9, indicating the component associated with each strain load.
1 = Strain11
2 = Strain22
3 = Strain12
4 = Curvature11
5 = Curvature22
6 = Curvature12
7 = Strain13
8 = Strain23
9 = Strain33
Value: This is an array that includes the strain value. [L/L] for Component = 1, 2, 3, 7, 8, and 9, and [1/L] for Component = 4, 5 and 6
PatternName: This is an array that includes the joint pattern name, if any, used to specify the strain load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the area object specified by the Name item.
If this item is Group, the assignments are retrieved for all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, Component, Value, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadStrain" failed')
        
        return ret

    def GetLoadSurfacePressure(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, Face = None, Value = None, PatternName = None, ItemType = None):
        """
This function retrieves the surface pressure load assignments to area objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
NumberItems: The total number of surface pressure loads retrieved for the specified area objects.
AreaName: This is an array that includes the name of the area object associated with each surface pressure load.
LoadPat: This is an array that includes the name of the load pattern associated with each surface pressure load.
Face: This is an array that includes either -1, -2 or a nonzero, positive integer, indicating the area object face to which the specified load assignment applies.
-1 = Bottom face
-2 = Top face
>0 = Edge face

Note that edge face n is from area object point n to area object point n + 1. For example, edge face 2 is from area object point 2 to area object point 3.
Value: This is an array that includes the surface pressure load value. [F/L2]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the surface pressure load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the area object specified by the Name item.
If this item is Group, the assignments are retrieved for all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, Face, Value, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetLoadSurfacePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadSurfacePressure" failed')
        
        return ret

    def GetLoadTemperature(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, MyType = None, Value = None, PatternName = None, ItemType = None):
        """
This function retrieves the temperature load assignments to area objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
NumberItems: The total number of temperature loads retrieved for the specified area objects.
AreaName: This is an array that includes the name of the area object associated with each temperature load.
LoadPat: This is an array that includes the name of the load pattern associated with each temperature load.
MyType: This is an array that includes either 1 or 3, indicating the type of temperature load.
1 = Temperature
3 = Temperature gradient along local 3 axis
Value: This is an array that includes the temperature load value. [T] for MyType= 1 and [T/L] for MyType= 3
PatternName: This is an array that includes the joint pattern name, if any, used to specify the temperature load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the area object specified by the Name item.
If this item is Group, the assignments are retrieved for all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, MyType, Value, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTemperature" failed')
        
        return ret

    def GetLoadUniformToFrame(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, CSys = None, Dir = None, Value = None, DistType = None, ItemType = None):
        """
This function retrieves the uniform to frame load assignments 
 to area objects.
The function returns zero if the load assignments are 
 successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending 
 on the value of the ItemType item.
NumberItems: The total number of uniform loads retrieved 
 for the specified area objects.
AreaName: This is an array that includes the name of the area 
 object associated with each uniform load.
LoadPat: This is an array that includes the name of the coordinate 
 system in which the uniform load is specified.
CSys: This is an array that includes the name of the coordinate 
 system associated with each uniform load.
Dir: This is an integer between 1 and 11, indicating the 
 direction of the load.
1 = Local 1 axis (only 
 applies when CSys is Local)
2 = Local 2 axis (only 
 applies when CSys is Local)
3 = Local 3 axis (only 
 applies when CSys is Local)
4 = X direction (does 
 not apply when CSys is Local)
5 = Y direction (does 
 not apply when CSys is Local)
6 = Z direction (does 
 not apply when CSys is Local)
7 = Projected X direction 
 (does not apply when CSys is Local)
8 = Projected Y direction 
 (does not apply when CSys is Local)
9 = Projected Z direction 
 (does not apply when CSys is Local)
10 = Gravity direction 
 (only applies when CSys is Global)
11 = Projected Gravity 
 direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) 
 is in the negative Global Z direction.
Value: The uniform load value. [F/L2]
DistType: This is either 1 or 2, indicating the load distribution 
 type.
1 = One-way load distribution
2 = Two-way load distribution

One-way distribution is parallel to the area object 
 local 1 axis. Two-way distribution is parallel to the area object local 
 1 and 2 axes.
ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved 
 for the area object specified by the Name item.
If this item is Group, the assignments are retrieved 
 for all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved 
 for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, CSys, Dir, Value, DistType, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetLoadUniformToFrame(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadUniformToFrame" failed')
        
        return ret

    def GetLoadUniform(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, CSys = None, Dir = None, Value = None, ItemType = None):
        """
This function retrieves the uniform load assignments to area objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
NumberItems: The total number of uniform loads retrieved for the specified area objects.
AreaName: This is an array that includes the name of the area object associated with each uniform load.
LoadPat: This is an array that includes the name of the coordinate system in which the uniform load is specified.
CSys: This is an array that includes the name of the coordinate system associated with each uniform load.
Dir: This is an integer between 1 and 11, indicating the direction of the load.
1 = Local 1 axis (only applies when CSys is Local)
2 = Local 2 axis (only applies when CSys is Local)
3 = Local 3 axis (only applies when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
7 = Projected X direction (does not apply when CSys is Local)
8 = Projected Y direction (does not apply when CSys is Local)
9 = Projected Z direction (does not apply when CSys is Local)
10 = Gravity direction (only applies when CSys is Global)
11 = Projected Gravity direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) is in the negative Global Z direction.
Value: The uniform load value. [F/L2]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the area object specified by the Name item.
If this item is Group, the assignments are retrieved for all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, CSys, Dir, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetLoadUniform(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadUniform" failed')
        
        return ret

    def GetLoadWindPressure(self, Name = None, NumberItems = None, AreaName = None, LoadPat = None, MyType = None, Cp = None, ItemType = None):
        """
This function retrieves the wind pressure load assignments 
 to area objects.
The function returns zero if the load assignments are 
 successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending 
 on the value of the ItemType item.
NumberItems: The total number of wind pressure loads retrieved for 
 the specified area objects.
AreaName: This is an array that includes the name of the area 
 object associated with each wind pressure load.
LoadPat: This is an array that includes the name of the load 
 pattern associated with each wind pressure load.
MyType: This is an array that includes either 1 or 2, indicating 
 the wind pressure type.
1 = Windward, pressure 
 varies over height
2 = Other, pressure is constant 
 over height
Cp: This is an array that includes the wind pressure coefficient 
 value.
ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved 
 for the area object specified by the Name item.
If this item is Group, the assignments are retrieved 
 for all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved 
 for all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, AreaName, LoadPat, MyType, Cp, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetLoadWindPressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadWindPressure" failed')
        
        return ret

    def GetLocalAxesAdvanced(self, Name = None, Active = None, Plane2 = None, PlVectOpt = None, PlCSys = None, PlDir = None, PlPt = None, PlVect = None):
        """
This function retrieves the advanced local axes assignments to area objects.
The function returns zero if the advanced local axes assignments are  retrieved successfully; otherwise it returns a nonzero value.

Name: The name of an existing area object.
Active: This is True if advanced local axes exist.
Plane2: This is 31 or 32, indicating that the local plane determined by the plane reference vector is the 3-1 plane or the 3-2 plane. This item applies only when the Active item is True.
PlVectOpt: This is 1, 2, or 3, indicating the plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
PlCSys: The coordinate system used to define the plane reference vector coordinate directions and the plane user vector. This item applies when the Active item is True and the PlVectOpt item is 1 or 3.
PlDir: This is an array dimensioned to 1 (2 integers) indicating the plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
PlPt: This is an array dimensioned to 1 (2 strings) indicating the labels of two joints that define the plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the PlVectOpt item is 2.
PlVect: This is an array dimensioned to 2 (3 doubles) that defines the plane reference vector. This item applies when the Active item is True and the PlVectOpt item is 3.
        """

        all_args = [Name, Active, Plane2, PlVectOpt, PlCSys, PlDir, PlPt, PlVect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetLocalAxesAdvanced(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxesAdvanced" failed')
        
        return ret

    def GetLocalAxes(self, Name = None, Ang = None, Advanced = None):
        """
This function retrieves the local axis angle assignment for area objects.
The function returns zero if the assignment is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object.
Ang: This is the angle that the local 1 and 2 axes are rotated about the positive local 3 axis from the default orientation. The rotation for a positive angle appears counter clockwise when the local +3 axis is pointing toward you. [deg]
Advanced: This item is True if the area object local axes orientation was obtained using advanced local axes parameters.
        """

        all_args = [Name, Ang, Advanced]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxes" failed')
        
        return ret

    def GetMass(self, Name = None, MassOverL2 = None):
        """
This function retrieves the mass per unit area assignment for area objects.
The function returns zero if the mass assignment is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object.
MassOverL2: The mass per unit area assigned to the area object. [M/L2]
        """

        all_args = [Name, MassOverL2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMass" failed')
        
        return ret

    def GetMaterialOverwrite(self, Name = None, PropName = None):
        """
This function retrieves the material overwrite assigned to an area object, if any. The material property name is indicated as None if there is no material overwrite assignment.
The function returns zero if the material overwrite assignment is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined area object.
PropName: This is None, indicating that no material overwrite exists for the specified area object, or it is the name of an existing material property.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetMaterialOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMaterialOverwrite" failed')
        
        return ret

    def GetMatTemp(self, Name = None, Temp = None, PatternName = None):
        """
This function retrieves the material temperature assignments to area objects.
The function returns zero if the material temperature assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object.
Temp: This is the material temperature value assigned to the area object. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the area object is uniform over the object at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the area object may vary. The material temperature at each corner point around the area object perimeter is equal to the specified temperature multiplied by the pattern value at the associated point object. The material temperature at other points in the area object is calculated by interpolation from the corner points.
        """

        all_args = [Name, Temp, PatternName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMatTemp" failed')
        
        return ret

    def GetModifiers(self, Name = None, Value = None):
        """
This function retrieves the modifier assignment for area objects. The default value for all modifiers is one.
The function returns zero if the modifier assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object.
Value: This is an array of ten unitless modifiers.
Value(0) = Membrane f11 modifier
Value(1) = Membrane f22 modifier
Value(2) = Membrane f12 modifier
Value(3) = Bending m11 modifier
Value(4) = Bending m22 modifier
Value(5) = Bending m12 modifier
Value(6) = Shear v13 modifier
Value(7) = Shear v23 modifier
Value(8) = Mass modifier
Value(9) = Weight modifier

        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModifiers" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined area objects.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of area object names retrieved by the program.
MyName: This is a one-dimensional array of area object names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetOffsets(self, Name = None, OffsetType = None, OffsetPattern = None, OffsetPatternSF = None, Offset = None):
        """
This function retrieves the joint offset assignments for area objects.
The function returns zero if the assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object.
OffsetType: This is 0, 1 or 2, indicating the joint offset type.
0 = No joint offsets
1 = User defined joint offsets specified by joint pattern
2 = User defined joint offsets specified by point

OffsetPattern: This item applies only when OffsetType = 1. It is the name of the defined joint pattern that is used to calculate the joint offsets.
OffsetPatternSF: This item applies only when OffsetType = 1. It is the scale factor applied to the joint pattern when calculating the joint offsets. [L]
Offset: This item applies only when OffsetType = 2. It is an array of joint offsets for each of the points that define the area object. [L]
        """

        all_args = [Name, OffsetType, OffsetPattern, OffsetPatternSF, Offset]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetOffsets(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOffsets" failed')
        
        return ret

    def GetPoints(self, Name = None, NumberPoints = None, Point = None):
        """
This function retrieves the names of the point objects that define an area object.
The function returns zero if the point object names are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined area object.
NumberPoints: The number of point objects that define the area object.
Point: This is an array containing the names of the point objects that define the area object. The point names are in order around the area object.
        """

        all_args = [Name, NumberPoints, Point]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPoints" failed')
        
        return ret

    def GetProperty(self, Name = None, PropName = None):
        """
This function retrieves the area property assigned to an area object.
The function returns zero if the property is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined area object.
PropName: The name of the area property assigned to the area object. This item is None if no area property is assigned to the area object.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProperty" failed')
        
        return ret

    def GetSpring(self, Name = None, NumberSprings = None, MyType = None, s = None, SimpleSpringType = None, LinkProp = None, Face = None, SpringLocalOneType = None, Dir = None, Outward = None, VecX = None, VecY = None, VecZ = None, CSys = None, Ang = None):
        """
This function retrieves the spring assignments to an area object face.
The function returns zero if the assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object.
NumberSprings: The number of spring assignments made to the specified area object.
MyType: Each value in this array is either 1 or 2, indicating the spring property type.
1 = Simple spring
2 = Link property
s: Each value in this array is the simple spring stiffness per unit area of the specified area object face. This item applies only when the corresponding MyType = 1. [F/L3]
SimpleSpringType: Each value in this array is 1, 2 or 3, indicating the simple spring type. This item applies only when the corresponding MyType = 1.
1 = Spring resists tension and compression
2 = Spring resists compression only
3 = Spring resists tension only
LinkProp: Each value in this array is the name of the link property assigned to the spring. This item applies only when the corresponding MyType = 2.
Face: Each value in this array is -1, -2 or a nonzero, positive integer, indicating the area object face to which the specified spring assignment applies.
-1 = Bottom face
-2 = Top face
>0 = Edge face

Note that edge face n is from area object point n to area object point n + 1. For example, edge face 2 is from area object point 2 to area object point 3.
SpringLocalOneType: Each value in this array is 1, 2 or 3, indicating the method used to specify the spring positive local 1-axis orientation.
1 = Parallel to area object local axis
2 = Normal to specified area object face
3 = User specified direction vector
Dir: Each value in this array is 1, 2, 3, -1, -2 or -3, indicating the area object local axis that corresponds to the positive local 1-axis of the spring. This item applies only when the corresponding SpringLocalOneType = 1.
Outward: Each value in this array is True if the spring positive local 1 axis is outward from the specified area object face. This item applies only when SpringLocalOneType = 2.
VecX: Each value in this array is the X-axis or area object local 1-axis component (depending on the CSys specified) of the user specified direction vector for the spring local 1-axis. The direction vector is in the coordinate system specified by the CSys item. This item applies only when the corresponding SpringLocalOneType = 3.
VecY: Each value in this array is the Y-axis or area object local 2-axis component (depending on the CSys specified) of the user specified direction vector for the spring local 1-axis. The direction vector is in the coordinate system specified by the CSys item. This item applies only when the corresponding SpringLocalOneType = 3.
VecZ: Each value in this array is the X-axis or area object local 3-axis component (depending on the CSys specified) of the user specified direction vector for the spring local 1-axis. The direction vector is in the coordinate system specified by the CSys item. This item applies only when the corresponding SpringLocalOneType = 3.
CSys: Each value in this array is Local (meaning the area object local coordinate system) or the name of a defined coordinate system. This item is the coordinate system in which the user specified direction vector, Vec, is specified. This item applies only when the corresponding SpringLocalOneType = 3.
Ang: Each value in this array is the angle that the link local 2-axis is rotated from its default orientation. This item applies only when the corresponding MyType = 2. [deg]
        """

        all_args = [Name, NumberSprings, MyType, s, SimpleSpringType, LinkProp, Face, SpringLocalOneType, Dir, Outward, VecX, VecY, VecZ, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSpring" failed')
        
        return ret

    def GetThickness(self, Name = None, ThicknessType = None, ThicknessPattern = None, ThicknessPatternSF = None, Thickness = None):
        """
This function retrieves the thickness overwrite assignments for area objects.
The function returns zero if the assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing area object.
ThicknessType: This is 0, 1 or 2, indicating the thickness overwrite type.
0 = No thickness overwrites
1 = User defined thickness overwrites specified by joint pattern
2 = User defined thickness overwrites specified by point

ThicknessPattern: This item applies only when ThicknessType = 1. It is the name of the defined joint pattern that is used to calculate the thicknesses.
ThicknessPatternSF: This item applies only when ThicknessType = 1. It is the scale factor applied to the joint pattern when calculating the thicknesses. [L]
Thickness: This item applies only when ThicknessType = 2. It is an array of thicknesses at each of the points that define the area object. [L]
        """

        all_args = [Name, ThicknessType, ThicknessPattern, ThicknessPatternSF, Thickness]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.GetThickness(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetThickness" failed')
        
        return ret

    def SetAutoMesh(self, Name = None, MeshType = None, n1 = None, n2 = None, MaxSize1 = None, MaxSize2 = None, PointOnEdgeFromLine = None, PointOnEdgeFromPoint = None, ExtendCookieCutLines = None, Rotation = None, MaxSizeGeneral = None, LocalAxesOnEdge = None, LocalAxesOnFace = None, RestraintsOnEdge = None, RestraintsOnFace = None, Group = None, SubMesh = None, SubMeshSize = None, ItemType = None):
        """
This function makes automatic meshing assignments to area objects.
The function returns zero if the meshing options are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
MeshType: This item is 0, 1, 2, 3, 4, 5 or 6, indicating the automatic mesh type for the area object.
0 = No automatic meshing
1 = Mesh area into a specified number of objects
2 = Mesh area into objects of a specified maximum size
3 = Mesh area based on points on area edges
4 = Cookie cut mesh area based on lines intersecting edges
5 = Cookie cut mesh area based on points
6 = Mesh area using General Divide Tool

Mesh options 1, 2 and 3 apply to quadrilaterals and triangles only.
n1: This item applies when MeshType = 1. It is the number of objects created along the edge of the meshed area object that runs from point 1 to point 2.
n2: This item applies when MeshType = 1. It is the number of objects created along the edge of the meshed area object that runs from point 1 to point 3.
MaxSize1: This item applies when MeshType = 2. It is the maximum size of objects created along the edge of the meshed area object that runs from point 1 to point 2. [L]
If this item is input as 0, the default value is used. The default value is 48 inches if the database units are English or 120 centimeters if the database units are metric.
MaxSize2: This item applies when MeshType = 2. It is the maximum size of objects created along the edge of the meshed area object that runs from point 1 to point 3. [L]
If this item is input as 0, the default value is used. The default value is 48 inches if the database units are English or 120 centimeters if the database units are metric.
PointOnEdgeFromLine: This item applies when MeshType = 3. If it is True, points on the area object edges are determined from intersections of straight line objects included in the group specified by the Group item with the area object edges.
PointOnEdgeFromPoint: This item applies when MeshType = 3. If it is True, points on the area object edges are determined from point objects included in the group specified by the Group item that lie on the area object edges.
ExtendCookieCutLines: This item applies when MeshType = 4. MeshType = 4 provides cookie cut meshing based on straight line objects included in the group specified by the Group item that intersect the area object edges. If the ExtendCookieCutLines item is True, all straight line objects included in the group specified by the Group item are extended to intersect the area object edges for the purpose of meshing the area object.
Rotation: This item applies when MeshType = 5. MeshType = 5 provides cookie cut meshing based on two perpendicular lines passing through point objects included in the group specified by the Group item. By default these lines align with the area object local 1 and 2 axes. The Rotation item is an angle in degrees that the meshing lines are rotated from their default orientation. [deg]
MaxSizeGeneral: This item applies when MeshType = 6. It is the maximum size of objects created by the General Divide Tool.
If this item is input as 0, the default value is used. The default value is 48 inches if the database units are English or 120 centimeters if the database units are metric.
LocalAxesOnEdge: If this item is True, and if both points along an edge of the original area object have the same local axes, then the program makes the local axes for added points along the edge the same as the edge end points.
LocalAxesOnFace: If this item is True, and if all points around the perimeter of the original area object have the same local axes, the program makes the local axes for all added points the same as the perimeter points.
RestraintsOnEdge: If this item is True, and if both points along an edge of the original area object have the same restraint/constraint, then, if the added point and the adjacent corner points have the same local axes definition, the program includes the restraint/constraint for added points along the edge.
RestraintsOnFace: If this item is True, and if all points around the perimeter of the original area object have the same restraint/constraint, then, if an added point and the perimeter points have the same local axes definition, the program includes the restraint/constraint for the added point.
Group: The name of a defined group. Some of the meshing options make use of point and line objects included in this group.
SubMesh: If this item is True, after initial meshing, the program further meshes any area objects that have an edge longer than the length specified by the SubMeshSize item.
SubMeshSize: This item applies when the SubMesh item is True. It is the maximum size of area objects to remain when the auto meshing is complete. [L]
If this item is input as 0, the default value is used. The default value is 12 inches if the database units are English or 30 centimeters if the database units are metric.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, MeshType, n1, n2, MaxSize1, MaxSize2, PointOnEdgeFromLine, PointOnEdgeFromPoint, ExtendCookieCutLines, Rotation, MaxSizeGeneral, LocalAxesOnEdge, LocalAxesOnFace, RestraintsOnEdge, RestraintsOnFace, Group, SubMesh, SubMeshSize, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetAutoMesh(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAutoMesh" failed')
        
        return ret

    def SetEdgeConstraint(self, Name = None, ConstraintExists = None, ItemType = None):
        """
This function makes generated edge constraint assignments to area objects.
The function returns zero if the edge constraint option is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
ConstraintExists: This item is True if an automatic edge constraint is generated by the program for the area object in the analysis model.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, ConstraintExists, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetEdgeConstraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEdgeConstraint" failed')
        
        return ret

    def SetGroupAssign(self, Name = None, GroupName = None, Remove = None, ItemType = None):
        """
This function adds or removes area objects from a specified group.
The function returns zero if the group assignment is successful; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
GroupName: The name of an existing group to which the assignment is made.
Remove: If this item is False, the specified area objects are added to the group specified by the GroupName item. If it is True, the area objects are removed from the group.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the area object specified by the Name item is added or removed from the group specified by the GroupName item.
If this item is Group, all area objects in the group specified by the Name item are added or removed from the group specified by the GroupName item.
If this item is SelectedObjects, all selected area objects are added or removed from the group specified by the GroupName item, and the Name item is ignored.
        """

        all_args = [Name, GroupName, Remove, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGroupAssign" failed')
        
        return ret

    def SetGUID(self, Name = None, GUID = None):
        """
This function sets the GUID for the specified area object. If the GUID is passed in as a blank string, the program automatically creates a GUID for the object.
This function returns zero if the area object GUID is successfully set; otherwise, it returns nonzero.

Name: The name of an existing area object.
GUID: The GUID (Global Unique ID) for the specified area object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGUID" failed')
        
        return ret

    def SetLoadGravity(self, Name = None, LoadPat = None, x = None, y = None, z = None, Replace = None, CSys = None, ItemType = None):
        """
This function assigns gravity load multipliers to area objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
x: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
Replace: If this item is True, all previous gravity loads, if any, assigned to the specified area object(s), in the specified load pattern, are deleted before making the new assignment.
CSys: The coordinate system in which the x, y and z multipliers are specified.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, x, y, z, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadGravity" failed')
        
        return ret

    def SetLoadPorePressure(self, Name = None, LoadPat = None, Value = None, PatternName = None, Replace = None, ItemType = None):
        """
This function assigns pore pressure loads to area objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Value: This is the pore pressure value. [F/L2]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the pore pressure load for the area object is uniform over the object at the value specified by Value.
If PatternName is the name of a defined joint pattern, the pore pressure load for the area object is based on the specified pore pressure value multiplied by the pattern value at the point objects that define the area object.
Replace: If this item is True, all previous pore pressure loads, if any, assigned to the specified area object(s), in the specified load case, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Value, PatternName, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetLoadPorePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadPorePressure" failed')
        
        return ret

    def SetLoadRotate(self, Name = None, LoadPat = None, Value = None):
        """
This function assigns rotate loads to area objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Value: This is the angular velocity. [Cyc/T]
        """

        all_args = [Name, LoadPat, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetLoadRotate(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadRotate" failed')
        
        return ret

    def SetLoadStrain(self, Name = None, LoadPat = None, Component = None, Value = None, Replace = None, PatternName = None, ItemType = None):
        """
This function assigns strain loads to area objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Component: This is 1, 2, 3, 4, 5, 6, 7, 8, or 9, indicating the component to which the strain load is applied.
1 = Strain11
2 = Strain22
3 = Strain12
4 = Curvature11
5 = Curvature22
6 = Curvature12
7 = Strain13
8 = Strain23
9 = Strain33
Value: This is the strain load value. [L/L] for Component = 1, 2, 3, 7, 8, and 9 and [1/L] for Component = 4, 5 and 6
Replace: If this item is True, all previous strain loads, if any, assigned to the specified area object(s), in the specified load pattern, for the specified degree of freedom, are deleted before making the new assignment.
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the strain load for the area object is uniform over the object at the value specified by Value.
If PatternName is the name of a defined joint pattern, the strain load for the area object is based on the specified strain value multiplied by the pattern value at the corner points of the area object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Component, Value, Replace, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadStrain" failed')
        
        return ret

    def SetLoadSurfacePressure(self, Name = None, LoadPat = None, Face = None, Value = None, PatternName = None, Replace = None, ItemType = None):
        """
This function assigns surface pressure loads to area objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Face: This is -1, -2 or a nonzero, positive integer, indicating the area object face to which the specified load assignment applies.
-1 = Bottom face
-2 = Top face
>0 = Edge face

Note that edge face n is from area object point n to area object point n + 1. For example, edge face 2 is from area object point 2 to area object point 3.
Value: This is the surface pressure value. [F/L2]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the surface pressure load for the area object face is uniform over the face at the value specified by Value.
If PatternName is the name of a defined joint pattern, the surface pressure load for the area object face is based on the specified surface pressure value multiplied by the pattern value at the point objects that are part of the face.
Replace: If this item is True, all previous surface pressure loads, if any, assigned to the specified area object(s), in the specified load case, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Face, Value, PatternName, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetLoadSurfacePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadSurfacePressure" failed')
        
        return ret

    def SetLoadTemperature(self, Name = None, LoadPat = None, MyType = None, Value = None, PatternName = None, Replace = None, ItemType = None):
        """
This function assigns temperature loads to area objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
MyType: This is either 1 or 3, indicating the type of temperature load.
1 = Temperature
3 = Temperature gradient along local 3 axis
Value: This is the temperature change value. [T] for MyType = 1 and [T/L] for MyType = 3
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the temperature load for the area object is uniform over the object at the value specified by Value.
If PatternName is the name of a defined joint pattern the temperature load for the area object is based on the specified temperature value multiplied by the pattern value at the joints that define the area object.
Replace: If this item is True, all previous temperature loads, if any, assigned to the specified area object(s), in the specified load case, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, MyType, Value, PatternName, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadTemperature" failed')
        
        return ret

    def SetLoadUniform(self, Name = None, LoadPat = None, Value = None, Dir = None, Replace = None, CSys = None, ItemType = None):
        """
This function assigns uniform loads to area objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Value: The uniform load value. [F/L2]
Dir: This is an integer between 1 and 11, indicating the direction of the load.
1 = Local 1 axis (only applies when CSys is Local)
2 = Local 2 axis (only applies when CSys is Local)
3 = Local 3 axis (only applies when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
7 = Projected X direction (does not apply when CSys is Local)
8 = Projected Y direction (does not apply when CSys is Local)
9 = Projected Z direction (does not apply when CSys is Local)
10 = Gravity direction (only applies when CSys is Global)
11 = Projected Gravity direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) is in the negative Global Z direction.
Replace: If this item is True, all previous uniform loads, if any, assigned to the specified area object(s), in the specified load pattern, are deleted before making the new assignment.
CSys: This is Local or the name of a defined coordinate system, indicating the coordinate system in which the uniform load is specified.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Value, Dir, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetLoadUniform(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadUniform" failed')
        
        return ret

    def SetLoadUniformToFrame(self, Name = None, LoadPat = None, Value = None, Dir = None, DistType = None, Replace = None, CSys = None, ItemType = None):
        """
This function assigns uniform to frame loads to area objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Value: The uniform load value. [F/L2]
Dir: This is an integer between 1 and 11, indicating the direction of the load.
1 = Local 1 axis (only applies when CSys is Local)
2 = Local 2 axis (only applies when CSys is Local)
3 = Local 3 axis (only applies when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
7 = Projected X direction (does not apply when CSys is Local)
8 = Projected Y direction (does not apply when CSys is Local)
9 = Projected Z direction (does not apply when CSys is Local)
10 = Gravity direction (only applies when CSys is Global)
11 = Projected Gravity direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) is in the negative Global Z direction.
DistType: This is either 1 or 2, indicating the load distribution type.
1 = One-way load distribution
2 = Two-way load distribution

One-way distribution is parallel to the area object local 1 axis. Two-way distribution is parallel to the area object local 1 and 2 axes.
Replace: If this item is True, all previous uniform loads, if any, assigned to the specified area object(s), in the specified load pattern, are deleted before making the new assignment.
CSys: This is Local or the name of a defined coordinate system, indicating the coordinate system in which the uniform load is specified.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Value, Dir, DistType, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetLoadUniformToFrame(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadUniformToFrame" failed')
        
        return ret

    def SetLoadWindPressure(self, Name = None, LoadPat = None, MyType = None, Cp = None, ItemType = None):
        """
This function assigns wind pressure loads to area objects.
The function returns zero if the loads are successfully 
 assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending 
 on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
MyType: This is either 1 or 2, indicating the wind pressure 
 type.
1 = Windward, pressure 
 varies over height
2 = Other, pressure is constant 
 over height
Cp: This is the wind pressure coefficient.
ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 
 0
Group = 
 1
SelectedObjects 
 = 2

If this item is Object, the assignment is made to the 
 area object specified by the Name item.
If this item is Group, the assignment is made to all 
 area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made 
 to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, MyType, Cp, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetLoadWindPressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadWindPressure" failed')
        
        return ret

    def SetLoadWindPressure_1(self, Name = None, LoadPat = None, MyType = None, Cp = None, DistributionType = None, ItemType = None):
        """
This function assigns wind pressure loads to area objects.
The function returns zero if the loads are successfully 
 assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending 
 on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
MyType: This is either 1 or 2, indicating the wind pressure 
 type.
1 = Windward, pressure 
 varies over height
2 = Other, pressure is constant 
 over height
Cp: This is the wind pressure coefficient.
DistributionType: This is either 1 or 2, indicating the distribution type.
1 = To Joints
2 = To Frames – One-way
3 = To Frames – Two-way
ItemType: This is one of the following items in the eItemType 
 enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the 
 area object specified by the Name item.
If this item is Group, the assignment is made to all 
 area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made 
 to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, MyType, Cp, DistributionType, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetLoadWindPressure_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadWindPressure_1" failed')
        
        return ret

    def SetLocalAxesAdvanced(self, Name = None, Active = None, Plane2 = None, PlVectOpt = None, PlCSys = None, PlDir = None, PlPt = None, PlVect = None, ItemType = None):
        """
This function assigns advanced local axes to area objects.
The function returns zero if the advanced local axes assignments are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group depending on the value of the ItemType item.
Active: This is True if advanced local axes exist.
Plane2: This is 31 or 32, indicating that the local plane determined by the plane reference vector is the 3-1 plane or the 3-2 plane. This item applies only when the Active item is True.
PlVectOpt: This is 1, 2, or 3, indicating the plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
PlCSys: The coordinate system used to define the plane reference vector coordinate directions and the plane user vector. This item applies when the Active item is True and the PlVectOpt item is 1 or 3.
PlDir: This is an array dimensioned to 1 (2 integers), indicating the plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
PlPt: This is an array dimensioned to 1 (2 strings) indicating the labels of two joints that define the plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the PlVectOpt item is 2.
PlVect: This is an array dimensioned to 2 (3 doubles) that defines the plane reference vector. This item applies when the Active item is True and the PlVectOpt item is 3.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
Selection = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is Selection, assignment is made to all selected area objects and the Name item is ignored.
        """

        all_args = [Name, Active, Plane2, PlVectOpt, PlCSys, PlDir, PlPt, PlVect, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetLocalAxesAdvanced(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxesAdvanced" failed')
        
        return ret

    def SetLocalAxes(self, Name = None, Ang = None, ItemType = None):
        """
This function assigns a local axis angle to area objects.
The function returns zero if the local axis angle is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
Ang: This is the angle that the local 1 and 2 axes are rotated about the positive local 3 axis from the default orientation. The rotation for a positive angle appears counter clockwise when the local +3 axis is pointing toward you. [deg]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, Ang, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxes" failed')
        
        return ret

    def SetMass(self, Name = None, MassOverL2 = None, Replace = None, ItemType = None):
        """
This function assigns mass per unit area to area objects.
The function returns zero if the mass is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
MassOverL2: The mass per unit area assigned to the area object. [M/L2]
Replace: If this item is True, all existing mass assignments to the area object are removed before assigning the specified mas. If it is False, the specified mass is added to any existing mass already assigned to the area object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects and the Name item is ignored.
        """

        all_args = [Name, MassOverL2, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMass" failed')
        
        return ret

    def SetMaterialOverwrite(self, Name = None, PropName = None, ItemType = None):
        """
This function sets the material overwrite assignment for area objects.
The function returns zero if the material overwrite assignment is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
PropName: This is None or a blank string, indicating that any existing material overwrites assigned to the specified area objects are to be removed, or it is the name of an existing material property.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetMaterialOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMaterialOverwrite" failed')
        
        return ret

    def SetMatTemp(self, Name = None, Temp = None, PatternName = None, ItemType = None):
        """
This function assigns material temperatures to area objects.
The function returns zero if the material temperatures are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
Temp: This is the material temperature value assigned to the area object. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the area object is uniform over the object at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the area object may vary. The material temperature at each corner point around the area object perimeter is equal to the specified temperature multiplied by the pattern value at the associated point object. The material temperature at other points in the area object is calculated by interpolation from the corner points.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, Temp, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMatTemp" failed')
        
        return ret

    def SetModifiers(self, Name = None, Value = None, ItemType = None):
        """
This function sets the modifier assignment for area objects. The default value for all modifiers is one.
The function returns zero if the modifier assignments are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
Value: This is an array of ten unitless modifiers.
Value(0) = Membrane f11 modifier
Value(1) = Membrane f22 modifier
Value(2) = Membrane f12 modifier
Value(3) = Bending m11 modifier
Value(4) = Bending m22 modifier
Value(5) = Bending m12 modifier
Value(6) = Shear v13 modifier
Value(7) = Shear v23 modifier
Value(8) = Mass modifier
Value(9) = Weight modifier

ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModifiers" failed')
        
        return ret

    def SetOffsets(self, Name = None, OffsetType = None, OffsetPattern = None, OffsetPatternSF = None, Offset = None, ItemType = None):
        """
This function sets the joint offset assignments for area objects.
The function returns zero if the offsets are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
OffsetType: This is 0, 1 or 2, indicating the joint offset type.
0 = No joint offsets
1 = User defined joint offsets specified by joint pattern
2 = User defined joint offsets specified by point

OffsetPattern: This item applies only when OffsetType = 1. It is the name of the defined joint pattern that is used to calculate the joint offsets.
OffsetPatternSF: This item applies only when OffsetType = 1. It is the scale factor applied to the joint pattern when calculating the joint offsets. [L]
Offset: This item applies only when OffsetType = 2. It is an array of joint offsets for each of the points that define the area object. [L]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, OffsetType, OffsetPattern, OffsetPatternSF, Offset, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetOffsets(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOffsets" failed')
        
        return ret

    def SetProperty(self, Name = None, PropName = None, ItemType = None):
        """
This function assigns an area property to area objects.
The function returns zero if the property is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
PropName: This is None or the name of a area property to be assigned to the specified area object(s). None means that no property is assigned to the area object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetProperty" failed')
        
        return ret

    def SetSpring(self, Name = None, MyType = None, s = None, SimpleSpringType = None, LinkProp = None, Face = None, SpringLocalOneType = None, Dir = None, Outward = None, Vec = None, Ang = None, Replace = None, CSys = None, ItemType = None):
        """
This function makes spring assignments to area objects. The springs are assigned to a specified area object face.
The function returns zero if the assignments are successfully applied; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
MyType: This is either 1 or 2, indicating the spring property type.
1 = Simple spring
2 = Link property
s: The simple spring stiffness per unit area of the specified area object face. This item applies only when MyType = 1. [F/L3]
SimpleSpringType: This is 1, 2 or 3, indicating the simple spring type. This item applies only when MyType = 1.
1 = Spring resists tension and compression
2 = Spring resists compression only
3 = Spring resists tension only
LinkProp: The name of the link property assigned to the spring. This item applies only when MyType = 2.
Face: This is -1, -2 or a nonzero, positive integer indicating the area object face to which the specified spring assignment applies.
-1 = Bottom face
-2 = Top face
>0 = Edge face

Note that edge face n is from area object point n to area object point n + 1. For example, edge face 2 is from area object point 2 to area object point 3.
SpringLocalOneType: This is 1, 2 or 3, indicating the method used to specify the spring positive local 1-axis orientation.
1 = Parallel to area object local axis
2 = Normal to specified area object face
3 = User specified direction vector
Dir: This is 1, 2, 3, -1, -2 or -3, indicating the area object local axis that corresponds to the positive local 1-axis of the spring. This item applies only when SpringLocalOneType = 1.
Outward: This item is True if the spring positive local 1 axis is outward from the specified area object face. This item applies only when SpringLocalOneType = 2.
Vec: This is an array of three values that define the direction vector of the spring positive local 1-axis. The direction vector is in the coordinate system specified by the CSys item. This item applies only when SpringLocalOneType = 3.
Ang: This is the angle that the link local 2-axis is rotated from its default orientation. This item applies only when MyType = 2. [deg]
Replace: If this item is True, all existing spring assignments to the area object are removed before assigning the specified spring. If it is False, the specified spring is added to any existing springs already assigned to the area object.
CSys: This is Local (meaning the area object local coordinate system) or the name of a defined coordinate system. This item is the coordinate system in which the user specified direction vector, Vec, is specified. This item applies only when SpringLocalOneType = 3.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, MyType, s, SimpleSpringType, LinkProp, Face, SpringLocalOneType, Dir, Outward, Vec, Ang, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSpring" failed')
        
        return ret

    def SetThickness(self, Name = None, ThicknessType = None, ThicknessPattern = None, ThicknessPatternSF = None, Thickness = None, ItemType = None):
        """
This function sets the thickness overwrite assignments for area objects.
The function returns zero if the thickness overwrites are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing area object or group, depending on the value of the ItemType item.
ThicknessType: This is 0, 1 or 2, indicating the thickness overwrite type.
0 = No thickness overwrites
1 = User defined thickness overwrites specified by joint pattern
2 = User defined thickness overwrites specified by point

ThicknessPattern: This item applies only when ThicknessType = 1. It is the name of the defined joint pattern that is used to calculate the thicknesses.
ThicknessPatternSF: This item applies only when ThicknessType = 1. It is the scale factor applied to the joint pattern when calculating the thicknesses. [L]
Thickness: This item applies only when ThicknessType = 2. It is an array of thicknesses at each of the points that define the area object. [L]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the area object specified by the Name item.
If this item is Group, the assignment is made to all area objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected area objects, and the Name item is ignored.
        """

        all_args = [Name, ThicknessType, ThicknessPattern, ThicknessPatternSF, Thickness, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.AreaObj.SetThickness(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetThickness" failed')
        
        return ret

class CableObj:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def AddByCoord(self, xi = None, yi = None, zi = None, xj = None, yj = None, zj = None, Name = None, PropName = None, UserName = None, CSys = None):
        """
This function adds a new cable object whose end points are at the specified coordinates.
The function returns zero if the cable object is successfully added, otherwise it returns a nonzero value.

xi: The coordinates of the I-End of the added cable object. The coordinates are in the coordinate system defined by the CSys item.
yi: The coordinates of the I-End of the added cable object. The coordinates are in the coordinate system defined by the CSys item.
zi: The coordinates of the I-End of the added cable object. The coordinates are in the coordinate system defined by the CSys item.
xj: The coordinates of the J-End of the added cable object. The coordinates are in the coordinate system defined by the CSys item.
yj: The coordinates of the J-End of the added cable object. The coordinates are in the coordinate system defined by the CSys item.
zj: The coordinates of the J-End of the added cable object. The coordinates are in the coordinate system defined by the CSys item.
Name: This is the name that the program ultimately assigns for the cable object. If no UserName is specified,n the program assigns a default name to the cable object. If a UserName is specified and that name is not used for another frame, cable or tendon object, the UserName is assigned to the cable object; otherwise a default name is assigned to the cable object.
PropName: This is Default or the name of a defined cable property.
If it is Default, the program assigns a default cable property to the cable object. If it is the name of a defined cable property, that property is assigned to the cable object.
UserName: This is an optional user specified name for the cable object. If a UserName is specified and that name is already used for another cable object, the program ignores the UserName.
CSys: The name of the coordinate system in which the cable object end point coordinates are defined.
        """

        all_args = [xi, yi, zi, xj, yj, zj, Name, PropName, UserName, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.AddByCoord(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddByCoord" failed')
        
        return ret

    def AddByPoint(self, Point1 = None, Point2 = None, Name = None, PropName = None, UserName = None):
        """
This function adds a new cable object whose end points are specified by name.
The function returns zero if the cable object is successfully added, otherwise it returns a nonzero value.

Point1: The name of a defined point object at the I-End of the added cable object.
Point2: The name of a defined point object at the J-End of the added cable object.
Name: This is the name that the program ultimately assigns for the cable object. If no UserName is specified, the program assigns a default name to the cable object. If a UserName is specified and that name is not used for another frame, cable or tendon object, the UserName is assigned to the cable object; otherwise a default name is assigned to the cable object.
PropName: This is Default or the name of a defined cable property.
If it is Default, the program assigns a default cable property to the cable object. If it is the name of a defined cable property, that property is assigned to the cable object.
UserName: This is an optional user specified name for the cable object. If a UserName is specified and that name is already used for another cable object, the program ignores the UserName.
        """

        all_args = [Point1, Point2, Name, PropName, UserName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.AddByPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddByPoint" failed')
        
        return ret

    def ChangeName(self, Name = None, NewName = None):
        """
The function returns zero if the new name is successfully applied, otherwise it returns a nonzero value.

Name: The existing name of a defined cable object.
NewName: The new name for the cable object.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns a count of the cable objects in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def DeleteLoadDeformation(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the deformation load assignments to the specified cable objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the cable object specified by the Name item.
If this item is Group, the load assignments are deleted for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.DeleteLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadDeformation" failed')
        
        return ret

    def DeleteLoadDistributedWithGUID(self, Name = None, GUID = None):
        """
This function deletes the distributed load assignment with the specified global unique ID for the specified cable object.
The function returns zero if the load assignment is successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing cable object.
GUID: The global unique ID of one of the distributed loads on that cable object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.DeleteLoadDistributedWithGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadDistributedWithGUID" failed')
        
        return ret

    def DeleteLoadDistributed(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the distributed load assignments to the specified cable objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the cable object specified by the Name item.
If this item is Group, the load assignments are deleted for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.DeleteLoadDistributed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadDistributed" failed')
        
        return ret

    def DeleteLoadGravity(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the gravity load assignments to the specified cable objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the cable object specified by the Name item.
If this item is Group, the load assignments are deleted for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.DeleteLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadGravity" failed')
        
        return ret

    def DeleteLoadStrain(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the strain load assignments to the specified cable objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the cable object specified by the Name item.
If this item is Group, the load assignments are deleted for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.DeleteLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadStrain" failed')
        
        return ret

    def DeleteLoadTargetForce(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the target force assignments to the specified cable objects for the specified load pattern.
The function returns zero if the target force assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the cable object specified by the Name item.
If this item is Group, the load assignments are deleted for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.DeleteLoadTargetForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadTargetForce" failed')
        
        return ret

    def DeleteLoadTemperature(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the temperature load assignments to the specified cable objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the cable object specified by the Name item.
If this item is Group, the load assignments are deleted for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.DeleteLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadTemperature" failed')
        
        return ret

    def DeleteMass(self, Name = None, ItemType = None):
        """
This function deletes the cable mass assignments for cable objects.
The function returns zero if the mass assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the cable mass assignments are deleted for the cable object specified by the Name item.
If this item is Group, the cable mass assignments are deleted for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, the cable mass assignments are deleted for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.DeleteMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteMass" failed')
        
        return ret

    def DeleteModifiers(self, Name = None, ItemType = None):
        """
This function deletes the cable modifier assignments for cable objects.
The function returns zero if the modifier assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the cable modifier assignments are deleted for the cable object specified by the Name item.
If this item is Group, the cable modifier assignments are deleted for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, the cable modifier assignments are deleted for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.DeleteModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteModifiers" failed')
        
        return ret

    def Delete(self, Name = None, ItemType = None):
        """
The function deletes cable objects.
The function returns zero if the cable objects are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the cable object specified by the Name item is deleted.
If this item is Group, the all cable objects in the group specified by the Name item are deleted.
If this item is SelectedObjects, all selected cable objects are deleted, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetCableData(self, Name = None, CableType = None, NumSegs = None, Weight = None, ProjectedLoad = None, UseDeformedGeom = None, ModelUsingFrames = None, Parameter = None):
        """
This function retrieves definition data for a specified cable object.
The function returns zero if the data is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined cable object.
CableType: This is 1, 2, 3, 4, 5, 6, 7, 8, or 9, indicating the cable definition parameter.
1 = Minimum tension at I-End
2 = Minimum tension at J-End
3 = Tension at I-End
4 = Tension at J-End
5 = Horizontal tension component
6 = Maximum vertical sag
7 = Low-point vertical sag
8 = Undeformed length
9 = Relative undeformed length

NumSegs: This is the number of segments into which the program internally divides the cable.
Weight: The added weight per unit length used when calculating the cable shape. [F/L]
ProjectedLoad: The projected uniform gravity load used when calculating the cable shape. [F/L]
UseDeformedGeom: If this item is True, the program uses the deformed geometry for the cable object; otherwise it uses the undeformed geometry.
ModelUsingFrames: If this item is True, the analysis model uses frame elements to model the cable instead of using cable elements.
Parameter: This is an array of parameters related to the cable shape. The array is dimensioned by Sap2000.
Parameter(0) = Tension at I-End [F]
Parameter(1) = Tension at J-End [F]
Parameter(2) = Horizontal tension component [F]
Parameter(3) = Maximum deformed vertical sag [L]
Parameter(4) = Deformed low-point vertical sag [L]
Parameter(5) = Deformed length [L]
Parameter(6) = Deformed relative length
Parameter(7) = Maximum undeformed vertical sag [L]
Parameter(8) = Undeformed low-point vertical sag [L]
Parameter(9) = Undeformed length [L]
Parameter(10) = Undeformed relative length
        """

        all_args = [Name, CableType, NumSegs, Weight, ProjectedLoad, UseDeformedGeom, ModelUsingFrames, Parameter]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetCableData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCableData" failed')
        
        return ret

    def GetCableGeometry(self, Name = None, NumberPoints = None, x = None, y = None, z = None, Sag = None, Distance = None, RD = None, CSys = None):
        """
This function retrieves geometric data for a specified cable object.
The function returns zero if the data is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined cable object.
NumberPoints: The number of points defining the cable geometry.
x: The x, y and z coordinates of the considered point on the cable in the coordinate system specified by the CSys item. [L]
y: The x, y and z coordinates of the considered point on the cable in the coordinate system specified by the CSys item. [L]
z: The x, y and z coordinates of the considered point on the cable in the coordinate system specified by the CSys item. [L]
Sag: The cable vertical sag, measured from the chord, at the considered point. [L]
Distance: The distance along the cable, measured from the cable I-End, to the considered point. [L]
RD: The relative distance along the cable, measured from the cable I-End, to the considered point.
CSys: The name of the coordinate system in which the x, y and z coordinates are to be reported.
        """

        all_args = [Name, NumberPoints, x, y, z, Sag, Distance, RD, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetCableGeometry(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCableGeometry" failed')
        
        return ret

    def GetElm(self, Name = None, nelm = None, Elm = None, RDI = None, RDJ = None):
        """
This function retrieves the names of the line elements (analysis model lines) associated with a specified cable object in the object-based model. It also retrieves information about the location of the line elements along the cable object.
This function returns zero if the line element information is successfully returned; otherwise it returns nonzero. An error occurs if the analysis model does not currently exist.

Name: The name of an existing cable object.
nelm: The number of line elements created from the specified cable object.
Elm: An array that includes the name of a line element created from the specified cable object.
RDI: An array that includes the relative distance along the cable object to the I-End of the line element.
RDJ: An array that includes the relative distance along the cable object to the J-End of the line element.
        """

        all_args = [Name, nelm, Elm, RDI, RDJ]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetElm(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetElm" failed')
        
        return ret

    def GetGroupAssign(self, Name = None, NumberGroups = None, Groups = None):
        """
This function retrieves the names of the groups to which a specified cable object is assigned.
The function returns zero if the group assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing cable object.
NumberGroups: The number of group names retrieved.
Groups: The names of the groups to which the cable object is assigned.
        """

        all_args = [Name, NumberGroups, Groups]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGroupAssign" failed')
        
        return ret

    def GetGUID(self, Name = None, GUID = None):
        """
This function retrieves the GUID for the specified cable object.
This function returns zero if the cable object GUID is successfully retrieved; otherwise it returns nonzero.

Name: The name of an existing cable object.
GUID: The GUID (Global Unique ID) for the specified cable object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGUID" failed')
        
        return ret

    def GetLoadDeformation(self, Name = None, NumberItems = None, CableName = None, LoadPat = None, U1 = None, ItemType = None):
        """
This function retrieves the deformation load assignments to cable objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
NumberItems: The total number of deformation loads retrieved for the specified cable objects.
CableName: This is an array that includes the name of the cable object associated with each deformation load.
LoadPat: This is an array that includes the name of the load pattern associated with each deformation load.
U1: This is an array of axial deformation load values. [L]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the cable object specified by the Name item.
If this item is Group, the assignments are retrieved for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, CableName, LoadPat, U1, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadDeformation" failed')
        
        return ret

    def GetLoadDistributed(self, Name = None, NumberItems = None, CableName = None, LoadPat = None, MyType = None, CSys = None, Dir = None, Value = None, ItemType = None):
        """
This function retrieves the distributed load assignments to cable objects. The loads are uniformly distributed over the full length of cable objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
NumberItems: The total number of distributed loads retrieved for the specified cable objects.
CableName: This is an array that includes the name of the cable object associated with each distributed load.
LoadPat: This is an array that includes the name of the coordinate system in which the distributed loads are specified.
MyType: This is an array that includes 1 or 2, indicating the type of distributed load.
1 = Force
2 = Moment
CSys: This is an array that includes the name of the coordinate system in which each distributed load is defined. It may be Local or the name of a defined coordinate system.
Dir: This is 1, 2, 3, 4, 5, 6 or 10, indicating the direction of the load.
1 = Local 1 axis (only applies when CSys is Local)
2 = Local 2 axis (only applies when CSys is Local)
3 = Local 3 axis (only applies when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
10 = Gravity direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10) is in the negative Global Z direction.
Value: This is the load value of the distributed load. The distributed load is applied over the full length of the cable. [F/L] when MyType is 1 and [FL/L] when MyType is 2
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the cable object specified by the Name item.
If this item is Group, the assignments are retrieved for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, CableName, LoadPat, MyType, CSys, Dir, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetLoadDistributed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadDistributed" failed')
        
        return ret

    def GetLoadGravity(self, Name = None, NumberItems = None, CableName = None, LoadPat = None, CSys = None, x = None, y = None, z = None, ItemType = None):
        """
This function retrieves the gravity load assignments to cable objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
NumberItems: The total number of gravity loads retrieved for the specified cable objects.
CableName: This is an array that includes the name of the cable object associated with each gravity load.
LoadPat: This is an array that includes the name of the coordinate system in which the gravity load multipliers are specified.
CSys: This is an array that includes the name of the coordinate system associated with each gravity load.
x: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the cable object specified by the Name item.
If this item is Group, the assignments are retrieved for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, CableName, LoadPat, CSys, x, y, z, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadGravity" failed')
        
        return ret

    def GetLoadStrain(self, Name = None, NumberItems = None, CableName = None, LoadPat = None, Strain = None, PatternName = None, ItemType = None):
        """
This function retrieves the strain load assignments to cable objects.
The function returns zero if the strain load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
NumberItems: The total number of strain loads retrieved for the specified cable objects.
CableName: This is an array that includes the name of the cable object associated with each strain load.
LoadPat: This is an array that includes the name of the load pattern associated with each strain load.
Strain: This is an array that includes the axial strain value. [L/L]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the strain load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the cable object specified by the Name item.
If this item is Group, the assignments are retrieved for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, CableName, LoadPat, Strain, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadStrain" failed')
        
        return ret

    def GetLoadTargetForce(self, Name = None, NumberItems = None, CableName = None, LoadPat = None, P = None, RD = None, ItemType = None):
        """
This function retrieves the target force assignments to cable objects.
The function returns zero if the target force assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
NumberItems: The total number of deformation loads retrieved for the specified cable objects.
CableName: This is an array that includes the name of the cable object associated with each target force.
LoadPat: This is an array that includes the name of the load pattern associated with each target force.
P: This is an array of axial target force values. [F]
RD: This is an array of the relative distances along the cable objects where the axial target force values apply.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the cable object specified by the Name item.
If this item is Group, the assignments are retrieved for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, CableName, LoadPat, P, RD, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetLoadTargetForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTargetForce" failed')
        
        return ret

    def GetLoadTemperature(self, Name = None, NumberItems = None, CableName = None, LoadPat = None, Val = None, PatternName = None, ItemType = None):
        """
This function retrieves the temperature load assignments to cable objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
NumberItems: The total number of temperature loads retrieved for the specified cable objects.
CableName: This is an array that includes the name of the cable object associated with each temperature load.
LoadPat: This is an array that includes the name of the load pattern associated with each temperature load.
Val: This is an array that includes the temperature load value. [T]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the temperature load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the cable object specified by the Name item.
If this item is Group, the assignments are retrieved for all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, CableName, LoadPat, Val, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTemperature" failed')
        
        return ret

    def GetMass(self, Name = None, MassOverL = None):
        """
This function retrieves the mass per unit length assignment for cable objects.
The function returns zero if the mass assignment is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing cable object.
MassOverL: The mass per unit length assigned to the cable object. [M/L]
        """

        all_args = [Name, MassOverL]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMass" failed')
        
        return ret

    def GetMaterialOverwrite(self, Name = None, PropName = None):
        """
This function retrieves the material overwrite assigned to a cable object, if any. It returns None if there is no material overwrite assignment.
The function returns zero if the material overwrite assignment is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined cable object.
PropName: This is None, indicating that no material overwrite exists for the specified cable object, or it is the name of an existing material property.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetMaterialOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMaterialOverwrite" failed')
        
        return ret

    def GetMatTemp(self, Name = None, Temp = None, PatternName = None):
        """
This function retrieves the material temperature assignments to cable objects.
The function returns zero if the material temperature assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing cable object.
Temp: This is the material temperature value assigned to the cable object. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the cable object is uniform along the object at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the cable object may vary from one end to the other. The material temperature at each end of the object is equal to the specified temperature multiplied by the pattern value at the joint at the end of the cable object.
        """

        all_args = [Name, Temp, PatternName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMatTemp" failed')
        
        return ret

    def GetModifiers(self, Name = None, Value = None):
        """
This function retrieves the cable modifier assignment for cable objects. The default value for all modifiers is one.
The function returns zero if the modifier assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing cable object.
Value: This is an array of three unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Mass modifier
Value(2) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModifiers" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined cable objects.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of cable object names retrieved by the program.
MyName: This is a one-dimensional array of cable object names. The MyName array is created as a dynamic, zero-based, array by the APIuser:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the APIuser.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetOutputStations(self, Name = None, MyType = None, MaxSegSize = None, MinSections = None, NoOutPutAndDesignAtElementEnds = None, NoOutPutAndDesignAtPointLoads = None):
        """
This function retrieves cable object output station data.
The function returns zero if the data is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing cable object.
MyType: This is 1 or 2, indicating how the output stations are specified.
1 = maximum segment size, that is, maximum station spacing
2 = minimum number of stations
MaxSegSize: The maximum segment size, that is, the maximum station spacing. This item applies only when MyType = 1. [L]
MinSections: The minimum number of stations. This item applies only when MyType = 2.
NoOutPutAndDesignAtElementEnds: If this item is True, no additional output stations are added at the ends of line elements when the cable object is internally meshed.
NoOutPutAndDesignAtPointLoads: If this item is True, no additional output stations are added at point load locations.
        """

        all_args = [Name, MyType, MaxSegSize, MinSections, NoOutPutAndDesignAtElementEnds, NoOutPutAndDesignAtPointLoads]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetOutputStations(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOutputStations" failed')
        
        return ret

    def GetPoints(self, Name = None, Point1 = None, Point2 = None):
        """
This function retrieves the names of the point objects at each end of a specified cable object.
The function returns zero if the point names are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined cable object.
Point1: The name of the point object at the I-End of the specified cable object.
Point2: The name of the point object at the J-End of the specified cable object.
        """

        all_args = [Name, Point1, Point2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPoints" failed')
        
        return ret

    def GetProperty(self, Name = None, PropName = None):
        """
This function retrieves the cable property assigned to a cable object.
The function returns zero if the cable object property is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined cable object.
PropName: The name of the cable property assigned to the cable object.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProperty" failed')
        
        return ret

    def SetCableData(self, Name = None, CableType = None, NumSegs = None, Weight = None, ProjectedLoad = None, Value = None, UseDeformedGeom = None, ModelUsingFrames = None):
        """
This function assigns the cable definition parameters to a cable object.
The function returns zero if the cable object is successfully defined; otherwise it returns a nonzero value. If the cable object is not successfully defined, it may be deleted.

Name: The name of a defined cable object.
CableType: This is 1, 2, 3, 4, 5, 6, 7, 8, or 9, indicating the cable definition parameter.
1 = Minimum tension at I-End
2 = Minimum tension at J-End
3 = Tension at I-End
4 = Tension at J-End
5 = Horizontal tension component
6 = Maximum vertical sag
7 = Low-point vertical sag
8 = Undeformed length
9 = Relative undeformed length

NumSegs: This is the number of segments into which the program internally divides the cable.
Weight: The added weight per unit length used when calculating the cable shape. [F/L]
ProjectedLoad: The projected uniform gravity load used when calculating the cable shape. [F/L]
Value: This is the value of the parameter used to define the cable shape. The item that Value represents depends on the CableType item.
CableType = 1: Not Used
CableType = 2: Not Used
CableType = 3: Tension at I-End [F]
CableType = 4: Tension at J-End [F]
CableType = 5: Horizontal tension component [F]
CableType = 6: Maximum vertical sag [L]
CableType = 7: Low-point vertical sag [L]
CableType = 8: Undeformed length [L]
CableType = 9: Relative undeformed length

UseDeformedGeom: If this item is True, the program uses the deformed geometry for the cable object; otherwise it uses the undeformed geometry.
ModelUsingFrames: If this item is True, the analysis model uses frame elements to model the cable instead of using cable elements.
        """

        all_args = [Name, CableType, NumSegs, Weight, ProjectedLoad, Value, UseDeformedGeom, ModelUsingFrames]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetCableData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCableData" failed')
        
        return ret

    def SetGroupAssign(self, Name = None, GroupName = None, Remove = None, ItemType = None):
        """
This function adds or removes cable objects from a specified group.
The function returns zero if the group assignment is successful, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
GroupName: The name of an existing group to which the assignment is made.
Remove: If this item is False, the specified cable objects are added to the group specified by the GroupName item. If it is True, the cable objects are removed from the group.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the cable object specified by the Name item is added or removed from the group specified by the GroupName item.
If this item is Group, all cable objects in the group specified by the Name item are added or removed from the group specified by the GroupName item.
If this item is SelectedObjects, all selected cable objects are added or removed from the group specified by the GroupName item, and the Name item is ignored.
        """

        all_args = [Name, GroupName, Remove, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGroupAssign" failed')
        
        return ret

    def SetGUID(self, Name = None, GUID = None):
        """
This function sets the GUID for the specified cable object. If the GUID is passed in as a blank string, the program automatically creates a GUID for the object.
This function returns zero if the cable object GUID is successfully set; otherwise it returns nonzero.

Name: The name of an existing cable object.
GUID: The GUID (Global Unique ID) for the specified cable object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGUID" failed')
        
        return ret

    def SetLoadDeformation(self, Name = None, LoadPat = None, d = None, ItemType = None):
        """
This function assigns deformation loads to cable objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
d: This is the axial deformation load value. [L]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, d, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadDeformation" failed')
        
        return ret

    def SetLoadDistributed(self, Name = None, LoadPat = None, MyType = None, Dir = None, Value = None, CSys = None, Replace = None, ItemType = None):
        """
This function assigns uniform distributed loads over the full length of cable objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
MyType: This is 1 or 2, indicating the type of distributed load.
1 = Force per unit length
2 = Moment per unit length
Dir: This is 1, 2, 3, 4, 5, 6 or 10, indicating the direction of the load.
1 = Local 1 axis (only applies when CSys is Local)
2 = Local 2 axis (only applies when CSys is Local)
3 = Local 3 axis (only applies when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
10 = Gravity direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10) is in the negative Global Z direction.
Value: This is the load value of the distributed load. The distributed load is applied over the full length of the cable. [F/L] when MyType is 1 and [FL/L] when MyType is 2
CSys: This is Local or the name of a defined coordinate system. It is the coordinate system in which the loads are specified.
Replace: If this item is True, all previous loads, if any, assigned to the specified cable object(s), in the specified load pattern, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, MyType, Dir, Value, CSys, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetLoadDistributed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadDistributed" failed')
        
        return ret

    def SetLoadGravity(self, Name = None, LoadPat = None, x = None, y = None, z = None, Replace = None, CSys = None, ItemType = None):
        """
This function assigns gravity load multipliers to cable objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
x: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
Replace: If this item is True, all previous gravity loads, if any, assigned to the specified cable object(s), in the specified load pattern, are deleted before making the new assignment.
CSys: The coordinate system in which the x, y and z multipliers are specified.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, x, y, z, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadGravity" failed')
        
        return ret

    def SetLoadStrain(self, Name = None, LoadPat = None, Strain = None, Replace = None, PatternName = None, ItemType = None):
        """
This function assigns strain loads to cable objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Strain: This is the axial strain load value. [L/L]
Replace: If this item is True, all previous strain loads, if any, assigned to the specified cable object(s), in the specified load pattern, are deleted before making the new assignment.
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the strain load for the cable object is uniform along the object at the value specified by Strain.
If PatternName is the name of a defined joint pattern, the strain load for the cable object is based on the specified strain value multiplied by the pattern value at the joints at each end of the cable object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Strain, Replace, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadStrain" failed')
        
        return ret

    def SetLoadTargetForce(self, Name = None, LoadPat = None, P = None, RD = None, ItemType = None):
        """
This function assigns target forces to cable objects.
The function returns zero if the target forces are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
P: This is the axial target force value. [F]
RD: This is the relative distance along the cable object to the location where the target force value applies. The relative distance must be between 0 and 1, 0 <= RD <=1.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, P, RD, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetLoadTargetForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadTargetForce" failed')
        
        return ret

    def SetLoadTemperature(self, Name = None, LoadPat = None, Val = None, PatternName = None, Replace = None, ItemType = None):
        """
This function assigns temperature loads to cable objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Val: This is the temperature change value. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the temperature load for the cable object is uniform along the object at the value specified by Val.
If PatternName is the name of a defined joint pattern, the temperature load for the cable object is based on the specified temperature value multiplied by the pattern value at the joints at each end of the cable object.
Replace: If this item is True, all previous temperature loads, if any, assigned to the specified cable object(s), in the specified load case, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Val, PatternName, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadTemperature" failed')
        
        return ret

    def SetMass(self, Name = None, MassOverL = None, Replace = None, ItemType = None):
        """
This function assigns mass per unit length to cable objects.
The function returns zero if the mass is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
MassOverL: The mass per unit length assigned to the cable object. [M/L]
Replace: If this item is True, all existing mass assignments to the cable object are removed before assigning the specified mas. If it is False, the specified mass is added to any mass already assigned to the cable object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, MassOverL, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMass" failed')
        
        return ret

    def SetMaterialOverwrite(self, Name = None, PropName = None, ItemType = None):
        """
This function sets the material overwrite assignment for cable objects.
The function returns zero if the material overwrite assignment is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
PropName: This is None or a blank string, indicating that any existing material overwrites assigned to the specified cable objects are to be removed, or it is the name of an existing material property.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetMaterialOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMaterialOverwrite" failed')
        
        return ret

    def SetMatTemp(self, Name = None, Temp = None, PatternName = None, ItemType = None):
        """
This function assigns material temperatures to cable objects.
The function returns zero if the material temperatures are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
Temp: This is the material temperature value assigned to the cable object. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the cable object is uniform along the object at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the cable object may vary from one end to the other. The material temperature at each end of the object is equal to the specified temperature multiplied by the pattern value at the joint at the end of the cable object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, Temp, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMatTemp" failed')
        
        return ret

    def SetModifiers(self, Name = None, Value = None, ItemType = None):
        """
This function sets the cable modifier assignment for cable objects. The default value for all modifiers is one.
The function returns zero if the modifier assignments are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
Value: This is an array of three unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Mass modifier
Value(2) = Weight modifier
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModifiers" failed')
        
        return ret

    def SetOutputStations(self, Name = None, MyType = None, MaxSegSize = None, MinSections = None, NoOutPutAndDesignAtElementEnds = None, NoOutPutAndDesignAtPointLoads = None, ItemType = None):
        """
This function assigns cable object output station data.
The function returns zero if the data is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
MyType: This is 1 or 2, indicating how the output stations are specified.
1 = maximum segment size, that is, maximum station spacing
2 = minimum number of stations
MaxSegSize: The maximum segment size, that is, the maximum station spacing. This item applies only when MyType = 1. [L]
MinSections: The minimum number of stations. This item applies only when MyType = 2.
NoOutPutAndDesignAtElementEnds: If this item is True, no additional output stations are added at the ends of line elements when the cable object is internally meshed.
NoOutPutAndDesignAtPointLoads: If this item is True, no additional output stations are added at point load locations.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, MyType, MaxSegSize, MinSections, NoOutPutAndDesignAtElementEnds, NoOutPutAndDesignAtPointLoads, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetOutputStations(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOutputStations" failed')
        
        return ret

    def SetProperty(self, Name = None, PropName = None, ItemType = None):
        """
This function assigns a cable property to a cable object.
The function returns zero if the cable property is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
PropName: The name of a cable property to be assigned to the specified cable object(s).
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetProperty" failed')
        
        return ret

    def GetInsertionPoint(self, Name = None, StiffTransform = None, Offset1 = None, Offset2 = None, CSys = None):
        """
This function retrieves cable object insertion point assignments. The assignments include the end joint offsets.
The function returns zero if the insertion point data is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing cable object.
StiffTransform: If this item is True, the cable object stiffness is transformed for cardinal point and joint offsets from the cable section centroid.
Offset1: This is an array of three joint offset distances, in the coordinate directions specified by CSys, at the I-End of the cable object. [L]
Offset1(0) = Offset in the 1-axis or X-axis direction
Offset1(1) = Offset in the 2-axis or Y-axis direction
Offset1(2) = Offset in the 3-axis or Z-axis direction
Offset2: This is an array of three joint offset distances, in the coordinate directions specified by CSys, at the J-End of the cable object. [L]
Offset2(0) = Offset in the 1-axis or X-axis direction
Offset2(1) = Offset in the 2-axis or Y-axis direction
Offset2(2) = Offset in the 3-axis or Z-axis direction
CSys: This is Local or the name of a defined coordinate system. It is the coordinate system in which the Offset1 and Offset2 items are specified.
        """

        all_args = [Name, StiffTransform, Offset1, Offset2, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.GetInsertionPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInsertionPoint" failed')
        
        return ret

    def SetInsertionPoint(self, Name = None, StiffTransform = None, Offset1 = None, Offset2 = None, CSys = None, ItemType = None):
        """
This function assigns cable object insertion point data. The assignments include the end joint offsets.
The function returns zero if the insertion point data is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing cable object or group, depending on the value of the ItemType item.
StiffTransform: If this item is True, the cable object stiffness is transformed for cardinal point and joint offsets from the cable section centroid.
Offset1: This is an array of three joint offset distances, in the coordinate directions specified by CSys, at the I-End of the cable object. [L]
Offset1(0) = Offset in the 1-axis or X-axis direction
Offset1(1) = Offset in the 2-axis or Y-axis direction
Offset1(2) = Offset in the 3-axis or Z-axis direction
Offset2: This is an array of three joint offset distances, in the coordinate directions specified by CSys, at the J-End of the cable object. [L]
Offset2(0) = Offset in the 1-axis or X-axis direction
Offset2(1) = Offset in the 2-axis or Y-axis direction
Offset2(2) = Offset in the 3-axis or Z-axis direction
CSys: This is Local or the name of a defined coordinate system. It is the coordinate system in which the Offset1 and Offset2 items are specified.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the cable object specified by the Name item.
If this item is Group, the assignment is made to all cable objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected cable objects, and the Name item is ignored.
        """

        all_args = [Name, StiffTransform, Offset1, Offset2, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.CableObj.SetInsertionPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInsertionPoint" failed')
        
        return ret

class ExternalAnalysisResults:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def DeleteAllFrameForces(self):
        """
This function deletes all the external results previously provided for all frame objects. The function returns zero if the results are successfully deleted, otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ExternalAnalysisResults.DeleteAllFrameForces(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteAllFrameForces" failed')
        
        return ret

    def DeleteFrameForces(self, Name = None):
        """
This function deletes all the external results previously provided for a given frame object. This function returns zero if the external results are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ExternalAnalysisResults.DeleteFrameForces(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteFrameForces" failed')
        
        return ret

    def PresetFrameCases(self, Name = None, Count = None, casename = None):
        """
Calling this function is optional, but it can speed up subsequent assignment of external analysis results which are available for more than one load case.
The first time this function is called for a particular frame object, it sets the list of names of external result load cases for which results relevant to the object are available. Subsequent calls to this function for the same object reset the results for load cases already in the list, and add load cases not already in.
This function returns zero if the stations are successfully set, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
Count: The length of the subsequent array.
casename: An array listing the names of previously defined external result load cases for which user-supplied external analysis results are available for the frame object.
        """

        all_args = [Name, Count, casename]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ExternalAnalysisResults.PresetFrameCases(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PresetFrameCases" failed')
        
        return ret

    def GetFrameForce(self, Name = None, InitialCase = None, NumStep = None, NumberStations = None, P = None, V2 = None, V3 = None, T = None, M2 = None, M3 = None):
        """
This function reports the external result forces for a given step of a given external results load case on a given object.
The function returns zero if the external result forces are successfully recovered, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
InitialCase: The name of an existing external results load case for which external results relevant to the object may have been previously provided.
NumStep: The zero based index of a load case step: 0 for the first step, 1 for the second, and so on.
NumberStations: The number of frame stations on the object at which external result forces are reported.
P: One dimensional arrays that include the axial force, shear force in the local 2 direction, and shear force in the local 3 direction, respectively, for each frame station. [F]
V2: One dimensional arrays that include the axial force, shear force in the local 2 direction, and shear force in the local 3 direction, respectively, for each frame station. [F]
V3: One dimensional arrays that include the axial force, shear force in the local 2 direction, and shear force in the local 3 direction, respectively, for each frame station. [F]
T: One dimensional arrays that include the torsion, moment about the local 2axis, and moment about the local 3-axis, respectively, for each frame station. [FL]
M2: One dimensional arrays that include the torsion, moment about the local 2axis, and moment about the local 3-axis, respectively, for each frame station. [FL]
M3: One dimensional arrays that include the torsion, moment about the local 2axis, and moment about the local 3-axis, respectively, for each frame station. [FL]
        """

        all_args = [Name, InitialCase, NumStep, NumberStations, P, V2, V3, T, M2, M3]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ExternalAnalysisResults.GetFrameForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetFrameForce" failed')
        
        return ret

    def GetFrameStations(self, Name = None, nStation = None, ObjSta = None):
        """
This function gets the frame stations on a frame object for which user-supplied external analysis results are available.
The function returns zero if the stations are successfully get, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
nStation: Number of the stations of an existing frame object.
ObjSta: This is an array that includes the distance measured from the I-end of the object to the result location.
        """

        all_args = [Name, nStation, ObjSta]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ExternalAnalysisResults.GetFrameStations(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetFrameStations" failed')
        
        return ret

    def SetFrameStations(self, Name = None, ObjSta = None):
        """
This function sets the frame stations on a frame object for which user-supplied external analysis results are available.
The function returns zero if the stations are successfully set, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
ObjSta: This is an array that includes the distance measured from the I-end of the object to the result location.
        """

        all_args = [Name, ObjSta]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ExternalAnalysisResults.SetFrameStations(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFrameStations" failed')
        
        return ret

    def SetFrameForceMultiple(self):
        """
This function sets the external result forces for all input frames and load cases.
The P, V2, V3, T, M2, M3 arrays should be of length:
(Sum of all steps for all input Load Cases) * (Sum of all stations for all input Frames)
 
As an example, consider setting results for two Frames, each with two defined Stations, for two Load Cases, each Load Case containing three steps, eg First Step = 1, Last step = 3.
The values of this array will be iterated over in the following order:
The P[0] value will be the axial force for FrameName[0], LoadCase[0], FirstStep[0], 1st Station
The P[1] value will be the axial force for FrameName[0], LoadCase[0], FirstStep[0], 2nd Station
The P[2] value will be the axial force for FrameName[0], LoadCase[0], FirstStep[0]+1, 1st Station
The P[3] value will be the axial force for FrameName[0], LoadCase[0], FirstStep[0]+1, 2nd Station
The P[4] value will be the axial force for FrameName[0], LoadCase[0], LastStep[0], 1st Station
The P[5] value will be the axial force for FrameName[0], LoadCase[0], LastStep[0], 2nd Station
The P[6] value will be the axial force for FrameName[0], LoadCase[1], FirstStep[1], 1st Station
The P[7] value will be the axial force for FrameName[0], LoadCase[1], FirstStep[1], 2nd Station
The P[8] value will be the axial force for FrameName[0], LoadCase[1], FirstStep[1]+1, 1st Station
The P[9] value will be the axial force for FrameName[0], LoadCase[1], FirstStep[1]+1, 2nd Station
The P[10] value will be the axial force for FrameName[0], LoadCase[1], LastStep[1], 1st Station
The P[11] value will be the axial force for FrameName[0], LoadCase[1],  LastStep[1], 2nd Station
The P[12] value will be the axial force for FrameName[1], LoadCase[0], FirstStep[0], 1st Station
And so on…
 
The number of stations must be previously declared using SetFrameStations
 
Enter 0 for any unneeded values in these arrays
 
The function returns zero if the forces are successfully set, otherwise it returns a nonzero value.
 
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ExternalAnalysisResults.SetFrameForceMultiple(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFrameForceMultiple" failed')
        
        return ret

    def SetFrameForce(self):
        """
This function sets the external result forces for a given step of a given external results load case on a frame object.
The function returns zero if the forces are successfully set, otherwise it returns a nonzero value.
 Failed to parse arguments, start with '.api.' to call method

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.ExternalAnalysisResults.SetFrameForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFrameForce" failed')
        
        return ret

class FrameObj:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def AddByCoord(self, xi = None, yi = None, zi = None, xj = None, yj = None, zj = None, Name = None, PropName = None, UserName = None, CSys = None):
        """
This function adds a new frame object whose end points are at the specified coordinates.
The function returns zero if the frame object is successfully added, otherwise it returns a nonzero value.

xi: The coordinates of the I-End of the added frame object. The coordinates are in the coordinate system defined by the CSys item.
yi: The coordinates of the I-End of the added frame object. The coordinates are in the coordinate system defined by the CSys item.
zi: The coordinates of the I-End of the added frame object. The coordinates are in the coordinate system defined by the CSys item.
xj: The coordinates of the J-End of the added frame object. The coordinates are in the coordinate system defined by the CSys item.
yj: The coordinates of the J-End of the added frame object. The coordinates are in the coordinate system defined by the CSys item.
zj: The coordinates of the J-End of the added frame object. The coordinates are in the coordinate system defined by the CSys item.
Name: This is the name that the program ultimately assigns for the frame object. If no UserName is specified, the program assigns a default name to the frame object. If a UserName is specified and that name is not used for another frame, cable or tendon object, the UserName is assigned to the frame object, otherwise a default name is assigned to the frame object.
PropName: This is Default, None, or the name of a defined frame section property.
If it is Default, the program assigns a default section property to the frame object. If it is None, no section property is assigned to the frame object. If it is the name of a defined frame section property, that property is assigned to the frame object.
UserName: This is an optional user specified name for the frame object. If a UserName is specified and that name is already used for another frame object, the program ignores the UserName.
CSys: The name of the coordinate system in which the frame object end point coordinates are defined.
        """

        all_args = [xi, yi, zi, xj, yj, zj, Name, PropName, UserName, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.AddByCoord(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddByCoord" failed')
        
        return ret

    def AddByPoint(self, Point1 = None, Point2 = None, Name = None, PropName = None, UserName = None):
        """
This function adds a new frame object whose end points are specified by name.
The function returns zero if the frame object is successfully added, otherwise it returns a nonzero value.

Point1: The name of a defined point object at the I-End of the added frame object.
Point2: The name of a defined point object at the J-End of the added frame object.
Name: This is the name that the program ultimately assigns for the frame object. If no UserName is specified, the program assigns a default name to the frame object. If a UserName is specified and that name is not used for another frame, cable or tendon object, the UserName is assigned to the frame object, otherwise a default name is assigned to the frame object.
PropName: This is Default, None, or the name of a defined frame section property.
If it is Default, the program assigns a default section property to the frame object. If it is None, no section property is assigned to the frame object. If it is the name of a defined frame section property, that property is assigned to the frame object.
UserName: This is an optional user specified name for the frame object. If a UserName is specified and that name is already used for another frame object, the program ignores the UserName.
        """

        all_args = [Point1, Point2, Name, PropName, UserName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.AddByPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddByPoint" failed')
        
        return ret

    def ChangeName(self, Name = None, NewName = None):
        """
The function returns zero if the new name is successfully applied, otherwise it returns a nonzero value.

Name: The existing name of a defined frame object.
NewName: The new name for the frame object.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self, MyType = None):
        """
This function returns a count of the frame objects in the model. Depending on the value of the MyType item, the count may be of all frame objects in the model, just the straight frame objects in the model or just the curved frame objects in the model.

MyType: This is All, Straight, or Curved.
All returns a count of all frame objects in the model, including both straight and curved frame objects. Straight returns a count of all straight frame objects in the model. Curved returns a count of all curved frame objects in the model.
        """

        all_args = [MyType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def DeleteFireproofing(self, Name = None, ItemType = None):
        """
This function deletes the fireproofing assignments for frame objects.
The function returns zero if the fireproofing assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2
If this item is Object, the fireproofing assignments are deleted for the frame object specified by the Name item.
If this item is Group, the fireproofing assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the fireproofing assignments are deleted for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteFireproofing(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteFireproofing" failed')
        
        return ret

    def DeleteLateralBracing(self, Name = None, MyType = None, ItemType = None):
        """
This function deletes the lateral bracing assignments for frame objects.
The function returns zero if the assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
MyType: This is 1, 2 or 3, indicating the bracing to be deleted.
1 = Delete point bracing
2 = Delete uniform bracing
3 = Delete both point and uniform bracing
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the lateral bracing assignments are deleted for the frame object specified by the Name item.
If this item is Group, the lateral bracing assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects then the lateral bracing assignments are deleted for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, MyType, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteLateralBracing(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLateralBracing" failed')
        
        return ret

    def DeleteLoadDeformation(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the deformation load assignments to the specified frame objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the frame object specified by the Name item.
If this item is Group, the load assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadDeformation" failed')
        
        return ret

    def DeleteLoadDistributedWithGUID(self, Name = None, GUID = None):
        """
This function deletes the distributed load assignment with the specified global unique ID for the frame objects for the specified frame object.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
GUID: The global unique ID of one of the distributed loads on that frame object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteLoadDistributedWithGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadDistributedWithGUID" failed')
        
        return ret

    def DeleteLoadDistributed(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the distributed load assignments to the specified frame objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the frame object specified by the Name item.
If this item is Group, the load assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteLoadDistributed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadDistributed" failed')
        
        return ret

    def DeleteLoadGravity(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the gravity load assignments to the specified frame objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object,the load assignments are deleted for the frame object specified by the Name item.
If this item is Group, the load assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadGravity" failed')
        
        return ret

    def DeleteLoadPoint(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the point load assignments to the specified frame objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the frame object specified by the Name item.
If this item is Group, the load assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteLoadPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadPoint" failed')
        
        return ret

    def DeleteLoadPointWithGUID(self, Name = None, GUID = None):
        """
This function deletes the point load assignment with the specified global unique ID for the specified frame object.
The function returns zero if the load assignment is successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
GUID: The global unique ID for one of the point loads on that frame object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteLoadPointWithGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadPointWithGUID" failed')
        
        return ret

    def DeleteLoadStrain(self, Name = None, LoadPat = None, DOF = None, ItemType = None):
        """
This function deletes the strain load assignments to the specified frame objects, for the specified load pattern, for the specified degree of freedom.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
DOF: This is 1, 2, 3, 4, 5 or 6, indicating the degree of freedom to which the strain load is applied.
1 = Strain11
2 = Strain12
3 = Strain13
4 = Curvature1
5 = Curvature2
6 = Curvature3
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the frame object specified by the Name item.
If this item is Group, the load assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, DOF, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadStrain" failed')
        
        return ret

    def DeleteLoadTargetForce(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the target force assignments to the specified frame objects for the specified load pattern.
The function returns zero if the target force assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the frame object specified by the Name item.
If this item is Group, the load assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteLoadTargetForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadTargetForce" failed')
        
        return ret

    def DeleteLoadTemperature(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the temperature load assignments to the specified frame objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the frame object specified by the Name item.
If this item is Group, the load assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadTemperature" failed')
        
        return ret

    def DeleteMass(self, Name = None, ItemType = None):
        """
This function deletes the frame mass assignments for frame objects.
The function returns zero if the mass assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the frame mass assignments are deleted for the frame object specified by the Name item.
If this item is Group, the frame mass assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the frame mass assignments are deleted for all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteMass" failed')
        
        return ret

    def DeleteModifiers(self, Name = None, ItemType = None):
        """
This function deletes the frame modifier assignments for frame objects.
The function returns zero if the modifier assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the frame modifier assignments are deleted for the frame object specified by the Name item.
If this item is Group, the frame modifier assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the frame modifier assignments are deleted for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteModifiers" failed')
        
        return ret

    def DeletePDeltaForce(self, Name = None, ItemType = None):
        """
This function deletes the P-Delta force assignments for frame objects.
The function returns zero if the assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the frame modifier assignments are deleted for the frame object specified by the Name item.
If this item is Group, the frame modifier assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the frame modifier assignments are deleted for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeletePDeltaForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeletePDeltaForce" failed')
        
        return ret

    def DeleteSpring(self, Name = None, ItemType = None):
        """
This function deletes all spring assignments for the specified frame objects.
The function returns zero if the assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2
If this item is Object, the frame spring assignments are deleted for the frame object specified by the Name item.
If this item is Group, the frame spring assignments are deleted for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, the frame spring assignments are deleted for all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.DeleteSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteSpring" failed')
        
        return ret

    def Delete(self, Name = None, ItemType = None):
        """
The function deletes frame objects.
The function returns zero if the frame object is successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the frame object specified by the Name item is deleted.
If this item is Group, all of the frame objects in the group specified by the Name item are deleted.
If this item is SelectedObjects, all selected frame objects are deleted, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetAutoMesh(self, Name = None, AutoMesh = None, AutoMeshAtPoints = None, AutoMeshAtLines = None, NumSegs = None, AutoMeshMaxLength = None):
        """
This function retrieves the automatic meshing assignments to frame objects.
The function returns zero if the meshing assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
AutoMesh: This item is True if the frame object is to be automatically meshed by the program when the analysis model is created.
AutoMeshAtPoints: This item is applicable only when the AutoMesh item is True. If this item is True, the frame object is automatically meshed at intermediate joints along its length.
AutoMeshAtLines: This item is applicable only when the AutoMesh item is True. If this item is True, the frame object is automatically meshed at intersections with other frames, area object edges and solid object edges.
NumSegs: This item is applicable only when the AutoMesh item is True. It is the minimum number of elements into which the frame object is automatically meshed. If this item is zero, the number of elements is not checked when the automatic meshing is done.
AutoMeshMaxLength: This item is applicable only when the AutoMesh item is True. It is the maximum length of auto meshed frame elements. If this item is zero, the element length is not checked when the automatic meshing is done. [L]
        """

        all_args = [Name, AutoMesh, AutoMeshAtPoints, AutoMeshAtLines, NumSegs, AutoMeshMaxLength]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetAutoMesh(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAutoMesh" failed')
        
        return ret

    def GetCurved_1(self, NumberItems = None, MyName = None, MyType = None, gx = None, gy = None, gz = None, PointName = None, Radius = None, NumSegs = None):
        """
This function retrieves definition data for all curved frame objects and returns the data in arrays.
The function returns zero if the curved frame object data is successfully retrieved, otherwise it returns a nonzero value.

NumberItems: The number of curved frame objects returned.
MyName: This is a one-dimensional array of frame object names. The MyName array is created as a dynamic, zero-based, array by the APIuser:
Dim MyName() as String
The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the APIuser
MyType: This is an array that includes a numeric value indicating the curved frame type. The type is 1, 2, 3, 4, or 5.
1 = Circular Arc Specified by a Third Point Name
2 = Circular Arc Specified by Third Point Coordinates
3 = Circular Arc Specified by Planar Point Coordinates and Radius
4 = Parabolic Arc Specified by a Third Point Name
5 = Parabolic Arc Specified by Third Point Coordinates

MyTypes 1, 2, 4, and 5 all define the curve by three points. The three points are the two end point of the frame object and a third point defined by naming an existing point object or specifying point coordinates.
MyType 3 defines a circular curved frame by it end points, the coordinates of another point that lies in the plane of the curve but not necessarily on the curved frame, and a curve radius.
gx: These are arrays that include the point coordinates in the global coordinate system. [L]
For MyType 1 and 4 these items do not apply.
For MyType 2 and 5 these are the coordinates of the third point on the curved frame.
For MyType 3 these are the coordinates of the planar point that lies in the plane of the curved frame.
gy: These are arrays that include the point coordinates in the global coordinate system. [L]
For MyType 1 and 4 these items do not apply.
For MyType 2 and 5 these are the coordinates of the third point on the curved frame.
For MyType 3 these are the coordinates of the planar point that lies in the plane of the curved frame.
gz: These are arrays that include the point coordinates in the global coordinate system. [L]
For MyType 1 and 4 these items do not apply.
For MyType 2 and 5 these are the coordinates of the third point on the curved frame.
For MyType 3 these are the coordinates of the planar point that lies in the plane of the curved frame.
PointName: This is an array that includes the name of the point object that is the third point on the curved frame. This item applies for MyType 1 and 4. It does not apply for MyType 2, 3 and 5.
Radius: This is an array of the radii of the circular curved frame. This item only applies for MyType 3. [L]
NumSegs: This is an array that includes the number of segments into which the program internally divides the curved frame.
        """

        all_args = [NumberItems, MyName, MyType, gx, gy, gz, PointName, Radius, NumSegs]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetCurved_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCurved_1" failed')
        
        return ret

    def GetDAMModifiers(self, Name = None, EAModifier = None, EIModifier = None):
        """
This function gets the modification factors for axial and flexural stiffness for a frame object if the Direct Analysis method is used.
The function returns zero if the factors are successfully retrieved, otherwise it returns a nonzero value. The function will return nonzero the modification factors are not available for the frame object.

Name: The name of an existing frame section whose design type is Steel Frame design.
EAModifier: The modification factor for axial stiffness if the Direct Analysis method is used.
EIModifier: The modification factor for flexural stiffness if the Direct Analysis method is used.
        """

        all_args = [Name, EAModifier, EIModifier]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetDAMModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDAMModifiers" failed')
        
        return ret

    def GetDesignProcedure(self, Name = None, MyType = None):
        """
This function retrieves the design procedure for a frame object.
The function returns zero if the design procedure is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame object.
MyType: This is 1, 2, 7, 8 or 9, indicating the design procedure for the specified frame object.
1 = Steel
2 = Concrete
7 = Aluminum
8 = Cold Formed
9 = No Design
        """

        all_args = [Name, MyType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetDesignProcedure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDesignProcedure" failed')
        
        return ret

    def GetElm(self, Name = None, nelm = None, Elm = None, RDI = None, RDJ = None):
        """
This function retrieves the names of the frame elements (analysis model lines) associated with a specified frame object in the object-based model. It also retrieves information about the location of the frame elements along the frame object.
This function returns zero if the frame element information is successfully returned; otherwise it returns nonzero. An error occurs if the analysis model does not exist.

Name: The name of an existing frame object.
nelm: The number of line elements created from the specified frame object.
Elm: An array that includes the name of a frame element created from the specified frame object.
RDI: An array that includes the relative distance along the frame object to the I-End of the frame element.
RDJ: An array that includes the relative distance along the line object to the J-End of the frame element.
        """

        all_args = [Name, nelm, Elm, RDI, RDJ]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetElm(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetElm" failed')
        
        return ret

    def GetEndLengthOffset(self, Name = None, AutoOffset = None, Length1 = None, Length2 = None, rz = None):
        """
This function retrieves the frame object end offsets along the 1-axis of the object.
The function returns zero if the offsets are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
AutoOffset: If this item is True, the end length offsets are automatically determined by the program from object connectivity.
Length1: The offset length along the 1-axis of the frame object at the I-End of the frame object. [L]
Length2: The offset along the 1-axis of the frame object at the J-End of the frame object. [L]
rz: The rigid zone factor.This is the fraction of the end offset length assumed to be rigid for bending and shear deformations.
        """

        all_args = [Name, AutoOffset, Length1, Length2, rz]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetEndLengthOffset(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEndLengthOffset" failed')
        
        return ret

    def GetEndSkew(self, Name = None, SkewI = None, SkewJ = None):
        """
This function retrieves frame object end skew assignments.
The function returns zero if the end skew data is successfully retrieved, otherwise it returns a nonzero value.
End skew assignments are only applicable to straight frame objects. An error is returned if skew data is requested for a curved frame object.
End skew data is only used in the program to plot the extruded view of bridge objects that have been updated as spine models.

Name: The name of an existing frame object.
SkewI: The angle in degrees measured counter clockwise from the positive local 3-axis to a line parallel to the I-End of the frame object (-90 < SkewI < 90). [deg]
SkewJ: The angle in degrees measured counter clockwise from the positive local 3-axis to a line parallel to the J-End of the frame object (-90 < SkewJ < 90). [deg]
        """

        all_args = [Name, SkewI, SkewJ]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetEndSkew(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEndSkew" failed')
        
        return ret

    def GetFireProofing_1(self, Name = None, MyType = None, Thickness = None, Perimeter = None, Density = None, tf = None, IncludeInSelfWeight = None, IncludeInGravityLoads = None, IncludeInThisLoadPattern = None):
        """
This function gets the fireproofing assignment to an existing frame object.
The function returns zero if the fireproofing assignment is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
MyType: This is 1, 2 or 3, indicating the type of fireproofing assigned.
1 = Sprayed on - program calculate section perimeter
2 = Sprayed on - user provides section perimeter
3 = Concrete encased
Thickness: When MyType = 1 or MyType = 2 this is the thickness of the sprayed on fireproofing. When MyType = 3 this is the concrete cover dimension. [L]
Perimeter: This item applies only when MyType = 2. It is the length of fireproofing applied measured around the perimeter of the frame object cross-section. [L]
Density: This is the weight per unit volume of the fireproofing material. [F/L3]
tf: This item applies only when MyType = 1 or MyType = 3. If this item is True, the fireproofing is assumed to be applied to the top flange of the section. If it is False, the program assumes no fireproofing is applied to the section top flange. This flag applies for I, channel and double channel sections.
IncludeInSelfWeight: If this item is True the fireproofing is included in the structure self weight.
IncludeInGravityLoads: If this item is True the fireproofing is included gravity loads applied in the X, Y and Z directions.
IncludeInThisLoadPattern: This item is either None or the name of an existing load pattern. If it is the name of a load pattern then the weight of the fireproofing is applied as a distributed load in the global Z direction in the load pattern.
        """

        all_args = [Name, MyType, Thickness, Perimeter, Density, tf, IncludeInSelfWeight, IncludeInGravityLoads, IncludeInThisLoadPattern]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetFireProofing_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetFireProofing_1" failed')
        
        return ret

    def GetGroupAssign(self, Name = None, NumberGroups = None, Groups = None):
        """
This function retrieves the names of the groups to which a specified frame object is assigned.
The function returns zero if the group assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
NumberGroups: The number of group names retrieved.
Groups: The names of the groups to which the frame object is assigned.
        """

        all_args = [Name, NumberGroups, Groups]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGroupAssign" failed')
        
        return ret

    def GetGUID(self, Name = None, GUID = None):
        """
This function retrieves the GUID for the specified frame object.
This function returns zero if the frame object GUID is successfully retrieved; otherwise it returns nonzero.

Name: The name of an existing frame object.
GUID: The GUID (Global Unique ID) for the specified frame object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGUID" failed')
        
        return ret

    def GetHingeAssigns(self, Name = None, NumberHinges = None, HingeNum = None, Prop = None, MyType = None, Behavior = None, Source = None, RD = None):
        """
This function reports the hinge assignments for a specified 
 frame object.
The function returns zero if the assignment data is 
 successfully obtained; otherwise it returns a nonzero value.

Name: The name of an existing frame object.
NumberHinges: The number of hinge assignments on the specified frame 
 object.
HingeNum: An array that includes the hinge number for each hinge 
 on the frame object.
Prop: An array that includes the name of the generated hinge 
 property for each hinge on the frame object.
MyType: An array that specifies the type of hinge for each hinge 
 on the frame object. It is one of the following:
1 = Axial 
 P
2 = Shear 
 V2
3 = Shear 
 V3
4 = Torsion 
 T
5 = Moment 
 M2
6 = Moment 
 M3
7 = Interacting 
 P-M2
8 = Interacting 
 P-M3
9 = Interacting 
 M2-M3
10 = Interacting P-M2-M3
11 = Fiber P-M2-M3
Behavior: An array that specifies the behavior of the hinge for 
 each hinge on the frame object. It is one of the following:
1 = Force controlled
2 = Deformation controlled
Source: An array that indicates the source of the generated 
 hinge property for each hinge on the frame object. The source is either 
 Auto or the name of a defined (not generated) hinge property.
RD: An array that indicates the relative distance of each 
 hinge along the frame object.
        """

        all_args = [Name, NumberHinges, HingeNum, Prop, MyType, Behavior, Source, RD]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetHingeAssigns(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetHingeAssigns" failed')
        
        return ret

    def GetHingeAssigns_1(self, Name = None, NumberHinges = None, HingeNum = None, Prop = None, MyType = None, Behavior = None, Source = None, LocType = None, RD = None, AD = None):
        """
This function reports the hinge assignments for a specified 
 frame object.
The function returns zero if the assignment data is 
 successfully obtained; otherwise it returns a nonzero value.

Name: The name of an existing frame object.
NumberHinges: The number of hinge assignments on the specified frame 
 object.
HingeNum: An array that includes the hinge number for each hinge 
 on the frame object.
Prop: An array that includes the name of the generated hinge 
 property for each hinge on the frame object.
MyType: An array that specifies the type of hinge for each hinge 
 on the frame object. It is one of the following:
1 = Axial 
 P
2 = Shear 
 V2
3 = Shear 
 V3
4 = Torsion 
 T
5 = Moment 
 M2
6 = Moment 
 M3
7 = Interacting 
 P-M2
8 = Interacting 
 P-M3
9 = Interacting 
 M2-M3
10 = Interacting P-M2-M3
11 = Fiber P-M2-M3
Behavior: An array that specifies the behavior of the hinge for 
 each hinge on the frame object. It is one of the following:
1 = Force controlled
2 = Deformation controlled
Source: An array that indicates the source of the generated 
 hinge property for each hinge on the frame object. The source is either 
 Auto or the name of a defined (not generated) hinge property.
LocType: This is a value from 
 the eHingeLocationType enumeration, specifying the type used to define 
 the location of the hinge:
RelativeDistance = 1
OffsetFromIEnd = 2
OffsetFromJEnd = 3
RD: If LocType = eHingeLocationType.RelativeDistance, this 
 is the distance of the hinge from the end of the i-end offset, as a ratio 
 to the clear length of the frame object.
AD: If LocType = eHingeLocationType.OffsetFromIEnd, this 
 is the absolute distance of the hinge from the end of the i-end offset. 
 If LocType = eHingeLocationType.OffsetFromJEnd, this is the absolute 
 distance of the hinge from the end of the j-end offset. 
        """

        all_args = [Name, NumberHinges, HingeNum, Prop, MyType, Behavior, Source, LocType, RD, AD]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetHingeAssigns_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetHingeAssigns_1" failed')
        
        return ret

    def GetInsertionPoint(self, Name = None, CardinalPoint = None, Mirror2 = None, StiffTransform = None, Offset1 = None, Offset2 = None, CSys = None):
        """
This function retrieves frame object insertion point assignments. The assignments include the cardinal point and end joint offsets.
The function returns zero if the insertion point data is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
CardinalPoint: This is a numeric value from 1 to 11 that specifies the cardinal point for the frame object. The cardinal point specifies the relative position of the frame section on the line representing the frame object.
1 = bottom left
2 = bottom center
3 = bottom right
4 = middle left
5 = middle center
6 = middle right
7 = top left
8 = top center
9 = top right
10 = centroid
11 = shear center
Mirror2: If this item is True, the frame object section is assumed to be mirrored (flipped) about its local 2-axis.
StiffTransform: If this item is True, the frame object stiffness is transformed for cardinal point and joint offsets from the frame section centroid.
Offset1: This is an array of three joint offset distances, in the coordinate directions specified by CSys, at the I-End of the frame object. [L]
Offset1(0) = Offset in the 1-axis or X-axis direction
Offset1(1) = Offset in the 2-axis or Y-axis direction
Offset1(2) = Offset in the 3-axis or Z-axis direction
Offset2: This is an array of three joint offset distances, in the coordinate directions specified by CSys, at the J-End of the frame object. [L]
Offset2(0) = Offset in the 1-axis or X-axis direction
Offset2(1) = Offset in the 2-axis or Y-axis direction
Offset2(2) = Offset in the 3-axis or Z-axis direction
CSys: This is either Local or the name of a defined coordinate system. It is the coordinate system in which the Offset1 and Offset2 items are specified.
        """

        all_args = [Name, CardinalPoint, Mirror2, StiffTransform, Offset1, Offset2, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetInsertionPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetInsertionPoint" failed')
        
        return ret

    def GetLateralBracing(self, Name = None, NumberItems = None, FrameName = None, MyType = None, Loc = None, RD1 = None, RD2 = None, Dist1 = None, Dist2 = None):
        """
This function retrieves the lateral bracing location assignments for frame objects.
The function returns zero if the assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame object.
NumberItems: The total number of bracing assignments retrieved for the specified frame objects.
FrameName: This is an array that includes the name of the frame object associated with each bracing assignment.
MyType: This is an array that includes 1 or 2, indicating the bracing type assigned.
1 = Point bracing
2 = Uniform bracing
Loc: This is an array that includes 1, 2 or 3; indicating the bracing location.
1 = Top
2 = Bottom
3 = All (top and bottom)
RD1: This is an array that includes the relative location of the point bracing (when MyType = 1) or the relative location of the start of the uniform bracing (when MyType = 2).
RD2: This is an array that includes the relative location of the start of the uniform bracing (when MyType = 2).
This item does not apply for point bracing (when MyType = 1).
Dist1: This is an array that includes the actual location of the point bracing (when MyType = 1) or the actual location of the start of the uniform bracing (when MyType = 2). [L]
Dist2: This is an array that includes the actual location of the start of the uniform bracing (when MyType = 2). [L]
This item does not apply for point bracing (when MyType = 1).
        """

        all_args = [Name, NumberItems, FrameName, MyType, Loc, RD1, RD2, Dist1, Dist2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetLateralBracing(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLateralBracing" failed')
        
        return ret

    def GetLoadDeformation(self, Name = None, NumberItems = None, FrameName = None, LoadPat = None, dof1 = None, dof2 = None, dof3 = None, dof4 = None, dof5 = None, dof6 = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None, ItemType = None):
        """
This function retrieves the deformation load assignments to frame objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The total number of deformation loads retrieved for the specified frame objects.
FrameName: This is an array that includes the name of the frame object associated with each deformation load.
LoadPat: This is an array that includes the name of the load pattern associated with each deformation load.
dof1: These are arrays of boolean values indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof2: These are arrays of boolean values indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof3: These are arrays of boolean values indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof4: These are arrays of boolean values indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof5: These are arrays of boolean values indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof6: These are arrays of boolean values indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
U1: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
U2: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
U3: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
R1: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
R2: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
R3: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the frame object specified by the Name item.
If this item is Group, the assignments are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, LoadPat, dof1, dof2, dof3, dof4, dof5, dof6, U1, U2, U3, R1, R2, R3, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadDeformation" failed')
        
        return ret

    def GetLoadDistributedWthGUID(self, Name = None, NumberItems = None, FrameName = None, LoadPat = None, MyType = None, CSys = None, Dir = None, RD1 = None, RD2 = None, Dist1 = None, Dist2 = None, Val1 = None, Val2 = None, GUID = None, ItemType = None):
        """
This function is identical to GetLoadDistributed but it includes an extra return parameter, which includes the global unique IDs of the retrieved distributed loads.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The total number of distributed loads retrieved for the specified frame objects.
FrameName: This is an array that includes the name of the frame object associated with each distributed load.
LoadPat: This is an array that includes the name of the coordinate system in which the distributed loads are specified.
MyType: This is an array that includes 1 or 2, indicating the type of distributed load.
1 = Force
2 = Moment
CSys: This is an array that includes the name of the coordinate system in which each distributed load is defined. It may be Local or the name of a defined coordinate system.
Dir: This is an array that includes an integer between 1 and 11, indicating the direction of the load.
1 = Local 1 axis (only applies when CSys is Local)
2 = Local 2 axis (only applies when CSys is Local)
3 = Local 3 axis (only applies when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
7 = Projected X direction (does not apply when CSys is Local)
8 = Projected Y direction (does not apply when CSys is Local)
9 = Projected Z direction (does not apply when CSys is Local)
10 = Gravity direction (only applies when CSys is Global)
11 = Projected Gravity direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) is in the negative Global Z direction.
RD1: This is an array that includes the relative distance from the I-End of the frame object to the start of the distributed load.
RD2: This is an array that includes the relative distance from the I-End of the frame object to the end of the distributed load.
Dist1: This is an array that includes the actual distance from the I-End of the frame object to the start of the distributed load. [L]
Dist2: This is an array that includes the actual distance from the I-End of the frame object to the end of the distributed load. [L]
Val1: This is an array that includes the load value at the start of the distributed load. [F/L] when MyType is 1 and [FL/L] when MyType is 2
Val2: This is an array that includes the load value at the end of the distributed load. [F/L] when MyType is 1 and [FL/L] when MyType is 2
GUID: This is an array that includes the global unique ID of the distributed load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the frame object specified by the Name item.
If this item is Group, the assignments are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, LoadPat, MyType, CSys, Dir, RD1, RD2, Dist1, Dist2, Val1, Val2, GUID, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetLoadDistributedWthGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadDistributedWthGUID" failed')
        
        return ret

    def GetLoadDistributed(self, Name = None, NumberItems = None, FrameName = None, LoadPat = None, MyType = None, CSys = None, Dir = None, RD1 = None, RD2 = None, Dist1 = None, Dist2 = None, Val1 = None, Val2 = None, ItemType = None):
        """
This function retrieves the distributed load assignments to frame objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The total number of distributed loads retrieved for the specified frame objects.
FrameName: This is an array that includes the name of the frame object associated with each distributed load.
LoadPat: This is an array that includes the name of the coordinate system in which the distributed loads are specified.
MyType: This is an array that includes 1 or 2, indicating the type of distributed load.
1 = Force
2 = Moment
CSys: This is an array that includes the name of the coordinate system in which each distributed load is defined. It may be Local or the name of a defined coordinate system.
Dir: This is an array that includes an integer between 1 and 11, indicating the direction of the load.
1 = Local 1 axis (only applies when CSys is Local)
2 = Local 2 axis (only applies when CSys is Local)
3 = Local 3 axis (only applies when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
7 = Projected X direction (does not apply when CSys is Local)
8 = Projected Y direction (does not apply when CSys is Local)
9 = Projected Z direction (does not apply when CSys is Local)
10 = Gravity direction (only applies when CSys is Global)
11 = Projected Gravity direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) is in the negative Global Z direction.
RD1: This is an array that includes the relative distance from the I-End of the frame object to the start of the distributed load.
RD2: This is an array that includes the relative distance from the I-End of the frame object to the end of the distributed load.
Dist1: This is an array that includes the actual distance from the I-End of the frame object to the start of the distributed load. [L]
Dist2: This is an array that includes the actual distance from the I-End of the frame object to the end of the distributed load. [L]
Val1: This is an array that includes the load value at the start of the distributed load. [F/L] when MyType is 1 and [FL/L] when MyType is 2
Val2: This is an array that includes the load value at the end of the distributed load. [F/L] when MyType is 1 and [FL/L] when MyType is 2
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the frame object specified by the Name item.
If this item is Group, the assignments are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, LoadPat, MyType, CSys, Dir, RD1, RD2, Dist1, Dist2, Val1, Val2, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetLoadDistributed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadDistributed" failed')
        
        return ret

    def GetLoadGravity(self, Name = None, NumberItems = None, FrameName = None, LoadPat = None, CSys = None, x = None, y = None, z = None, ItemType = None):
        """
This function retrieves the gravity load assignments to frame objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The total number of gravity loads retrieved for the specified frame objects.
FrameName: This is an array that includes the name of the frame object associated with each gravity load.
LoadPat: This is an array that includes the name of the coordinate system in which the gravity load multipliers are specified.
CSys: This is an array that includes the name of the coordinate system associated with each gravity load.
x: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the frame object specified by the Name item.
If this item is Group, the assignments are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, LoadPat, CSys, x, y, z, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadGravity" failed')
        
        return ret

    def GetLoadPoint(self, Name = None, NumberItems = None, FrameName = None, LoadPat = None, MyType = None, CSys = None, Dir = None, RelDist = None, Dist = None, Val = None, ItemType = None):
        """
This function retrieves the point load assignments to frame objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
NumberItems: The total number of point loads retrieved for the specified frame objects.
FrameName: This is an array that includes the name of the frame object associated with each point load.
LoadPat: This is an array that includes the name of the coordinate system in which the point loads are specified.
MyType: This is an array that includes 1 or 2, indicating the type of point load.
1 = Force
2 = Moment
CSys: This is an array that includes the name of the coordinate system in which each point load is defined. It may be Local or the name of a defined coordinate system.
Dir: This is an array that includes an integer between 1 and 11 indicating the direction of the load.
1 = Local 1 axis (only applies when CSys is Local)
2 = Local 2 axis (only applies when CSys is Local)
3 = Local 3 axis (only applies when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
7 = Projected X direction (does not apply when CSys is Local)
8 = Projected Y direction (does not apply when CSys is Local)
9 = Projected Z direction (does not apply when CSys is Local)
10 = Gravity direction (only applies when CSys is Global)
11 = Projected Gravity direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) is in the negative Global Z direction.
RelDist: This is an array that includes the relative distance from the I-End of the frame object to the location where the point load is applied.
Dist: This is an array that includes the actual distance from the I-End of the frame object to the location where the point load is applied. [L]
Val: This is an array that includes the value of the point load. [F] when MyType is 1 and [FL] when MyType is 2
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the frame object specified by the Name item.
If this item is Group, the assignments are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, LoadPat, MyType, CSys, Dir, RelDist, Dist, Val, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetLoadPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadPoint" failed')
        
        return ret

    def GetLoadStrain(self, Name = None, NumberItems = None, FrameName = None, LoadPat = None, DOF = None, Val = None, PatternName = None, ItemType = None):
        """
This function retrieves the strain load assignments to frame objects.
The function returns zero if the strain load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The total number of strain loads retrieved for the specified frame objects.
FrameName: This is an array that includes the name of the frame object associated with each strain load.
LoadPat: This is an array that includes the name of the load pattern associated with each strain load.
DOF: This is an array that includes 1, 2, 3, 4, 5 or 6, indicating the degree of freedom associated with each strain load.
1 = Strain11
2 = Strain12
3 = Strain13
4 = Curvature1
5 = Curvature2
6 = Curvature3
Val: This is an array that includes the strain value. [L/L] for DOF = 1, 2 and 3 and [1/L] for DOF = 4, 5 and 6
PatternName: This is an array that includes the joint pattern name, if any, used to specify the strain load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the frame object specified by the Name item.
If this item is Group, the assignments are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, LoadPat, DOF, Val, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadStrain" failed')
        
        return ret

    def GetLoadTargetForce(self, Name = None, NumberItems = None, FrameName = None, LoadPat = None, dof1 = None, dof2 = None, dof3 = None, dof4 = None, dof5 = None, dof6 = None, P = None, V2 = None, V3 = None, T = None, M2 = None, M3 = None, T1 = None, T2 = None, T3 = None, T4 = None, T5 = None, T6 = None, ItemType = None):
        """
This function retrieves the target force assignments to frame objects.
The function returns zero if the target force assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The total number of deformation loads retrieved for the specified frame objects.
FrameName: This is an array that includes the name of the frame object associated with each target force.
LoadPat: This is an array that includes the name of the load pattern associated with each target force.
dof1: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof2: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof3: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof4: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof5: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof6: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
P: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
V2: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
V3: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
T: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
M2: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
M3: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
T1: These are arrays of the relative distances along the frame objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T2: These are arrays of the relative distances along the frame objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T3: These are arrays of the relative distances along the frame objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T4: These are arrays of the relative distances along the frame objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T5: These are arrays of the relative distances along the frame objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T6: These are arrays of the relative distances along the frame objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the frame object specified by the Name item.
If this item is Group, the assignments are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, LoadPat, dof1, dof2, dof3, dof4, dof5, dof6, P, V2, V3, T, M2, M3, T1, T2, T3, T4, T5, T6, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetLoadTargetForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTargetForce" failed')
        
        return ret

    def GetLoadTemperature(self, Name = None, NumberItems = None, FrameName = None, LoadPat = None, MyType = None, Val = None, PatternName = None, ItemType = None):
        """
This function retrieves the temperature load assignments to frame objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
NumberItems: The total number of temperature loads retrieved for the specified frame objects.
FrameName: This is an array that includes the name of the frame object associated with each temperature load.
LoadPat: This is an array that includes the name of the load pattern associated with each temperature load.
MyType: This is an array that includes 1, 2 or 3, indicating the type of temperature load.
1 = Temperature
2 = Temperature gradient along local 2 axis
3 = Temperature gradient along local 3 axis
Val: This is an array that includes the temperature load value. [T] for MyType= 1 and [T/L] for MyType= 2 and 3
PatternName: This is an array that includes the joint pattern name, if any, used to specify the temperature load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the frame object specified by the Name item.
If this item is Group, the assignments are retrieved for all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, FrameName, LoadPat, MyType, Val, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTemperature" failed')
        
        return ret

    def GetLoadTransfer(self, Name = None, Val = None):
        """
This function returns the load transfer option for a frame object.  It indicates whether the frame receives load from an area object when the area object is loaded with a load of type uniform to frame.
The function returns zero if the load transfer option is successfully returned, otherwise it returns a nonzero value.

Name: The name of an existing frame.
Val: This boolean value indicates if load is allowed to be transferred from area objects to this frame object.
        """

        all_args = [Name, Val]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetLoadTransfer(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTransfer" failed')
        
        return ret

    def GetLocalAxesAdvanced(self, Name = None, Active = None, Plane2 = None, PlVectOpt = None, PlCSys = None, PlDir = None, PlPt = None, PlVect = None):
        """
This function retrieves the advanced local axes assignments to frame objects.
The function returns zero if the advanced local axes assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing frame object.
Active: This is True if advanced local axes exist.
Plane2: This is 12 or 13, indicating that the local plane determined by the plane reference vector is the 1-2 plane or the 1-3 plane. This item applies only when the Active item is True.
PlVectOpt: This is 1, 2, or 3, indicating the plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
PlCSys: The coordinate system used to define the plane reference vector coordinate directions and the plane user vector. This item applies when the Active item is True and the PlVectOpt item is 1 or 3.
PlDir: This is an array dimensioned to 1 (2 integers), indicating the plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
PlPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the PlVectOpt item is 2.
PlVect: This is an array dimensioned to 2 (3 doubles) that defines the plane reference vector. This item applies when the Active item is True and the PlVectOpt item is 3.
        """

        all_args = [Name, Active, Plane2, PlVectOpt, PlCSys, PlDir, PlPt, PlVect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetLocalAxesAdvanced(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxesAdvanced" failed')
        
        return ret

    def GetLocalAxes(self, Name = None, Ang = None, Advanced = None):
        """
This function retrieves the frame local axis angle assignment for frame objects.
The function returns zero if the assignment is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
Ang: This is the angle that the local 2 and 3 axes are rotated about the positive local 1 axis, from the default orientation or, if the Advanced item is True, from the orientation determined by the plane reference vector. The rotation for a positive angle appears counter clockwise when the local +1 axis is pointing toward you. [deg]
Advanced: This item is True if the line object local axes orientation was obtained using advanced local axes parameters.
        """

        all_args = [Name, Ang, Advanced]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxes" failed')
        
        return ret

    def GetMass(self, Name = None, MassOverL = None):
        """
This function retrieves the frame mass per unit length assignment for frame objects.
The function returns zero if the mass assignment is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
MassOverL: The mass per unit length assigned to the frame object. [M/L]
        """

        all_args = [Name, MassOverL]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMass" failed')
        
        return ret

    def GetMaterialOverwrite(self, Name = None, PropName = None):
        """
This function retrieves the material overwrite assigned to a frame object, if any. It returns None if there is no material overwrite assignment.
The function returns zero if the material overwrite assignment is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined frame object.
PropName: This is None, indicating that no material overwrite exists for the specified frame object, or it is the name of an existing material property.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetMaterialOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMaterialOverwrite" failed')
        
        return ret

    def GetMatTemp(self, Name = None, Temp = None, PatternName = None):
        """
This function retrieves the material temperature assignments to frame objects.
The function returns zero if the material temperature assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
Temp: This is the material temperature value assigned to the frame object. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the frame object is uniform along the object at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the frame object may vary from one end to the other. The material temperature at each end of the object is equal to the specified temperature multiplied by the pattern value at the joint at the end of the frame object.
        """

        all_args = [Name, Temp, PatternName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMatTemp" failed')
        
        return ret

    def GetModifiers(self, Name = None, Value = None):
        """
This function retrieves the frame modifier assignment for frame objects. The default value for all modifiers is one.
The function returns zero if the modifier assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
Value: This is an array of eight unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Shear area in local 2 direction modifier
Value(2) = Shear area in local 3 direction modifier
Value(3) = Torsional constant modifier
Value(4) = Moment of inertia about local 2 axis modifier
Value(5) = Moment of inertia about local 3 axis modifier
Value(6) = Mass modifier
Value(7) = Weight modifier
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetModifiers" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined frame objects.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of frame object names retrieved by the program.
MyName: This is a one-dimensional array of frame object names. The MyName array is created as a dynamic, zero-based, array by the APIuser:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the APIuser.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetOutputStations(self, Name = None, MyType = None, MaxSegSize = None, MinSections = None, NoOutPutAndDesignAtElementEnds = None, NoOutPutAndDesignAtPointLoads = None):
        """
This function retrieves frame object output station data.
The function returns zero if the data is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
MyType: This is either 1 or 2 indicating how the output stations are specified.
1 = maximum segment size, that is, maximum station spacing
2 = minimum number of stations
MaxSegSize: The maximum segment size, that is, the maximum station spacing. This item applies only when MyType = 1. [L]
MinSections: The minimum number of stations. This item applies only when MyType = 2.
NoOutPutAndDesignAtElementEnds: If this item is True, no additional output stations are added at the ends of line elements when the frame object is internally meshed.
NoOutPutAndDesignAtPointLoads: If this item is True, no additional output stations are added at point load locations.
        """

        all_args = [Name, MyType, MaxSegSize, MinSections, NoOutPutAndDesignAtElementEnds, NoOutPutAndDesignAtPointLoads]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetOutputStations(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetOutputStations" failed')
        
        return ret

    def GetPDeltaForce(self, Name = None, NumberForces = None, PDeltaForce = None, Dir = None, CSys = None):
        """
This function retrieves the P-Delta force assignments to frame objects. P-Delta forces do not apply to curved frame objects. If you request data for a curved frame, an error is returned.
The function returns zero if the assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing straight frame object.
NumberForces: The number of P-Delta forces assigned to the frame object.
PDeltaForce: This is an array of the P-Delta force values assigned to the frame object. [F]
Dir: This is an array that contains 0, 1, 2 or 3, indicating the direction of each P-Delta force assignment.
0 = Frame object local 1-axis direction
1 = Projected X direction in CSys coordinate system
2 = Projected Y direction in CSys coordinate system
3 = Projected Z direction in CSys coordinate system
CSys: This is an array that contains the name of the coordinate system in which each projected P-Delta force is defined. This item is blank when the Dir item is zero, that is, when the P-Delta force is defined in the frame object local 1-axis direction.
        """

        all_args = [Name, NumberForces, PDeltaForce, Dir, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetPDeltaForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPDeltaForce" failed')
        
        return ret

    def GetPoints(self, Name = None, Point1 = None, Point2 = None):
        """
This function retrieves the names of the point objects at each end of a specified frame object.
The function returns zero if the point names are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined frame object.
Point1: The name of the point object at the I-End of the specified frame object.
Point2: The name of the point object at the J-End of the specified frame object.
        """

        all_args = [Name, Point1, Point2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPoints" failed')
        
        return ret

    def GetReleases(self, Name = None, ii = None, jj = None, StartValue = None, EndValue = None):
        """
This function retrieves the frame object end release and partial fixity assignments.
The function returns zero if the assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
ii: These are arrays of six booleans indicating the I-End and J-End releases for the frame object.
ii(0) and jj(0) = U1 release
ii(1) and jj(1) = U2 release
ii(2) and jj(2) = U3 release
ii(3) and jj(3) = R1 release
ii(4) and jj(4) = R2 release
ii(5) and jj(5) = R3 release

jj: These are arrays of six booleans indicating the I-End and J-End releases for the frame object.
ii(0) and jj(0) = U1 release
ii(1) and jj(1) = U2 release
ii(2) and jj(2) = U3 release
ii(3) and jj(3) = R1 release
ii(4) and jj(4) = R2 release
ii(5) and jj(5) = R3 release

StartValue: These are arrays of six values indicating the I-End and J-End partial fixity springs for the frame object.
StartValue(0) and EndValue(0) = U1 partial fixity [F/L]
StartValue(1) and EndValue(1) = U2 partial fixity [F/L]
StartValue(2) and EndValue(2) = U3 partial fixity [F/L]
StartValue(3) and EndValue(3) = R1 partial fixity [FL/rad]
StartValue(4) and EndValue(4) = R2 partial fixity [FL/rad]
StartValue(5) and EndValue(5) = R3 partial fixity [FL/rad]
EndValue: These are arrays of six values indicating the I-End and J-End partial fixity springs for the frame object.
StartValue(0) and EndValue(0) = U1 partial fixity [F/L]
StartValue(1) and EndValue(1) = U2 partial fixity [F/L]
StartValue(2) and EndValue(2) = U3 partial fixity [F/L]
StartValue(3) and EndValue(3) = R1 partial fixity [FL/rad]
StartValue(4) and EndValue(4) = R2 partial fixity [FL/rad]
StartValue(5) and EndValue(5) = R3 partial fixity [FL/rad]
        """

        all_args = [Name, ii, jj, StartValue, EndValue]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetReleases(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetReleases" failed')
        
        return ret

    def GetSectionNonPrismatic(self, Name = None, PropName = None, sVarTotalLength = None, sVarRelStartLoc = None):
        """
This function retrieves the nonprismatic frame section property data assigned to a frame object.
The function returns zero if the nonprismatic frame object property data is successfully retrieved, otherwise it returns a nonzero value.
The function returns an error if the section property assigned to the frame object is not a nonprismatic property.

Name: The name of a defined frame object.
PropName: The name of the nonprismatic frame section property assigned to the frame object.
sVarTotalLength: This is the total assumed length of the nonprismatic section. Enter 0 for this item to indicate that the section length is the same as the frame object length.
sVarRelStartLoc: This is the relative distance along the nonprismatic section to the I-End (start) of the frame object. This item is ignored when the sVarTotalLengthitem is 0.
        """

        all_args = [Name, PropName, sVarTotalLength, sVarRelStartLoc]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetSectionNonPrismatic(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSectionNonPrismatic" failed')
        
        return ret

    def GetSection(self, Name = None, PropName = None, SAuto = None):
        """
This function retrieves the frame section property assigned to a frame object.
The function returns zero if the frame object property is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined frame object.
PropName: If no auto select list is assigned to the frame object, this is the name of the frame section property assigned to the frame object. If an auto select list is assigned to the frame object, this is the name of the frame section property, within the auto select list, which is currently being used as the analysis property for the frame object. If this item is None, no frame section property is assigned to the frame object.
SAuto: This is the name of the auto select list assigned to the frame object, if any. If this item is returned as a blank string, no auto select list is assigned to the frame object.
        """

        all_args = [Name, PropName, SAuto]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSection" failed')
        
        return ret

    def GetSpring(self, Name = None, NumberSprings = None, MyType = None, s = None, SimpleSpringType = None, LinkProp = None, SpringLocalOneType = None, Dir = None, Plane23Angle = None, VecX = None, VecY = None, VecZ = None, CSys = None, Ang = None):
        """
This function retrieves the spring assignments to a frame object.
The function returns zero if the assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
NumberSprings: The number of springs assignments made to the specified frame object.
MyType: Each value in this array is either 1 or 2, indicating the spring property type.
1 = Simple spring
2 = Link property
s: Each value in this array is the simple spring stiffness per unit length of the frame object. This item applies only when the corresponding MyType = 1. [F/L2]
SimpleSpringType: Each value in this array is 1, 2 or 3, indicating the simple spring type. This item applies only when the corresponding MyType = 1.
1 = Spring resists tension and compression
2 = Spring resists compression only
3 = Spring resists tension only
LinkProp: Each value in this array is the name of the link property assigned to the spring. This item applies only when the corresponding MyType = 2.
SpringLocalOneType: Each value in this array is 1, 2 or 3, indicating the method used to specify the spring positive local 1-axis orientation.
1 = Parallel to frame object local axis
2 = In the frame object 2-3 plane
3 = User specified direction vector
Dir: Each value in this array is 1, 2, 3, -1, -2 or -3, indicating the frame object local axis that corresponds to the positive local 1-axis of the spring. This item applies only when the corresponding SpringLocalOneType = 1.
Plane23Angle: Each value in this array is the angle in the frame object 2-3 plane measured counter clockwise from the frame positive 2-axis to the spring positive 1-axis. This item applies only when the corresponding SpringLocalOneType = 2. [deg]
VecX: Each value in this array is the X-axis or frame local 1-axis component (depending on the CSys specified) of the user specified direction vector for the spring local 1-axis. The direction vector is in the coordinate system specified by the CSys item. This item applies only when the corresponding SpringLocalOneType = 3.
VecY: Each value in this array is the Y-axis or frame local 2-axis component (depending on the CSys specified) of the user specified direction vector for the spring local 1-axis. The direction vector is in the coordinate system specified by the CSys item. This item applies only when the corresponding SpringLocalOneType = 3.
VecZ: Each value in this array is the X-axis or frame local 3-axis component (depending on the CSys specified) of the user specified direction vector for the spring local 1-axis. The direction vector is in the coordinate system specified by the CSys item. This item applies only when the corresponding SpringLocalOneType = 3.
CSys: Each value in this array is Local (meaning the frame object local coordinate system) or the name of a defined coordinate system. This item is the coordinate system in which the user specified direction vector, Vec, is specified. This item applies only when the corresponding SpringLocalOneType = 3.
Ang: Each value in this array is the angle that the link local 2-axis is rotated from its default orientation. This item applies only when the corresponding MyType = 2. [deg]
        """

        all_args = [Name, NumberSprings, MyType, s, SimpleSpringType, LinkProp, SpringLocalOneType, Dir, Plane23Angle, VecX, VecY, VecZ, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSpring" failed')
        
        return ret

    def GetTCLimits(self, Name = None, LimitCompressionExists = None, LimitCompression = None, LimitTensionExists = None, LimitTension = None):
        """
This function retrieves the tension/compression force limit assignments to frame objects.
The function returns zero if the assignments are successfully retrieved, otherwise it returns a nonzero value.
Note that the tension and compression limits are used only in nonlinear analyses.

Name: The name of an existing frame object.
LimitCompressionExists: This item is True if a compression force limit exists for the frame object.
LimitCompression: The compression force limit for the frame object. [F]
LimitTensionExists: This item is True if a tension force limit exists for the frame object.
LimitTension: The tension force limit for the frame object. [F]
        """

        all_args = [Name, LimitCompressionExists, LimitCompression, LimitTensionExists, LimitTension]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetTCLimits(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTCLimits" failed')
        
        return ret

    def GetTypeOAPI(self, Name = None, MyType = None):
        """
This function retrieves the type of frame object (straight or curved).
The function returns zero if the frame object type is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined frame object.
MyType: This is Straight or Curved, indicating the type of frame object.
        """

        all_args = [Name, MyType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetTypeOAPI(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTypeOAPI" failed')
        
        return ret

    def SetAutoMesh(self, Name = None, AutoMesh = None, AutoMeshAtPoints = None, AutoMeshAtLines = None, NumSegs = None, AutoMeshMaxLength = None, ItemType = None):
        """
This function makes automatic meshing assignments to frame objects.
The function returns zero if the meshing options are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
AutoMesh: This item is True if the frame object is to be automatically meshed by the program when the analysis model is created.
AutoMeshAtPoints: This item is applicable only when the AutoMesh item is True. If this item is True, the frame object is automatically meshed at intermediate joints along its length.
AutoMeshAtLines: This item is applicable only when the AutoMesh item is True. If this item is True, the frame object is automatically meshed at intersections with other frames, area object edges and solid object edges.
NumSegs: This item is applicable only when the AutoMesh item is True. It is the minimum number of elements into which the frame object is automatically meshed. If this item is zero, the number of elements is not checked when the automatic meshing is done.
AutoMeshMaxLength: This item is applicable only when the AutoMesh item is True. It is the maximum length of auto meshed frame elements. If this item is zero, the element length is not checked when the automatic meshing is done. [L]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, AutoMesh, AutoMeshAtPoints, AutoMeshAtLines, NumSegs, AutoMeshMaxLength, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetAutoMesh(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAutoMesh" failed')
        
        return ret

    def SetCurved(self, Name = None, MyType = None, x = None, y = None, z = None, PointName = None, Radius = None, NumSegs = None, CSys = None):
        """
This function changes the curve data for a curved frame object and sets straight frame objects to be curved.
The function returns zero if the frame object type is successfully set, otherwise it returns a nonzero value.

Name: The name of a defined curved frame object.
MyType: This is 1, 2, 3, 4, or 5, indicating the curved frame type.
1 = Circular Arc Specified by a Third Point Name
2 = Circular Arc Specified by Third Point Coordinates
3 = Circular Arc Specified by Planar Point Coordinates and Radius
4 = Parabolic Arc Specified by a Third Point Name
5 = Parabolic Arc Specified by Third Point Coordinates

MyTypes 1, 2, 4, and 5 all define the curve by three points. The three points are the two end point of the frame object and a third point defined by naming an existing point object or specifying point coordinates.
MyType 3 defines a circular curved frame by it end points, the coordinates of another point that lies in the plane of the curve but not necessarily on the curved frame, and a curve radius.
x: These are point coordinates in the coordinate system specified by CSys. [L]
For MyType 1 and 4 these items do not apply.
For MyType 2 and 5 these are the coordinates of the third point on the curved frame.
For MyType 3 these are the coordinates of the planar point that lies in the plane of the curved frame.
y: These are point coordinates in the coordinate system specified by CSys. [L]
For MyType 1 and 4 these items do not apply.
For MyType 2 and 5 these are the coordinates of the third point on the curved frame.
For MyType 3 these are the coordinates of the planar point that lies in the plane of the curved frame.
z: These are point coordinates in the coordinate system specified by CSys. [L]
For MyType 1 and 4 these items do not apply.
For MyType 2 and 5 these are the coordinates of the third point on the curved frame.
For MyType 3 these are the coordinates of the planar point that lies in the plane of the curved frame.
PointName: This is the name of the point object that is the third point on the curved frame. This item applies for MyType 1 and 4. It does not apply for MyType 2, 3 and 5.
Radius: The radius of the circular curved frame. This item only applies for MyType 3. [L]
NumSegs: This is the number of segments into which the program internally divides the curved frame.
CSys: This is the coordinate system in which the coordinates x, y and z are defined.
        """

        all_args = [Name, MyType, x, y, z, PointName, Radius, NumSegs, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetCurved(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetCurved" failed')
        
        return ret

    def SetDesignProcedure(self, Name = None, MyType = None, ItemType = None):
        """
This function sets the design procedure for frame objects.
The function returns zero if the design procedure is successfully set; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
MyType: This is 1 or 2, indicating the design procedure type desired for the specified frame object.
1 = Default from material
2 = No design
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
Selection = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is Selection, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, MyType, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetDesignProcedure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDesignProcedure" failed')
        
        return ret

    def SetEndLengthOffset(self, Name = None, AutoOffset = None, Length1 = None, Length2 = None, rz = None, ItemType = None):
        """
This function assigns frame object end offsets along the 1-axis of the object.
The function returns zero if the offsets are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
AutoOffset: If this item is True, the end length offsets are automatically determined by the program from object connectivity, and the Length1, Length2 and rz items are ignored.
Length1: The offset length along the 1-axis of the frame object at the I-End of the frame object. [L]
Length2: The offset along the 1-axis of the frame object at the J-End of the frame object. [L]
rz: The rigid zone factor.This is the fraction of the end offset length assumed to be rigid for bending and shear deformations.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2
If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, AutoOffset, Length1, Length2, rz, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetEndLengthOffset(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEndLengthOffset" failed')
        
        return ret

    def SetEndSkew(self, Name = None, SkewI = None, SkewJ = None, ItemType = None):
        """
This function assigns frame object end skew data. End skew data is used in the program to plot the extruded view of bridge objects that have been updated as spine models only.
The function returns zero if the end skew data is successfully assigned, otherwise it returns a nonzero value.
End skew assignments are applicable only to straight frame objects.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
SkewI: The angle in degrees measured counter clockwise from the positive local 3-axis to a line parallel to the I-End of the frame object (-90 < SkewI < 90). [deg]
SkewJ: The angle in degrees measured counter clockwise from the positive local 3-axis to a line parallel to the J-End of the frame object (-90 < SkewJ < 90). [deg]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, SkewI, SkewJ, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetEndSkew(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEndSkew" failed')
        
        return ret

    def SetFireProofing_1(self, Name = None, MyType = None, Thickness = None, Perimeter = None, Density = None, tf = None, IncludeInSelfWeight = None, IncludeInGravityLoads = None, IncludeInThisLoadPattern = None, ItemType = None):
        """


Name: The name of an existing frame object.
MyType: This is 1, 2 or 3, indicating the type of fireproofing assigned.
1 = Sprayed on - program calculate section perimeter
2 = Sprayed on - user provides section perimeter
3 = Concrete encased
Thickness: When MyType = 1 or MyType = 2 this is the thickness of the sprayed on fireproofing. When MyType = 3 this is the concrete cover dimension. [L]
Perimeter: This item applies only when MyType = 2. It is the length of fireproofing applied measured around the perimeter of the frame object cross-section. [L]
Density: This is the weight per unit volume of the fireproofing material. [F/L3]
tf: This item applies only when MyType = 1 or MyType = 3. If this item is True, the fireproofing is assumed to be applied to the top flange of the section. If it is False, the program assumes no fireproofing is applied to the section top flange. This flag applies for I, channel and double channel sections.
IncludeInSelfWeight: If this item is True the fireproofing is included in the structure self weight.
IncludeInGravityLoads: If this item is True the fireproofing is included gravity loads applied in the X, Y and Z directions.
IncludeInThisLoadPattern: This item is either None or the name of an existing load pattern. If it is the name of a load pattern then the weight of the fireproofing is applied as a distributed load in the global Z direction in the load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2
If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, MyType, Thickness, Perimeter, Density, tf, IncludeInSelfWeight, IncludeInGravityLoads, IncludeInThisLoadPattern, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetFireProofing_1(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFireProofing_1" failed')
        
        return ret

    def SetGroupAssign(self, Name = None, GroupName = None, Remove = None, ItemType = None):
        """
This function adds or removes frame objects from a specified group.
The function returns zero if the group assignment is successful, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
GroupName: The name of an existing group to which the assignment is made.
Remove: If this item is False, the specified frame objects are added to the group specified by the GroupName item. If it is True, the frame objects are removed from the group.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the frame object specified by the Name item is added or removed from the group specified by the GroupName item.
If this item is Group, all frame objects in the group specified by the Name item are added or removed from the group specified by the GroupName item.
If this item is SelectedObjects, all selected frame objects are added or removed from the group specified by the GroupName item, and the Name item is ignored.
        """

        all_args = [Name, GroupName, Remove, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGroupAssign" failed')
        
        return ret

    def SetGUID(self, Name = None, GUID = None):
        """
This function sets the GUID for the specified frame object. If the GUID is passed in as a blank string, the program automatically creates a GUID for the object.
This function returns zero if the frame object GUID is successfully set; otherwise it returns nonzero.

Name: The name of an existing frame object.
GUID: The GUID (Global Unique ID) for the specified frame object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGUID" failed')
        
        return ret

    def SetInsertionPoint(self, Name = None, CardinalPoint = None, Mirror2 = None, StiffTransform = None, Offset1 = None, Offset2 = None, CSys = None, ItemType = None):
        """
This function assigns frame object insertion point data. The assignments include the cardinal point and end joint offsets.
The function returns zero if the insertion point data is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
CardinalPoint: This is a numeric value from 1 to 11 that specifies the cardinal point for the frame object. The cardinal point specifies the relative position of the frame section on the line representing the frame object.
1 = bottom left
2 = bottom center
3 = bottom right
4 = middle left
5 = middle center
6 = middle right
7 = top left
8 = top center
9 = top right
10 = centroid
11 = shear center
Mirror2: If this item is True, the frame object section is assumed to be mirrored (flipped) about its local 2-axis.
StiffTransform: If this item is True, the frame object stiffness is transformed for cardinal point and joint offsets from the frame section centroid.
Offset1: This is an array of three joint offset distances, in the coordinate directions specified by CSys, at the I-End of the frame object. [L]
Offset1(0) = Offset in the 1-axis or X-axis direction
Offset1(1) = Offset in the 2-axis or Y-axis direction
Offset1(2) = Offset in the 3-axis or Z-axis direction
Offset2: This is an array of three joint offset distances, in the coordinate directions specified by CSys, at the J-End of the frame object. [L]
Offset2(0) = Offset in the 1-axis or X-axis direction
Offset2(1) = Offset in the 2-axis or Y-axis direction
Offset2(2) = Offset in the 3-axis or Z-axis direction
CSys: This is Local or the name of a defined coordinate system. It is the coordinate system in which the Offset1 and Offset2 items are specified.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, CardinalPoint, Mirror2, StiffTransform, Offset1, Offset2, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetInsertionPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetInsertionPoint" failed')
        
        return ret

    def SetLateralBracing(self, Name = None, MyType = None, Loc = None, MyDist1 = None, MyDist2 = None, RelDist = None, ItemType = None):
        """
This function assigns a lateral bracing location to frame objects.
The function returns zero if the location is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
MyType: This is 1 or 2, indicating the bracing type assigned.
1 = Point bracing
2 = Uniform bracing
Loc: This is 1, 2 or 3, indicating the bracing location.
1 = Top
2 = Bottom
3 = All (top and bottom)
MyDist1: When MyType = 1 this is the location of the point bracing.
When MyType = 2 this is the location of the start of the uniform bracing. [L] when RelDist = False
MyDist2: This item is not used when MyType = 1.
When MyType = 2 this is the location of the end of the uniform bracing. [L] when RelDist = False
RelDist: If this item is True, MyDist1 and MyDist2 are relative distances; otherwise they are actual distances.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, MyType, Loc, MyDist1, MyDist2, RelDist, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetLateralBracing(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLateralBracing" failed')
        
        return ret

    def SetLoadDeformation(self, Name = None, LoadPat = None, DOF = None, d = None, ItemType = None):
        """
This function assigns deformation loads to frame objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
DOF: This is a array of boolean values indicating if the considered degree of freedom has a deformation load.
DOF(1) = U1
DOF(2) = U2
DOF(3) = U3
DOF(4) = R1
DOF(5) = R2
DOF(6) = R3
d: This is a array of deformation load values. The deformations specified for a given degree of freedom are applied only if the corresponding DOF item for that degree of freedom is True.
d(1) = U1 deformation [L]
d(2) = U2 deformation [L]
d(3) = U3 deformation [L]
d(4) = R1 deformation [rad]
d(5) = R2 deformation [rad]
d(6) = R3 deformation [rad]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, LoadPat, DOF, d, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadDeformation" failed')
        
        return ret

    def SetLoadDistributed(self, Name = None, LoadPat = None, MyType = None, Dir = None, Dist1 = None, Dist2 = None, Val1 = None, Val2 = None, CSys = None, RelDist = None, Replace = None, ItemType = None):
        """
This function assigns distributed loads to frame objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
MyType: This is 1 or 2, indicating the type of distributed load.
1 = Force per unit length
2 = Moment per unit length
Dir: This is an integer between 1 and 11, indicating the direction of the load.
1 = Local 1 axis (only applies when CSys is Local)
2 = Local 2 axis (only applies when CSys is Local)
3 = Local 3 axis (only applies when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
7 = Projected X direction (does not apply when CSys is Local)
8 = Projected Y direction (does not apply when CSys is Local)
9 = Projected Z direction (does not apply when CSys is Local)
10 = Gravity direction (only applies when CSys is Global)
11 = Projected Gravity direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) is in the negative Global Z direction.
Dist1: This is the distance from the I-End of the frame object to the start of the distributed load. This may be a relative distance (0 <= Dist1 <= 1) or an actual distance, depending on the value of the RelDist item. [L] when RelDist is False
Dist2: This is the distance from the I-End of the frame object to the end of the distributed load. This may be a relative distance (0 <= Dist2 <= 1) or an actual distance, depending on the value of the RelDist item. [L] when RelDist is False
Val1: This is the load value at the start of the distributed load. [F/L] when MyType is 1 and [FL/L] when MyType is 2
Val2: This is the load value at the end of the distributed load. [F/L] when MyType is 1 and [FL/L] when MyType is 2
CSys: This is Local or the name of a defined coordinate system. It is the coordinate system in which the loads are specified.
RelDist: If this item is True, the specified Dist item is a relative distance, otherwise it is an actual distance.
Replace: If this item is True, all previous distributed loads, if any, assigned to the specified frame object(s), in the specified load pattern, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, MyType, Dir, Dist1, Dist2, Val1, Val2, CSys, RelDist, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetLoadDistributed(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadDistributed" failed')
        
        return ret

    def SetLoadGravity(self, Name = None, LoadPat = None, x = None, y = None, z = None, Replace = None, CSys = None, ItemType = None):
        """
This function assigns gravity load multipliers to frame objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
x: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
Replace: If this item is True, all previous gravity loads, if any, assigned to the specified frame object(s), in the specified load pattern, are deleted before making the new assignment.
CSys: The coordinate system in which the x, y and z multipliers are specified.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, x, y, z, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadGravity" failed')
        
        return ret

    def SetLoadPoint(self, Name = None, LoadPat = None, MyType = None, Dir = None, Dist = None, Val = None, CSys = None, RelDist = None, Replace = None, ItemType = None):
        """
This function assigns point loads to frame objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
MyType: This is 1 or 2, indicating the type of point load.
1 = Force
2 = Moment
Dir: This is an integer between 1 and 11, indicating the direction of the load.
1 = Local 1 axis (only applies when CSys is Local)
2 = Local 2 axis (only applies when CSys is Local)
3 = Local 3 axis (only applies when CSys is Local)
4 = X direction (does not apply when CSys is Local)
5 = Y direction (does not apply when CSys is Local)
6 = Z direction (does not apply when CSys is Local)
7 = Projected X direction (does not apply when CSys is Local)
8 = Projected Y direction (does not apply when CSys is Local)
9 = Projected Z direction (does not apply when CSys is Local)
10 = Gravity direction (only applies when CSys is Global)
11 = Projected Gravity direction (only applies when CSys is Global)

The positive gravity direction (see Dir = 10 and 11) is in the negative Global Z direction.
Dist: This is the distance from the I-End of the frame object to the load location. This may be a relative distance (0 <= Dist <= 1) or an actual distance, depending on the value of the RelDist item. [L] when RelDist is False
Val: This is the value of the point load. [F] when MyType is 1 and [FL] when MyType is 2
CSys: This is Local or the name of a defined coordinate system. It is the coordinate system in which the loads are specified.
RelDist: If this item is True, the specified Dist item is a relative distance, otherwise it is an actual distance.
Replace: If this item is True, all previous loads, if any, assigned to the specified frame object(s), in the specified load pattern, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, MyType, Dir, Dist, Val, CSys, RelDist, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetLoadPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadPoint" failed')
        
        return ret

    def SetLoadStrain(self, Name = None, LoadPat = None, DOF = None, Val = None, Replace = None, PatternName = None, ItemType = None):
        """
This function assigns strain loads to frame objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
DOF: This is 1, 2, 3, 4, 5 or 6, indicating the degree of freedom to which the strain load is applied.
1 = Strain11
2 = Strain12
3 = Strain13
4 = Curvature1
5 = Curvature2
6 = Curvature3
Val: This is the strain load value. [L/L] for DOF = 1, 2 and 3 and [1/L] for DOF = 4, 5 and 6
Replace: If this item is True, all previous strain loads, if any, assigned to the specified frame object(s), in the specified load pattern, for the specified degree of freedom, are deleted before making the new assignment.
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the strain load for the frame object is uniform along the object at the value specified by Val.
If PatternName is the name of a defined joint pattern, the strain load for the frame object is based on the specified strain value multiplied by the pattern value at the joints at each end of the frame object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, DOF, Val, Replace, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadStrain" failed')
        
        return ret

    def SetLoadTargetForce(self, Name = None, LoadPat = None, DOF = None, f = None, RD = None, ItemType = None):
        """
This function assigns target forces to frame objects.
The function returns zero if the target forces are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
DOF: This is a array of boolean values indicating if the considered degree of freedom has a target force.
DOF(1) = P
DOF(2) = V2
DOF(3) = V3
DOF(4) = T
DOF(5) = M2
DOF(6) = M3
f: This is a array of target force values. The target forces specified for a given degree of freedom are applied only if the corresponding DOF item for that degree of freedom is True.
f(1) = P [F]
f(2) = V2 [F]
f(3) = V3 [F]
f(4) = T [FL]
f(5) = M2 [FL]
f(6) = M3 [FL]
RD: This is a array of relative distances along the frame objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True. The relative distance must be between 0 and 1, 0 <= RD <=1.
RD(1) = relative location for P target force
RD(2) = relative location for V2 target force
RD(3) = relative location for V3 target force
RD(4) = relative location for T target force
RD(5) = relative location for M2 target force
RD(6) = relative location for M3 target force
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, DOF, f, RD, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetLoadTargetForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadTargetForce" failed')
        
        return ret

    def SetLoadTemperature(self, Name = None, LoadPat = None, MyType = None, Val = None, PatternName = None, Replace = None, ItemType = None):
        """
This function assigns temperature loads to frame objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
MyType: This is 1, 2 or 3, indicating the type of temperature load.
1 = Temperature
2 = Temperature gradient along local 2 axis
3 = Temperature gradient along local 3 axis
Val: This is the temperature change value. [T] for MyType = 1 and [T/L] for MyType = 2 and 3
PatternName: This is blank or the name of a defined joint pattern. If it is blank the temperature load for the frame object is uniform along the object at the value specified by Val.
If PatternName is the name of a defined joint pattern, the temperature load for the frame object is based on the specified temperature value multiplied by the pattern value at the joints at each end of the frame object.
Replace: If this item is True, all previous temperature loads, if any, assigned to the specified frame object(s), in the specified load case, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, MyType, Val, PatternName, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadTemperature" failed')
        
        return ret

    def SetLoadTransfer(self, Name = None, Val = None):
        """
This function returns the load transfer option for frame objects.  It indicates whether the frame receives load from an area object when the area object is loaded with a load of type uniform to frame.
The function returns zero if the load transfer option is successfully returned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Val: This boolean value indicates if load is allowed to be transferred from area objects to this frame object.
ItemType
This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2
If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Val]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetLoadTransfer(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadTransfer" failed')
        
        return ret

    def SetLocalAxesAdvanced(self, Name = None, Active = None, Plane2 = None, PlVectOpt = None, PlCSys = None, PlDir = None, PlPt = None, PlVect = None, ItemType = None):
        """
This function assigns advanced local axes to frame objects.
The function returns zero if the advanced local axes assignments are assigned successfully; otherwise it returns a nonzero value.

Name: The name of an existing frame object or group depending on the value of the ItemType item.
Active: This is True if advanced local axes exist.
Plane2: This is 12 or 13, indicating that the local plane determined by the plane reference vector is the 1-2 plane or the 1-3 plane. This item applies only when the Active item is True.
PlVectOpt: This is 1, 2, or 3, indicating the plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
PlCSys: The coordinate system used to define the plane reference vector coordinate directions and the plane user vector. This item applies when the Active item is True and the PlVectOpt item is 1 or 3.
PlDir: This is an array dimensioned to 1 (2 integers), indicating the plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
PlPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the PlVectOpt item is 2.
PlVect: This is an array dimensioned to 2 (3 doubles) that defines the plane reference vector. This item applies when the Active item is True and the PlVectOpt item is 3.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
Selection = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is Selection, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Active, Plane2, PlVectOpt, PlCSys, PlDir, PlPt, PlVect, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetLocalAxesAdvanced(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxesAdvanced" failed')
        
        return ret

    def SetLocalAxes(self, Name = None, Ang = None, ItemType = None):
        """
This function assigns a local axis angle to frame objects.
The function returns zero if the local axis angle is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Ang: This is the angle that the local 2 and 3 axes are rotated about the positive local 1 axis, from the default orientation or, if the Advanced item is True, from the orientation determined by the plane reference vector. The rotation for a positive angle appears counter clockwise when the local +1 axis is pointing toward you. [deg]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Ang, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxes" failed')
        
        return ret

    def SetMass(self, Name = None, MassOverL = None, Replace = None, ItemType = None):
        """
This function assigns mass per unit length to frame objects.
The function returns zero if the mass is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
MassOverL: The mass per unit length assigned to the frame object. [M/L]
Replace: If this item is True, all existing mass assignments to the frame object are removed before assigning the specified mas. If it is False, the specified mass is added to any existing mass already assigned to the frame object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, MassOverL, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMass" failed')
        
        return ret

    def SetMaterialOverwrite(self, Name = None, PropName = None, ItemType = None):
        """
This function sets the material overwrite assignment for frame objects.
The function returns zero if the material overwrite assignment is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
PropName: This is None or a blank string, indicating that any existing material overwrites assigned to the specified frame objects are to be removed, or it is the name of an existing material property.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetMaterialOverwrite(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMaterialOverwrite" failed')
        
        return ret

    def SetMatTemp(self, Name = None, Temp = None, PatternName = None, ItemType = None):
        """
This function assigns material temperatures to frame objects.
The function returns zero if the material temperatures are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Temp: This is the material temperature value assigned to the frame object. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the frame object is uniform along the object at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the frame object may vary from one end to the other. The material temperature at each end of the object is equal to the specified temperature multiplied by the pattern value at the joint at the end of the frame object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, Temp, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMatTemp" failed')
        
        return ret

    def SetModifiers(self, Name = None, Value = None, ItemType = None):
        """
This function sets the frame modifier assignment for frame objects. The default value for all modifiers is one.
The function returns zero if the modifier assignments are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
Value: This is an array of eight unitless modifiers.
Value(0) = Cross sectional area modifier
Value(1) = Shear area in local 2 direction modifier
Value(2) = Shear area in local 3 direction modifier
Value(3) = Torsional constant modifier
Value(4) = Moment of inertia about local 2 axis modifier
Value(5) = Moment of inertia about local 3 axis modifier
Value(6) = Mass modifier
Value(7) = Weight modifier

ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetModifiers(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetModifiers" failed')
        
        return ret

    def SetOutputStations(self, Name = None, MyType = None, MaxSegSize = None, MinSections = None, NoOutPutAndDesignAtElementEnds = None, NoOutPutAndDesignAtPointLoads = None, ItemType = None):
        """
This function assigns frame object output station data.
The function returns zero if the data is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
MyType: This is 1 or 2, indicating how the output stations are specified.
1 = maximum segment size, that is, maximum station spacing
2 = minimum number of stations
MaxSegSize: The maximum segment size, that is, the maximum station spacing. This item applies only when MyType = 1. [L]
MinSections: The minimum number of stations. This item applies only when MyType = 2.
NoOutPutAndDesignAtElementEnds: If this item is True, no additional output stations are added at the ends of line elements when the frame object is internally meshed.
NoOutPutAndDesignAtPointLoads: If this item is True, no additional output stations are added at point load locations.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects and the Name item is ignored.
        """

        all_args = [Name, MyType, MaxSegSize, MinSections, NoOutPutAndDesignAtElementEnds, NoOutPutAndDesignAtPointLoads, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetOutputStations(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetOutputStations" failed')
        
        return ret

    def SetPDeltaForce(self, Name = None, PDeltaForce = None, Dir = None, Replace = None, CSys = None, ItemType = None):
        """
This function assigns P-Delta forces to straight frame objects. P-Delta force assignments do not apply to curved frames.
The function returns zero if the assignments are successfully applied, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
PDeltaForce: The P-Delta force assigned to the frame object. [F]
Dir: This is 0, 1, 2 or 3, indicating the direction of the P-Delta force assignment.
0 = Frame object local 1-axis direction
1 = Projected X direction in CSys coordinate system
2 = Projected Y direction in CSys coordinate system
3 = Projected Z direction in CSys coordinate system
Replace: If this item is True, all existing P-Delta force assignments to the frame object are removed before assigning the specified P-Delta force. If it is False, the specified P-Delta force is added to any existing P-Delta forces already assigned to the frame object.
CSys: This is the name of the coordinate system in which the projected X, Y or Z direction P-Delta forces are defined. This item does not apply if the Dir item is zero (frame object local 1-axis direction).
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, PDeltaForce, Dir, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetPDeltaForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPDeltaForce" failed')
        
        return ret

    def SetReleases(self, Name = None, ii = None, jj = None, StartValue = None, EndValue = None, ItemType = None):
        """
This function makes end release and partial fixity assignments to frame objects.
The function returns zero if the assignments are successfully retrieved, otherwise it returns a nonzero value.
Partial fixity assignments are made to degrees of freedom that have been released only.
Some release assignments would cause instability in the model. An error is returned if this type of assignment is made. Unstable release assignments include the following:
U1 released at both ends
U2 released at both ends
U3 released at both ends
R1 released at both ends
R2 released at both ends and U3 at either end
R3 released at both ends and U2 at either end

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
ii: These are arrays of six booleans indicating the I-End and J-End releases for the frame object.
ii(0) and jj(0) = U1 release
ii(1) and jj(1) = U2 release
ii(2) and jj(2) = U3 release
ii(3) and jj(3) = R1 release
ii(4) and jj(4) = R2 release
ii(5) and jj(5) = R3 release

jj: These are arrays of six booleans indicating the I-End and J-End releases for the frame object.
ii(0) and jj(0) = U1 release
ii(1) and jj(1) = U2 release
ii(2) and jj(2) = U3 release
ii(3) and jj(3) = R1 release
ii(4) and jj(4) = R2 release
ii(5) and jj(5) = R3 release

StartValue: These are arrays of six values indicating the I-End and J-End partial fixity springs for the frame object.
StartValue(0) and EndValue(0) = U1 partial fixity [F/L]
StartValue(1) and EndValue(1) = U2 partial fixity [F/L]
StartValue(2) and EndValue(2) = U3 partial fixity [F/L]
StartValue(3) and EndValue(3) = R1 partial fixity [FL/rad]
StartValue(4) and EndValue(4) = R2 partial fixity [FL/rad]
StartValue(5) and EndValue(5) = R3 partial fixity [FL/rad]
EndValue: These are arrays of six values indicating the I-End and J-End partial fixity springs for the frame object.
StartValue(0) and EndValue(0) = U1 partial fixity [F/L]
StartValue(1) and EndValue(1) = U2 partial fixity [F/L]
StartValue(2) and EndValue(2) = U3 partial fixity [F/L]
StartValue(3) and EndValue(3) = R1 partial fixity [FL/rad]
StartValue(4) and EndValue(4) = R2 partial fixity [FL/rad]
StartValue(5) and EndValue(5) = R3 partial fixity [FL/rad]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, ii, jj, StartValue, EndValue, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetReleases(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetReleases" failed')
        
        return ret

    def SetSection(self, Name = None, PropName = None, ItemType = None, sVarTotalLength = None, sVarRelStartLoc = None):
        """
This function assigns a frame section property to a frame object.
The function returns zero if the frame section property data is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
PropName: This is None or the name of a frame section property to be assigned to the specified frame object(s).
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
sVarTotalLength: This is the total assumed length of the nonprismatic section. Enter 0 for this item to indicate that the section length is the same as the frame object length.
This item is applicable only when the assigned frame section property is a nonprismatic section.
sVarRelStartLoc: This is the relative distance along the nonprismatic section to the I-End (start) of the frame object. This item is ignored when the sVarTotalLengthitem is 0.
This item is applicable only when the assigned frame section property is a nonprismatic section, and the sVarTotalLengthitem is greater than zero.
        """

        all_args = [Name, PropName, ItemType, sVarTotalLength, sVarRelStartLoc]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetSection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSection" failed')
        
        return ret

    def SetSpring(self, Name = None, MyType = None, s = None, SimpleSpringType = None, LinkProp = None, SpringLocalOneType = None, Dir = None, Plane23Angle = None, Vec = None, Ang = None, Replace = None, CSys = None, ItemType = None):
        """
This function makes spring assignments to frame objects.
The function returns zero if the assignments are successfully applied, otherwise it returns a nonzero value.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
MyType: This is 1 or 2, indicating the spring property type.
1 = Simple spring
2 = Link property
s: The simple spring stiffness per unit length of the frame object. This item applies only when MyType = 1. [F/L2]
SimpleSpringType: This is 1, 2 or 3, indicating the simple spring type. This item applies only when MyType = 1.
1 = Spring resists tension and compression
2 = Spring resists compression only
3 = Spring resists tension only
LinkProp: The name of the link property assigned to the spring. This item applies only when MyType = 2.
SpringLocalOneType: This is 1, 2 or 3, indicating the method used to specify the spring positive local 1-axis orientation.
1 = Parallel to frame object local axis
2 = In the frame object 2-3 plane
3 = User specified direction vector
Dir: This is 1, 2, 3, -1, -2 or -3, indicating the frame object local axis that corresponds to the positive local 1-axis of the spring. This item applies only when SpringLocalOneType = 1.
Plane23Angle: This is the angle in the frame object 2-3 plane measured counter clockwise from the frame positive 2-axis to the spring positive 1-axis. This item applies only when SpringLocalOneType = 2. [deg]
Vec: This is an array of three values that define the direction vector of the spring positive local 1-axis. The direction vector is in the coordinate system specified by the CSys item. This item applies only when SpringLocalOneType = 3.
Ang: This is the angle that the link local 2-axis is rotated from its default orientation. This item applies only when MyType = 2. [deg]
Replace: If this item is True, all existing spring assignments to the frame object are removed before assigning the specified spring. If it is False, the specified spring is added to any existing springs already assigned to the frame object.
CSys: This is Local (meaning the frame object local coordinate system) or the name of a defined coordinate system. This item is the coordinate system in which the user specified direction vector, Vec, is specified. This item applies only when SpringLocalOneType = 3.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, MyType, s, SimpleSpringType, LinkProp, SpringLocalOneType, Dir, Plane23Angle, Vec, Ang, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSpring" failed')
        
        return ret

    def SetStraight(self, Name = None):
        """
This function sets a curved frame object straight.
The function returns zero if the frame object type is successfully set, otherwise it returns a nonzero value.

Name: The name of a defined curved frame object.
        """

        all_args = [Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetStraight(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetStraight" failed')
        
        return ret

    def SetTCLimits(self, Name = None, LimitCompressionExists = None, LimitCompression = None, LimitTensionExists = None, LimitTension = None, ItemType = None):
        """
This function makes tension/compression force limit assignments to frame objects.
The function returns zero if the assignments are successfully applied, otherwise it returns a nonzero value.
Note that the tension and compression limits are only used in nonlinear analyses.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
LimitCompressionExists: This item is True if a compression force limit exists for the frame object.
LimitCompression: The compression force limit for the frame object. [F]
LimitTensionExists: This item is True if a tension force limit exists for the frame object.
LimitTension: The tension force limit for the frame object. [F]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, LimitCompressionExists, LimitCompression, LimitTensionExists, LimitTension, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetTCLimits(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTCLimits" failed')
        
        return ret

    def GetCurved(self, NumberItems = None, MyType = None, gx = None, gy = None, gz = None, PointName = None, Radius = None, NumSegs = None):
        """
This function retrieves definition data for all curved frame objects and returns the data in arrays.
The function returns zero if the curved frame object data is successfully retrieved, otherwise it returns a nonzero value.

NumberItems: The number of curved frame objects returned.
MyType: This is an array that includes a numeric value indicating the curved frame type. The type is 1, 2, 3, 4, or 5.
1 = Circular Arc Specified by a Third Point Name
2 = Circular Arc Specified by Third Point Coordinates
3 = Circular Arc Specified by Planar Point Coordinates and Radius
4 = Parabolic Arc Specified by a Third Point Name
5 = Parabolic Arc Specified by Third Point Coordinates

MyTypes 1, 2, 4, and 5 all define the curve by three points. The three points are the two end point of the frame object and a third point defined by naming an existing point object or specifying point coordinates.
MyType 3 defines a circular curved frame by it end points, the coordinates of another point that lies in the plane of the curve but not necessarily on the curved frame, and a curve radius.
gx: These are arrays that include the point coordinates in the global coordinate system. [L]
For MyType 1 and 4 these items do not apply.
For MyType 2 and 5 these are the coordinates of the third point on the curved frame.
For MyType 3 these are the coordinates of the planar point that lies in the plane of the curved frame.
gy: These are arrays that include the point coordinates in the global coordinate system. [L]
For MyType 1 and 4 these items do not apply.
For MyType 2 and 5 these are the coordinates of the third point on the curved frame.
For MyType 3 these are the coordinates of the planar point that lies in the plane of the curved frame.
gz: These are arrays that include the point coordinates in the global coordinate system. [L]
For MyType 1 and 4 these items do not apply.
For MyType 2 and 5 these are the coordinates of the third point on the curved frame.
For MyType 3 these are the coordinates of the planar point that lies in the plane of the curved frame.
PointName: This is an array that includes the name of the point object that is the third point on the curved frame. This item applies for MyType 1 and 4. It does not apply for MyType 2, 3 and 5.
Radius: This is an array of the radii of the circular curved frame. This item only applies for MyType 3. [L]
NumSegs: This is an array that includes the number of segments into which the program internally divides the curved frame.
        """

        all_args = [NumberItems, MyType, gx, gy, gz, PointName, Radius, NumSegs]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetCurved(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCurved" failed')
        
        return ret

    def GetFireproofing(self, Name = None, MyType = None, Thickness = None, Perimeter = None, Density = None, tf = None):
        """
This function retrieves the fireproofing assignments to frame objects.
The function returns zero if the fireproofing assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing frame object.
MyType: This is 1, 2 or 3, indicating the type of fireproofing assigned.
1 = Sprayed on - program calculate section perimeter
2 = Sprayed on - user provides section perimeter
3 = Concrete encased
Thickness: When MyType = 1 or MyType = 2 this is the thickness of the sprayed on fireproofing. When MyType = 3 this is the concrete cover dimension. [L]
Perimeter: This item applies only when MyType = 2. It is the length of fireproofing applied measured around the perimeter of the frame object cross-section. [L]
Density: This is the weight per unit volume of the fireproofing material. [F/L3]
tf: This item applies only when MyType = 1 or MyType = 3. If this item is True, the fireproofing is assumed to be applied to the top flange of the section. If it is False, the program assumes no fireproofing is applied to the section top flange. This flag applies for I, channel and double channel sections.
        """

        all_args = [Name, MyType, Thickness, Perimeter, Density, tf]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.GetFireproofing(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetFireproofing" failed')
        
        return ret

    def SetFireproofing(self, Name = None, MyType = None, Thickness = None, Perimeter = None, Density = None, tf = None, ItemType = None):
        """
This function assigns fireproofing to frame objects.
The function returns zero if the fireproofing assignments are successfully assigned, otherwise it returns a nonzero value.
The program automatically adds the load *(weight) calculated for the fireproofing to all load patterns that include self weight.

Name: The name of an existing frame object or group, depending on the value of the ItemType item.
MyType: This is 1, 2 or 3, indicating the type of fireproofing assigned.
1 = Sprayed on - program calculate section perimeter
2 = Sprayed on - user provides section perimeter
3 = Concrete encased
Thickness: When MyType = 1 or MyType = 2, this is the thickness of the sprayed on fireproofing. When MyType = 3, this is the concrete cover dimension. [L]
Perimeter: This item applies only when MyType = 2. It is the length of fireproofing applied, measured around the perimeter of the frame object cross-section. [L]
Density: This is the weight per unit volume of the fireproofing material. [F/L3]
tf: This item applies only when MyType = 1 or MyType = 3. If this item is True, the fireproofing is assumed to be applied to the top flange of the section. If it is False, the program assumes no fireproofing is applied to the section top flange. This flag applies for I, channel and double channel sections.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the frame object specified by the Name item.
If this item is Group, the assignment is made to all frame objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected frame objects, and the Name item is ignored.
        """

        all_args = [Name, MyType, Thickness, Perimeter, Density, tf, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.FrameObj.SetFireproofing(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetFireproofing" failed')
        
        return ret

class LinkObj:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def AddByCoord(self, xi = None, yi = None, zi = None, xj = None, yj = None, zj = None, Name = None, IsSingleJoint = None, PropName = None, UserName = None, CSys = None):
        """
This function adds a new link object whose end points are at the specified coordinates.
The function returns zero if the link object is successfully added; otherwise it returns a nonzero value.

xi: The coordinates of the I-End of the added link object. The coordinates are in the coordinate system defined by the CSys item.
yi: The coordinates of the I-End of the added link object. The coordinates are in the coordinate system defined by the CSys item.
zi: The coordinates of the I-End of the added link object. The coordinates are in the coordinate system defined by the CSys item.
xj: The coordinates of the J-End of the added link object. The coordinates are in the coordinate system defined by the CSys item.
These coordinates are ignored if the IsSingleJoint item is True.
yj: The coordinates of the J-End of the added link object. The coordinates are in the coordinate system defined by the CSys item.
These coordinates are ignored if the IsSingleJoint item is True.
zj: The coordinates of the J-End of the added link object. The coordinates are in the coordinate system defined by the CSys item.
These coordinates are ignored if the IsSingleJoint item is True.
Name: This is the name that the program ultimately assigns for the link object. If no UserName is specified, the program assigns a default name to the link object. If a UserName is specified and that name is not used for another link object, the UserName is assigned to the link object; otherwise a default name is assigned to the link object.
IsSingleJoint: This item is True if a one-joint link is added and False if a two-joint link is added.
PropName: This is either Default or the name of a defined link property.
If it is Default the program assigns a default link property to the link object. If it is the name of a defined link property, that property is assigned to the link object.
UserName: This is an optional user specified name for the link object. If a UserName is specified and that name is already used for another link object, the program ignores the UserName.
CSys: The name of the coordinate system in which the link object end point coordinates are defined.
        """

        all_args = [xi, yi, zi, xj, yj, zj, Name, IsSingleJoint, PropName, UserName, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.AddByCoord(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddByCoord" failed')
        
        return ret

    def AddByPoint(self, Point1 = None, Point2 = None, Name = None, IsSingleJoint = None, PropName = None, UserName = None):
        """
This function adds a new link object whose end points are specified by name.
The function returns zero if the link object is successfully added; otherwise it returns a nonzero value.

Point1: The name of a defined point object at the I-End of the added link object.
Point2: The name of a defined point object at the J-End of the added link object.
This item is ignored if the IsSingleJoint item is True.
Name: This is the name that the program ultimately assigns for the link object. If no UserName is specified, the program assigns a default name to the link object. If a UserName is specified and that name is not used for another link object, the UserName is assigned to the link object; otherwise a default name is assigned to the link object.
IsSingleJoint: This item is True if a one-joint link is added and False if a two-joint link is added.
PropName: This is either Default or the name of a defined link property.
If it is Default the program assigns a default link property to the link object. If it is the name of a defined link property, that property is assigned to the link object.
UserName: This is an optional user specified name for the link object. If a UserName is specified and that name is already used for another link object, the program ignores the UserName.
        """

        all_args = [Point1, Point2, Name, IsSingleJoint, PropName, UserName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.AddByPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddByPoint" failed')
        
        return ret

    def ChangeName(self, Name = None, NewName = None):
        """
This function applies a new name to an link object.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined link object.
NewName: The new name for the link object.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns a count of the link objects in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def DeleteLoadDeformation(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the deformation load assignments to the specified link objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the link object specified by the Name item.
If this item is Group, the load assignments are deleted for all link objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.DeleteLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadDeformation" failed')
        
        return ret

    def DeleteLoadGravity(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the gravity load assignments to the specified link objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the link object specified by the Name item.
If this item is Group, the load assignments are deleted for all link objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.DeleteLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadGravity" failed')
        
        return ret

    def DeleteLoadTargetForce(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the target force assignments to the specified link objects for the specified load pattern.
The function returns zero if the target force assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the link object specified by the Name item.
If this item is Group, the load assignments are deleted for all link objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.DeleteLoadTargetForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadTargetForce" failed')
        
        return ret

    def Delete(self, Name = None, ItemType = None):
        """
The function deletes link objects.
The function returns zero if the link objects are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the link object specified by the Name item is deleted.
If this item is Group, the all link objects in the group specified by the Name item are deleted.
If this item is SelectedObjects, all selected link objects are deleted, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetElm(self, Name = None, Elm = None):
        """
This function retrieves the name of the link element (analysis model link) associated with a specified link object in the object-based model.
This function returns zero if the link element name is successfully retrieved; otherwise it returns nonzero. An error occurs if the analysis model does not exist.

Name: The name of an existing link object.
Elm: The name of the link element created from the specified link object.
        """

        all_args = [Name, Elm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.GetElm(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetElm" failed')
        
        return ret

    def GetGroupAssign(self, Name = None, NumberGroups = None, Groups = None):
        """
This function retrieves the names of the groups to which a specified link object is assigned.
The function returns zero if the group assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing link object.
NumberGroups: The number of group names retrieved.
Groups: The names of the groups to which the link object is assigned.
        """

        all_args = [Name, NumberGroups, Groups]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.GetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGroupAssign" failed')
        
        return ret

    def GetGUID(self, Name = None, GUID = None):
        """
This function retrieves the GUID for the specified link object.
This function returns zero if the link object GUID is successfully retrieved; otherwise it returns nonzero.

Name: The name of an existing link object.
GUID: The GUID (Global Unique ID) for the specified link object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.GetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGUID" failed')
        
        return ret

    def GetLoadDeformation(self, Name = None, NumberItems = None, LinkName = None, LoadPat = None, dof1 = None, dof2 = None, dof3 = None, dof4 = None, dof5 = None, dof6 = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None, ItemType = None):
        """
This function retrieves the deformation load assignments to link objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
NumberItems: The total number of deformation loads retrieved for the specified link objects.
LinkName: This is an array that includes the name of the link object associated with each deformation load.
LoadPat: This is an array that includes the name of the load pattern associated with each deformation load.
dof1: These are arrays of boolean values, indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof2: These are arrays of boolean values, indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof3: These are arrays of boolean values, indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof4: These are arrays of boolean values, indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof5: These are arrays of boolean values, indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
dof6: These are arrays of boolean values, indicating if the considered degree of freedom has a deformation load.
dof1 = U1
dof2 = U2
dof3 = U3
dof4 = R1
dof5 = R2
dof6 = R3
U1: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
U2: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
U3: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
R1: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
R2: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
R3: These are arrays of deformation load values. The deformations specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the link object specified by the Name item.
If this item is Group, the assignments are retrieved for all link objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LinkName, LoadPat, dof1, dof2, dof3, dof4, dof5, dof6, U1, U2, U3, R1, R2, R3, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.GetLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadDeformation" failed')
        
        return ret

    def GetLoadGravity(self, Name = None, NumberItems = None, LinkName = None, LoadPat = None, CSys = None, x = None, y = None, z = None, ItemType = None):
        """
This function retrieves the gravity load assignments to link objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
NumberItems: The total number of gravity loads retrieved for the specified link objects.
LinkName: This is an array that includes the name of the link object associated with each gravity load.
LoadPat: This is an array that includes the name of the coordinate system in which the gravity load multipliers are specified.
CSys: This is an array that includes the name of the coordinate system associated with each gravity load.
x: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the link object specified by the Name item.
If this item is Group, the assignments are retrieved for all link objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LinkName, LoadPat, CSys, x, y, z, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.GetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadGravity" failed')
        
        return ret

    def GetLoadTargetForce(self, Name = None, NumberItems = None, LinkName = None, LoadPat = None, dof1 = None, dof2 = None, dof3 = None, dof4 = None, dof5 = None, dof6 = None, P = None, V2 = None, V3 = None, T = None, M2 = None, M3 = None, T1 = None, T2 = None, T3 = None, T4 = None, T5 = None, T6 = None, ItemType = None):
        """
This function retrieves the target force assignments to link objects.
The function returns zero if the target force assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
NumberItems: The total number of deformation loads retrieved for the specified link objects.
LinkName: This is an array that includes the name of the link object associated with each target force.
LoadPat: This is an array that includes the name of the load pattern associated with each target force.
dof1: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof2: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof3: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof4: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof5: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
dof6: These are arrays of boolean values indicating if the considered degree of freedom has a target force assignment.
dof1 = P
dof2 = V2
dof3 = V3
dof4 = T
dof5 = M2
dof6 = M3
P: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
V2: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
V3: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
T: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
M2: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
M3: These are arrays of target force values. The target forces specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True.
U1 = U1 deformation [L]
U2 = U2 deformation [L]
U3 = U3 deformation [L]
R1 = R1 deformation [rad]
R2 = R2 deformation [rad]
R3 = R3 deformation [rad]
T1: These are arrays of the relative distances along the link objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T2: These are arrays of the relative distances along the link objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T3: These are arrays of the relative distances along the link objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T4: These are arrays of the relative distances along the link objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T5: These are arrays of the relative distances along the link objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
T6: These are arrays of the relative distances along the link objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding dofn item for that degree of freedom is True.
T1 = relative location for P target force
T2 = relative location for V2 target force
T3 = relative location for V3 target force
T4 = relative location for T target force
T5 = relative location for M2 target force
T6 = relative location for M3 target force
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the link object specified by the Name item.
If this item is Group, the assignments are retrieved for all link objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, LinkName, LoadPat, dof1, dof2, dof3, dof4, dof5, dof6, P, V2, V3, T, M2, M3, T1, T2, T3, T4, T5, T6, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.GetLoadTargetForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTargetForce" failed')
        
        return ret

    def GetLocalAxesAdvanced(self, Name = None, Active = None, AxVectOpt = None, PlVectOpt = None, AxCSys = None, PlCSys = None, AxDir = None, PlDir = None, AxPt = None, PlPt = None, AxVect = None, PlVect = None, Plane2 = None):
        """
This function assigns advanced local axes to link objects.
The function returns zero if the advanced local axes assignments are assigned successfully; otherwise it returns a nonzero value.

Name: The name of an existing link object.
Active: This is True if advanced local axes exist.
AxVectOpt: This is 1, 2, or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
PlVectOpt: This is 1, 2, or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
AxCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
PlCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
AxDir: This is an array dimensioned to 1 (2 integers), indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
PlDir: This is an array dimensioned to 1 (2 integers), indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
AxPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
PlPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
AxVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
PlVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
Plane2: This is 12 or 13, indicating that the local plane determined by the plane reference vector is the 1-2 or 1-3 plane. This item applies only when the Active item is True.
        """

        all_args = [Name, Active, AxVectOpt, PlVectOpt, AxCSys, PlCSys, AxDir, PlDir, AxPt, PlPt, AxVect, PlVect, Plane2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.GetLocalAxesAdvanced(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxesAdvanced" failed')
        
        return ret

    def GetLocalAxes(self, Name = None, Ang = None, Advanced = None):
        """
This function retrieves the local axis angle assignment for link objects.
The function returns zero if the assignment is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing link object.
Ang: This is the angle that the local 2 and 3 axes are rotated about the positive local 1 axis, from the default orientation or, if the Advanced item is True, from the orientation determined by the plane reference vector. The rotation for a positive angle appears counter clockwise when the local +1 axis is pointing toward you. [deg]
Advanced: This item is True if the link object local axes orientation was obtained using advanced local axes parameters.
        """

        all_args = [Name, Ang, Advanced]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.GetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxes" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined link objects.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of link object names retrieved by the program.
MyName: This is a one-dimensional array of link object names. The MyName array is created as a dynamic, zero-based, array by the APIuser:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the SAP2000 program, filled with the names, and returned to the APIuser.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetPoints(self, Name = None, Point1 = None, Point2 = None):
        """
This function retrieves the names of the point objects at each end of a specified link object. If names of the two point objects are the same, the specified link object is a one-joint link object.
The function returns zero if the point names are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined link object.
Point1: The name of the point object at the I-End of the specified link object.
Point2: The name of the point object at the J-End of the specified link object.
        """

        all_args = [Name, Point1, Point2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.GetPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPoints" failed')
        
        return ret

    def GetPropertyFD(self, Name = None, PropName = None):
        """
This function retrieves the frequency dependent link property assigned to a link object.
The function returns zero if the property is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined link object.
PropName: The name of the frequency dependent link property assigned to the link object. This item is None if there is no frequency dependent link property assigned to the link object.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.GetPropertyFD(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPropertyFD" failed')
        
        return ret

    def GetProperty(self, Name = None, PropName = None):
        """
This function retrieves the link property assigned to a link object.
The function returns zero if the property is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined link object.
PropName: The name of the link property assigned to the link object.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.GetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProperty" failed')
        
        return ret

    def SetGroupAssign(self, Name = None, GroupName = None, Remove = None, ItemType = None):
        """
This function adds or removes link objects from a specified group.
The function returns zero if the group assignment is successful; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
GroupName: The name of an existing group to which the assignment is made.
Remove: If this item is False, the specified link objects are added to the group specified by the GroupName item. If it is True, the link objects are removed from the group.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the link object specified by the Name item is added or removed from the group specified by the GroupName item.
If this item is Group, all link objects in the group specified by the Name item are added or removed from the group specified by the GroupName item.
If this item is SelectedObjects, all selected link objects are added or removed from the group specified by the GroupName item, and the Name item is ignored.
        """

        all_args = [Name, GroupName, Remove, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.SetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGroupAssign" failed')
        
        return ret

    def SetGUID(self, Name = None, GUID = None):
        """
This function sets the GUID for the specified link object. If the GUID is passed in as a blank string, the program automatically creates a GUID for the object.
This function returns zero if the link object GUID is successfully set; otherwise it returns nonzero.

Name: The name of an existing link object.
GUID: The GUID (Global Unique ID) for the specified link object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.SetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGUID" failed')
        
        return ret

    def SetLoadDeformation(self, Name = None, LoadPat = None, DOF = None, d = None, ItemType = None):
        """
This function assigns deformation loads to link objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
DOF: This is a array of boolean values indicating if the considered degree of freedom has a deformation load.
DOF(1) = U1
DOF(2) = U2
DOF(3) = U3
DOF(4) = R1
DOF(5) = R2
DOF(6) = R3
d: This is a array of deformation load values. The deformations specified for a given degree of freedom are applied only if the corresponding DOF item for that degree of freedom is True.
d(1) = U1 deformation [L]
d(2) = U2 deformation [L]
d(3) = U3 deformation [L]
d(4) = R1 deformation [rad]
d(5) = R2 deformation [rad]
d(6) = R3 deformation [rad]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the link object specified by the Name item.
If this item is Group, the assignment is made to all link objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, DOF, d, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.SetLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadDeformation" failed')
        
        return ret

    def SetLoadGravity(self, Name = None, LoadPat = None, x = None, y = None, z = None, Replace = None, CSys = None, ItemType = None):
        """
This function assigns gravity load multipliers to link objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
x: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
Replace: If this item is True, all previous gravity loads, if any, assigned to the specified link object(s), in the specified load pattern, are deleted before making the new assignment.
CSys: The coordinate system in which the x, y and z multipliers are specified.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the link object specified by the Name item.
If this item is Group, the assignment is made to all link objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, x, y, z, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.SetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadGravity" failed')
        
        return ret

    def SetLoadTargetForce(self, Name = None, LoadPat = None, DOF = None, f = None, RD = None, ItemType = None):
        """
This function assigns target forces to frame objects.
The function returns zero if the target forces are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
DOF: This is a array of boolean values indicating if the considered degree of freedom has a target force.
DOF(1) = P
DOF(2) = V2
DOF(3) = V3
DOF(4) = T
DOF(5) = M2
DOF(6) = M3
f: This is a array of target force values. The target forces specified for a given degree of freedom are applied only if the corresponding DOF item for that degree of freedom is True.
f(1) = P [F]
f(2) = V2 [F]
f(3) = V3 [F]
f(4) = T [FL]
f(5) = M2 [FL]
f(6) = M3 [FL]
RD: This is a array of relative distances along the link objects where the target force values apply. The relative distances specified for a given degree of freedom are applicable only if the corresponding DOF item for that degree of freedom is True. The relative distance must be between 0 and 1, 0 <= RD <=1.
RD(1) = relative location for P target force
RD(2) = relative location for V2 target force
RD(3) = relative location for V3 target force
RD(4) = relative location for T target force
RD(5) = relative location for M2 target force
RD(6) = relative location for M3 target force
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the link object specified by the Name item.
If this item is Group, the assignment is made to all link objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, DOF, f, RD, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.SetLoadTargetForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadTargetForce" failed')
        
        return ret

    def SetLocalAxesAdvanced(self, Name = None, Active = None, AxVectOpt = None, PlVectOpt = None, AxCSys = None, PlCSys = None, AxDir = None, PlDir = None, AxPt = None, PlPt = None, AxVect = None, PlVect = None, Plane2 = None, ItemType = None):
        """
This function assigns advanced local axes to link objects.
The function returns zero if the advanced local axes assignments are assigned successfully; otherwise, it returns a nonzero value.

Name: The name of an existing link object or group depending on the value of the ItemType item.
Active: This is True if advanced local axes exist.
AxVectOpt: This is 1, 2, or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
PlVectOpt: This is 1, 2, or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
AxCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
PlCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
AxDir: This is an array dimensioned to 1 (2 integers), indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
PlDir: This is an array dimensioned to 1 (2 integers), indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
AxPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
PlPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
AxVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
PlVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
Plane2: This is 12 or 13, indicating that the local plane determined by the plane reference vector is the 1-2 or 1-3 plane. This item applies only when the Active item is True.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
Selection = 2

If this item is Object, the assignment is made to the link object specified by the Name item.
If this item is Group, the assignment is made to all link objects in the group specified by the Name item.
If this item is Selection, assignment is made to all selected link objects and the Name item is ignored.
        """

        all_args = [Name, Active, AxVectOpt, PlVectOpt, AxCSys, PlCSys, AxDir, PlDir, AxPt, PlPt, AxVect, PlVect, Plane2, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.SetLocalAxesAdvanced(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxesAdvanced" failed')
        
        return ret

    def SetLocalAxes(self, Name = None, Ang = None, ItemType = None):
        """
This function assigns a local axis angle to link objects.
The function returns zero if the local axis angle is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
Ang: This is the angle that the local 2 and 3 axes are rotated about the positive local 1 axis, from the default orientation or, if the Advanced item is True, from the orientation determined by the plane reference vector. The rotation for a positive angle appears counter clockwise when the local +1 axis is pointing toward you. [deg]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the link object specified by the Name item.
If this item is Group, the assignment is made to all link objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, Ang, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.SetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxes" failed')
        
        return ret

    def SetPropertyFD(self, Name = None, PropName = None, ItemType = None):
        """
This function assigns a frequency dependent link property to link objects.
The function returns zero if the property is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
PropName: This is either None or the name of a frequency dependent link property to be assigned to the specified link object(s). None means that no frequency dependent link property is assigned to the link object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the link object specified by the Name item.
If this item is Group, the assignment is made to all link objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.SetPropertyFD(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPropertyFD" failed')
        
        return ret

    def SetProperty(self, Name = None, PropName = None, ItemType = None):
        """
This function assigns a link property to link objects.
The function returns zero if the property is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing link object or group, depending on the value of the ItemType item.
PropName: This is the name of a link property to be assigned to the specified link object(s).
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the link object specified by the Name item.
If this item is Group, the assignment is made to all link objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected link objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.LinkObj.SetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetProperty" failed')
        
        return ret

class PointObj:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def AddCartesian(self, x = None, y = None, z = None, Name = None, UserName = None, CSys = "GLOBAL", MergeOff = False, MergeNumber = False):
        """
This function adds a point object to a model. The added point object will be tagged as a Special Point except if it was merged with another point object. Special points are allowed to exist in the model with no objects connected to them.
The function returns zero if the point object is successfully added or merged, otherwise it returns a nonzero value.

x: The X-coordinate of the added point object in the specified coordinate system. [L]
y: The Y-coordinate of the added point object in the specified coordinate system. [L]
z: The Z-coordinate of the added point object in the specified coordinate system. [L]
Name: This is the name that the program ultimately assigns for the point object. If no UserName is specified, the program assigns a default name to the point object. If a UserName is specified and that name is not used for another point, the UserName is assigned to the point; otherwise a default name is assigned to the point.
If a point is merged with another point, this will be the name of the point object with which it was merged.
UserName: This is an optional user specified name for the point object. If a UserName is specified and that name is already used for another point object, the program ignores the UserName.
CSys: The name of the coordinate system in which the joint coordinates are defined.
MergeOff: If this item is False, a new point object that is added at the same location as an existing point object will be merged with the existing point object (assuming the two point objects have the same MergeNumber) and thus only one point object will exist at the location.
If this item is True, the points will not merge and two point objects will exist at the same location.
MergeNumber: Two points objects in the same location will merge only if their merge number assignments are the same. By default all pointobjects have a merge number of zero.
        """

        all_args = [x, y, z, Name, UserName, CSys, MergeOff, MergeNumber]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.AddCartesian(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddCartesian" failed')
        
        return ret

    def AddCylindrical(self, r = None, Theta = None, z = None, Name = None, UserName = None, CSys = None, MergeOff = None, MergeNumber = None):
        """
This function adds a point object to a model. The added point object will be tagged as a Special Point except if it was merged with another point object. Special points are allowed to exist in the model with no objects connected to them
The function returns zero if the point object is successfully added or merged, otherwise it returns a nonzero value.

r: The radius for the added point object in the specified coordinate system. [L]
Theta: The angle for the added point object in the specified coordinate system. The angle is measured in the XY plane from the positive global X axis. When looking in the XY plane with the positive Z axis pointing toward you, a positive Theta angle is counter clockwise. [deg]
z: The Z-coordinate of the added point object in the specified coordinate system. [L]
Name: This is the name that the program ultimately assigns for the point object. If no UserName is specified, the program assigns a default name to the point object. If a UserName is specified and that name is not used for another point, the UserName is assigned to the point; otherwise a default name is assigned to the point.
If a point is merged with another point, this will be the name of the point object with which it was merged.
UserName: This is an optional user specified name for the point object. If a UserName is specified and that name is already used for another point object, the program ignores the UserName.
CSys: The name of the coordinate system in which the joint coordinates are defined.
MergeOff: If this item is False, a new point object that is added at the same location as an existing point object will be merged with the existing point object (assuming the two point objects have the same MergeNumber) and thus only one point object will exist at the location.
If this item is True, the points will not merge and two point objects will exist at the same location.
MergeNumber: Two points objects in the same location will merge only if their merge number assignments are the same. By default all pointobjects have a merge number of zero.
        """

        all_args = [r, Theta, z, Name, UserName, CSys, MergeOff, MergeNumber]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.AddCylindrical(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddCylindrical" failed')
        
        return ret

    def AddSpherical(self, r = None, a = None, b = None, Name = None, UserName = None, CSys = None, MergeOff = None, MergeNumber = None):
        """
This function adds a point object to a model. The added point object will be tagged as a Special Point except if it was merged with another point object. Special points are allowed to exist in the model with no objects connected to them
The function returns zero if the point object is successfully added or merged, otherwise it returns a nonzero value.

r: The radius for the added point object in the specified coordinate system. [L]
a: The plan angle for the added point object in the specified coordinate system. This angle is measured in the XY plane from the positive global X axis. When looking in the XY plane with the positive Z axis pointing toward you, a positive a angle is counterclockwise. [deg]
b: The elevation angle for the added point object in the specified coordinate system. This angle is measured in an X'Z plane that is perpendicular to the XY plane with the positive X' axis oriented at angle a from the positive global X axis. Angle b is measured from the positive global Z axis. When looking in the X’Z plane with the positive Y' axis pointing toward you, a positive b angle is counter clockwise. [deg]
Name: This is the name that the program ultimately assigns for the point object. If no UserName is specified, the program assigns a default name to the point object. If a UserName is specified and that name is not used for another point, the UserName is assigned to the point; otherwise a default name is assigned to the point.
If a point is merged with another point, this will be the name of the point object with which it was merged.
UserName: This is an optional user specified name for the point object. If a UserName is specified and that name is already used for another point object, the program ignores the UserName.
CSys: The name of the coordinate system in which the joint coordinates are defined.
MergeOff: If this item is False, a new point object that is added at the same location as an existing point object will be merged with the existing point object (assuming the two point objects have the same MergeNumber) and thus only one point object will exist at the location.
If this item is True, the points will not merge and two point objects will exist at the same location.
MergeNumber: Two points objects in the same location will merge only if their merge number assignments are the same. By default all pointobjects have a merge number of zero.
        """

        all_args = [r, a, b, Name, UserName, CSys, MergeOff, MergeNumber]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.AddSpherical(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddSpherical" failed')
        
        return ret

    def ChangeName(self, Name = None, NewName = None):
        """
The function returns zero if the new name is successfully applied, otherwise it returns a nonzero value.

Name: The existing name of a point object.
NewName: The new name for the point object.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def CountConstraint(self, Count = None, Name = None):
        """
If the Name item is provided, the Count item returns the total number of constraint assignments made to the specified point object. If the Name item is not specified, or is specified as an empty string, the Count item returns the total number of constraint assignments to all point objects in the model. If the Name item is specified but it is not recognized by the program as a valid point object, an error is returned.
This function returns zero if the count is successfully completed, otherwise it returns a nonzero value.

Count: The number of counted constraints.
Name: This optional item is the name of an existing point object.
        """

        all_args = [Count, Name]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.CountConstraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountConstraint" failed')
        
        return ret

    def CountLoadDispl(self, Count = None, Name = None, LoadPat = None):
        """
If neither the Name item nor the LoadPat item is provided, the Count item returns the total number of ground displacement load assignments in the model.
If the Name item is provided but not the LoadPat item, the Count item returns the total number of ground displacement load assignments made for the specified point object.
If the Name item is not provided but the LoadPat item is specified, the Count item returns the total number of ground displacement load assignments made to all point objects for the specified load pattern.
If both the Name item and the LoadPat item are provided, the Count item returns the total number of ground displacement load assignments made to the specified point object for the specified load pattern.
If the Name item or the LoadPat item is provided but is not recognized by the program as valid, an error is returned.
This function returns zero if the count is successfully completed, otherwise it returns a nonzero value.

Count: The number of counted ground displacement loads.
Name: This optional item is the name of an existing point object.
LoadPat: This optional item is the name of an existing load pattern.
        """

        all_args = [Count, Name, LoadPat]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.CountLoadDispl(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountLoadDispl" failed')
        
        return ret

    def CountLoadForce(self, Count = None, Name = None, LoadPat = None):
        """
If neither the Name item nor the LoadPat item is provided, the Count item returns the total number of point load assignments in the model.
If the Name item is provided but not the LoadPat item, the Count item returns the total number of point load assignments made for the specified point object.
If the Name item is not provided but the LoadPat item is specified, the Count item returns the total number of point  load assignments made to all point objects for the specified load pattern.
If both the Name item and the LoadPat item are provided,n the Count item returns the total number of point load assignments made to the specified point object for the specified load pattern.
If the Name item or the LoadPat item is provided but is not recognized by the program as valid, an error is returned.
This function returns zero if the count is successfully completed, otherwise it returns a nonzero value.

Count: The number of counted point loads.
Name: This optional item is the name of an existing point object.
LoadPat: This optional item is the name of an existing load pattern.
        """

        all_args = [Count, Name, LoadPat]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.CountLoadForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountLoadForce" failed')
        
        return ret

    def CountPanelZone(self):
        """
This function returns the total number of panel zone assignments to point objects in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.CountPanelZone(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountPanelZone" failed')
        
        return ret

    def CountRestraint(self):
        """
This function returns the total number of point objects in the model with restraint assignments.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.CountRestraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountRestraint" failed')
        
        return ret

    def CountSpring(self):
        """
This function returns the total number of point objects in the model with spring assignments.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.CountSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CountSpring" failed')
        
        return ret

    def Count(self):
        """
This function returns the total number of point objects in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def DeleteConstraint(self, Name = None, ItemType = None):
        """
This function deletes all constraint assignments from the specified point object(s).
The function returns zero if the constraint assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of a point object or a group depending on the value selected for ItemType item.
ItemType: This is one of the following items from the eItemType enumeration.
Object = 0
Group = 1
SelectedObjects = 2

If Object is selected, the Name item refers to a point object and the constraint assignments to that point object are removed.
If Group is selected, the Name item refers to a group and the constraint assignments to all point objects in the group are removed.
If SelectedObjects is selected, the Name item is ignored and the constraint assignments to all selected point objects are removed.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.DeleteConstraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteConstraint" failed')
        
        return ret

    def DeleteLoadDispl(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes all ground displacement load assignments, for the specified load pattern, from the specified point object(s).
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of a point object or a group depending on the value selected for ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items from the eItemType enumeration.
Object = 0
Group = 1
SelectedObjects = 2

If Object is selected, the Name item refers to a point object. The ground displacement load assignments, for the specified load case, made to that point object, are removed.
If Group is selected, the Name item refers to a group. The ground displacement load assignments, for the specified load pattern, made to all point objects in the group, are removed.
If SelectedObjects is selected, the Name item is ignored. The ground displacement load assignments, for the specified load pattern, made to all selected point objects, are removed.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.DeleteLoadDispl(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadDispl" failed')
        
        return ret

    def DeleteLoadForce(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes all point load assignments, for the specified load pattern, from the specified point object(s).
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of a point object or a group depending on the value selected for ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items from the eItemType enumeration.
Object = 0
Group = 1
SelectedObjects = 2

If Object is selected, the Name item refers to a point object. The point load assignments, for the specified load pattern, made to that point object, are removed.
If Group is selected, the Name item refers to a group. The point load assignments, for the specified load pattern, made to all point objects in the group, are removed.
If SelectedObjects is selected, the Name item is ignored. The point load assignments, for the specified load pattern, made to all selected point objects, are removed.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.DeleteLoadForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadForce" failed')
        
        return ret

    def DeleteMass(self, Name = None, ItemType = None):
        """
This function deletes all mass assignments from the specified point object(s).
The function returns zero if the mass assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of a point object or a group depending on the value selected for ItemType item.
ItemType: This is one of the following items from the eItemType enumeration.
Object = 0
Group = 1
SelectedObjects = 2

If Object is selected, the Name item refers to a point object. The mass assignments for that point object are removed.
If Group is selected, the Name item refers to a group. The mass assignments for all point objects in the group are removed.
If SelectedObjects is selected, the Name item is ignored. The mass assignments for all selected point objects are removed.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.DeleteMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteMass" failed')
        
        return ret

    def DeletePanelZone(self, Name = None, ItemType = None):
        """
This function deletes all panel zone assignments from the specified point object(s).
The function returns zero if the panel zone assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of a point object or a group depending on the value selected for ItemType item.
ItemType: This is one of the following items from the eItemType enumeration.
Object = 0
Group = 1
SelectedObjects = 2

If Object is selected, the Name item refers to a point object. The panel zone assignments for that point object are removed.
If Group is selected, the Name item refers to a group. The panel zone assignments for all point objects in the group are removed.
If SelectedObjects is selected, the Name item is ignored. The panel zone assignments for all selected point objects are removed.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.DeletePanelZone(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeletePanelZone" failed')
        
        return ret

    def DeletePatternValue(self, Name = None, PatternName = None, ItemType = None):
        """
This function deletes all joint pattern assignments, associated with the specified joint pattern, from the specified point object(s).
The function returns zero if the joint pattern assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of a point object or a group depending on the value selected for ItemType item.
PatternName: The name of a defined joint pattern.
ItemType: This is one of the following items from the eItemType enumeration.
Object = 0
Group = 1
SelectedObjects = 2

If Object is selected, the Name item refers to a point object. The joint pattern assignments, associated with the specified joint pattern, for that point object are removed.
If Group is selected, the Name item refers to a group. The joint pattern assignments, associated with the specified joint pattern, for all point objects in the group, are removed.
If SelectedObjects is selected, the Name item is ignored. The joint pattern assignments, associated with the specified joint pattern, for all selected point objects, are removed.
        """

        all_args = [Name, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.DeletePatternValue(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeletePatternValue" failed')
        
        return ret

    def DeleteRestraint(self, Name = None, ItemType = None):
        """
This function deletes all restraint assignments from the specified point object(s).
The function returns zero if the restraint assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of a point object or a group depending on the value selected for ItemType item.
ItemType: This is one of the following items from the eItemType enumeration.
Object = 0
Group = 1
SelectedObjects = 2

If Object is selected, the Name item refers to a point object. The restraint assignments for that point object are removed.
If Group is selected, the Name item refers to a group. The restraint assignments for all point objects in the group are removed.
If SelectedObjects is selected, the Name item is ignored. The restraint assignments for all selected point objects are removed.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.DeleteRestraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteRestraint" failed')
        
        return ret

    def DeleteSpecialPoint(self, Name = None, ItemType = None):
        """
The function deletes special point objects that have no other objects connected to them.
The function returns zero if the function completes successfully, otherwise it returns a nonzero value.
Point objects can be deleted only if they have no other objects (e.g., frame, cable, tendon, area, solid link) connected to them. If a point object is not specified to be a Special Point, the program automatically deletes that point object when it has no other objects connected to it. If a point object is specified to be a Special Point, to delete it, first delete all other objects connected to the point and then call this function to delete the point.

Name: The name of an existing point object or group depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the deletion applies to the point object specified by the Name item.
If this item is Group, the deletion applies to all point objects in the group specified by the Name item.
If this item is SelectedObjects, the deletion applies to all selected point objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.DeleteSpecialPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteSpecialPoint" failed')
        
        return ret

    def DeleteSpring(self, Name = None, ItemType = None):
        """
This function deletes all point spring assignments from the specified point object(s).
The function returns zero if the restraint assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of a point object or a group depending on the value selected for ItemType item.
ItemType: This is one of the following items from the eItemType enumeration.
Object = 0
Group = 1
SelectedObjects = 2

If Object is selected, the Name item refers to a point object. The point spring assignments for that point object are removed.
If Group is selected, the Name item refers to a group. The point spring assignments for all point objects in the group are removed.
If SelectedObjects is selected, the Name item is ignored. The point spring assignments for all selected point objects are removed.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.DeleteSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteSpring" failed')
        
        return ret

    def GetCommonTo(self, Name = None, CommonTo = None):
        """
This function returns the total number of objects (line, area, solid and link) that connect to the specified point object.
The function returns zero if the CommonTo is successfully calculated, otherwise it returns a nonzero value.

Name: The name of a point object or a group depending on the value selected for ItemType item.
CommonTo: The total number of objects (line, area, solid and link) that connect to the specified point object.
        """

        all_args = [Name, CommonTo]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetCommonTo(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCommonTo" failed')
        
        return ret

    def GetConnectivity(self, Name = None, NumberItems = None, ObjectType = None, ObjectName = None, PointNumber = None):
        """
This function returns a list of objects connected to a specified point object.
The function returns zero if the list is successfully filled; otherwise it returns nonzero.

Name: The name of an existing point object.
NumberItems: This is the total number of objects connected to the specified point object.
ObjectType: This is an array that includes the object type of each object connected to the specified point object.
2 = Frame object
3 = Cable object
4 = Tendon object
5 = Area object
6 = Solid object
7 = Link object
ObjectName: This is an array that includes the object name of each object connected to the specified point object.
PointNumber: This is an array that includes the point number within the considered object that corresponds to the specified point object.
        """

        all_args = [Name, NumberItems, ObjectType, ObjectName, PointNumber]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetConnectivity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetConnectivity" failed')
        
        return ret

    def GetConstraint(self, Name = None, NumberItems = None, PointName = None, ConstraintName = None, ItemType = None):
        """
This function returns a list of constraint assignments made to one or more specified point objects.
The function returns zero if the constraint name list is successfully filled, otherwise it returns nonzero.
The PointName and ConstraintName items are returned in one-dimensional arrays. Each array is created as a dynamic array by the API user. In VBA a dynamic string array is defined by:
   Dim PointName() as String
The arrays are dimensioned to (NumberItems – 1) inside the Sap2000 program, filled with values, and returned to the API user.
The arrays are zero-based. Thus the first item is at array index 0, and the last item is at array index (NumberItems - 1).

Name: The name of an existing point object or group, depending on the value of the ItemType item.
NumberItems: This is the total number of constraint assignments returned.
PointName: This is an array that includes the name of the point object to which the specified constraint assignment applies.
ConstraintName: This is an array that includes the name of the constraint that is assigned to the point object specified by the PointName item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the constraint assignments are retrieved for the point object specified by the Name item.
If this item is Group, the constraint assignments are retrieved for all point objects in the group specified by the Name item.
If this item is SelectedObjects, the constraint assignments are retrieved for all selected point objects and the Name item is ignored.
        """

        all_args = [Name, NumberItems, PointName, ConstraintName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetConstraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetConstraint" failed')
        
        return ret

    def GetCoordCartesian(self, Name = None, x = None, y = None, z = None, Csys = None):
        """
The function returns zero if the coordinates are successfully returned; otherwise it returns nonzero. If successful, the function returns the x, y and z coordinates of the specified point object in the Present Units. The coordinates are reported in the coordinate system specified by Csys.

Name: The name of a defined point object.
x: The X-coordinate of the specified point object in the specified coordinate system. [L]
y: The Y-coordinate of the specified point object in the specified coordinate system. [L]
z: The Z-coordinate of the specified point object in the specified coordinate system. [L]
Csys: The name of a defined coordinate system. If Csys is not specified, the Global coordinate system is assumed.
        """

        all_args = [Name, x, y, z, Csys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetCoordCartesian(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCoordCartesian" failed')
        
        return ret

    def GetCoordCylindrical(self, Name = None, r = None, Theta = None, z = None, Csys = None):
        """
The function returns zero if the coordinates are successfully returned; otherwise it returns nonzero. If successful, the function returns the r, theta and z coordinates of the specified point object in the Present Units. The coordinates are reported in the coordinate system specified by CSys.

Name: The name of a defined point object.
r: The radius for the specified point object in the specified coordinate system. [L]
Theta: The angle for the specified point object in the specified coordinate system. The angle is measured in the XY plane from the positive X axis. When looking in the XY plane with the positive Z axis pointing toward you, a positive Theta angle is counter clockwise [deg]
z: The Z-coordinate of the specified point object in the specified coordinate system. [L]
Csys: The name of a defined coordinate system. If Csys is not specified, the Global coordinate system is assumed.
        """

        all_args = [Name, r, Theta, z, Csys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetCoordCylindrical(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCoordCylindrical" failed')
        
        return ret

    def GetCoordSpherical(self, Name = None, r = None, a = None, b = None, CSys = None):
        """
The function returns zero if the coordinates are successfully returned; otherwise it returns nonzero. If successful, the function returns the r, a and b coordinates of the specified point object in the Present Units. The coordinates are reported in the coordinate system specified by CSys.

Name: The name of an existing point object.
r: The radius for the point object in the specified coordinate system. [L]
a: The plan angle for the point object in the specified coordinate system. This angle is measured in the XY plane from the positive global X axis. When looking in the XY plane with the positive Z axis pointing toward you, a positive a angle is counter clockwise. [deg]
b: The elevation angle for the point object in the specified coordinate system. This angle is measured in an X'Z plane that is perpendicular to the XY plane with the positive X' axis oriented at angle a from the positive global X axis. Angle b is measured from the positive global Z axis. When looking in the X’Z plane with the positive Y' axis pointing toward you, a positive b angle is counter clockwise. [deg]
CSys: The name of the coordinate system in which the joint coordinates are returned.
        """

        all_args = [Name, r, a, b, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetCoordSpherical(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetCoordSpherical" failed')
        
        return ret

    def GetElm(self, Name = None, Elm = None):
        """
This function retrieves the name of the point element (analysis model point) associated with a specified point object in the object-based model.
This function returns zero if the point element name is successfully returned; otherwise it returns nonzero. An error occurs if the analysis model does not currently exist.

Name: The name of an existing point object.
Elm: The name of the point element associated with the specified point object.
        """

        all_args = [Name, Elm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetElm(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetElm" failed')
        
        return ret

    def GetGroupAssign(self, Name = None, NumberGroups = None, Groups = None):
        """
This function retrieves the names of the groups to which a specified point object is assigned.
The function returns zero if the group assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point object.
NumberGroups: The number of group names retrieved.
Groups: The names of the groups to which the point object is assigned.
        """

        all_args = [Name, NumberGroups, Groups]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGroupAssign" failed')
        
        return ret

    def GetGUID(self, Name = None, GUID = None):
        """
This function retrieves the GUID for specified point object.
This function returns zero if the point object GUID is successfully retrieved; otherwise it returns nonzero.

Name: The name of an existing point object.
GUID: The GUID (Global Unique ID) for the specified point object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGUID" failed')
        
        return ret

    def GetLoadDispl(self, Name = None, NumberItems = None, PointName = None, LoadPat = None, LCStep = None, CSys = None, U1 = None, U2 = None, U3 = None, R1 = None, R2 = None, R3 = None, ItemType = None):
        """
This function retrieves the ground displacement load assignments to point objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point object or group, depending on the value of the ItemType item.
NumberItems: This is the total number of joint ground displacement assignments returned.
PointName: This is an array that includes the name of the point object to which the specified ground displacement assignment applies.
LoadPat: This is an array that includes the name of the load pattern for the ground displacement load.
LCStep: This is an array that includes the load pattern step for the ground displacement load. In most cases, this item does not apply and will be returned as 0.
CSys: This is an array that includes the name of the coordinate system for the ground displacement load. This is Local or the name of a defined coordinate system.
U1: This is an array that includes the assigned translational ground displacement in the local 1-axis or coordinate system X-axis direction, depending on the specified CSys. [L]
U2: This is an array that includes the assigned translational ground displacement in the local 2-axis or coordinate system Y-axis direction, depending on the specified CSys. [L]
U3: This is an array that includes the assigned translational ground displacement in the local 3-axis or coordinate system Z-axis direction, depending on the specified CSys. [L]
R1: This is an array that includes the assigned rotational ground displacement about the local 1-axis or coordinate system X-axis, depending on the specified CSys. [rad]
R2: This is an array that includes the assigned rotational ground displacement about the local 2-axis or coordinate system Y-axis, depending on the specified CSys. [rad]
R3: This is an array that includes the assigned rotational ground displacement about the local 3-axis or coordinate system Z-axis, depending on the specified CSys. [rad]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are retrieved for the point object specified by the Name item.
If this item is Group, the assignments are retrieved for all point objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are retrieved for all selected point objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, PointName, LoadPat, LCStep, CSys, U1, U2, U3, R1, R2, R3, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetLoadDispl(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadDispl" failed')
        
        return ret

    def GetLoadForce(self, Name = None, NumberItems = None, PointName = None, LoadPat = None, LCStep = None, CSys = None, F1 = None, F2 = None, F3 = None, M1 = None, M2 = None, M3 = None, ItemType = None):
        """
This function retrieves the joint force load assignments to point objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point object or group, depending on the value of the ItemType item.
NumberItems: This is the total number of joint force load assignments returned.
PointName: This is an array that includes the name of the point object to which the specified load assignment applies.
LoadPat: This is an array that includes the name of the load pattern for the load.
LCStep: This is an array that includes the load pattern step for the load. In most cases, this item does not apply and will be returned as 0.
CSys: This is an array that includes the name of the coordinate system for the load. This is Local or the name of a defined coordinate system.
F1: This is an array that includes the assigned translational force in the local 1-axis or coordinate system X-axis direction, depending on the specified CSys. [F]
F2: This is an array that includes the assigned translational force in the local 2-axis or coordinate system Y-axis direction, depending on the specified CSys. [F]
F3: This is an array that includes the assigned translational force in the local 3-axis or coordinate system Z-axis direction, depending on the specified CSys. [F]
M1: This is an array that includes the assigned moment about the local 1-axis or coordinate system X-axis, depending on the specified CSys. [FL]
M2: This is an array that includes the assigned moment about the local 2-axis or coordinate system Y-axis, depending on the specified CSys. [FL]
M3: This is an array that includes the assigned moment about the local 3-axis or coordinate system Z-axis, depending on the specified CSys. [FL]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are retrieved for the point object specified by the Name item.
If this item is Group, the assignments are retrieved for all point objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are retrieved for all selected point objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, PointName, LoadPat, LCStep, CSys, F1, F2, F3, M1, M2, M3, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetLoadForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadForce" failed')
        
        return ret

    def GetLocalAxesAdvanced(self, Name = None, Active = None, AxVectOpt = None, PlVectOpt = None, AxCSys = None, PlCSys = None, AxDir = None, PlDir = None, AxPt = None, PlPt = None, AxVect = None, PlVect = None, Plane2 = None):
        """
This function assigns advanced local axes to point objects.
The function returns zero if the advanced local axes assignments are assigned successfully; otherwise it returns a nonzero value.

Name: The name of an existing point object.
Active: This is True if advanced local axes exist.
AxVectOpt: This is 1, 2, or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
PlVectOpt: This is 1, 2, or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
AxCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
PlCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
AxDir: This is an array dimensioned to 1 (2 integers), indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
PlDir: This is an array dimensioned to 1 (2 integers), indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
AxPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
PlPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
AxVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
PlVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
Plane2: This is 12, 13, 21, 23, 31 or 32, indicating that the local plane determined by the plane reference vector is the 1-2, 1-3, 2-1, 2-3, 3-1, or 3-2 plane. This item applies only when the Active item is True.
        """

        all_args = [Name, Active, AxVectOpt, PlVectOpt, AxCSys, PlCSys, AxDir, PlDir, AxPt, PlPt, AxVect, PlVect, Plane2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetLocalAxesAdvanced(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxesAdvanced" failed')
        
        return ret

    def GetLocalAxes(self, Name = None, a = None, b = None, c = None, Advanced = None):
        """
This function retrieves the local axes angles for a point object.
The function returns zero if the local axes angles are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point object.
a: The local axes of the point are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
b: The local axes of the point are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
c: The local axes of the point are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
Advanced: This item is True if the point object local axes orientation was obtained using advanced local axes parameters.
        """

        all_args = [Name, a, b, c, Advanced]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxes" failed')
        
        return ret

    def GetMass(self, Name = None, m = None):
        """
This function retrieves the point mass assignment values for a point object. The masses are always returned in the point local coordinate system.
The function returns zero if the mass is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point object.
m: This is an array of six mass assignment values.
Value(0) = U1 [M]
Value(1) = U2 [M]
Value(2) = U3 [M]
Value(3) = R1 [ML2]
Value(4) = R2 [ML2]
Value(5) = R3 [ML2]
        """

        all_args = [Name, m]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMass" failed')
        
        return ret

    def GetMergeNumber(self, Name = None, MergeNumber = None):
        """
This function retrieves the merge number for a point object. By default the merge number for a point is zero. Points with different merge numbers are not automatically merged by the program.
The function returns zero if the merge number is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point object.
MergeNumber: The merge number assigned to the specified point object.
        """

        all_args = [Name, MergeNumber]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetMergeNumber(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMergeNumber" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined point objects.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of point object names retrieved by the program.
MyName: This is a one-dimensional array of point object names. The MyName array is created as a dynamic, zero-based, array by the API user:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the API user.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetPanelZone(self, Name = None, PropType = None, Thickness = None, K1 = None, K2 = None, LinkProp = None, Connectivity = None, LocalAxisFrom = None, LocalAxisAngle = None):
        """
This function retrieves the panel zone assignment data for a point object.
The function returns zero if the panel zone data is successfully retrieved, otherwise it returns a nonzero value.
If no panel zone assignment is made to the point object, an error is returned.

Name: The name of an existing point object.
PropType: This is 0, 1, 2, or 3.
0 = Properties are elastic from column
1 = Properties are elastic from column and doubler plate
2 = Properties are from specified spring stiffnesses
3 = Properties are from a specified link property
Thickness: The thickness of the doubler plate. This item applies only when PropType = 1. [L]
K1: The spring stiffness for major axis bending (about the local 3 axis of the column and panel zone). This item applies only when PropType = 2. [FL/rad]
K2: The spring stiffness for minor axis bending (about the local 2 axis of the column and panel zone). This item applies only when PropType = 2. [FL/rad]
LinkProp: The name of the link property used to define the panel zone. This item applies only when PropType = 3.
Connectivity: This is 0 or 1.
0 = Panel zone connects beams to other objects
1 = Panel zone connects braces to other objects
LocalAxisFrom: This is 0 or 1.
0 = Panel zone local axis angle is from column
1 = Panel zone local axis angle is user defined

The LocalAxisFrom item can be 1 only when the PropType item is 3.
LocalAxisAngle: This item applies only when PropType = 3 and LocalAxisFrom = 1. It is the angle measured counter clockwise from the positive global X-axis to the local 2-axis of the panel zone. [deg]
        """

        all_args = [Name, PropType, Thickness, K1, K2, LinkProp, Connectivity, LocalAxisFrom, LocalAxisAngle]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetPanelZone(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPanelZone" failed')
        
        return ret

    def GetPatternValue(self, Name = None, PatternName = None, Value = None):
        """
This function retrieves the joint pattern value for a specific point object and joint pattern.
The function returns zero if the value is successfully retrieved, otherwise it returns a nonzero value.
Joint pattern values are unitless.

Name: The name of an existing point object.
PatternName: The name of a defined joint pattern.
Value: The value that the specified point object has for the specified joint pattern.
        """

        all_args = [Name, PatternName, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetPatternValue(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPatternValue" failed')
        
        return ret

    def GetRestraint(self, Name = None, Value = None):
        """
This function retrieves the restraint assignments for a point object. The restraint assignments are always returned in the point local coordinate system.
The function returns zero if the restraint assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point object.
Value: This is an array of six restraint values.
Value(0) = U1
Value(1) = U2
Value(2) = U3
Value(3) = R1
Value(4) = R2
Value(5) = R3
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetRestraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetRestraint" failed')
        
        return ret

    def GetSelected(self, Name = None, Selected = None):
        """
This function retrieves the selected status for a point object.
The function returns zero if the selected status is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point object.
Selected: This item returns True if the specified point object is selected, otherwise it returns False.
        """

        all_args = [Name, Selected]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetSelected(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSelected" failed')
        
        return ret

    def GetSpecialPoint(self, Name = None, SpecialPoint = None):
        """
This function retrieves the special point status for a point object.
The function returns zero if the special point status is successfully retrieved, otherwise it returns a nonzero value.
Special points are allowed to exist in the model even if no objects (line, area, solid, link) are connected to them. Points that are not special are automatically deleted if no objects connect to them.

Name: The name of an existing point object.
SpecialPoint: This item is True if the point object is specified as a special point, otherwise it is False.
        """

        all_args = [Name, SpecialPoint]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetSpecialPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSpecialPoint" failed')
        
        return ret

    def GetSpringCoupled(self, Name = None, k = None):
        """
This function retrieves coupled spring stiffness assignments for a point object.
The spring stiffnesses reported are the sum of all springs assigned to the point object. The spring stiffness values are reported in the point local coordinate system.
The function returns zero if the stiffnesses are successfully retrieved, otherwise it returns a nonzero value. If no springs exist at the point object, the function returns a nonzero value.

Name: The name of an existing point object.
k: This is an array of twenty one spring stiffness values.
Value(0) = U1U1 [F/L]
Value(1) = U1U2 [F/L]
Value(2) = U2U2 [F/L]
Value(3) = U1U3 [F/L]
Value(4) = U2U3 [F/L]
Value(5) = U3U3 [F/L]
Value(6) = U1R1 [F/rad]
Value(7) = U2R1 [F/rad]
Value(8) = U3R1 [F/rad]
Value(9) = R1R1 [FL/rad]
Value(10) = U1R2 [F/rad]
Value(11) = U2R2 [F/rad]
Value(12) = U3R2 [F/rad]
Value(13) = R1R2 [FL/rad]
Value(14) = R2R2 [FL/rad]
Value(15) = U1R3 [F/rad]
Value(16) = U2R3 [F/rad]
Value(17) = U3R3 [F/rad]
Value(18) = R1R3 [FL/rad]
Value(19) = R2R3 [FL/rad]
Value(20) = R3R3 [FL/rad]
        """

        all_args = [Name, k]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetSpringCoupled(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSpringCoupled" failed')
        
        return ret

    def GetSpring(self, Name = None, k = None):
        """
This function retrieves uncoupled spring stiffness assignments for a point object, that is, it retrieves the diagonal terms in the 6x6 spring matrix for the point object.
The spring stiffnesses reported are the sum of all springs assigned to the point object. The spring stiffness values are reported in the point local coordinate system.
The function returns zero if the stiffnesses are successfully retrieved, otherwise it returns a nonzero value. If no springs exist at the point object, the function returns a nonzero value.

Name: The name of an existing point object.
k: This is an array of six spring stiffness values.
Value(0) = U1 [F/L]
Value(1) = U2 [F/L]
Value(2) = U3 [F/L]
Value(3) = R1 [FL/rad]
Value(4) = R2 [FL/rad]
Value(5) = R3 [FL/rad]
        """

        all_args = [Name, k]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSpring" failed')
        
        return ret

    def GetTransformationMatrix(self, Name = None, Value = None, IsGlobal = None):
        """
The function returns zero if the point object transformation matrix is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing point object.
Value: Value is an array of nine direction cosines that define the transformation matrix.
The following matrix equation shows how the transformation matrix is used to convert items from the point object local coordinate system to the global coordinate system.

In the equation, c0 through c8 are the nine values from the transformation array; (Local1, Local2, Local3) are an item (such as a point load) in the point object local coordinate system; and (GlobalX, GlobalY, GlobalZ) are the same item in the global coordinate system.
The transformation from the local coordinate system to the present coordinate system is the same as that shown above for the global system if you substitute the present system for the global system.
IsGlobal: If this item is True, the transformation matrix is between the Global coordinate system and the point object local coordinate system.
If this item is False, the transformation matrix is between the present coordinate system and the point object local coordinate system.
        """

        all_args = [Name, Value, IsGlobal]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.GetTransformationMatrix(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTransformationMatrix" failed')
        
        return ret

    def IsSpringCoupled(self, Name = None, IsCoupled = None):
        """
This function indicates if the spring assignments to a point object are coupled, that is, if they have off-diagonal terms in the 6x6 spring matrix for the point object.
The function returns zero if the coupled status is successfully retrieved, otherwise it returns a nonzero value. If no springs exist at the point object,n the function returns a nonzero value.

Name: The name of an existing point object.
IsCoupled: This item is True if the spring assigned to the specified point object is coupled, otherwise it is False.
        """

        all_args = [Name, IsCoupled]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.IsSpringCoupled(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"IsSpringCoupled" failed')
        
        return ret

    def SetConstraint(self, Name = None, ConstraintName = None, ItemType = None, Replace = None):
        """
This function makes joint constraint assignments to point objects.
The function returns 0 if the assignment is successfully made, otherwise it returns nonzero.

Name: The name of an existing point object or group depending on the value of the ItemType item.
ConstraintName: The name of an existing joint constraint.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the constraint assignment is made to the point object specified by the Name item.
If this item is Group, the constraint assignment is made to all point objects in the group specified by the Name item.
If this item is SelectedObjects, the constraint assignment is made to all selected point objects and the Name item is ignored.
Replace: If this item is True, all previous joint constraints, if any, assigned to the specified point object(s) are deleted before making the new assignment.
        """

        all_args = [Name, ConstraintName, ItemType, Replace]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetConstraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetConstraint" failed')
        
        return ret

    def SetGroupAssign(self, Name = None, GroupName = None, Remove = None, ItemType = None):
        """
This function adds or removes point objects from a specified group.
The function returns zero if the group assignment is successful, otherwise it returns a nonzero value.

Name: The name of an existing point object or group depending on the value of the ItemType item.
GroupName: The name of an existing group to which the assignment is made.
Remove: If this item is False, the specified point objects are added to the group specified by the GroupName item. If it is True, the point objects are removed from the group.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the point object specified by the Name item is added or removed from the group specified by the GroupName item.
If this item is Group, all point objects in the group specified by the Name item are added or removed from the group specified by the GroupName item.
If this item is SelectedObjects, all selected point objects are added or removed from the group specified by the GroupName item and the Name item is ignored.
        """

        all_args = [Name, GroupName, Remove, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGroupAssign" failed')
        
        return ret

    def SetGUID(self, Name = None, GUID = None):
        """
This function sets the GUID for specified point object. If the GUID is passed in as a blank string, the program automatically creates a GUID for the object.
This function returns zero if the point object GUID is successfully set; otherwise it returns nonzero.

Name: The name of an existing point object.
GUID: The GUID (Global Unique ID) for the specified point object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGUID" failed')
        
        return ret

    def SetLoadDispl(self, Name = None, LoadPat = None, Value = None, Replace = None, CSys = None, ItemType = None):
        """
This function makes ground displacement load assignments to point objects.
The function returns zero if the load assignments are successfully made, otherwise it returns a nonzero value.

Name: The name of an existing point object or group depending on the value of the ItemType item.
LoadPat: The name of the load pattern for the ground displacement load.
Value: This is an array of six ground displacement load values.
Value(0) = U1 [L]
Value(1) = U2 [L]
Value(2) = U3 [L]
Value(3) = R1 [rad]
Value(4) = R2 [rad]
Value(5) = R3 [rad]
Replace: If this item is True, all previous ground displacement loads, if any, assigned to the specified point object(s) in the specified load pattern are deleted before making the new assignment.
CSys: The name of the coordinate system for the considered ground displacement load. This is Local or the name of a defined coordinate system.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignment is made to the point object specified by the Name item.
If this item is Group, the load assignment is made to all point objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignment is made to all selected point objects and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Value, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetLoadDispl(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadDispl" failed')
        
        return ret

    def SetLoadForce(self, Name = None, LoadPat = None, Value = None, Replace = True, CSys = "GLOBAL", ItemType = 0):
        """
This function makes point load assignments to point objects.
The function returns zero if the load assignments are successfully made, otherwise it returns a nonzero value.

Name: The name of an existing point object or group depending on the value of the ItemType item.
LoadPat: The name of the load pattern for the point load.
Value: This is an array of six point load values.
Value(0) = F1 [F]
Value(1) = F2 [F]
Value(2) = F3 [F]
Value(3) = M1 [FL]
Value(4) = M2 [FL]
Value(5) = M3 [FL]
Replace: If this item is True, all previous point loads, if any, assigned to the specified point object(s) in the specified load pattern are deleted before making the new assignment.
CSys: The name of the coordinate system for the considered point load. This is Local or the name of a defined coordinate system.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignment is made to the point object specified by the Name item.
If this item is Group, the load assignment is made to all point objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignment is made to all selected point objects and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Value, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetLoadForce(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadForce" failed')
        
        return ret

    def SetLocalAxesAdvanced(self, Name = None, Active = None, AxVectOpt = None, PlVectOpt = None, AxCSys = None, PlCSys = None, AxDir = None, PlDir = None, AxPt = None, PlPt = None, AxVect = None, PlVect = None, Plane2 = None, ItemType = None):
        """
This function assigns advanced local axes to point objects.
The function returns zero if the advanced local axes assignments are assigned successfully; otherwise it returns a nonzero value.

Name: The name of an existing point object or group, depending on the value of the ItemType item.
Active: This is True if advanced local axes exist.
AxVectOpt: This is 1, 2 or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
PlVectOpt: This is 1, 2 or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
AxCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
PlCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
AxDir: This is an array dimensioned to 1 (2 integers), indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
PlDir: This is an array dimensioned to 1 (2 integers), indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
AxPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
PlPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
AxVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
PlVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
Plane2: This is 12, 13, 21, 23, 31 or 32, indicating that the local plane determined by the plane reference vector is the 1-2, 1-3, 2-1, 2-3, 3-1, 0r 3-2 plane. This item applies only when the Active item is True.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
Selection = 2

If this item is Object, the assignment is made to the point object specified by the Name item.
If this item is Group, the assignment is made to all point objects in the group specified by the Name item.
If this item is Selection, assignment is made to all selected point objects and the Name item is ignored.
        """

        all_args = [Name, Active, AxVectOpt, PlVectOpt, AxCSys, PlCSys, AxDir, PlDir, AxPt, PlPt, AxVect, PlVect, Plane2, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetLocalAxesAdvanced(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxesAdvanced" failed')
        
        return ret

    def SetLocalAxes(self, Name = None, a = None, b = None, c = None, ItemType = None):
        """
This function sets the local axes angles for point objects.
The function returns zero if the local axes angles are successfully set, otherwise it returns a nonzero value.

Name: The name of an existing point object or group depending on the value of the ItemType item.
a: The local axes of the point are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
b: The local axes of the point are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
c: The local axes of the point are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the local axes assignment is made to the point object specified by the Name item.
If this item is Group, the local axes assignment is made to all point objects in the group specified by the Name item.
If this item is SelectedObjects, the local axes assignment is made to all selected point objects and the Name item is ignored.
        """

        all_args = [Name, a, b, c, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxes" failed')
        
        return ret

    def SetMass(self, Name = None, m = None, ItemType = None, IsLocalCSys = None, Replace = None):
        """
This function assigns point mass to a point object.
The function returns zero if the mass is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing point object or group depending on the value of the ItemType item.
m: This is an array of six mass assignment values.
Value(0) = U1 [M]
Value(1) = U2 [M]
Value(2) = U3 [M]
Value(3) = R1 [ML2]
Value(4) = R2 [ML2]
Value(5) = R3 [ML2]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the mass assignment is made to the point object specified by the Name item.
If this item is Group, the mass assignment is made to all point objects in the group specified by the Name item.
If this item is SelectedObjects, the mass assignment is made to all selected point objects and the Name item is ignored.
IsLocalCSys: If this item is True, the specified mass assignments are in the point object local coordinate system. If it is False, the assignments are in the Global coordinate system.
Replace: If this item is True, all existing point mass assignments to the specified point object(s) are deleted prior to making the assignment. If it is False, the mass assignments are added to any existing assignments.
        """

        all_args = [Name, m, ItemType, IsLocalCSys, Replace]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetMass(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMass" failed')
        
        return ret

    def SetMergeNumber(self, Name = None, MergeNumber = None, ItemType = None):
        """
This function assigns a merge number to a point object. By default the merge number for a point is zero. Points with different merge numbers are not automatically merged by the program.
The function returns zero if the merge number is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing point object or group depending on the value of the ItemType item.
MergeNumber: The merge number for the specified point object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the merge number assignment is made to the point object specified by the Name item.
If this item is Group, the merge number assignment is made to all point objects in the group specified by the Name item.
If this item is SelectedObjects, the merge number assignment is made to all selected point objects and the Name item is ignored.
        """

        all_args = [Name, MergeNumber, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetMergeNumber(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMergeNumber" failed')
        
        return ret

    def SetPatternByPressure(self, Name = None, PatternName = None, z = None, w = None, u = None, r = None, ItemType = None, Restriction = None, Replace = None):
        """
This function sets the joint pattern value for a specified point object and joint pattern.
The joint pattern value is calculated as:
Value = [(z – zpoint) * w] + u
where z, w and u are described in the Parameters section and zpoint is the Z coordinate of the considered point object in the present coordinate system. All appropriate unit conversions are used to calculate the value in the database units, but thereafter it is assumed to be unitless.
The function returns zero if the pattern value is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing point object or group depending on the value of the ItemType item.
PatternName: The name of a defined joint pattern.
z: The Z coordinate at zero pressure in the present coordinate system. [L]
w: A weight per unit volume. [F/L3]
u: An added uniform force per unit area. [F/L2]
r: This is 0, 1, or 2.
0 = All values are used
1 = Negative values are set to zero
2 = Positive values are set to zero

This restriction applies before the pattern value has been added to any existing pattern value assigned to the point object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2
If this item is Object, the joint pattern assignment is made to the point object specified by the Name item.
If this item is Group, the joint pattern assignment is made to all point objects in the group specified by the Name item.
If this item is SelectedObjects, the joint pattern assignment is made to all selected point objects and the Name item is ignored.
Restriction: This is 0, 1, or 2.
0 = All values are used
1 = Negative values are set to zero
2 = Positive values are set to zero

This restriction applies after the pattern value has been added to any existing pattern value assigned to the point object. This restriction applies even if there was no existing joint pattern value on the point object.
Replace: If this item is True, the joint pattern value calculated as shown in the Remarks section replaces any previous joint pattern value for the point object.
If this item is False, the joint pattern value calculated as shown in the Remarks section is added to any previous joint pattern value for the point object and then the Restriction items are checked.
        """

        all_args = [Name, PatternName, z, w, u, r, ItemType, Restriction, Replace]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetPatternByPressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPatternByPressure" failed')
        
        return ret

    def SetRestraint(self, Name = None, Value = None, ItemType = 0):
        """
This function assigns the restraint assignments for a point object. The restraint assignments are always set in the point local coordinate system.
The function returns zero if the restraint assignments are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing point object or group depending on the value of the ItemType item.
Value: This is an array of six restraint values.
Value(0) = U1
Value(1) = U2
Value(2) = U3
Value(3) = R1
Value(4) = R2
Value(5) = R3
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the restraint assignment is made to the point object specified by the Name item.
If this item is Group, the restraint assignment is made to all point objects in the group specified by the Name item.
If this item is SelectedObjects, the restraint assignment is made to all selected point objects and the Name item is ignored.
        """

        all_args = [Name, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetRestraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetRestraint" failed')
        
        return ret

    def SetSelected(self, Name = None, Selected = None, ItemType = None):
        """
This function sets the selected status for a point object.
The function returns zero if the selected status is successfully set, otherwise it returns a nonzero value.

Name: The name of an existing point object or group depending on the value of the ItemType item.
Selected: This item is True if the specified point object is selected, otherwise it is False.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the selected status is set for the point object specified by the Name item.
If this item is Group, the selected status is set for all point objects in the group specified by the Name item.
If this item is SelectedObjects, the selected status is set for all selected point objects and the Name item is ignored.
        """

        all_args = [Name, Selected, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetSelected(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSelected" failed')
        
        return ret

    def SetSpecialPoint(self, Name = None, SpecialPoint = None, ItemType = None):
        """
This function sets the special point status for a point object.
The function returns zero if the special point status is successfully set, otherwise it returns a nonzero value.
Special points are allowed to exist in the model even if no objects (line, area, solid, link) are connected to them. Points that are not special are automatically deleted if no objects connect to them.

Name: The name of an existing point object or group depending on the value of the ItemType item.
SpecialPoint: This item is True if the point object is specified as a special point, otherwise it is False.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the special point status is set for the point object specified by the Name item.
If this item is Group, the special point status is set for all point objects in the group specified by the Name item.
If this item is SelectedObjects, the special point status is set for all selected point objects and the Name item is ignored.
        """

        all_args = [Name, SpecialPoint, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetSpecialPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSpecialPoint" failed')
        
        return ret

    def SetSpring(self, Name = None, k = None, ItemType = None, IsLocalCSys = None, Replace = None):
        """
This function assigns coupled springs to a point object.
The function returns zero if the stiffnesses are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing point object or group depending on the value of the ItemType item.
k: This is an array of six spring stiffness values.
Value(0) = U1 [F/L]
Value(1) = U2 [F/L]
Value(2) = U3 [F/L]
Value(3) = R1 [FL/rad]
Value(4) = R2 [FL/rad]
Value(5) = R3 [FL/rad]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the spring assignment is made to the point object specified by the Name item.
If this item is Group, the spring assignment is made to all point objects in the group specified by the Name item.
If this item is SelectedObjects, the spring assignment is made to all selected point objects and the Name item is ignored.
IsLocalCSys: If this item is True, the specified spring assignments are in the point object local coordinate system. If it is False, the assignments are in the Global coordinate system.
Replace: If this item is True, all existing point spring assignments to the specified point object(s) are deleted prior to making the assignment. If it is False, the spring assignments are added to any existing assignments.
        """

        all_args = [Name, k, ItemType, IsLocalCSys, Replace]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSpring" failed')
        
        return ret

    def SetSpringCoupled(self, Name = None, k = None, ItemType = None, IsLocalCSys = None, Replace = None):
        """
This function assigns coupled springs to a point object.
The function returns zero if the stiffnesses are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing point object or group depending on the value of the ItemType item.
k: This is an array of twenty one spring stiffness values.
Value(0) = U1U1 [F/L]
Value(1) = U1U2 [F/L]
Value(2) = U2U2 [F/L]
Value(3) = U1U3 [F/L]
Value(4) = U2U3 [F/L]
Value(5) = U3U3 [F/L]
Value(6) = U1R1 [F/rad]
Value(7) = U2R1 [F/rad]
Value(8) = U3R1 [F/rad]
Value(9) = R1R1 [FL/rad]
Value(10) = U1R2 [F/rad]
Value(11) = U2R2 [F/rad]
Value(12) = U3R2 [F/rad]
Value(13) = R1R2 [FL/rad]
Value(14) = R2R2 [FL/rad]
Value(15) = U1R3 [F/rad]
Value(16) = U2R3 [F/rad]
Value(17) = U3R3 [F/rad]
Value(18) = R1R3 [FL/rad]
Value(19) = R2R3 [FL/rad]
Value(20) = R3R3 [FL/rad]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the spring assignment is made to the point object specified by the Name item.
If this item is Group, the spring assignment is made to all point objects in the group specified by the Name item.
If this item is SelectedObjects, the spring assignment is made to all selected point objects and the Name item is ignored.
IsLocalCSys: If this item is True, the specified spring assignments are in the point object local coordinate system. If it is False, the assignments are in the Global coordinate system.
Replace: If this item is True, all existing point spring assignments to the specified point object(s) are deleted prior to making the assignment. If it is False, the spring assignments are added to any existing assignments.
        """

        all_args = [Name, k, ItemType, IsLocalCSys, Replace]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.PointObj.SetSpringCoupled(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSpringCoupled" failed')
        
        return ret

class SolidObj:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def AddByCoord(self, x = None, y = None, z = None, Name = None, PropName = None, UserName = None, CSys = None):
        """
This function adds a new solid object whose corner points are at the specified coordinates. Note that solid objects always are defined with eight corner points.
The function returns zero if the solid object is successfully added; otherwise it returns a nonzero value.

x: These are arrays of x, y and z coordinates, respectively, for the corner points of the solid object. The coordinates are in the coordinate system defined by the CSys item.
y: These are arrays of x, y and z coordinates, respectively, for the corner points of the solid object. The coordinates are in the coordinate system defined by the CSys item.
z: These are arrays of x, y and z coordinates, respectively, for the corner points of the solid object. The coordinates are in the coordinate system defined by the CSys item.
Name: This is the name that the program ultimately assigns for the solid object. If no UserName is specified, the program assigns a default name to the solid object. If a UserName is specified and that name is not used for another solid object, the UserName is assigned to the solid object; otherwise a default name is assigned to the solid object.
PropName: This is either Default or the name of a defined solid property.
If it is Default, the program assigns a default solid property to the solid object. If it is the name of a defined solid property, that property is assigned to the solid object.
UserName: This is an optional user specified name for the solid object. If a UserName is specified and that name is already used for another solid object, the program ignores the UserName.
CSys: The name of the coordinate system in which the solid object point coordinates are defined.
        """

        all_args = [x, y, z, Name, PropName, UserName, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.AddByCoord(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddByCoord" failed')
        
        return ret

    def AddByPoint(self, Point = None, Name = None, PropName = None, UserName = None):
        """
This function adds a new solid object whose corner points are specified by name.
The function returns zero if the solid object is successfully added; otherwise it returns a nonzero value.

Point: This is an array containing the names of the eight point objects that define the corner points of the added solid object.
Name: This is the name that the program ultimately assigns for the solid object. If no UserName is specified, the program assigns a default name to the solid object. If a UserName is specified and that name is not used for another solid object, the UserName is assigned to the solid object; otherwise a default name is assigned to the solid object.
PropName: This is either Default or the name of a defined solid property.
If it is Default, the program assigns a default solid property to the solid object. If it is the name of a defined solid property, that property is assigned to the solid object.
UserName: This is an optional user specified name for the solid object. If a UserName is specified and that name is already used for another solid object, the program ignores the UserName.
        """

        all_args = [Point, Name, PropName, UserName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.AddByPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddByPoint" failed')
        
        return ret

    def ChangeName(self, Name = None, NewName = None):
        """
This function applies a new name to a solid object.
The function returns zero if the new name is successfully applied; otherwise it returns a nonzero value.

Name: The existing name of a defined solid object.
NewName: The new name for the solid object.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns a count of the solid objects in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def DeleteLoadGravity(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the gravity load assignments to the specified solid objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the solid object specified by the Name item.
If this item is Group, the load assignments are deleted for all solid objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.DeleteLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadGravity" failed')
        
        return ret

    def DeleteLoadPorePressure(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the pore pressure load assignments to the specified solid objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the solid object specified by the Name item.
If this item is Group, the load assignments are deleted for all solid objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.DeleteLoadPorePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadPorePressure" failed')
        
        return ret

    def DeleteLoadStrain(self, Name = None, LoadPat = None, Component = None, ItemType = None):
        """
This function deletes the strain load assignments to the specified solid objects, for the specified load pattern, for the specified components.
The function returns zero if the load assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Component: This is 1, 2, 3, 4, 5 or 6, indicating the component for which the strain load is to be deleted.
1 = Strain11
2 = Strain22
3 = Strain33
4 = Strain12
5 = Strain13
6 = Strain23
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the solid object specified by the Name item.
If this item is Group, the load assignments are deleted for all solid objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Component, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.DeleteLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadStrain" failed')
        
        return ret

    def DeleteLoadSurfacePressure(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the surface pressure load assignments to the specified solid objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the solid object specified by the Name item.
If this item is Group, the load assignments are deleted for all solid objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.DeleteLoadSurfacePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadSurfacePressure" failed')
        
        return ret

    def DeleteLoadTemperature(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the temperature load assignments to the specified solid objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the solid object specified by the Name item.
If this item is Group, the load assignments are deleted for all solid objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.DeleteLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadTemperature" failed')
        
        return ret

    def DeleteSpring(self, Name = None, ItemType = None):
        """
This function deletes all spring assignments for the specified solid objects.
The function returns zero if the assignments are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the spring assignments are deleted for the solid object specified by the Name item.
If this item is Group, the spring assignments are deleted for all solid objects in the group specified by the Name item.
If this item is SelectedObjects, the spring assignments are deleted for all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.DeleteSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteSpring" failed')
        
        return ret

    def Delete(self, Name = None, ItemType = None):
        """
The function deletes solid objects.
The function returns zero if the solid objects are successfully deleted; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the solid object specified by the Name item is deleted.
If this item is Group, the all solid objects in the group specified by the Name item are deleted.
If this item is SelectedObjects, all selected solid objects are deleted, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetAutoMesh(self, Name = None, MeshType = None, n1 = None, n2 = None, n3 = None, MaxSize1 = None, MaxSize2 = None, MaxSize3 = None, RestraintsOnEdge = None, RestraintsOnFace = None):
        """
This function retrieves the automatic meshing assignments to solid objects.
The function returns zero if the meshing assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid object.
MeshType: This item is 0, 1 or 2, indicating the automatic mesh type for the solid object.
0 = No automatic meshing
1 = Mesh solid into a specified number of objects
2 = Mesh solid into objects of a specified maximum size

n1: This item applies when MeshType = 1. It is the number of objects created along the edge of the meshed solid object that runs from point 1 to point 2.
n2: This item applies when MeshType = 1. It is the number of objects created along the edge of the meshed solid object that runs from point 1 to point 3.
n3: This item applies when MeshType = 1. It is the number of objects created along the edge of the meshed solid object that runs from point 1 to point 5.
MaxSize1: This item applies when MeshType = 2. It is the maximum size of objects created along the edge of the meshed solid object that runs from point 1 to point 2. [L]
If this item is input as 0, the default value is used. The default value is 48 inches if the database units are English or 120 centimeters if the database units are metric.
MaxSize2: This item applies when MeshType = 2. It is the maximum size of objects created along the edge of the meshed solid object that runs from point 1 to point 3. [L]
If this item is input as 0, the default value is used. The default value is 48 inches if the database units are English or 120 centimeters if the database units are metric.
MaxSize3: This item applies when MeshType = 2. It is the maximum size of objects created along the edge of the meshed solid object that runs from point 1 to point 5. [L]
If this item is input as 0, the default value is used. The default value is 48 inches if the database units are English or 120 centimeters if the database units are metric.
RestraintsOnEdge: If this item is True, and if both points along an edge of the original solid object have the same restraint/constraint, then, if the an added point on that edge and the original corner points have the same local axes definition, the program assigns the restraint/constraint to the added point.
RestraintsOnFace: If this item is True, and if all corner points on an solid object face have the same restraint/constraint, then, if an added point on that face and the original corner points for the face have the same local axes definition, the program assigns the restraint/constraint to the added point.
        """

        all_args = [Name, MeshType, n1, n2, n3, MaxSize1, MaxSize2, MaxSize3, RestraintsOnEdge, RestraintsOnFace]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetAutoMesh(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetAutoMesh" failed')
        
        return ret

    def GetEdgeConstraint(self, Name = None, ConstraintExists = None):
        """
This function retrieves the generated edge constraint assignments to solid objects.
The function returns zero if the assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid object.
ConstraintExists: This item is True if an automatic edge constraint is generated by the program for the solid object in the analysis model.
        """

        all_args = [Name, ConstraintExists]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetEdgeConstraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetEdgeConstraint" failed')
        
        return ret

    def GetElm(self, Name = None, nelm = None, Elm = None):
        """
This function retrieves the names of the solid elements (analysis model solid) associated with a specified solid object in the object-based model.
This function returns zero if the solid element information is successfully returned; otherwise it returns nonzero. An error occurs if the analysis model does not exist.

Name: The name of an existing solid object.
nelm: The number of solid elements created from the specified solid object.
Elm: An array that includes the name of a solid element created from the specified solid object.
        """

        all_args = [Name, nelm, Elm]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetElm(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetElm" failed')
        
        return ret

    def GetGroupAssign(self, Name = None, NumberGroups = None, Groups = None):
        """
This function retrieves the names of the groups to which a specified solid object is assigned.
The function returns zero if the group assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing solid object.
NumberGroups: The number of group names retrieved.
Groups: The names of the groups to which the solid object is assigned.
        """

        all_args = [Name, NumberGroups, Groups]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGroupAssign" failed')
        
        return ret

    def GetGUID(self, Name = None, GUID = None):
        """
This function retrieves the GUID for the specified solid object.
This function returns zero if the solid object GUID is successfully retrieved; otherwise it returns nonzero.

Name: The name of an existing solid object.
GUID: The GUID (Global Unique ID) for the specified solid object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGUID" failed')
        
        return ret

    def GetLoadGravity(self, Name = None, NumberItems = None, SolidName = None, LoadPat = None, CSys = None, x = None, y = None, z = None, ItemType = None):
        """
This function retrieves the gravity load assignments to solid objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
NumberItems: The total number of gravity loads retrieved for the specified solid objects.
SolidName: This is an array that includes the name of the solid object associated with each gravity load.
LoadPat: This is an array that includes the name of the coordinate system in which the gravity load multipliers are specified.
CSys: This is an array that includes the name of the coordinate system associated with each gravity load.
x: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the solid object specified by the Name item.
If this item is Group, the assignments are retrieved for all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, SolidName, LoadPat, CSys, x, y, z, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadGravity" failed')
        
        return ret

    def GetLoadPorePressure(self, Name = None, NumberItems = None, SolidName = None, LoadPat = None, Value = None, PatternName = None, ItemType = None):
        """
This function retrieves the pore pressure load assignments to solid objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
NumberItems: The total number of pore pressure loads retrieved for the specified solid objects.
SolidName: This is an array that includes the name of the solid object associated with each pore pressure load.
LoadPat: This is an array that includes the name of the load pattern associated with each pore pressure load.
Value: This is an array that includes the pore pressure load value. [F/L2]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the pore pressure load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the solid object specified by the Name item.
If this item is Group, the assignments are retrieved for all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, SolidName, LoadPat, Value, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetLoadPorePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadPorePressure" failed')
        
        return ret

    def GetLoadStrain(self, Name = None, NumberItems = None, SolidName = None, LoadPat = None, Component = None, Value = None, PatternName = None, ItemType = None):
        """
This function retrieves the strain load assignments to solid objects.
The function returns zero if the strain load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
NumberItems: The total number of strain loads retrieved for the specified solid objects.
SolidName: This is an array that includes the name of the solid object associated with each strain load.
LoadPat: This is an array that includes the name of the load pattern associated with each strain load.
Component: This is 1, 2, 3, 4, 5 or 6, indicating the component to which the strain load is applied.
1 = Strain11
2 = Strain22
3 = Strain33
4 = Strain12
5 = Strain13
6 = Strain23
Value: This is an array that includes the strain value. [L/L]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the strain load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the solid object specified by the Name item.
If this item is Group, the assignments are retrieved for all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, SolidName, LoadPat, Component, Value, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadStrain" failed')
        
        return ret

    def GetLoadSurfacePressure(self, Name = None, NumberItems = None, SolidName = None, LoadPat = None, Face = None, Value = None, PatternName = None, ItemType = None):
        """
This function retrieves the surface pressure load assignments to solid objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
NumberItems: The total number of surface pressure loads retrieved for the specified solid objects.
SolidName: This is an array that includes the name of the solid object associated with each surface pressure load.
LoadPat: This is an array that includes the name of the load pattern associated with each surface pressure load.
Face: This is an array that includes 1, 2, 3, 4, 5 or 6, indicating the solid object face to which the specified load assignment applies.
Value: This is an array that includes the surface pressure load value. [F/L2]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the surface pressure load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the solid object specified by the Name item.
If this item is Group, the assignments are retrieved for all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, SolidName, LoadPat, Face, Value, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetLoadSurfacePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadSurfacePressure" failed')
        
        return ret

    def GetLoadTemperature(self, Name = None, NumberItems = None, SolidName = None, LoadPat = None, Value = None, PatternName = None, ItemType = None):
        """
This function retrieves the temperature load assignments to solid objects.
The function returns zero if the load assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
NumberItems: The total number of temperature loads retrieved for the specified solid objects.
SolidName: This is an array that includes the name of the solid object associated with each temperature load.
LoadPat: This is an array that includes the name of the load pattern associated with each temperature load.
Value: This is an array that includes the temperature load value. [T]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the temperature load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the solid object specified by the Name item.
If this item is Group, the assignments are retrieved for all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, SolidName, LoadPat, Value, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTemperature" failed')
        
        return ret

    def GetLocalAxesAdvanced(self, Name = None, Active = None, AxVectOpt = None, PlVectOpt = None, AxCSys = None, PlCSys = None, AxDir = None, PlDir = None, AxPt = None, PlPt = None, AxVect = None, PlVect = None, Plane2 = None):
        """
This function assigns advanced local axes to solid objects.
The function returns zero if the advanced local axes assignments are assigned successfully; otherwise it returns a nonzero value.

Name: The name of an existing solid object.
Active: This is True if advanced local axes exist.
AxVectOpt: This is 1, 2 or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
PlVectOpt: This is 1, 2 or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
AxCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
PlCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
AxDir: This is an array dimensioned to 1 (2 integers) indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
PlDir: This is an array dimensioned to 1 (2 integers) indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
AxPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
PlPt: This is an array dimensioned to 1 (2 strings), indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
AxVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
PlVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
Plane2: This is 12, 13, 21, 23, 31 or 32, indicating that the local plane determined by the plane reference vector is the 1-2, 1-3, 2-1, 2-3, 3-1, 0r 3-2 plane. This item applies only when the Active item is True.
        """

        all_args = [Name, Active, AxVectOpt, PlVectOpt, AxCSys, PlCSys, AxDir, PlDir, AxPt, PlPt, AxVect, PlVect, Plane2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetLocalAxesAdvanced(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxesAdvanced" failed')
        
        return ret

    def GetLocalAxes(self, Name = None, a = None, b = None, c = None, Advanced = None):
        """
This function retrieves the local axes angles for a solid object.
The function returns zero if the local axes angles are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid object.
a: The local axes of the solid object are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
b: The local axes of the solid object are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
c: The local axes of the solid object are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
Advanced: This item is True if the solid object local axes orientation was obtained using advanced local axes parameters.
        """

        all_args = [Name, a, b, c, Advanced]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxes" failed')
        
        return ret

    def GetMatTemp(self, Name = None, Temp = None, PatternName = None):
        """
This function retrieves the material temperature assignments to solid objects.
The function returns zero if the material temperature assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid object.
Temp: This is the material temperature value assigned to the solid object. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the solid object is uniform over the object at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the solid object may vary. The material temperature at each corner point of the solid object is equal to the specified temperature multiplied by the pattern value at the associated point object. The material temperature at other points in the solid object is calculated by interpolation from the corner points.
        """

        all_args = [Name, Temp, PatternName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMatTemp" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined solid objects.
The function returns zero if the names are successfully retrieved; otherwise it returns nonzero.

NumberNames: The number of solid object names retrieved by the program.
MyName: This is a one-dimensional array of solid object names. The MyName array is created as a dynamic, zero-based, array by the APIuser:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the SAP2000 program, filled with the names, and returned to the APIuser.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetPoints(self, Name = None, Point = None):
        """
This function retrieves the names of the corner point objects of a solid object.
The function returns zero if the point object names are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined solid object.
Point: This is an array containing the names of the corner point objects of the solid object.
        """

        all_args = [Name, Point]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPoints" failed')
        
        return ret

    def GetProperty(self, Name = None, PropName = None):
        """
This function retrieves the solid property assigned to a solid object.
The function returns zero if the property is successfully retrieved; otherwise it returns a nonzero value.

Name: The name of a defined solid object.
PropName: The name of the solid property assigned to the solid object.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProperty" failed')
        
        return ret

    def GetSpring(self, Name = None, NumberSprings = None, MyType = None, s = None, SimpleSpringType = None, LinkProp = None, Face = None, SpringLocalOneType = None, Dir = None, Outward = None, VecX = None, VecY = None, VecZ = None, CSys = None, Ang = None):
        """
This function retrieves the spring assignments to a solid object face.
The function returns zero if the assignments are successfully retrieved; otherwise it returns a nonzero value.

Name: The name of an existing solid object.
NumberSprings: The number of springs assignments made to the specified solid object.
MyType: Each value in this array is either 1 or 2, indicating the spring property type.
1 = Simple spring
2 = Link property
s: Each value in this array is the simple spring stiffness per unit area of the specified solid object face. This item applies only when the corresponding MyType = 1. [F/L3]
SimpleSpringType: Each value in this array is 1, 2 or 3, indicating the simple spring type. This item applies only when the corresponding MyType = 1.
1 = Spring resists tension and compression
2 = Spring resists compression only
3 = Spring resists tension only
LinkProp: Each value in this array is the name of the link property assigned to the spring. This item applies only when the corresponding MyType = 2.
Face: This is 1, 2, 3, 4, 5 or 6, indicating the solid object face to which the specified spring assignment applies.
SpringLocalOneType: Each value in this array is 1, 2 or 3, indicating the method used to specify the spring positive local 1-axis orientation.
1 = Parallel to solid object local axis
2 = Normal to specified solid object face
3 = User specified direction vector
Dir: Each value in this array is 1, 2, 3, -1, -2 or -3, indicating the solid object local axis that corresponds to the positive local 1-axis of the spring. This item applies only when the corresponding SpringLocalOneType = 1.
Outward: Each value in this array is True if the spring positive local 1 axis is outward from the specified solid object face. This item applies only when SpringLocalOneType = 2.
VecX: Each value in this array is the X-axis or solid object local 1-axis component (depending on the CSys specified) of the user specified direction vector for the spring local 1-axis. The direction vector is in the coordinate system specified by the CSys item. This item applies only when the corresponding SpringLocalOneType = 3.
VecY: Each value in this array is the Y-axis or solid object local 2-axis component (depending on the CSys specified) of the user specified direction vector for the spring local 1-axis. The direction vector is in the coordinate system specified by the CSys item. This item applies only when the corresponding SpringLocalOneType = 3.
VecZ: Each value in this array is the X-axis or solid object local 3-axis component (depending on the CSys specified) of the user specified direction vector for the spring local 1-axis. The direction vector is in the coordinate system specified by the CSys item. This item applies only when the corresponding SpringLocalOneType = 3.
CSys: Each value in this array is Local (meaning the solid object local coordinate system) or the name of a defined coordinate system. This item is the coordinate system in which the user specified direction vector, Vec, is specified. This item applies only when the corresponding SpringLocalOneType = 3.
Ang: Each value in this array is the angle that the link local 2-axis is rotated from its default orientation. This item applies only when the corresponding MyType = 2. [deg]
        """

        all_args = [Name, NumberSprings, MyType, s, SimpleSpringType, LinkProp, Face, SpringLocalOneType, Dir, Outward, VecX, VecY, VecZ, CSys, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.GetSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSpring" failed')
        
        return ret

    def SetAutoMesh(self, Name = None, MeshType = None, n1 = None, n2 = None, n3 = None, MaxSize1 = None, MaxSize2 = None, MaxSize3 = None, RestraintsOnEdge = None, RestraintsOnFace = None):
        """
This function makes automatic meshing assignments to solid objects.
The function returns zero if the meshing options are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
MeshType: This item is 0, 1 or 2, indicating the automatic mesh type for the solid object.
0 = No automatic meshing
1 = Mesh solid into a specified number of objects
2 = Mesh solid into objects of a specified maximum size

n1: This item applies when MeshType = 1. It is the number of objects created along the edge of the meshed solid object that runs from point 1 to point 2.
n2: This item applies when MeshType = 1. It is the number of objects created along the edge of the meshed solid object that runs from point 1 to point 3.
n3: This item applies when MeshType = 1. It is the number of objects created along the edge of the meshed solid object that runs from point 1 to point 5.
MaxSize1: This item applies when MeshType = 2. It is the maximum size of objects created along the edge of the meshed solid object that runs from point 1 to point 2. [L]
If this item is input as 0, the default value is used. The default value is 48 inches if the database units are English or 120 centimeters if the database units are metric.
MaxSize2: This item applies when MeshType = 2. It is the maximum size of objects created along the edge of the meshed solid object that runs from point 1 to point 3. [L]
If this item is input as 0, the default value is used. The default value is 48 inches if the database units are English or 120 centimeters if the database units are metric.
MaxSize3: This item applies when MeshType = 2. It is the maximum size of objects created along the edge of the meshed solid object that runs from point 1 to point 5. [L]
If this item is input as 0, the default value is used. The default value is 48 inches if the database units are English or 120 centimeters if the database units are metric.
RestraintsOnEdge: If this item is True, and if both points along an edge of the original solid object have the same restraint/constraint, then, if the an added point on that edge and the original corner points have the same local axes definition, the program assigns the restraint/constraint to the added point.
RestraintsOnFace: If this item is True, and if all corner points on an solid object face have the same restraint/constraint, then, if an added point on that face and the original corner points for the face have the same local axes definition, the program assigns the restraint/constraint to the added point.
        """

        all_args = [Name, MeshType, n1, n2, n3, MaxSize1, MaxSize2, MaxSize3, RestraintsOnEdge, RestraintsOnFace]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetAutoMesh(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetAutoMesh" failed')
        
        return ret

    def SetEdgeConstraint(self, Name = None, ConstraintExists = None, ItemType = None):
        """
This function makes generated edge constraint assignments to solid objects.
The function returns zero if the edge constraint option is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
ConstraintExists: This item is True if an automatic edge constraint is generated by the program for the solid object in the analysis model.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the solid object specified by the Name item.
If this item is Group, the assignment is made to all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, ConstraintExists, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetEdgeConstraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetEdgeConstraint" failed')
        
        return ret

    def SetGroupAssign(self, Name = None, GroupName = None, Remove = None, ItemType = None):
        """
This function adds or removes solid objects from a specified group.
The function returns zero if the group assignment is successful; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
GroupName: The name of an existing group to which the assignment is made.
Remove: If this item is False, the specified solid objects are added to the group specified by the GroupName item. If it is True, the solid objects are removed from the group.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the solid object specified by the Name item is added or removed from the group specified by the GroupName item.
If this item is Group, all solid objects in the group specified by the Name item are added or removed from the group specified by the GroupName item.
If this item is SelectedObjects, all selected solid objects are added or removed from the group specified by the GroupName item, and the Name item is ignored.
        """

        all_args = [Name, GroupName, Remove, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGroupAssign" failed')
        
        return ret

    def SetGUID(self, Name = None, GUID = None):
        """
This function sets the GUID for the specified solid object. If the GUID is passed in as a blank string, the program automatically creates a GUID for the object.
This function returns zero if the solid object GUID is successfully set; otherwise it returns nonzero.

Name: The name of an existing solid object.
GUID: The GUID (Global Unique ID) for the specified solid object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGUID" failed')
        
        return ret

    def SetLoadGravity(self, Name = None, LoadPat = None, x = None, y = None, z = None, Replace = None, CSys = None, ItemType = None):
        """
This function assigns gravity load multipliers to solid objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
x: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
Replace: If this item is True, all previous gravity loads, if any, assigned to the specified solid object(s), in the specified load pattern, are deleted before making the new assignment.
CSys: The coordinate system in which the x, y and z multipliers are specified.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the solid object specified by the Name item.
If this item is Group, the assignment is made to all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, x, y, z, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadGravity" failed')
        
        return ret

    def SetLoadPorePressure(self, Name = None, LoadPat = None, Value = None, PatternName = None, Replace = None, ItemType = None):
        """
This function assigns pore pressure loads to solid objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Value: This is the pore pressure value. [F/L2]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the pore pressure load for the solid object is uniform over the object at the value specified by Value.
If PatternName is the name of a defined joint pattern, the pore pressure load for the solid object is based on the specified pore pressure value multiplied by the pattern value at the corner point objects of the solid object.
Replace: If this item is True, all previous pore pressure loads, if any, assigned to the specified solid object(s), in the specified load case, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the solid object specified by the Name item.
If this item is Group, the assignment is made to all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Value, PatternName, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetLoadPorePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadPorePressure" failed')
        
        return ret

    def SetLoadStrain(self, Name = None, LoadPat = None, Component = None, Value = None, Replace = None, PatternName = None, ItemType = None):
        """
This function assigns strain loads to solid objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Component: This is 1, 2, 3, 4, 5 or 6, indicating the component to which the strain load is applied.
1 = Strain11
2 = Strain22
3 = Strain33
4 = Strain12
5 = Strain13
6 = Strain23
Value: This is the strain load value. [L/L]
Replace: If this item is True, all previous strain loads, if any, assigned to the specified solid object(s), in the specified load pattern, for the specified degree of freedom, are deleted before making the new assignment.
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the strain load for the solid object is uniform over the object at the value specified by Value.
If PatternName is the name of a defined joint pattern, the strain load for the solid object is based on the specified strain value multiplied by the pattern value at the corner point objects of the solid object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the solid object specified by the Name item.
If this item is Group, the assignment is made to all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Component, Value, Replace, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadStrain" failed')
        
        return ret

    def SetLoadSurfacePressure(self, Name = None, LoadPat = None, Face = None, Value = None, PatternName = None, Replace = None, ItemType = None):
        """
This function assigns surface pressure loads to solid objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Face: This is 1, 2, 3, 4, 5 or 6, indicating the solid object face to which the specified load assignment applies.
Value: This is the surface pressure value. [F/L2]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the surface pressure load for the solid object is uniform over the object at the value specified by Value.
If PatternName is the name of a defined joint pattern, the surface pressure load for the solid object is based on the specified surface pressure value multiplied by the pattern value at the corner point objects of the solid object.
Replace: If this item is True, all previous surface pressure loads, if any, assigned to the specified solid object(s), on the specified face, in the specified load pattern, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the solid object specified by the Name item.
If this item is Group, the assignment is made to all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Face, Value, PatternName, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetLoadSurfacePressure(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadSurfacePressure" failed')
        
        return ret

    def SetLoadTemperature(self, Name = None, LoadPat = None, Value = None, PatternName = None, Replace = None, ItemType = None):
        """
This function assigns temperature loads to solid objects.
The function returns zero if the loads are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Value: This is the temperature change value. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the temperature load for the solid object is uniform over the object at the value specified by Value.
If PatternName is the name of a defined joint pattern, the temperature load for the solid object is based on the specified temperature value multiplied by the pattern value at the corner point objects of the solid object.
Replace: If this item is True, all previous temperature loads, if any, assigned to the specified solid object(s), in the specified load case, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the solid object specified by the Name item.
If this item is Group, the assignment is made to all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Value, PatternName, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadTemperature" failed')
        
        return ret

    def SetLocalAxesAdvanced(self, Name = None, Active = None, AxVectOpt = None, PlVectOpt = None, AxCSys = None, PlCSys = None, AxDir = None, PlDir = None, AxPt = None, PlPt = None, AxVect = None, PlVect = None, Plane2 = None, ItemType = None):
        """
This function assigns advanced local axes to solid objects.
The function returns zero if the advanced local axes assignments are assigned successfully; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
Active: This is True if advanced local axes exist.
AxVectOpt: This is 1, 2, or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
PlVectOpt: This is 1, 2, or 3, indicating the axis/plane reference vector option. This item applies only when the Active item is True.
1 = Coordinate direction
2 = Two joints
3 = User vector
AxCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
PlCSys: The coordinate system used to define the axis/plane reference vector coordinate directions and the axis/plane user vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1 or 3.
AxDir: This is an array dimensioned to 1 (2 integers) indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
PlDir: This is an array dimensioned to 1 (2 integers) indicating the axis/plane reference vector primary and secondary coordinate directions, PlDir(0) and PlDir(1) respectively, taken at the object center in the specified coordinate system and used to determine the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 1. Possible coordinate direction values are:
1 = +X-1 = -X
2 = +Y-2 = -Y
3 = +Z-3 = -Z
4 = +CR-4 = -CR
5 = +CA-5 = -CA
6 = +CZ-6 = -CZ
7 = +SR-7 = -SR
8 = +SA-8 = -SA
9 = +SB-9 = -SB
AxPt: This is an array dimensioned to 1 (2 strings) indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
PlPt: This is an array dimensioned to 1 (2 strings) indicating the labels of two joints that define the axis/plane reference vector. Either of these joints may be specified as None to indicate the center of the specified object.If both joints are specified as None, they are not used to define the plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 2.
AxVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
PlVect: This is an array dimensioned to 2 (3 doubles) that defines the axis/plane reference vector. This item applies when the Active item is True and the AxVectOpt/PlVectOpt item is 3.
Plane2: This is 12, 13, 21, 23, 31 or 32, indicating that the local plane determined by the plane reference vector is the 1-2, 1-3, 2-1, 2-3, 3-1, or 3-2 plane. This item applies only when the Active item is True.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
Selection = 2

If this item is Object, the assignment is made to the solid object specified by the Name item.
If this item is Group, the assignment is made to all solid objects in the group specified by the Name item.
If this item is Selection, assignment is made to all selected solid objects and the Name item is ignored.
        """

        all_args = [Name, Active, AxVectOpt, PlVectOpt, AxCSys, PlCSys, AxDir, PlDir, AxPt, PlPt, AxVect, PlVect, Plane2, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetLocalAxesAdvanced(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxesAdvanced" failed')
        
        return ret

    def SetLocalAxes(self, Name = None, a = None, b = None, c = None, ItemType = None):
        """
This function sets the local axes angles for solid objects.
The function returns zero if the local axes angles are successfully set; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
a: The local axes of the solid object are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
b: The local axes of the solid object are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
c: The local axes of the solid object are defined by first setting the positive local 1, 2 and 3 axes the same as the positive global X, Y and Z axes and then doing the following: [deg]
1.Rotate about the 3 axis by angle a.
2.Rotate about the resulting 2 axis by angle b.
3.Rotate about the resulting 1 axis by angle c.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the local axes assignment is made to the solid object specified by the Name item.
If this item is Group, the local axes assignment is made to all solid objects in the group specified by the Name item.
If this item is SelectedObjects, the local axes assignment is made to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, a, b, c, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxes" failed')
        
        return ret

    def SetMatTemp(self, Name = None, Temp = None, PatternName = None, ItemType = None):
        """
This function assigns material temperatures to solid objects.
The function returns zero if the material temperatures are successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
Temp: This is the material temperature value assigned to the solid object. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the solid object is uniform over the object at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the solid object may vary. The material temperature at each corner point of the solid object is equal to the specified temperature multiplied by the pattern value at the associated point object. The material temperature at other points in the solid object is calculated by interpolation from the corner points.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the solid object specified by the Name item.
If this item is Group, the assignment is made to all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, Temp, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMatTemp" failed')
        
        return ret

    def SetProperty(self, Name = None, PropName = None, ItemType = None):
        """
This function assigns a solid property to solid objects.
The function returns zero if the property is successfully assigned; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
PropName: This is the name of a solid property to be assigned to the specified solid object(s).
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the solid object specified by the Name item.
If this item is Group, the assignment is made to all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetProperty" failed')
        
        return ret

    def SetSpring(self, Name = None, MyType = None, s = None, SimpleSpringType = None, LinkProp = None, Face = None, SpringLocalOneType = None, Dir = None, Outward = None, Vec = None, Ang = None, Replace = None, CSys = None, ItemType = None):
        """
This function makes spring assignments to solid objects. The springs are assigned to a specified solid object face.
The function returns zero if the assignments are successfully applied; otherwise it returns a nonzero value.

Name: The name of an existing solid object or group, depending on the value of the ItemType item.
MyType: This is either 1 or 2, indicating the spring property type.
1 = Simple spring
2 = Link property
s: The simple spring stiffness per unit area of the specified solid object face. This item applies only when MyType = 1. [F/L3]
SimpleSpringType: This is 1, 2 or 3, indicating the simple spring type. This item applies only when MyType = 1.
1 = Spring resists tension and compression
2 = Spring resists compression only
3 = Spring resists tension only
LinkProp: The name of the link property assigned to the spring. This item applies only when MyType = 2.
Face: This is 1, 2, 3, 4, 5 or 6, indicating the solid object face to which the specified spring assignment applies.
SpringLocalOneType: This is 1, 2 or 3, indicating the method used to specify the spring positive local 1-axis orientation.
1 = Parallel to solid object local axis
2 = Normal to specified solid object face
3 = User specified direction vector
Dir: This is 1, 2, 3, -1, -2 or -3, indicating the solid object local axis that corresponds to the positive local 1-axis of the spring. This item applies only when SpringLocalOneType = 1.
Outward: This item is True if the spring positive local 1 axis is outward from the specified solid object face. This item applies only when SpringLocalOneType = 2.
Vec: This is an array of three values that define the direction vector of the spring positive local 1-axis. The direction vector is in the coordinate system specified by the CSys item. This item applies only when SpringLocalOneType = 3.
Ang: This is the angle that the link local 2-axis is rotated from its default orientation. This item applies only when MyType = 2. [deg]
Replace: If this item is True, all existing spring assignments to the solid object are removed before assigning the specified spring. If it is False, the specified spring is added to any existing springs already assigned to the solid object.
CSys: This is Local (meaning the solid object local coordinate system) or the name of a defined coordinate system. This item is the coordinate system in which the user specified direction vector, Vec, is specified. This item applies only when SpringLocalOneType = 3.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the solid object specified by the Name item.
If this item is Group, the assignment is made to all solid objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected solid objects, and the Name item is ignored.
        """

        all_args = [Name, MyType, s, SimpleSpringType, LinkProp, Face, SpringLocalOneType, Dir, Outward, Vec, Ang, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SolidObj.SetSpring(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetSpring" failed')
        
        return ret

class TendonObj:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def AddByCoord(self, xi = None, yi = None, zi = None, xj = None, yj = None, zj = None, Name = None, PropName = None, UserName = None, CSys = None):
        """
This function adds a new tendon object whose end points are at the specified coordinates.
The function returns zero if the tendon object is successfully added, otherwise it returns a nonzero value.

xi: The coordinates of the I-End of the added tendon object. The coordinates are in the coordinate system defined by the CSys item.
yi: The coordinates of the I-End of the added tendon object. The coordinates are in the coordinate system defined by the CSys item.
zi: The coordinates of the I-End of the added tendon object. The coordinates are in the coordinate system defined by the CSys item.
xj: The coordinates of the J-End of the added tendon object. The coordinates are in the coordinate system defined by the CSys item.
yj: The coordinates of the J-End of the added tendon object. The coordinates are in the coordinate system defined by the CSys item.
zj: The coordinates of the J-End of the added tendon object. The coordinates are in the coordinate system defined by the CSys item.
Name: This is the name that the program ultimately assigns for the tendon object. If no UserName is specified, the program assigns a default name to the tendon object. If a UserName is specified and that name is not used for another frame, cable or tendon object, the UserName is assigned to the tendon object; otherwise a default name is assigned to the tendon object.
PropName: This is Default, None or the name of a defined tendon property.
If it is Default, the program assigns a default tendon property to the tendon object. If it is None, no tendon property is assigned to the tendon object. If it is the name of a defined tendon property, that property is assigned to the tendon object.
UserName: This is an optional user specified name for the tendon object. If a UserName is specified and that name is already used for another tendon object, the program ignores the UserName.
CSys: The name of the coordinate system in which the tendon object end point coordinates are defined.
        """

        all_args = [xi, yi, zi, xj, yj, zj, Name, PropName, UserName, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.AddByCoord(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddByCoord" failed')
        
        return ret

    def AddByPoint(self, Point1 = None, Point2 = None, Name = None, PropName = None, UserName = None):
        """
This function adds a new tendon object whose end points are specified by name.
The function returns zero if the tendon object is successfully added, otherwise it returns a nonzero value.

Point1: The name of a defined point object at the I-End of the added tendon object.
Point2: The name of a defined point object at the J-End of the added tendon object.
Name: This is the name that the program ultimately assigns for the tendon object. If no UserName is specified, the program assigns a default name to the tendon object. If a UserName is specified and that name is not used for another frame, cable or tendon object, the UserName is assigned to the tendon object; otherwise a default name is assigned to the tendon object.
PropName: This is Default, None or the name of a defined tendon property.
If it is Default, the program assigns a default tendon property to the tendon object. If it is None, no tendon property is assigned to the tendon object. If it is the name of a defined tendon property, that property is assigned to the tendon object.
UserName: This is an optional user specified name for the tendon object. If a UserName is specified and that name is already used for another tendon object, the program ignores the UserName.
        """

        all_args = [Point1, Point2, Name, PropName, UserName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.AddByPoint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"AddByPoint" failed')
        
        return ret

    def ChangeName(self, Name = None, NewName = None):
        """
The function returns zero if the new name is successfully applied, otherwise it returns a nonzero value.

Name: The existing name of a defined tendon object.
NewName: The new name for the tendon object.
        """

        all_args = [Name, NewName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.ChangeName(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ChangeName" failed')
        
        return ret

    def Count(self):
        """
This function returns a count of the tendon objects in the model.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.Count(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Count" failed')
        
        return ret

    def DeleteLoadDeformation(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the deformation load assignments to the specified tendon objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the tendon object specified by the Name item.
If this item is Group, the load assignments are deleted for all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected tendon objects and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.DeleteLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadDeformation" failed')
        
        return ret

    def DeleteLoadForceStress(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the tendon force/stress load assignments to the specified tendon objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the tendon object specified by the Name item.
If this item is Group, the load assignments are deleted for all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.DeleteLoadForceStress(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadForceStress" failed')
        
        return ret

    def DeleteLoadGravity(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the gravity load assignments to the specified tendon objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the tendon object specified by the Name item.
If this item is Group, the load assignments are deleted for all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.DeleteLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadGravity" failed')
        
        return ret

    def DeleteLoadStrain(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the strain load assignments to the specified tendon objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the tendon object specified by the Name item.
If this item is Group, the load assignments are deleted for all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.DeleteLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadStrain" failed')
        
        return ret

    def DeleteLoadTemperature(self, Name = None, LoadPat = None, ItemType = None):
        """
This function deletes the temperature load assignments to the specified tendon objects for the specified load pattern.
The function returns zero if the load assignments are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the load assignments are deleted for the tendon object specified by the Name item.
If this item is Group, the load assignments are deleted for all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, the load assignments are deleted for all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.DeleteLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"DeleteLoadTemperature" failed')
        
        return ret

    def Delete(self, Name = None, ItemType = None):
        """
The function deletes tendon objects.
The function returns zero if the tendon objects are successfully deleted, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group depending on the value of the ItemType item.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the tendon object specified by the Name item is deleted.
If this item is Group, all of the tendon objects in the group specified by the Name item are deleted.
If this item is SelectedObjects, all selected tendon objects are deleted, and the Name item is ignored.
        """

        all_args = [Name, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.Delete(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Delete" failed')
        
        return ret

    def GetDiscretization(self, Name = None, Value = None):
        """
This function retrieves the maximum discretization length assignment for tendon objects.
The function returns zero if the assignment is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing tendon object.
Value: The maximum discretization length for the tendon. [L]
        """

        all_args = [Name, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetDiscretization(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDiscretization" failed')
        
        return ret

    def GetElm(self, Name = None, nelm = None, Elm = None, RDI = None, RDJ = None):
        """
This function retrieves the names of the line elements (analysis model lines) associated with a specified tendon object in the object-based model. It also retrieves information about the location of the line elements along the tendon object.
This function returns zero if the line element information is successfully returned; otherwise it returns nonzero. An error occurs if the analysis model does not currently exist.

Name: The name of an existing tendon object.
nelm: The number of line elements created from the specified tendon object.
Elm: An array that includes the name of a line element created from the specified tendon object.
RDI: An array that includes the relative distance along the tendon object to the I-End of the line element.
RDJ: An array that includes the relative distance along the tendon object to the J-End of the line element.
        """

        all_args = [Name, nelm, Elm, RDI, RDJ]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetElm(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetElm" failed')
        
        return ret

    def GetGroupAssign(self, Name = None, NumberGroups = None, Groups = None):
        """
This function retrieves the names of the groups to which a specified tendon object is assigned.
The function returns zero if the group assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing tendon object.
NumberGroups: The number of group names retrieved.
Groups: The names of the groups to which the tendon object is assigned.
        """

        all_args = [Name, NumberGroups, Groups]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGroupAssign" failed')
        
        return ret

    def GetGUID(self, Name = None, GUID = None):
        """
This function retrieves the GUID for the specified tendon object.
This function returns zero if the tendon object GUID is successfully retrieved; otherwise it returns nonzero.

Name: The name of an existing tendon object.
GUID: The GUID (Global Unique ID) for the specified tendon object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetGUID" failed')
        
        return ret

    def GetLoadDeformation(self, Name = None, NumberItems = None, TendonName = None, LoadPat = None, U1 = None, ItemType = None):
        """
This function retrieves the deformation load assignments to tendon objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
NumberItems: The total number of deformation loads retrieved for the specified tendon objects.
TendonName: This is an array that includes the name of the tendon object associated with each deformation load.
LoadPat: This is an array that includes the name of the load pattern associated with each deformation load.
U1: This is an array of axial deformation load values. [L]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the tendon object specified by the Name item.
If this item is Group, the assignments are retrieved for all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, TendonName, LoadPat, U1, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadDeformation" failed')
        
        return ret

    def GetLoadedGroup(self, Name = None, GroupName = None):
        """
This function retrieves the loaded group for tendon objects. A tendon object transfers its load to any object that is in the specified group.
The function returns zero if the assignment is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing tendon object.
GroupName: This is the name of an existing group. All objects in the specified group can be loaded by the tendon.
        """

        all_args = [Name, GroupName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetLoadedGroup(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadedGroup" failed')
        
        return ret

    def GetLoadForceStress(self, Name = None, NumberItems = None, TendonName = None, LoadPat = None, JackFrom = None, LoadType = None, Value = None, CurvatureCoeff = None, WobbleCoeff = None, LossAnchorage = None, LossShortening = None, LossCreep = None, LossShrinkage = None, LossSteelRelax = None, ItemType = None):
        """
This function retrieves the force/stress load assignments to tendon objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
NumberItems: The total number of temperature loads retrieved for the specified tendon objects.
TendonName: This is an array that includes the name of the tendon object associated with each temperature load.
LoadPat: This is an array that includes the name of the load pattern associated with each temperature load.
JackFrom: This is an array that includes 1, 2 or 3, indicating how the tendon is jacked.
1 = Tendon jacked from I-End
2 = Tendon jacked from J-End
3 = Tendon jacked from both ends
LoadType: This is an array that includes either 0 or 1, indicating how the type of load.
0 = Force
1 = Stress
Value: This is an array that includes the load value. [F] when LoadType is 0, and [F/L2] when Loadtype is 1
CurvatureCoeff: This is an array that includes the curvature coefficient used when calculating friction losses.
WobbleCoeff: This is an array that includes the wobble coefficient used when calculating friction losses. [1/L]
LossAnchorage: This is an array that includes the anchorage set slip. [L]
LossShortening: This is an array that includes the tendon stress loss due to elastic shortening. [F/L2]
LossCreep: This is an array that includes the tendon stress loss due to creep. [F/L2]
LossShrinkage: This is an array that includes the tendon stress loss due to shrinkage. [F/L2]
LossSteelRelax: This is an array that includes the tendon stress loss due to tendon steel relaxation. [F/L2]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the tendon object specified by the Name item.
If this item is Group, the assignments are retrieved for all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, TendonName, LoadPat, JackFrom, LoadType, Value, CurvatureCoeff, WobbleCoeff, LossAnchorage, LossShortening, LossCreep, LossShrinkage, LossSteelRelax, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetLoadForceStress(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadForceStress" failed')
        
        return ret

    def GetLoadGravity(self, Name = None, NumberItems = None, TendonName = None, LoadPat = None, CSys = None, x = None, y = None, z = None, ItemType = None):
        """
This function retrieves the gravity load assignments to tendon objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
NumberItems: The total number of gravity loads retrieved for the specified tendon objects.
TendonName: This is an array that includes the name of the tendon object associated with each gravity load.
LoadPat: This is an array that includes the name of the coordinate system in which the gravity load multipliers are specified.
CSys: This is an array that includes the name of the coordinate system associated with each gravity load.
x: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are arrays of gravity load multipliers in the x, y and z directions of the specified coordinate system.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the tendon object specified by the Name item.
If this item is Group, the assignments are retrieved for all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, TendonName, LoadPat, CSys, x, y, z, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadGravity" failed')
        
        return ret

    def GetLoadStrain(self, Name = None, NumberItems = None, TendonName = None, LoadPat = None, Strain = None, PatternName = None, ItemType = None):
        """
This function retrieves the strain load assignments to tendon objects.
The function returns zero if the strain load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
NumberItems: The total number of strain loads retrieved for the specified tendon objects.
TendonName: This is an array that includes the name of the tendon object associated with each strain load.
LoadPat: This is an array that includes the name of the load pattern associated with each strain load.
Strain: This is an array that includes the axial strain value. [L/L]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the strain load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the tendon object specified by the Name item.
If this item is Group, the assignments are retrieved for all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, TendonName, LoadPat, Strain, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadStrain" failed')
        
        return ret

    def GetLoadTemperature(self, Name = None, NumberItems = None, TendonName = None, LoadPat = None, Val = None, PatternName = None, ItemType = None):
        """
This function retrieves the temperature load assignments to tendon objects.
The function returns zero if the load assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
NumberItems: The total number of temperature loads retrieved for the specified tendon objects.
TendonName: This is an array that includes the name of the tendon object associated with each temperature load.
LoadPat: This is an array that includes the name of the load pattern associated with each temperature load.
Val: This is an array that includes the temperature load value. [T]
PatternName: This is an array that includes the joint pattern name, if any, used to specify the temperature load.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignments are retrieved for the tendon object specified by the Name item.
If this item is Group, the assignments are retrieved for all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignments are retrieved for all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, NumberItems, TendonName, LoadPat, Val, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLoadTemperature" failed')
        
        return ret

    def GetLocalAxes(self, Name = None, Ang = None):
        """
This function retrieves the tendon local axis angle assignment for tendon objects.
The function returns zero if the assignment is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing tendon object.
Ang: This is the angle that the local 2 and 3 axes are rotated about the positive local 1 axis, from the default orientation. The rotation for a positive angle appears counter clockwise when the local +1 axis is pointing toward you. [deg]
        """

        all_args = [Name, Ang]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetLocalAxes" failed')
        
        return ret

    def GetMatTemp(self, Name = None, Temp = None, PatternName = None):
        """
This function retrieves the material temperature assignments to tendon objects.
The function returns zero if the material temperature assignments are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of an existing tendon object.
Temp: This is the material temperature value assigned to the tendon object. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the tendon object is uniform along the object at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the tendon object may vary from one end to the other. The material temperature at each end of the object is equal to the specified temperature multiplied by the pattern value at the joint at the end of the tendon object.
        """

        all_args = [Name, Temp, PatternName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetMatTemp" failed')
        
        return ret

    def GetNameList(self, NumberNames = None, MyName = None):
        """
This function retrieves the names of all defined tendon objects.
The function returns zero if the names are successfully retrieved, otherwise it returns nonzero.

NumberNames: The number of tendon object names retrieved by the program.
MyName: This is a one-dimensional array of tendon object names. The MyName array is created as a dynamic, zero-based, array by the APIuser:
Dim MyName() as String

The array is dimensioned to (NumberNames – 1) inside the Sap2000 program, filled with the names, and returned to the APIuser.
        """

        all_args = [NumberNames, MyName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetNameList(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetNameList" failed')
        
        return ret

    def GetPoints(self, Name = None, Point1 = None, Point2 = None):
        """
This function retrieves the names of the point objects at each end of a specified tendon object.
The function returns zero if the point names are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined tendon object.
Point1: The name of the point object at the I-End of the specified tendon object.
Point2: The name of the point object at the J-End of the specified tendon object.
        """

        all_args = [Name, Point1, Point2]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPoints" failed')
        
        return ret

    def GetProperty(self, Name = None, PropName = None):
        """
This function retrieves the tendon property assigned to a tendon object.
The function returns zero if the tendon object property is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined tendon object.
PropName: The name of the tendon property assigned to the tendon object.
        """

        all_args = [Name, PropName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetProperty" failed')
        
        return ret

    def GetTCLimits(self, Name = None, LimitCompressionExists = None, LimitCompression = None, LimitTensionExists = None, LimitTension = None):
        """
This function retrieves the tension/compression force limit assignments to tendon objects.
The function returns zero if the assignments are successfully retrieved, otherwise it returns a nonzero value.
Note that the tension and compression limits are used in nonlinear analyses only.

Name: The name of an existing tendon object.
LimitCompressionExists: This item is True if a compression force limit exists for the tendon object.
LimitCompression: The compression force limit for the tendon object. [F]
LimitTensionExists: This item is True if a tension force limit exists for the tendon object.
LimitTension: The tension force limit for the tendon object. [F]
        """

        all_args = [Name, LimitCompressionExists, LimitCompression, LimitTensionExists, LimitTension]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetTCLimits(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTCLimits" failed')
        
        return ret

    def GetTendonData(self, Name = None, NumberPoints = None, MyType = None, x = None, y = None, z = None, CSys = None):
        """
This function retrieves the tendon geometric definition parameters for a tendon object.
The function returns zero if the tendon object parameters are successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined tendon object.
NumberPoints: The number of items used to define the tendon geometry.
MyType: This is an array of values that are 1, 3, 6, 7, 8, or 9, indicating the tendon geometry definition parameter for the specified point.
1 = Start of tendon
2 = The segment preceding the point is linear
6 = The specified point is the end of a parabola
7 = The specified point is an intermediate point on a parabola
8 = The specified point is the end of a circle
9 = The specified point is an intermediate point on a parabola

The first point always has a MyType value of 1.
MyType of 6 through 9 is based on using three points to calculate a parabolic or circular arc. MyType 6 and 8 use the specified point and the two previous points as the three points. MyType 7 and 9 use the specified point and the points just before and after the specified point as the three points.
x: This is an array of the X (or local 1) coordinate of each point in the coordinate system specified by CSys. [L]
y: This is an array of the Y (or local 2) coordinate of each point in the coordinate system specified by CSys. [L]
z: This is an array of the Z (or local 3) coordinate of each point in the coordinate system specified by CSys. [L]
CSys: This is the coordinate system in which the x, y and z coordinate parameters are defined. It is Local or the name of a defined coordinate system.
Local means that the point coordinates are in the local system of the specified tendon object with the origin assumed to be at the I-End of the tendon.
        """

        all_args = [Name, NumberPoints, MyType, x, y, z, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetTendonData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTendonData" failed')
        
        return ret

    def GetTendonGeometry(self, Name = None, NumberPoints = None, x = None, y = None, z = None, CSys = None):
        """
This function retrieves tendon object discretized geometry, that is, it retrieves the coordinates of the points along the discretized tendon.
The function returns zero if the tendon object discretized geometry is successfully retrieved, otherwise it returns a nonzero value.

Name: The name of a defined tendon object.
NumberPoints: The number of items used to define the discretized tendon geometry.
x: This is an array of the X (or local 1) coordinate of each point in the coordinate system specified by CSys. [L]
y: This is an array of the Y (or local 2) coordinate of each point in the coordinate system specified by CSys. [L]
z: This is an array of the Z (or local 3) coordinate of each point in the coordinate system specified by CSys. [L]
CSys: This is the coordinate system in which the x, y and z coordinate parameters are defined. It is Local or the name of a defined coordinate system.
Local means that the point coordinates are in the local system of the specified tendon object with the origin assumed to be at the I-End of the tendon.
        """

        all_args = [Name, NumberPoints, x, y, z, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.GetTendonGeometry(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetTendonGeometry" failed')
        
        return ret

    def SetDiscretization(self, Name = None, Value = None, ItemType = None):
        """
This function assigns a maximum discretization length to tendon objects.
The function returns zero if the discretization length is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
Value: The maximum discretization length for the tendon. [L]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the tendon object specified by the Name item.
If this item is Group, the assignment is made to all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, Value, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetDiscretization(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDiscretization" failed')
        
        return ret

    def SetGroupAssign(self, Name = None, GroupName = None, Remove = None, ItemType = None):
        """
This function adds or removes tendon objects from a specified group.
The function returns zero if the group assignment is successful, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
GroupName: The name of an existing group to which the assignment is made.
Remove: If this item is False, the specified tendon objects are added to the group specified by the GroupName item. If it is True, the tendon objects are removed from the group.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the tendon object specified by the Name item is added or removed from the group specified by the GroupName item.
If this item is Group, all tendon objects in the group specified by the Name item are added or removed from the group specified by the GroupName item.
If this item is SelectedObjects, all selected tendon objects are added or removed from the group specified by the GroupName item, and the Name item is ignored.
        """

        all_args = [Name, GroupName, Remove, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetGroupAssign(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGroupAssign" failed')
        
        return ret

    def SetGUID(self, Name = None, GUID = None):
        """
This function sets the GUID for the specified tendon object. If the GUID is passed in as a blank string, the program automatically creates a GUID for the object.
This function returns zero if the tendon object GUID is successfully set; otherwise it returns nonzero.

Name: The name of an existing tendon object.
GUID: The GUID (Global Unique ID) for the specified tendon object.
        """

        all_args = [Name, GUID]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetGUID(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetGUID" failed')
        
        return ret

    def SetLoadDeformation(self, Name = None, LoadPat = None, d = None, ItemType = None):
        """
This function assigns deformation loads to tendon objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
d: This is the axial deformation load value. [L]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the tendon object specified by the Name item.
If this item is Group, the assignment is made to all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected tendon objects and the Name item is ignored.
        """

        all_args = [Name, LoadPat, d, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetLoadDeformation(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadDeformation" failed')
        
        return ret

    def SetLoadedGroup(self, Name = None, GroupName = None, ItemType = None):
        """
This function makes the loaded group assignment to tendon objects. A tendon object transfers its load to any object that is in the specified group.
The function returns zero if the group is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
GroupName: This is the name of an existing group. All objects in the specified group can be loaded by the tendon.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the tendon object specified by the Name item.
If this item is Group, the assignment is made to all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, GroupName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetLoadedGroup(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadedGroup" failed')
        
        return ret

    def SetLoadForceStress(self, Name = None, LoadPat = None, JackFrom = None, LoadType = None, Value = None, CurvatureCoeff = None, WobbleCoeff = None, LossAnchorage = None, LossShortening = None, LossCreep = None, LossShrinkage = None, LossSteelRelax = None, Replace = None, ItemType = None):
        """
This function assigns force/stress loads to tendon objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
JackFrom: This is 1, 2 or 3, indicating how the tendon is jacked.
1 = Tendon jacked from I-End
2 = Tendon jacked from J-End
3 = Tendon jacked from both ends
LoadType: This is either 0 or 1, indicating how the type of load.
0 = Force
1 = Stress
Value: This is the load value. [F] whenLoadType is 0, and [F/L2] when Loadtype is 1
CurvatureCoeff: The curvature coefficient used when calculating friction losses.
WobbleCoeff: The wobble coefficient used when calculating friction losses. [1/L]
LossAnchorage: The anchorage set slip. [L]
LossShortening: The tendon stress loss due to elastic shortening. [F/L2]
LossCreep: The tendon stress loss due to creep. [F/L2]
LossShrinkage: The tendon stress loss due to shrinkage. [F/L2]
LossSteelRelax: The tendon stress loss due to tendon steel relaxation. [F/L2]
Replace: If this item is True, all previous force/stress loads, if any, assigned to the specified tendon object(s), in the specified load case, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the tendon object specified by the Name item.
If this item is Group, the assignment is made to all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, JackFrom, LoadType, Value, CurvatureCoeff, WobbleCoeff, LossAnchorage, LossShortening, LossCreep, LossShrinkage, LossSteelRelax, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetLoadForceStress(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadForceStress" failed')
        
        return ret

    def SetLoadGravity(self, Name = None, LoadPat = None, x = None, y = None, z = None, Replace = None, CSys = None, ItemType = None):
        """
This function assigns gravity load multipliers to tendon objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
x: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
y: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
z: These are the gravity load multipliers in the x, y and z directions of the specified coordinate system.
Replace: If this item is True, all previous gravity loads, if any, assigned to the specified tendon object(s), in the specified load pattern, are deleted before making the new assignment.
CSys: The coordinate system in which the x, y and z multipliers are specified.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the tendon object specified by the Name item.
If this item is Group, the assignment is made to all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected tendon objects and the Name item is ignored.
        """

        all_args = [Name, LoadPat, x, y, z, Replace, CSys, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetLoadGravity(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadGravity" failed')
        
        return ret

    def SetLoadStrain(self, Name = None, LoadPat = None, Strain = None, Replace = None, PatternName = None, ItemType = None):
        """
This function assigns strain loads to tendon objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Strain: This is the axial strain load value. [L/L]
Replace: If this item is True, all previous strain loads, if any, assigned to the specified tendon object(s), in the specified load pattern, are deleted before making the new assignment.
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the strain load for the tendon object is uniform along the object at the value specified by Strain.
If PatternName is the name of a defined joint pattern, the strain load for the tendon object is based on the specified strain value multiplied by the pattern value at the joints at each end of the tendon object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the tendon object specified by the Name item.
If this item is Group, the assignment is made to all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Strain, Replace, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetLoadStrain(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadStrain" failed')
        
        return ret

    def SetLoadTemperature(self, Name = None, LoadPat = None, Val = None, PatternName = None, Replace = None, ItemType = None):
        """
This function assigns temperature loads to tendon objects.
The function returns zero if the loads are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group depending on the value of the ItemType item.
LoadPat: The name of a defined load pattern.
Val: This is the temperature change value. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the temperature load for the tendon object is uniform along the object at the value specified by Val.
If PatternName is the name of a defined joint pattern, the temperature load for the tendon object is based on the specified temperature value multiplied by the pattern value at the joints at each end of the tendon object.
Replace: If this item is True, all previous temperature loads, if any, assigned to the specified tendon object(s), in the specified load case, are deleted before making the new assignment.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the tendon object specified by the Name item.
If this item is Group, the assignment is made to all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, LoadPat, Val, PatternName, Replace, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetLoadTemperature(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLoadTemperature" failed')
        
        return ret

    def SetLocalAxes(self, Name = None, Ang = None, ItemType = None):
        """
This function assigns a local axis angle to tendon objects.
The function returns zero if the local axis angle is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
Ang: This is the angle that the local 2 and 3 axes are rotated about the positive local 1 axis, from the default orientation. The rotation for a positive angle appears counter clockwise when the local +1 axis is pointing toward you. [deg]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the tendon object specified by the Name item.
If this item is Group, the assignment is made to all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, Ang, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetLocalAxes(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetLocalAxes" failed')
        
        return ret

    def SetMatTemp(self, Name = None, Temp = None, PatternName = None, ItemType = None):
        """
This function assigns material temperatures to tendon objects.
The function returns zero if the material temperatures are successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
Temp: This is the material temperature value assigned to the tendon object. [T]
PatternName: This is blank or the name of a defined joint pattern. If it is blank, the material temperature for the tendon object is uniform along the object at the value specified by Temp.
If PatternName is the name of a defined joint pattern, the material temperature for the tendon object may vary from one end to the other. The material temperature at each end of the object is equal to the specified temperature multiplied by the pattern value at the joint at the end of the tendon object.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the tendon object specified by the Name item.
If this item is Group, the assignment is made to all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, Temp, PatternName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetMatTemp(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetMatTemp" failed')
        
        return ret

    def SetProperty(self, Name = None, PropName = None, ItemType = None):
        """
This function assigns a tendon property to a tendon object.
The function returns zero if the tendon property is successfully assigned, otherwise it returns a nonzero value.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
PropName: This is None or the name of a tendon property to be assigned to the specified tendon object(s). None means that no property is assigned to the tendon.
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the tendon object specified by the Name item.
If this item is Group, the assignment is made to all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected tendon objects, and the Name item is ignored.
        """

        all_args = [Name, PropName, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetProperty(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetProperty" failed')
        
        return ret

    def SetTCLimits(self, Name = None, LimitCompressionExists = None, LimitCompression = None, LimitTensionExists = None, LimitTension = None, ItemType = None):
        """
This function makes tension/compression force limit assignments to tendon objects.
The function returns zero if the assignments are successfully applied, otherwise it returns a nonzero value.
Note that the tension and compression limits are used in nonlinear analyses only.

Name: The name of an existing tendon object or group, depending on the value of the ItemType item.
LimitCompressionExists: This item is True if a compression force limit exists for the tendon object.
LimitCompression: The compression force limit for the tendon object. [F]
LimitTensionExists: This item is True if a tension force limit exists for the tendon object.
LimitTension: The tension force limit for the tendon object. [F]
ItemType: This is one of the following items in the eItemType enumeration:
Object = 0
Group = 1
SelectedObjects = 2

If this item is Object, the assignment is made to the tendon object specified by the Name item.
If this item is Group, the assignment is made to all tendon objects in the group specified by the Name item.
If this item is SelectedObjects, assignment is made to all selected tendon objects and the Name item is ignored.
        """

        all_args = [Name, LimitCompressionExists, LimitCompression, LimitTensionExists, LimitTension, ItemType]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetTCLimits(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTCLimits" failed')
        
        return ret

    def SetTendonData(self, Name = None, NumberPoints = None, MyType = None, x = None, y = None, z = None, CSys = None):
        """
This function assigns the tendon geometric definition parameters to a tendon object.
The function returns zero if the tendon object is successfully defined, otherwise it returns a nonzero value. If the tendon object is not successfully defined, it may be deleted.

Name: The name of a defined tendon object.
NumberPoints: The number of items used to define the tendon geometry.
MyType: This is an array of values that are 1, 3, 6, 7, 8, or 9, indicating the tendon geometry definition parameter for the specified point.
1 = Start of tendon
2 = The segment preceding the point is linear
6 = The specified point is the end of a parabola
7 = The specified point is an intermediate point on a parabola
8 = The specified point is the end of a circle
9 = The specified point is an intermediate point on a parabola

The first point should always have a MyType value of 1. If it is not equal to 1, the program uses 1 anyway.
MyType of 6 through 9 is based on using three points to calculate a parabolic or circular arc. MyType 6 and 8 use the specified point and the two previous points as the three points. MyType 7 and 9 use the specified point and the points just before and after the specified point as the three points.
x: This is an array of the X (or local 1) coordinate of each point in the coordinate system specified by CSys. [L]
y: This is an array of the Y (or local 2) coordinate of each point in the coordinate system specified by CSys. [L]
z: This is an array of the Z (or local 3) coordinate of each point in the coordinate system specified by CSys. [L]
CSys: This is the coordinate system in which the x, y and z coordinate parameters are defined. It is Local or the name of a defined coordinate system.
Local means that the point coordinates are in the local system of the specified tendon object with the origin assumed to be at the I-End of the tendon.
        """

        all_args = [Name, NumberPoints, MyType, x, y, z, CSys]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.TendonObj.SetTendonData(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetTendonData" failed')
        
        return ret

class Chinese_2002:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a concrete design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Importance factor gamma 0
4 = Column design procedure
5 = Seismic design grade
6 = Pattern live load factor
7 = Utilization factor limit
8 = Multi-response case design
9 = Structural system
10 = Is tall building?
11 = Seismic field type
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Importance factor gamma 0
Value > 0

4 = Column design procedure
1 = Appendix F
2 = Simplified

5 = Seismic design grade
1 = Super I
2 = Grade I
3 = Grade II
4 = Grade III
5 = Grade IV
6 = Nonseismic

6 = Pattern live load factor
Value >= 0

7 = Utilization factor limit
Value > 0

8 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

9 = Structural system
1 = Frame only
2 = Shearwall only
3 = Frame-shearwall
4 = Braced frame only
5 = Frame-braced frame
10 = Is tall building?
0 = No
1 = Yes
11 = Seismic field type
1 = I
2 = II
3 = III
4 = IV
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Chinese_2002.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a concrete design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 11, inclusive, indicating the preference item considered.
1 = Number of interaction curves
2 = Number of interaction points
3 = Importance factor gamma 0
4 = Column design procedure
5 = Seismic design grade
6 = Pattern live load factor
7 = Utilization factor limit
8 = Multi-response case design
9 = Structural system
10 = Is tall building?
11 = Seismic field type
Value: The value of the considered preference item.
1 = Number of interaction curves
Value >= 4 and devisable by 4

2 = Number of interaction points
Value >= 5 and odd

3 = Importance factor gamma 0
Value > 0

4 = Column design procedure
1 = Appendix F
2 = Simplified

5 = Seismic design grade
1 = Super I
2 = Grade I
3 = Grade II
4 = Grade III
5 = Grade IV
6 = Nonseismic

6 = Pattern live load factor
Value >= 0

7 = Utilization factor limit
Value > 0

8 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

9 = Structural system
1 = Frame only
2 = Shearwall only
3 = Frame-shearwall
4 = Braced frame only
5 = Frame-braced frame
10 = Is tall building?
0 = No
1 = Yes
11 = Seismic field type
1 = I
2 = II
3 = III
4 = IV
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignConcrete.Chinese_2002.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Chinese_2000:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetPreference(self, Item = None, Value = None):
        """
This function retrieves the value of a steel design preference item.
The function returns zero if the item is successfully retrieved; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 14, inclusive, indicating the preference item considered.
1 = Framing type
2 = Gamma0
3 = Ignore b/t check
4 = Classify beam as flexo compression member
5 = Consider deflection
6 = DL deflection limit, L/Value
7 = SDL + LL deflection limit, L/Value
8 = LL deflection limit, L/Value
9 = Total load deflection limit, L/Value
10 = Total camber limit, L/Value
11 = Pattern live load factor
12 = Demand/capacity ratio limit
13 = Multi-response case design
14 = Is tall building?
Value: The value of the considered preference item.
1 = Framing type
0 = As specified in preferences
1 = Sway Moment Frame, SMF
2 = Concentrically Braced Frame, CBF
3 = Eccentrically Braced Frame, EBF
4 = NonSway Moment Frame, NMF

2 = Gamma0
Value > 0

3 = Ignore b/t check
0 = No
Any other value = Yes

4 = Classify beam as flexo compression member
0 = No
Any other value = Yes

5 = Consider deflection
0 = No
Any other value = Yes

6 = DL deflection limit, L/Value
Value > 0

7 = SDL + LL deflection limit, L/Value
Value > 0

8 = LL deflection limit, L/Value
Value > 0

9 = Total load deflection limit, L/Value
Value > 0

10 = Total camber limit, L/Value
Value > 0

11 = Pattern live load factor
Value >= 0

12 = Demand/capacity ratio limit
Value > 0

13 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

14 = Tall building
0 = No
1 = Yes
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Chinese_2000.GetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetPreference" failed')
        
        return ret

    def SetPreference(self, Item = None, Value = None):
        """
This function sets the value of a steel design preference item.
The function returns zero if the item is successfully set; otherwise it returns a nonzero value.

Item: This is an integer between 1 and 14, inclusive, indicating the preference item considered.
1 = Framing type
2 = Gamma0
3 = Ignore b/t check
4 = Classify beam as flexo compression member
5 = Consider deflection
6 = DL deflection limit, L/Value
7 = SDL + LL deflection limit, L/Value
8 = LL deflection limit, L/Value
9 = Total load deflection limit, L/Value
10 = Total camber limit, L/Value
11 = Pattern live load factor
12 = Demand/capacity ratio limit
13 = Multi-response case design
14 = Is tall building?
Value: The value of the considered preference item.
1 = Framing type
0 = As specified in preferences
1 = Sway Moment Frame, SMF
2 = Concentrically Braced Frame, CBF
3 = Eccentrically Braced Frame, EBF
4 = NonSway Moment Frame, NMF

2 = Gamma0
Value > 0

3 = Ignore b/t check
0 = No
Any other value = Yes

4 = Classify beam as flexo compression member
0 = No
Any other value = Yes

5 = Consider deflection
0 = No
Any other value = Yes

6 = DL deflection limit, L/Value
Value > 0

7 = SDL + LL deflection limit, L/Value
Value > 0

8 = LL deflection limit, L/Value
Value > 0

9 = Total load deflection limit, L/Value
Value > 0

10 = Total camber limit, L/Value
Value > 0

11 = Pattern live load factor
Value >= 0

12 = Demand/capacity ratio limit
Value > 0

13 = Multi-response case design
1 = Envelopes
2 = Step-by-step
3 = Last step
4 = Envelopes -- All
5 = Step-by-step -- All

14 = Tall building
0 = No
1 = Yes
        """

        all_args = [Item, Value]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.DesignSteel.Chinese_2000.SetPreference(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetPreference" failed')
        
        return ret

class Options:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def GetDimensions(self, CuttingPlaneTol = None, WorldSpacing = None, NudgeValue = None, PixelClickSize = None, PixelSnapSize = None, ScrLinThk = None, PrtLinThk = None, MaxFont = None, MinFont = None, ZoomStep = None, ShrinkFact = None, TextFileMaxChar = None):
        """
This function retrieves the program dimension and tolerance items.
The function returns zero if the items are successfully retrieved; otherwise it returns a nonzero value.

CuttingPlaneTol: The tolerance for 2D view cutting planes. [L]
WorldSpacing: The plan fine grid spacing. [L]
NudgeValue: The plan nudge value. [L]
PixelClickSize: The screen selection tolerance in pixels.
PixelSnapSize: The screen snap tolerance in pixels.
ScrLinThk: The screen line thickness in pixels.
PrtLinThk: The printer line thickness in pixels.
MaxFont: The maximum graphic font size in points.
MinFont: The minimum graphic font size in points.
ZoomStep: The auto zoom step size in percent (0 < ZoomStep < = 100).
ShrinkFact: The shrink factor in percent (0 < ShrinkFact < = 100).
TextFileMaxChar: The maximum line length in the text file (ShrinkFact > = 80).
        """

        all_args = [CuttingPlaneTol, WorldSpacing, NudgeValue, PixelClickSize, PixelSnapSize, ScrLinThk, PrtLinThk, MaxFont, MinFont, ZoomStep, ShrinkFact, TextFileMaxChar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Options.GetDimensions(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetDimensions" failed')
        
        return ret

    def SetDimensions(self, CuttingPlaneTol = None, WorldSpacing = None, NudgeValue = None, PixelClickSize = None, PixelSnapSize = None, ScrLinThk = None, PrtLinThk = None, MaxFont = None, MinFont = None, ZoomStep = None, ShrinkFact = None, TextFileMaxChar = None):
        """
This function sets program dimension and tolerance items. Inputting 0 for any item means that the item will be ignored by the program; that is, its current value will not be changed.
The function returns zero if the items are successfully set; otherwise it returns a nonzero value.

CuttingPlaneTol: The tolerance for 2D view cutting planes. [L]
WorldSpacing: The plan fine grid spacing. [L]
NudgeValue: The plan nudge value. [L]
PixelClickSize: The screen selection tolerance in pixels.
PixelSnapSize: The screen snap tolerance in pixels.
ScrLinThk: The screen line thickness in pixels.
PrtLinThk: The printer line thickness in pixels.
MaxFont: The maximum graphic font size in points.
MinFont: The minimum graphic font size in points.
ZoomStep: The auto zoom step size in percent (0 < ZoomStep <= 100).
ShrinkFact: The shrink factor in percent (0 < ShrinkFact <= 100).
TextFileMaxChar: The maximum line length in the text file (ShrinkFact >= 80).
        """

        all_args = [CuttingPlaneTol, WorldSpacing, NudgeValue, PixelClickSize, PixelSnapSize, ScrLinThk, PrtLinThk, MaxFont, MinFont, ZoomStep, ShrinkFact, TextFileMaxChar]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.Options.SetDimensions(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SetDimensions" failed')
        
        return ret

class SelectObj:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def All(self, DeSelect = None):
        """
This function selects or deselects all objects in the model.
This function returns zero if the selection is successfully completed, otherwise it returns nonzero.

DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.All(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"All" failed')
        
        return ret

    def ClearSelection(self):
        """
This function deselects all objects in the model. It returns zero if the selection status is successfully set, otherwise it returns nonzero.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.ClearSelection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"ClearSelection" failed')
        
        return ret

    def Constraint(self, Name = None, DeSelect = None):
        """
This function selects or deselects all point objects to which the specified constraint has been assigned.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of an existing joint constraint.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.Constraint(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Constraint" failed')
        
        return ret

    def CoordinateRange(self, XMin = None, XMax = None, YMin = None, YMax = None, ZMin = None, ZMax = None, DeSelect = None, CSys = None, IncludeIntersections = None, Point = None, Line = None, Area = None, Solid = None, Link = None):
        """
This function selects or deselects objects inside the box defined by the XMin, XMax, YMin, YMax, ZMin and ZMax coordinates.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

XMin: The maximum and minimum X coordinates of the selection box in the specified coordinate system.
XMax: The maximum and minimum X coordinates of the selection box in the specified coordinate system.
YMin: The maximum and minimum Y coordinates of the selection box in the specified coordinate system.
YMax: The maximum and minimum Y coordinates of the selection box in the specified coordinate system.
ZMin: The maximum and minimum Z coordinates of the selection box in the specified coordinate system.
ZMax: The maximum and minimum Z coordinates of the selection box in the specified coordinate system.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
CSys: The name of the coordinate system in which XMin, XMax, YMin, YMax, ZMin and ZMax are specified.
IncludeIntersections: When this item is True, objects that are inside the box or intersecting the sides and edges of the box are selected or deselected.
When this item is False, only objects that are fully inside the box are selected or deselected.
Point: Point objects that fall inside the box are only selected or deselected when this item is True.
Line: Line objects that fall inside the box are only selected or deselected when this item is True.
Area: Area objects that fall inside the box are only selected or deselected when this item is True.
Solid: Solid objects that fall inside the box are only selected or deselected when this item is True.
Link: Link objects that fall inside the box are only selected or deselected when this item is True.
        """

        all_args = [XMin, XMax, YMin, YMax, ZMin, ZMax, DeSelect, CSys, IncludeIntersections, Point, Line, Area, Solid, Link]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.CoordinateRange(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"CoordinateRange" failed')
        
        return ret

    def GetSelected(self, NumberItems = None, ObjectType = None, ObjectName = None):
        """
This function retrieves a list of selected objects.
The function returns zero if the selection list is successfully retrieved, otherwise it returns a nonzero value.

NumberItems: The number of selected objects.
ObjectType: This is an array that includes the object type of each selected object.
1 = Point object
2 = Frame object
3 = Cable object
4 = Tendon object
5 = Area object
6 = Solid object
7 = Link object
ObjectName: This is an array that includes the name of each selected object.
        """

        all_args = [NumberItems, ObjectType, ObjectName]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.GetSelected(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"GetSelected" failed')
        
        return ret

    def Group(self, Name = None, DeSelect = None):
        """
This function selects or deselects all objects in the specified group.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of an existing group.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.Group(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"Group" failed')
        
        return ret

    def InvertSelection(self):
        """
This function deselects all selected objects and selects all unselected objects; that is, it inverts the selection.
The function returns zero if the selection is successfully inverted, otherwise it returns nonzero.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.InvertSelection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"InvertSelection" failed')
        
        return ret

    def LinesParallelToCoordAxis(self, ParallelTo = None, CSys = None, Tolerance = None, DeSelect = None):
        """
This function selects or deselects objects parallel to specified coordinate axes or planes.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

ParallelTo: This is an array of six booleans representing three coordinate axes and three coordinate planes. Any combination of the six may be specified.
ParallelTo(0) = X axis
ParallelTo(1) = Y axis
ParallelTo(2) = Z axis
ParallelTo(3) = XY plane
ParallelTo(4) = XZ plane
ParallelTo(5) = YZ plane
CSys: The name of the coordinate system to which the ParallelTo items apply.
Tolerance: Line objects that are within this angle in degrees of being parallel to a specified coordinate axis or plane are selected or deselected. [deg]
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [ParallelTo, CSys, Tolerance, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.LinesParallelToCoordAxis(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"LinesParallelToCoordAxis" failed')
        
        return ret

    def PlaneXY(self, Name = None, DeSelect = None):
        """
This function selects or deselects all objects that are in the same XY plane (in the present coordinate system) as the specified point object.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of a point object.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.PlaneXY(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PlaneXY" failed')
        
        return ret

    def PlaneXZ(self, Name = None, DeSelect = None):
        """
This function selects or deselects all objects that are in the same XZ plane (in the present coordinate system) as the specified point object.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of a point object.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.PlaneXZ(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PlaneXZ" failed')
        
        return ret

    def PlaneYZ(self, Name = None, DeSelect = None):
        """
This function selects or deselects all objects that are in the same YZ plane (in the present coordinate system) as the specified point object.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of a point object.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.PlaneYZ(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PlaneYZ" failed')
        
        return ret

    def PreviousSelection(self):
        """
This function restores the previous selection.
The function returns zero if the selection is successfully restored, otherwise it returns nonzero.

        """

        all_args = []

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.PreviousSelection(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PreviousSelection" failed')
        
        return ret

    def PropertyArea(self, Name = None, DeSelect = None):
        """
This function selects or deselects all area objects to which the specified section has been assigned.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of an existing area section property.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.PropertyArea(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PropertyArea" failed')
        
        return ret

    def PropertyCable(self, Name = None, DeSelect = None):
        """
This function selects or deselects all cable objects to which the specified section has been assigned.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of an existing cable section property.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.PropertyCable(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PropertyCable" failed')
        
        return ret

    def PropertyFrame(self, Name = None, DeSelect = None):
        """
This function selects or deselects all line objects to which the specified section has been assigned.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of an existing frame section property.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.PropertyFrame(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PropertyFrame" failed')
        
        return ret

    def PropertyLink(self, Name = None, DeSelect = None):
        """
This function selects or deselects all link objects to which the specified section property has been assigned.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of an existing link property.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.PropertyLink(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PropertyLink" failed')
        
        return ret

    def PropertyLinkFD(self, Name = None, DeSelect = None):
        """
This function selects or deselects all link objects to which the specified frequency dependent link property has been assigned.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of an existing frequency dependent link property.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.PropertyLinkFD(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PropertyLinkFD" failed')
        
        return ret

    def PropertyMaterial(self, Name = None, DeSelect = None):
        """
This function selects or deselects all objects to which the specified material property has been assigned.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of an existing material property.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.PropertyMaterial(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PropertyMaterial" failed')
        
        return ret

    def PropertySolid(self, Name = None, DeSelect = None):
        """
This function selects or deselects all solid objects to which the specified property has been assigned.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of an existing solid property.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.PropertySolid(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PropertySolid" failed')
        
        return ret

    def PropertyTendon(self, Name = None, DeSelect = None):
        """
This function selects or deselects all tendon objects to which the specified section has been assigned.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

Name: The name of an existing tendon section property.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
        """

        all_args = [Name, DeSelect]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.PropertyTendon(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"PropertyTendon" failed')
        
        return ret

    def SupportedPoints(self, DOF = None, CSys = None, DeSelect = None, SelectRestraints = None, SelectJointSprings = None, SelectLineSprings = None, SelectAreaSprings = None, SelectSolidSprings = None, SelectOneJointLinks = None):
        """
This function selects or deselects point objects with support in the specified degrees of freedom.
The function returns zero if the selection is successfully completed, otherwise it returns nonzero.

DOF: This is an array of six booleans for the six degrees of freedom of a point object.
DOF(0) = U1
DOF(1) = U2
DOF(2) = U3
DOF(3) = R1
DOF(4) = R2
DOF(5) = R3
CSys: The name of the coordinate system in which degrees of freedom (DOF) are specified. This is either Local or the name of a defined coordinate system. Local means the point local coordinate system.
DeSelect: The item is False if objects are to be selected and True if they are to be deselected.
SelectRestraints: If this item is True then points with restraint assignments in one of the specified degrees of freedom are selected or deselected.
SelectJointSprings: If this item is True then points with joint spring assignments in one of the specified degrees of freedom are selected or deselected.
SelectLineSprings: If this item is True, points with a contribution from line spring assignments in one of the specified degrees of freedom are selected or deselected.
SelectAreaSprings: If this item is True, points with a contribution from area spring assignments in one of the specified degrees of freedom are selected or deselected.
SelectSolidSprings: If this item is True, points with a contribution from solid surface spring assignments in one of the specified degrees of freedom are selected or deselected.
SelectOneJointLinks: If this item is True, points with one joint link assignments in one of the specified degrees of freedom are selected or deselected.
        """

        all_args = [DOF, CSys, DeSelect, SelectRestraints, SelectJointSprings, SelectLineSprings, SelectAreaSprings, SelectSolidSprings, SelectOneJointLinks]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.SelectObj.SupportedPoints(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"SupportedPoints" failed')
        
        return ret

class View:
    def __init__(self, strict, api):
        self.strict = strict
        self.api = api

    def RefreshView(self, Window = None, Zoom = None):
        """
This function refreshes the view for the specified window(s). It returns zero if the window views are successfully refreshed, otherwise it returns a nonzero value.
See RefreshWindow and RefreshView for more information.

Window: This is 0 meaning all windows or an existing window number. It indicates the window(s) to have its view refreshed.
Zoom: If this item is True, the window zoom is maintained when the view is refreshed. If it is False, the zoom returns to a default zoom.
        """

        all_args = [Window, Zoom]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.View.RefreshView(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"RefreshView" failed')
        
        return ret

    def RefreshWindow(self, Window = None):
        """
This function refreshes the specified window(s). It returns zero if the windows are successfully refreshed, otherwise it returns a nonzero value.
See RefreshWindow and RefreshView for more information.

Window: This is 0 meaning all windows or an existing window number. It indicates the window(s) to be refreshed.
        """

        all_args = [Window]

        if None in all_args:
            none_idx = all_args.index(None)
            filled_args = all_args[:none_idx]
        else:
            filled_args = all_args

        ret = self.api.SapModel.View.RefreshWindow(*filled_args)

        if not isinstance(ret,list):
            ret = [ret]

        if self.strict and ret[-1] != 0:
            raise Exception(f'"RefreshWindow" failed')
        
        return ret

